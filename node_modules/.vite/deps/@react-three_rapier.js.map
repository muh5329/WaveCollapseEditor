{
  "version": 3,
  "sources": ["../../fast-deep-equal/index.js", "../../@react-three/rapier/dist/react-three-rapier.esm.js", "../../use-asset/dist/index.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/MorphBlendMesh.js", "../../@react-three/rapier/node_modules/three-stdlib/math/ConvexHull.js", "../../@react-three/rapier/node_modules/three-stdlib/geometries/ConvexGeometry.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/ConvexObjectBreaker.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/Gyroscope.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/MorphAnimMesh.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/RollerCoaster.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/VolumeSlice.js", "../../@react-three/rapier/node_modules/three-stdlib/misc/Volume.js", "../../@react-three/rapier/node_modules/three-stdlib/renderers/CSS2DRenderer.js", "../../@react-three/rapier/node_modules/three-stdlib/renderers/CSS3DRenderer.js", "../../@react-three/rapier/node_modules/three-stdlib/renderers/Projector.js", "../../@react-three/rapier/node_modules/three-stdlib/renderers/SVGRenderer.js", "../../@react-three/rapier/node_modules/three-stdlib/modifiers/CurveModifier.js", "../../@react-three/rapier/node_modules/three-stdlib/utils/BufferGeometryUtils.js", "../../@react-three/rapier/node_modules/three-stdlib/modifiers/SimplifyModifier.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/constants.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeUtils.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/Node.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/InputNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/UniformNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/ArrayUniformNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/VaryNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/AttributeNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/BypassNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/CodeNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/ConstNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/ContextNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/TempNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/ExpressionNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeAttribute.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeUniform.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeVary.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeVar.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeBuilder.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeFunctionInput.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/PropertyNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/core/VarNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/BufferNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/Object3DNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/CameraNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/UVNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/TextureNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/ModelNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/utils/JoinNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/utils/SplitNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/math/OperatorNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/math/MathNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/PositionNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/NormalNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/math/CondNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/utils/ArrayElementNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/utils/ConvertNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/ShaderNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/ReflectNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/CubeTextureNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/ReferenceNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/MaterialReferenceNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/MaterialNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/PointUVNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/accessors/SkinningNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/display/ColorSpaceNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/display/NormalMapNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/functions/BSDFs.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/utils/TimerNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/utils/OscNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/procedural/CheckerNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/fog/FogNode.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/fog/FogRangeNode.js", "../../@react-three/rapier/node_modules/three-stdlib/exporters/GLTFExporter.js", "../../@react-three/rapier/node_modules/three-stdlib/exporters/DRACOExporter.js", "../../@react-three/rapier/node_modules/three-stdlib/animation/AnimationClipCreator.js", "../../@react-three/rapier/node_modules/three-stdlib/animation/CCDIKSolver.js", "../../@react-three/rapier/node_modules/three-stdlib/animation/MMDPhysics.js", "../../@react-three/rapier/node_modules/three-stdlib/animation/MMDAnimationHelper.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/Reflector.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/Refractor.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/ShadowMesh.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/Lensflare.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/Water.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/MarchingCubes.js", "../../@react-three/rapier/node_modules/three-stdlib/math/SimplexNoise.js", "../../@react-three/rapier/node_modules/three-stdlib/geometries/LightningStrike.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/LightningStorm.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/ReflectorForSSRPass.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/Sky.js", "../../@react-three/rapier/node_modules/three-stdlib/objects/Water2.js", "../../@react-three/rapier/node_modules/three-stdlib/utils/RoughnessMipmapper.js", "../../@react-three/rapier/node_modules/three-stdlib/utils/SkeletonUtils.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/UnpackDepthRGBAShader.js", "../../@react-three/rapier/node_modules/three-stdlib/utils/ShadowMapViewer.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/BokehShader2.js", "../../@react-three/rapier/node_modules/three-stdlib/math/MeshSurfaceSampler.js", "../../@react-three/rapier/node_modules/three-stdlib/math/OBB.js", "../../@react-three/rapier/node_modules/three-stdlib/math/Capsule.js", "../../@react-three/rapier/node_modules/three-stdlib/math/ColorConverter.js", "../../@react-three/rapier/node_modules/three-stdlib/math/Octree.js", "../../@react-three/rapier/node_modules/three-stdlib/math/Lut.js", "../../@react-three/rapier/node_modules/three-stdlib/controls/experimental/CameraControls.js", "../../@react-three/rapier/node_modules/three-stdlib/controls/FirstPersonControls.js", "../../@react-three/rapier/node_modules/three-stdlib/controls/PointerLockControls.js", "../../@react-three/rapier/node_modules/three-stdlib/controls/ArcballControls.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/Pass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/HalftoneShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SMAAShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/FilmShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/CopyShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SSAOShader.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/SSAOPass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/BokehShader.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/TexturePass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/LuminosityShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ToneMapShader.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/AdaptiveToneMappingPass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/LuminosityHighPassShader.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/UnrealBloomPass.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/CubeTexturePass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SAOShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/SAOPass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/AfterimageShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/DotScreenShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SSRShader.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/SSRPass.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/SSAARenderPass.js", "../../@react-three/rapier/node_modules/three-stdlib/postprocessing/TAARenderPass.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ConvolutionShader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/GLTFLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/webxr/OculusHandPointerModel.js", "../../@react-three/rapier/node_modules/three-stdlib/webxr/VRButton.js", "../../@react-three/rapier/node_modules/three-stdlib/libs/MotionControllers.js", "../../@react-three/rapier/node_modules/three-stdlib/webxr/XRHandPrimitiveModel.js", "../../@react-three/rapier/node_modules/three-stdlib/geometries/ParametricGeometry.js", "../../@react-three/rapier/node_modules/three-stdlib/geometries/ParametricGeometries.js", "../../@react-three/rapier/node_modules/three-stdlib/geometries/RoundedBoxGeometry.js", "../../@react-three/rapier/node_modules/three-stdlib/csm/CSMFrustum.js", "../../@react-three/rapier/node_modules/three-stdlib/csm/CSMShader.js", "../../@react-three/rapier/node_modules/three-stdlib/csm/CSM.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ACESFilmicToneMappingShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/BasicShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/BleachBypassShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/BlendShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/BrightnessContrastShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ColorCorrectionShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ColorifyShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/DOFMipMapShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/FXAAShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/FocusShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/FreiChenShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/FresnelShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/GammaCorrectionShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/GodRaysShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/HorizontalBlurShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/HorizontalTiltShiftShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/HueSaturationShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/KaleidoShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/MirrorShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/NormalMapShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ParallaxShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/PixelShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/RGBShiftShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SepiaShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SobelOperatorShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/SubsurfaceScatteringShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/TechnicolorShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/ToonShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/TriangleBlurShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/VerticalBlurShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/VerticalTiltShiftShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/VignetteShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/VolumeShader.js", "../../@react-three/rapier/node_modules/three-stdlib/shaders/WaterRefractionShader.js", "../../@react-three/rapier/node_modules/three-stdlib/interactive/InteractiveGroup.js", "../../@react-three/rapier/node_modules/three-stdlib/interactive/SelectionHelper.js", "../../@react-three/rapier/node_modules/three-stdlib/interactive/SelectionBox.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/FBXLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/FontLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/XLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/utils/WorkerPool.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/KTX2Loader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/AssimpLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/BasisTextureLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/LDrawLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/lwo/LWO3Parser.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/lwo/LWO2Parser.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/lwo/IFFParser.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/OBJLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/KTXLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/loaders/RGBMLoader.js", "../../@react-three/rapier/node_modules/three-stdlib/lines/LineSegmentsGeometry.js", "../../@react-three/rapier/node_modules/three-stdlib/lines/LineMaterial.js", "../../@react-three/rapier/node_modules/three-stdlib/lines/Wireframe.js", "../../@react-three/rapier/node_modules/three-stdlib/lines/LineSegments2.js", "../../@react-three/rapier/node_modules/three-stdlib/helpers/VertexTangentsHelper.js", "../../@react-three/rapier/node_modules/three-stdlib/helpers/VertexNormalsHelper.js", "../../@react-three/rapier/node_modules/three-stdlib/deprecated/Geometry.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/materials/NodeMaterial.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/materials/LineBasicNodeMaterial.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/materials/MeshBasicNodeMaterial.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/materials/MeshStandardNodeMaterial.js", "../../@react-three/rapier/node_modules/three-stdlib/nodes/materials/PointsNodeMaterial.js"],
  "sourcesContent": ["'use strict';\r\n\r\n// do not edit .js files directly - edit src/index.jst\r\n\r\n\r\n\r\nmodule.exports = function equal(a, b) {\r\n  if (a === b) return true;\r\n\r\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\r\n    if (a.constructor !== b.constructor) return false;\r\n\r\n    var length, i, keys;\r\n    if (Array.isArray(a)) {\r\n      length = a.length;\r\n      if (length != b.length) return false;\r\n      for (i = length; i-- !== 0;)\r\n        if (!equal(a[i], b[i])) return false;\r\n      return true;\r\n    }\r\n\r\n\r\n\r\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\r\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\r\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\r\n\r\n    keys = Object.keys(a);\r\n    length = keys.length;\r\n    if (length !== Object.keys(b).length) return false;\r\n\r\n    for (i = length; i-- !== 0;)\r\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\r\n\r\n    for (i = length; i-- !== 0;) {\r\n      var key = keys[i];\r\n\r\n      if (!equal(a[key], b[key])) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // true if both NaN, false otherwise\r\n  return a!==a && b!==b;\r\n};\r\n", "import { EventQueue, ColliderDesc, ActiveEvents, RigidBodyDesc } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame } from '@react-three/fiber';\nimport React, { useRef, useState, useEffect, useCallback, useMemo, createContext, useContext, memo, forwardRef, useImperativeHandle, useLayoutEffect } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, MathUtils, InstancedMesh, BufferAttribute, DynamicDrawUsage } from 'three';\nimport { useAsset } from 'use-asset';\nimport { mergeVertices } from 'three-stdlib';\n\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nconst _object3d = new Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst rapierVector3ToVector3 = ({\n  x,\n  y,\n  z\n}) => _vector3.set(x, y, z);\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n\n  if (Array.isArray(v)) {\n    return v;\n  }\n\n  return [v];\n};\n\nconst createRigidBodyApi = ref => {\n  return {\n    raw: () => ref.current(),\n\n    get handle() {\n      return ref.current().handle;\n    },\n\n    mass: () => ref.current().mass(),\n\n    applyImpulse(impulseVector, wakeUp = true) {\n      ref.current().applyImpulse(impulseVector, wakeUp);\n    },\n\n    applyTorqueImpulse(torqueVector, wakeUp = true) {\n      ref.current().applyTorqueImpulse(torqueVector, wakeUp);\n    },\n\n    applyImpulseAtPoint: (impulseVector, impulsePoint, wakeUp = true) => ref.current().applyImpulseAtPoint(impulseVector, impulsePoint, wakeUp),\n    addForce: (force, wakeUp = true) => ref.current().addForce(force, wakeUp),\n    addForceAtPoint: (force, point, wakeUp = true) => ref.current().addForceAtPoint(force, point, wakeUp),\n    addTorque: (torque, wakeUp = true) => ref.current().addTorque(torque, wakeUp),\n\n    translation() {\n      return rapierVector3ToVector3(ref.current().translation());\n    },\n\n    setTranslation: (translation, wakeUp = true) => ref.current().setTranslation(translation, wakeUp),\n\n    rotation() {\n      const {\n        x,\n        y,\n        z,\n        w\n      } = ref.current().rotation();\n      return new Quaternion(x, y, z, w);\n    },\n\n    setRotation: (rotation, wakeUp = true) => {\n      ref.current().setRotation(rotation, wakeUp);\n    },\n\n    linvel() {\n      const {\n        x,\n        y,\n        z\n      } = ref.current().linvel();\n      return new Vector3(x, y, z);\n    },\n\n    setLinvel: (velocity, wakeUp = true) => ref.current().setLinvel(velocity, wakeUp),\n\n    angvel() {\n      const {\n        x,\n        y,\n        z\n      } = ref.current().angvel();\n      return new Vector3(x, y, z);\n    },\n\n    setAngvel: (velocity, wakeUp = true) => ref.current().setAngvel(velocity, wakeUp),\n\n    linearDamping() {\n      return ref.current().linearDamping();\n    },\n\n    setLinearDamping: factor => ref.current().setLinearDamping(factor),\n\n    angularDamping() {\n      return ref.current().angularDamping();\n    },\n\n    setAngularDamping: factor => ref.current().setAngularDamping(factor),\n    setNextKinematicRotation: rotation => {\n      ref.current().setNextKinematicRotation(rotation);\n    },\n    setNextKinematicTranslation: translation => ref.current().setNextKinematicTranslation(translation),\n    resetForces: (wakeUp = true) => ref.current().resetForces(wakeUp),\n    resetTorques: (wakeUp = true) => ref.current().resetTorques(wakeUp),\n    lockRotations: (locked, wakeUp = true) => ref.current().lockRotations(locked, wakeUp),\n    lockTranslations: (locked, wakeUp = true) => ref.current().lockTranslations(locked, wakeUp),\n    setEnabledRotations: (x, y, z, wakeUp = true) => ref.current().setEnabledRotations(x, y, z, wakeUp),\n    setEnabledTranslations: (x, y, z, wakeUp = true) => ref.current().setEnabledTranslations(x, y, z, wakeUp)\n  };\n};\nconst createInstancedRigidBodiesApi = bodiesGetter => ({\n  at: index => bodiesGetter.current()[index].api,\n\n  forEach(callback) {\n    return bodiesGetter.current().map(b => b.api).forEach(callback);\n  },\n\n  get count() {\n    return bodiesGetter.current().length;\n  }\n\n}); // TODO: Flesh this out\nconst createWorldApi = ref => {\n  return {\n    raw: () => ref.current(),\n    getCollider: handle => ref.current().getCollider(handle),\n    getRigidBody: handle => ref.current().getRigidBody(handle),\n    createRigidBody: desc => ref.current().createRigidBody(desc),\n    createCollider: (desc, rigidBody) => ref.current().createCollider(desc, rigidBody),\n    removeRigidBody: rigidBody => {\n      if (!ref.current().bodies.contains(rigidBody.handle)) return;\n      ref.current().removeRigidBody(rigidBody);\n    },\n    removeCollider: (collider, wakeUp = true) => {\n      if (!ref.current().colliders.contains(collider.handle)) return;\n      ref.current().removeCollider(collider, wakeUp);\n    },\n    createImpulseJoint: (params, rigidBodyA, rigidBodyB, wakeUp = true) => ref.current().createImpulseJoint(params, rigidBodyA, rigidBodyB, wakeUp),\n    removeImpulseJoint: (joint, wakeUp = true) => {\n      if (!ref.current().impulseJoints.contains(joint.handle)) return;\n      ref.current().removeImpulseJoint(joint, wakeUp);\n    },\n    forEachCollider: callback => ref.current().forEachCollider(callback),\n    setGravity: ({\n      x,\n      y,\n      z\n    }) => ref.current().gravity = {\n      x,\n      y,\n      z\n    },\n    debugRender: () => ref.current().debugRender()\n  };\n}; // TODO: Broken currently, waiting for Rapier3D to fix\n\nconst createJointApi = ref => {\n  return {\n    raw: () => ref.current(),\n\n    get handle() {\n      return ref.current().handle;\n    },\n\n    configureMotorPosition: (targetPos, stiffness, damping) => ref.current().configureMotorPosition(targetPos, stiffness, damping),\n    configureMotorVelocity: (targetVel, damping) => ref.current().configureMotorVelocity(targetVel, damping)\n  };\n};\n\nconst RapierContext = /*#__PURE__*/createContext(undefined);\n\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n\nconst Physics = ({\n  colliders: _colliders = \"cuboid\",\n  gravity: _gravity = [0, -9.81, 0],\n  children,\n  timeStep: _timeStep = 1 / 60,\n  paused: _paused = false,\n  updatePriority,\n  interpolate: _interpolate = true\n}) => {\n  const rapier = useAsset(importRapier);\n  const worldRef = useRef();\n  const getWorldRef = useRef(() => {\n    if (!worldRef.current) {\n      const world = new rapier.World(vectorArrayToVector3(_gravity));\n      worldRef.current = world;\n    }\n\n    return worldRef.current;\n  });\n  const [rigidBodyStates] = useState(() => new Map());\n  const [colliderStates] = useState(() => new Map());\n  const [rigidBodyEvents] = useState(() => new Map());\n  const [colliderEvents] = useState(() => new Map());\n  const [eventQueue] = useState(() => new EventQueue(false)); // Init world\n\n  useEffect(() => {\n    const world = getWorldRef.current();\n    return () => {\n      if (world) {\n        world.free();\n        worldRef.current = undefined;\n      }\n    };\n  }, []); // Update gravity\n\n  useEffect(() => {\n    const world = worldRef.current;\n\n    if (world) {\n      world.gravity = vectorArrayToVector3(_gravity);\n    }\n  }, [_gravity]);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  /* Check if the timestep is supposed to be variable. We'll do this here\n  once so we don't have to string-check every frame. */\n\n  const timeStepVariable = _timeStep === \"vary\";\n  const getSourceFromColliderHandle = useCallback(handle => {\n    const world = worldRef.current;\n\n    if (world) {\n      var _collider$parent;\n\n      const collider = world.getCollider(handle);\n      const colEvents = colliderEvents.get(handle);\n      const colliderState = colliderStates.get(handle);\n      const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n      const rigidBody = rigidBodyHandle ? world.getRigidBody(rigidBodyHandle) : undefined;\n      const rbEvents = rigidBody && rigidBodyHandle ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n      const rigidBodyState = rigidBodyHandle ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n      return {\n        collider: {\n          object: collider,\n          events: colEvents,\n          state: colliderState\n        },\n        rigidBody: {\n          object: rigidBody,\n          events: rbEvents,\n          state: rigidBodyState\n        }\n      };\n    }\n  }, []);\n  useFrame((_, dt) => {\n    const world = worldRef.current;\n    if (!world) return;\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.2);\n\n    if (timeStepVariable) {\n      world.timestep = clampedDelta;\n      if (!_paused) world.step(eventQueue);\n    } else {\n      world.timestep = _timeStep; // don't step time forwards if paused\n      // Increase accumulator\n\n      steppingState.accumulator += _paused ? 0 : clampedDelta;\n\n      if (!_paused) {\n        while (steppingState.accumulator >= _timeStep) {\n          if (_interpolate) {\n            // Set up previous state\n            // needed for accurate interpolations if the world steps more than once\n            steppingState.previousState = {};\n            world.forEachRigidBody(body => {\n              steppingState.previousState[body.handle] = {\n                position: body.translation(),\n                rotation: body.rotation()\n              };\n            });\n          }\n\n          world.step(eventQueue);\n          steppingState.accumulator -= _timeStep;\n        }\n      }\n    }\n\n    const interpolationAlpha = timeStepVariable || !_interpolate ? 1 : steppingState.accumulator / _timeStep; // Update meshes\n\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n\n        state.isSleeping = rigidBody.isSleeping();\n      }\n\n      if (!rigidBody || rigidBody.isSleeping() || !state.setMatrix) {\n        return;\n      }\n\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale); // Apply previous tick position\n\n\n        if (!(state.object instanceof InstancedMesh)) {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      } // Get new position\n\n\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n      if (state.object instanceof InstancedMesh) {\n        state.setMatrix(_matrix4);\n        state.object.instanceMatrix.needsUpdate = true;\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$collider$sta, _source2$rigidBody$st, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$sta, _source1$rigidBody$st, _source1$collider$eve, _source1$collider$eve2, _source2$collider$sta2, _source2$rigidBody$st2, _source2$collider$eve, _source2$collider$eve2, _source1$collider$sta2, _source1$rigidBody$st2;\n\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, {\n            rigidBody: source2.rigidBody.object,\n            collider: source2.collider.object,\n            colliderObject: (_source2$collider$sta = source2.collider.state) === null || _source2$collider$sta === void 0 ? void 0 : _source2$collider$sta.object,\n            rigidBodyObject: (_source2$rigidBody$st = source2.rigidBody.state) === null || _source2$rigidBody$st === void 0 ? void 0 : _source2$rigidBody$st.object,\n            manifold,\n            flipped\n          });\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, {\n            rigidBody: source1.rigidBody.object,\n            collider: source1.collider.object,\n            colliderObject: (_source1$collider$sta = source1.collider.state) === null || _source1$collider$sta === void 0 ? void 0 : _source1$collider$sta.object,\n            rigidBodyObject: (_source1$rigidBody$st = source1.rigidBody.state) === null || _source1$rigidBody$st === void 0 ? void 0 : _source1$rigidBody$st.object,\n            manifold,\n            flipped\n          });\n          /* Collider events */\n\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, {\n            rigidBody: source2.rigidBody.object,\n            collider: source2.collider.object,\n            colliderObject: (_source2$collider$sta2 = source2.collider.state) === null || _source2$collider$sta2 === void 0 ? void 0 : _source2$collider$sta2.object,\n            rigidBodyObject: (_source2$rigidBody$st2 = source2.rigidBody.state) === null || _source2$rigidBody$st2 === void 0 ? void 0 : _source2$rigidBody$st2.object,\n            manifold,\n            flipped\n          });\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, {\n            rigidBody: source1.rigidBody.object,\n            collider: source1.collider.object,\n            colliderObject: (_source1$collider$sta2 = source1.collider.state) === null || _source1$collider$sta2 === void 0 ? void 0 : _source1$collider$sta2.object,\n            rigidBodyObject: (_source1$rigidBody$st2 = source1.rigidBody.state) === null || _source1$rigidBody$st2 === void 0 ? void 0 : _source1$rigidBody$st2.object,\n            manifold,\n            flipped\n          });\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, {\n          rigidBody: source2.rigidBody.object,\n          collider: source2.collider.object\n        });\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, {\n          rigidBody: source1.rigidBody.object,\n          collider: source1.collider.object\n        });\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, {\n          rigidBody: source2.rigidBody.object,\n          collider: source2.collider.object\n        });\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, {\n          rigidBody: source1.rigidBody.object,\n          collider: source1.collider.object\n        });\n      } // Sensor Intersections\n\n\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$collider$sta3, _source2$rigidBody$st3, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$sta3, _source1$rigidBody$st3, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$sta4, _source2$rigidBody$st4, _source2$collider$eve5, _source2$collider$eve6, _source1$collider$sta4, _source1$rigidBody$st4;\n\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, {\n            rigidBody: source2.rigidBody.object,\n            collider: source2.collider.object,\n            colliderObject: (_source2$collider$sta3 = source2.collider.state) === null || _source2$collider$sta3 === void 0 ? void 0 : _source2$collider$sta3.object,\n            rigidBodyObject: (_source2$rigidBody$st3 = source2.rigidBody.state) === null || _source2$rigidBody$st3 === void 0 ? void 0 : _source2$rigidBody$st3.object\n          });\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, {\n            rigidBody: source1.rigidBody.object,\n            collider: source1.collider.object,\n            colliderObject: (_source1$collider$sta3 = source1.collider.state) === null || _source1$collider$sta3 === void 0 ? void 0 : _source1$collider$sta3.object,\n            rigidBodyObject: (_source1$rigidBody$st3 = source1.rigidBody.state) === null || _source1$rigidBody$st3 === void 0 ? void 0 : _source1$rigidBody$st3.object\n          });\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, {\n            rigidBody: source2.rigidBody.object,\n            collider: source2.collider.object,\n            colliderObject: (_source2$collider$sta4 = source2.collider.state) === null || _source2$collider$sta4 === void 0 ? void 0 : _source2$collider$sta4.object,\n            rigidBodyObject: (_source2$rigidBody$st4 = source2.rigidBody.state) === null || _source2$rigidBody$st4 === void 0 ? void 0 : _source2$rigidBody$st4.object\n          });\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, {\n            rigidBody: source1.rigidBody.object,\n            collider: source1.collider.object,\n            colliderObject: (_source1$collider$sta4 = source1.collider.state) === null || _source1$collider$sta4 === void 0 ? void 0 : _source1$collider$sta4.object,\n            rigidBodyObject: (_source1$rigidBody$st4 = source1.rigidBody.state) === null || _source1$rigidBody$st4 === void 0 ? void 0 : _source1$rigidBody$st4.object\n          });\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, {\n          rigidBody: source2.rigidBody.object,\n          collider: source2.collider.object\n        });\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, {\n          rigidBody: source1.rigidBody.object,\n          collider: source1.collider.object\n        });\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, {\n          rigidBody: source2.rigidBody.object,\n          collider: source2.collider.object\n        });\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, {\n          rigidBody: source1.rigidBody.object,\n          collider: source1.collider.object\n        });\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$collider$sta5, _source2$rigidBody$st5, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$sta5, _source1$rigidBody$st5, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$sta6, _source2$rigidBody$st6, _source2$collider$eve9, _source2$collider$eve10, _source1$collider$sta6, _source1$rigidBody$st6;\n\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2()); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, {\n        rigidBody: source2.rigidBody.object,\n        collider: source2.collider.object,\n        colliderObject: (_source2$collider$sta5 = source2.collider.state) === null || _source2$collider$sta5 === void 0 ? void 0 : _source2$collider$sta5.object,\n        rigidBodyObject: (_source2$rigidBody$st5 = source2.rigidBody.state) === null || _source2$rigidBody$st5 === void 0 ? void 0 : _source2$rigidBody$st5.object,\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      });\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, {\n        rigidBody: source1.rigidBody.object,\n        collider: source1.collider.object,\n        colliderObject: (_source1$collider$sta5 = source1.collider.state) === null || _source1$collider$sta5 === void 0 ? void 0 : _source1$collider$sta5.object,\n        rigidBodyObject: (_source1$rigidBody$st5 = source1.rigidBody.state) === null || _source1$rigidBody$st5 === void 0 ? void 0 : _source1$rigidBody$st5.object,\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      });\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, {\n        rigidBody: source2.rigidBody.object,\n        collider: source2.collider.object,\n        colliderObject: (_source2$collider$sta6 = source2.collider.state) === null || _source2$collider$sta6 === void 0 ? void 0 : _source2$collider$sta6.object,\n        rigidBodyObject: (_source2$rigidBody$st6 = source2.rigidBody.state) === null || _source2$rigidBody$st6 === void 0 ? void 0 : _source2$rigidBody$st6.object,\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      });\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, {\n        rigidBody: source1.rigidBody.object,\n        collider: source1.collider.object,\n        colliderObject: (_source1$collider$sta6 = source1.collider.state) === null || _source1$collider$sta6 === void 0 ? void 0 : _source1$collider$sta6.object,\n        rigidBodyObject: (_source1$rigidBody$st6 = source1.rigidBody.state) === null || _source1$rigidBody$st6 === void 0 ? void 0 : _source1$rigidBody$st6.object,\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      });\n    });\n  }, updatePriority);\n  const api = useMemo(() => createWorldApi(getWorldRef), []);\n  const context = useMemo(() => ({\n    rapier,\n    world: api,\n    physicsOptions: {\n      colliders: _colliders,\n      gravity: _gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    isPaused: _paused\n  }), [_paused]);\n  return /*#__PURE__*/React.createElement(RapierContext.Provider, {\n    value: context\n  }, children);\n};\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice(); // Heightfield uses a vector\n\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  } // Trimesh and convex scale the vertices\n\n\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  } // Prepfill with some extra\n\n\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, rigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale); // @ts-ignore\n\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, rigidBody);\n};\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\n\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setDensity(options.density);\n    return;\n  }\n\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setMass(options.mass);\n    return;\n  }\n\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\n\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  // To make sure the options all mutalbe options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n\n  if (state) {\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    state.object.updateWorldMatrix(true, false);\n\n    _matrix4.copy(state.object.matrixWorld).premultiply(state.worldParent.matrixWorld.clone().invert()).decompose(_position, _rotation, _scale);\n\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider, // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    }); // handle mass separately, because the assignments\n    // are exclusive.\n\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (collidersRef, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    collidersRef.current.forEach(collider => {\n      setColliderOptions(collider, props, states);\n    });\n  }, mutablePropsAsFlatArray);\n};\n\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\n\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || object.parent,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const colliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      colliderProps.push(_objectSpread2(_objectSpread2({}, options), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      }));\n    }\n  };\n\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n\n  return colliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst useColliderEvents = (collidersRef, props, events) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    var _collidersRef$current;\n\n    (_collidersRef$current = collidersRef.current) === null || _collidersRef$current === void 0 ? void 0 : _collidersRef$current.forEach(collider => {\n      const hasCollisionEvent = !!(onCollisionEnter || onCollisionExit || onIntersectionEnter || onIntersectionExit);\n      const hasContactForceEvent = !!onContactForce;\n\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    });\n    return () => {\n      var _collidersRef$current2;\n\n      (_collidersRef$current2 = collidersRef.current) === null || _collidersRef$current2 === void 0 ? void 0 : _collidersRef$current2.forEach(collider => events.delete(collider.handle));\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\nconst rigidBodyDescFromOptions = options => {\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type);\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false\n  };\n};\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n\n  const state = states.get(rigidBody.handle);\n\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (rigidBodyRef, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    if (Array.isArray(rigidBodyRef.current)) {\n      for (const rigidBody of rigidBodyRef.current) {\n        setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n      }\n    } else if (rigidBodyRef.current) {\n      setRigidBodyOptions(rigidBodyRef.current, props, states, updateTranslations);\n    }\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (rigidBodyRef, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit\n  };\n  useEffect(() => {\n    if (Array.isArray(rigidBodyRef.current)) {\n      for (const rigidBody of rigidBodyRef.current) {\n        events.set(rigidBody.handle, eventHandlers);\n      }\n    } else if (rigidBodyRef.current) {\n      events.set(rigidBodyRef.current.handle, eventHandlers);\n    }\n\n    return () => {\n      if (Array.isArray(rigidBodyRef.current)) {\n        for (const rigidBody of rigidBodyRef.current) {\n          events.delete(rigidBody.handle);\n        }\n      } else if (rigidBodyRef.current) {\n        events.delete(rigidBodyRef.current.handle);\n      }\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit]);\n};\n\nconst useRapier = () => {\n  return useContext(RapierContext);\n};\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\nconst useRigidBody = (options = {}) => {\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const ref = useRef();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(ref, mergedOptions); // Create rigidbody\n\n  const rigidBodyRef = useRef();\n  const getRigidBodyRef = useRef(() => {\n    if (!rigidBodyRef.current) {\n      const desc = rigidBodyDescFromOptions(options);\n      const rigidBody = world.createRigidBody(desc);\n      rigidBodyRef.current = world.getRigidBody(rigidBody.handle);\n    }\n\n    return rigidBodyRef.current;\n  }); // Setup\n\n  useEffect(() => {\n    const rigidBody = getRigidBodyRef.current();\n    rigidBodyRef.current = rigidBody;\n\n    if (!ref.current) {\n      ref.current = new Object3D();\n    }\n\n    rigidBodyStates.set(rigidBody.handle, createRigidBodyState({\n      rigidBody,\n      object: ref.current\n    }));\n    return () => {\n      world.removeRigidBody(rigidBody);\n      rigidBodyStates.delete(rigidBody.handle);\n      rigidBodyRef.current = undefined;\n    };\n  }, []);\n  useUpdateRigidBodyOptions(rigidBodyRef, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(rigidBodyRef, mergedOptions, rigidBodyEvents);\n  const api = useMemo(() => createRigidBodyApi(getRigidBodyRef), []);\n  return [ref, api, childColliderProps];\n}; // Joints\n\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef();\n  const getJointRef = useRef(() => {\n    if (!jointRef.current) {\n      let rb1;\n      let rb2;\n\n      if (\"current\" in body1 && body1.current && \"current\" in body2 && body2.current) {\n        rb1 = world.getRigidBody(body1.current.handle);\n        rb2 = world.getRigidBody(body2.current.handle);\n        const newJoint = world.createImpulseJoint(params, rb1, rb2);\n        jointRef.current = newJoint;\n      }\n    }\n\n    return jointRef.current;\n  });\n  useEffect(() => {\n    const joint = getJointRef.current();\n    return () => {\n      if (joint) {\n        world.removeImpulseJoint(joint);\n        jointRef.current = undefined;\n      }\n    };\n  }, []);\n  const api = useMemo(() => createJointApi(getJointRef), []);\n  return api;\n};\n/**\n *\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n */\n\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vectorArrayToVector3(body1Anchor), _objectSpread2(_objectSpread2({}, vectorArrayToVector3(body1LocalFrame)), {}, {\n    w: 1\n  }), vectorArrayToVector3(body2Anchor), _objectSpread2(_objectSpread2({}, vectorArrayToVector3(body2LocalFrame)), {}, {\n    w: 1\n  })));\n};\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n */\n\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor)));\n};\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n */\n\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.revolute(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis)));\n};\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n */\n\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.prismatic(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis)));\n};\n\n// Colliders\nconst AnyCollider = /*#__PURE__*/memo( /*#__PURE__*/React.forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const ref = useRef(null);\n  const collidersRef = useMemo(() => {\n    if (forwardedRef !== null) {\n      return forwardedRef;\n    }\n\n    const result = /*#__PURE__*/React.createRef();\n    result.current = [];\n    return result;\n  }, []);\n  useEffect(() => {\n    const object = ref.current;\n    const worldScale = object.getWorldScale(new Vector3());\n    const colliders = []; // If this is an InstancedRigidBody api\n\n    if (rigidBodyContext && \"at\" in rigidBodyContext.api) {\n      rigidBodyContext.api.forEach((body, index) => {\n        var _rigidBodyContext$opt, _rigidBodyContext$opt2;\n\n        let instanceScale = worldScale;\n\n        if (\"scales\" in rigidBodyContext.options && rigidBodyContext !== null && rigidBodyContext !== void 0 && (_rigidBodyContext$opt = rigidBodyContext.options) !== null && _rigidBodyContext$opt !== void 0 && (_rigidBodyContext$opt2 = _rigidBodyContext$opt.scales) !== null && _rigidBodyContext$opt2 !== void 0 && _rigidBodyContext$opt2[index]) {\n          instanceScale = instanceScale.clone().multiply(vectorArrayToVector3(rigidBodyContext.options.scales[index]));\n        }\n\n        const collider = createColliderFromOptions(props, world, instanceScale, body.raw());\n        colliderStates.set(collider.handle, createColliderState(collider, object, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n        colliders.push(collider);\n      });\n    } else {\n      const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext && (rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.api).raw());\n      colliderStates.set(collider.handle, createColliderState(collider, object, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n      colliders.push(collider);\n    }\n\n    collidersRef.current = colliders;\n    return () => {\n      colliders.forEach(collider => {\n        world.removeCollider(collider);\n      });\n    };\n  }, []);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(collidersRef, mergedProps, colliderStates);\n  useColliderEvents(collidersRef, mergedProps, colliderEvents);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: ref,\n    name: name\n  }, children);\n}));\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"roundCuboid\",\n    ref: ref\n  }));\n});\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"ball\",\n    ref: ref\n  }));\n});\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"capsule\",\n    ref: ref\n  }));\n});\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"heightfield\",\n    ref: ref\n  }));\n});\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"trimesh\",\n    ref: ref\n  }));\n});\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cone\",\n    ref: ref\n  }));\n});\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cylinder\",\n    ref: ref\n  }));\n});\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"convexHull\",\n    ref: ref\n  }));\n});\n\nconst _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\nconst RigidBody = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, ref) => {\n  const {\n    children,\n    type,\n    position,\n    rotation,\n    scale,\n    quaternion\n  } = props,\n        objectProps = _objectWithoutProperties(props, _excluded$1);\n\n  const [object, api, childColliderProps] = useRigidBody(props);\n  useImperativeHandle(ref, () => api);\n  const contextValue = useMemo(() => ({\n    ref: object,\n    api,\n    options: props\n  }), [object, api, props]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: object\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n}));\n\nconst MeshCollider = props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions,\n    world\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n};\n\nconst Debug = () => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    mesh.geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    mesh.geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\n  });\n  return /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null));\n};\n\nconst _excluded = [\"positions\", \"rotations\", \"children\"];\nconst InstancedRigidBodies = /*#__PURE__*/forwardRef((props, ref) => {\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const object = useRef(null);\n\n  const {\n    positions,\n    rotations,\n    children\n  } = props,\n        options = _objectWithoutProperties(props, _excluded);\n\n  const instancesRef = useRef([]);\n  const rigidBodyRefs = useRef([]);\n  const instancesRefGetter = useRef(() => {\n    if (!instancesRef.current) {\n      instancesRef.current = [];\n    }\n\n    return instancesRef.current;\n  });\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, physicsOptions), options);\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions);\n  useLayoutEffect(() => {\n    object.current.updateWorldMatrix(true, false);\n    const instances = instancesRefGetter.current();\n    const invertedWorld = object.current.matrixWorld.clone().invert();\n    object.current.traverseVisible(mesh => {\n      if (mesh instanceof InstancedMesh) {\n        mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n        const worldScale = mesh.getWorldScale(_scale);\n\n        for (let index = 0; index < mesh.count; index++) {\n          var _options$scales;\n\n          const desc = rigidBodyDescFromOptions(props);\n          const rigidBody = world.createRigidBody(desc);\n          rigidBodyRefs.current.push(rigidBody);\n          const scale = ((_options$scales = options.scales) === null || _options$scales === void 0 ? void 0 : _options$scales[index]) || [1, 1, 1];\n          const instanceScale = worldScale.clone().multiply(vectorArrayToVector3(scale));\n          rigidBodyStates.set(rigidBody.handle, createRigidBodyState({\n            rigidBody,\n            object: mesh,\n            setMatrix: matrix => mesh.setMatrixAt(index, matrix),\n            getMatrix: matrix => {\n              mesh.getMatrixAt(index, matrix);\n              return matrix;\n            },\n            worldScale: instanceScale\n          }));\n          const [x, y, z] = (positions === null || positions === void 0 ? void 0 : positions[index]) || [0, 0, 0];\n          const [rx, ry, rz] = (rotations === null || rotations === void 0 ? void 0 : rotations[index]) || [0, 0, 0];\n\n          _object3d.position.set(x, y, z);\n\n          _object3d.rotation.set(rx, ry, rz);\n\n          _object3d.applyMatrix4(invertedWorld);\n\n          mesh.setMatrixAt(index, _object3d.matrix);\n          rigidBody.setTranslation(_object3d.position, false);\n          rigidBody.setRotation(_object3d.quaternion, false);\n          const api = createRigidBodyApi({\n            current() {\n              return rigidBody;\n            }\n\n          });\n          instances.push({\n            rigidBody,\n            api\n          });\n        }\n      }\n    });\n    return () => {\n      instances.forEach(rb => {\n        world.removeRigidBody(rb.rigidBody);\n        rigidBodyStates.delete(rb.rigidBody.handle);\n      });\n      rigidBodyRefs.current = [];\n      instancesRef.current = [];\n    };\n  }, []);\n  const api = useMemo(() => createInstancedRigidBodiesApi(instancesRefGetter), []);\n  useImperativeHandle(ref, () => api);\n  useUpdateRigidBodyOptions(rigidBodyRefs, mergedOptions, rigidBodyStates, false);\n  useRigidBodyEvents(rigidBodyRefs, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: object,\n      api,\n      options: mergedOptions\n    };\n  }, [api, mergedOptions]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object\n  }, props.children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n});\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\n\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, Debug, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundCuboidCollider, TrimeshCollider, interactionGroups, useChildColliderProps, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRigidBody, useSphericalJoint };\n", "import deepEqual from 'fast-deep-equal';\r\n\r\nconst globalCache = [];\r\n\r\nfunction handleAsset(fn, cache, args, lifespan = 0, preload = false) {\r\n  for (const entry of cache) {\r\n    // Find a match\r\n    if (deepEqual(args, entry.args)) {\r\n      // If we're pre-loading and the element is present, just return\r\n      if (preload) return; // If an error occurred, throw\r\n\r\n      if (entry.error) throw entry.error; // If a response was successful, return\r\n\r\n      if (entry.response) return entry.response; // If the promise is still unresolved, throw\r\n\r\n      throw entry.promise;\r\n    }\r\n  } // The request is new or has changed.\r\n\r\n\r\n  const entry = {\r\n    args,\r\n    promise: // Make the promise request.\r\n    fn(...args) // Response can't be undefined or else the loop above wouldn't be able to return it\r\n    // This is for promises that do not return results (delays for instance)\r\n    .then(response => entry.response = response != null ? response : true).catch(e => entry.error = e != null ? e : 'unknown error').then(() => {\r\n      if (lifespan > 0) {\r\n        setTimeout(() => {\r\n          const index = cache.indexOf(entry);\r\n          if (index !== -1) cache.splice(index, 1);\r\n        }, lifespan);\r\n      }\r\n    })\r\n  };\r\n  cache.push(entry);\r\n  if (!preload) throw entry.promise;\r\n}\r\n\r\nfunction clear(cache, ...args) {\r\n  if (args === undefined || args.length === 0) cache.splice(0, cache.length);else {\r\n    const entry = cache.find(entry => deepEqual(args, entry.args));\r\n\r\n    if (entry) {\r\n      const index = cache.indexOf(entry);\r\n      if (index !== -1) cache.splice(index, 1);\r\n    }\r\n  }\r\n}\r\n\r\nfunction createAsset(fn, lifespan = 0) {\r\n  const cache = [];\r\n  return {\r\n    /**\r\n     * @throws Suspense Promise if asset is not yet ready\r\n     * @throws Error if the promise rejected for some reason\r\n     */\r\n    read: (...args) => handleAsset(fn, cache, args, lifespan),\r\n    preload: (...args) => void handleAsset(fn, cache, args, lifespan, true),\r\n    clear: (...args) => clear(cache, ...args),\r\n    peek: (...args) => {\r\n      var _cache$find;\r\n\r\n      return (_cache$find = cache.find(entry => deepEqual(args, entry.args))) == null ? void 0 : _cache$find.response;\r\n    }\r\n  };\r\n}\r\n\r\nfunction useAsset(fn, ...args) {\r\n  return handleAsset(fn, globalCache, args, useAsset.lifespan);\r\n}\r\n\r\nuseAsset.lifespan = 0;\r\n\r\nuseAsset.clear = (...args) => clear(globalCache, ...args);\r\n\r\nuseAsset.preload = (fn, ...args) => void handleAsset(fn, globalCache, args, useAsset.lifespan, true);\r\n\r\nuseAsset.peek = (...args) => {\r\n  var _globalCache$find;\r\n\r\n  return (_globalCache$find = globalCache.find(entry => deepEqual(args, entry.args))) == null ? void 0 : _globalCache$find.response;\r\n};\r\n\r\nexport { createAsset, useAsset };\r\n", "import { Mesh, MathUtils } from 'three';\r\n\r\nvar MorphBlendMesh = function (geometry, material) {\r\n  Mesh.call(this, geometry, material);\r\n  this.animationsMap = {};\r\n  this.animationsList = []; // prepare default animation\r\n  // (all frames played together in 1 second)\r\n\r\n  var numFrames = Object.keys(this.morphTargetDictionary).length;\r\n  var name = '__default';\r\n  var startFrame = 0;\r\n  var endFrame = numFrames - 1;\r\n  var fps = numFrames / 1;\r\n  this.createAnimation(name, startFrame, endFrame, fps);\r\n  this.setAnimationWeight(name, 1);\r\n};\r\n\r\nMorphBlendMesh.prototype = Object.assign(Object.create(Mesh.prototype), {\r\n  constructor: MorphBlendMesh,\r\n  createAnimation: function (name, start, end, fps) {\r\n    var animation = {\r\n      start: start,\r\n      end: end,\r\n      length: end - start + 1,\r\n      fps: fps,\r\n      duration: (end - start) / fps,\r\n      lastFrame: 0,\r\n      currentFrame: 0,\r\n      active: false,\r\n      time: 0,\r\n      direction: 1,\r\n      weight: 1,\r\n      directionBackwards: false,\r\n      mirroredLoop: false\r\n    };\r\n    this.animationsMap[name] = animation;\r\n    this.animationsList.push(animation);\r\n  },\r\n  autoCreateAnimations: function (fps) {\r\n    var pattern = /([a-z]+)_?(\\d+)/i;\r\n    var firstAnimation,\r\n        frameRanges = {};\r\n    var i = 0;\r\n\r\n    for (let key in this.morphTargetDictionary) {\r\n      var chunks = key.match(pattern);\r\n\r\n      if (chunks && chunks.length > 1) {\r\n        var name = chunks[1];\r\n        if (!frameRanges[name]) frameRanges[name] = {\r\n          start: Infinity,\r\n          end: -Infinity\r\n        };\r\n        var range = frameRanges[name];\r\n        if (i < range.start) range.start = i;\r\n        if (i > range.end) range.end = i;\r\n        if (!firstAnimation) firstAnimation = name;\r\n      }\r\n\r\n      i++;\r\n    }\r\n\r\n    for (let name in frameRanges) {\r\n      var range = frameRanges[name];\r\n      this.createAnimation(name, range.start, range.end, fps);\r\n    }\r\n\r\n    this.firstAnimation = firstAnimation;\r\n  },\r\n  setAnimationDirectionForward: function (name) {\r\n    var animation = this.animationsMap[name];\r\n\r\n    if (animation) {\r\n      animation.direction = 1;\r\n      animation.directionBackwards = false;\r\n    }\r\n  },\r\n  setAnimationDirectionBackward: function (name) {\r\n    var animation = this.animationsMap[name];\r\n\r\n    if (animation) {\r\n      animation.direction = -1;\r\n      animation.directionBackwards = true;\r\n    }\r\n  },\r\n  setAnimationFPS: function (name, fps) {\r\n    var animation = this.animationsMap[name];\r\n\r\n    if (animation) {\r\n      animation.fps = fps;\r\n      animation.duration = (animation.end - animation.start) / animation.fps;\r\n    }\r\n  },\r\n  setAnimationDuration: function (name, duration) {\r\n    var animation = this.animationsMap[name];\r\n\r\n    if (animation) {\r\n      animation.duration = duration;\r\n      animation.fps = (animation.end - animation.start) / animation.duration;\r\n    }\r\n  },\r\n  setAnimationWeight: function (name, weight) {\r\n    var animation = this.animationsMap[name];\r\n\r\n    if (animation) {\r\n      animation.weight = weight;\r\n    }\r\n  },\r\n  setAnimationTime: function (name, time) {\r\n    var animation = this.animationsMap[name];\r\n\r\n    if (animation) {\r\n      animation.time = time;\r\n    }\r\n  },\r\n  getAnimationTime: function (name) {\r\n    var time = 0;\r\n    var animation = this.animationsMap[name];\r\n\r\n    if (animation) {\r\n      time = animation.time;\r\n    }\r\n\r\n    return time;\r\n  },\r\n  getAnimationDuration: function (name) {\r\n    var duration = -1;\r\n    var animation = this.animationsMap[name];\r\n\r\n    if (animation) {\r\n      duration = animation.duration;\r\n    }\r\n\r\n    return duration;\r\n  },\r\n  playAnimation: function (name) {\r\n    var animation = this.animationsMap[name];\r\n\r\n    if (animation) {\r\n      animation.time = 0;\r\n      animation.active = true;\r\n    } else {\r\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\r\n    }\r\n  },\r\n  stopAnimation: function (name) {\r\n    var animation = this.animationsMap[name];\r\n\r\n    if (animation) {\r\n      animation.active = false;\r\n    }\r\n  },\r\n  update: function (delta) {\r\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\r\n      var animation = this.animationsList[i];\r\n      if (!animation.active) continue;\r\n      var frameTime = animation.duration / animation.length;\r\n      animation.time += animation.direction * delta;\r\n\r\n      if (animation.mirroredLoop) {\r\n        if (animation.time > animation.duration || animation.time < 0) {\r\n          animation.direction *= -1;\r\n\r\n          if (animation.time > animation.duration) {\r\n            animation.time = animation.duration;\r\n            animation.directionBackwards = true;\r\n          }\r\n\r\n          if (animation.time < 0) {\r\n            animation.time = 0;\r\n            animation.directionBackwards = false;\r\n          }\r\n        }\r\n      } else {\r\n        animation.time = animation.time % animation.duration;\r\n        if (animation.time < 0) animation.time += animation.duration;\r\n      }\r\n\r\n      var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\r\n      var weight = animation.weight;\r\n\r\n      if (keyframe !== animation.currentFrame) {\r\n        this.morphTargetInfluences[animation.lastFrame] = 0;\r\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\r\n        this.morphTargetInfluences[keyframe] = 0;\r\n        animation.lastFrame = animation.currentFrame;\r\n        animation.currentFrame = keyframe;\r\n      }\r\n\r\n      var mix = animation.time % frameTime / frameTime;\r\n      if (animation.directionBackwards) mix = 1 - mix;\r\n\r\n      if (animation.currentFrame !== animation.lastFrame) {\r\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\r\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\r\n      } else {\r\n        this.morphTargetInfluences[animation.currentFrame] = weight;\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\nexport { MorphBlendMesh };\r\n", "import { Vector3, Line3, Plane, Triangle } from 'three';\r\n\r\n/**\r\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\r\n */\r\n\r\nconst Visible = 0;\r\nconst Deleted = 1;\r\n\r\nconst _v1 = new Vector3();\r\n\r\nconst _line3 = new Line3();\r\n\r\nconst _plane = new Plane();\r\n\r\nconst _closestPoint = new Vector3();\r\n\r\nconst _triangle = new Triangle();\r\n\r\nclass ConvexHull {\r\n  constructor() {\r\n    this.tolerance = -1;\r\n    this.faces = []; // the generated faces of the convex hull\r\n\r\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\r\n    // the vertex lists work as follows:\r\n    //\r\n    // let 'a' and 'b' be 'Face' instances\r\n    // let 'v' be points wrapped as instance of 'Vertex'\r\n    //\r\n    //     [v, v, ..., v, v, v, ...]\r\n    //      ^             ^\r\n    //      |             |\r\n    //  a.outside     b.outside\r\n    //\r\n\r\n    this.assigned = new VertexList();\r\n    this.unassigned = new VertexList();\r\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\r\n  }\r\n\r\n  setFromPoints(points) {\r\n    // The algorithm needs at least four points.\r\n    if (points.length >= 4) {\r\n      this.makeEmpty();\r\n\r\n      for (let i = 0, l = points.length; i < l; i++) {\r\n        this.vertices.push(new VertexNode(points[i]));\r\n      }\r\n\r\n      this.compute();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  setFromObject(object) {\r\n    const points = [];\r\n    object.updateMatrixWorld(true);\r\n    object.traverse(function (node) {\r\n      const geometry = node.geometry;\r\n\r\n      if (geometry !== undefined) {\r\n        if (geometry.isGeometry) {\r\n          console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');\r\n          return;\r\n        } else if (geometry.isBufferGeometry) {\r\n          const attribute = geometry.attributes.position;\r\n\r\n          if (attribute !== undefined) {\r\n            for (let i = 0, l = attribute.count; i < l; i++) {\r\n              const point = new Vector3();\r\n              point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\r\n              points.push(point);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n    return this.setFromPoints(points);\r\n  }\r\n\r\n  containsPoint(point) {\r\n    const faces = this.faces;\r\n\r\n    for (let i = 0, l = faces.length; i < l; i++) {\r\n      const face = faces[i]; // compute signed distance and check on what half space the point lies\r\n\r\n      if (face.distanceToPoint(point) > this.tolerance) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  intersectRay(ray, target) {\r\n    // based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\r\n    const faces = this.faces;\r\n    let tNear = -Infinity;\r\n    let tFar = Infinity;\r\n\r\n    for (let i = 0, l = faces.length; i < l; i++) {\r\n      const face = faces[i]; // interpret faces as planes for the further computation\r\n\r\n      const vN = face.distanceToPoint(ray.origin);\r\n      const vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\r\n      // the ray is turned away or parallel to the plane, there is no intersection\r\n\r\n      if (vN > 0 && vD >= 0) return null; // compute the distance from the ray’s origin to the intersection with the plane\r\n\r\n      const t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point\r\n      // lies \"behind\" the origin\r\n\r\n      if (t <= 0) continue; // now categorized plane as front-facing or back-facing\r\n\r\n      if (vD > 0) {\r\n        //  plane faces away from the ray, so this plane is a back-face\r\n        tFar = Math.min(t, tFar);\r\n      } else {\r\n        // front-face\r\n        tNear = Math.max(t, tNear);\r\n      }\r\n\r\n      if (tNear > tFar) {\r\n        // if tNear ever is greater than tFar, the ray must miss the convex hull\r\n        return null;\r\n      }\r\n    } // evaluate intersection point\r\n    // always try tNear first since its the closer intersection point\r\n\r\n\r\n    if (tNear !== -Infinity) {\r\n      ray.at(tNear, target);\r\n    } else {\r\n      ray.at(tFar, target);\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  intersectsRay(ray) {\r\n    return this.intersectRay(ray, _v1) !== null;\r\n  }\r\n\r\n  makeEmpty() {\r\n    this.faces = [];\r\n    this.vertices = [];\r\n    return this;\r\n  } // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\r\n\r\n\r\n  addVertexToFace(vertex, face) {\r\n    vertex.face = face;\r\n\r\n    if (face.outside === null) {\r\n      this.assigned.append(vertex);\r\n    } else {\r\n      this.assigned.insertBefore(face.outside, vertex);\r\n    }\r\n\r\n    face.outside = vertex;\r\n    return this;\r\n  } // Removes a vertex from the 'assigned' list of vertices and from the given face\r\n\r\n\r\n  removeVertexFromFace(vertex, face) {\r\n    if (vertex === face.outside) {\r\n      // fix face.outside link\r\n      if (vertex.next !== null && vertex.next.face === face) {\r\n        // face has at least 2 outside vertices, move the 'outside' reference\r\n        face.outside = vertex.next;\r\n      } else {\r\n        // vertex was the only outside vertex that face had\r\n        face.outside = null;\r\n      }\r\n    }\r\n\r\n    this.assigned.remove(vertex);\r\n    return this;\r\n  } // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\r\n\r\n\r\n  removeAllVerticesFromFace(face) {\r\n    if (face.outside !== null) {\r\n      // reference to the first and last vertex of this face\r\n      const start = face.outside;\r\n      let end = face.outside;\r\n\r\n      while (end.next !== null && end.next.face === face) {\r\n        end = end.next;\r\n      }\r\n\r\n      this.assigned.removeSubList(start, end); // fix references\r\n\r\n      start.prev = end.next = null;\r\n      face.outside = null;\r\n      return start;\r\n    }\r\n  } // Removes all the visible vertices that 'face' is able to see\r\n\r\n\r\n  deleteFaceVertices(face, absorbingFace) {\r\n    const faceVertices = this.removeAllVerticesFromFace(face);\r\n\r\n    if (faceVertices !== undefined) {\r\n      if (absorbingFace === undefined) {\r\n        // mark the vertices to be reassigned to some other face\r\n        this.unassigned.appendChain(faceVertices);\r\n      } else {\r\n        // if there's an absorbing face try to assign as many vertices as possible to it\r\n        let vertex = faceVertices;\r\n\r\n        do {\r\n          // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\r\n          // will be changed by upcoming method calls\r\n          const nextVertex = vertex.next;\r\n          const distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'\r\n\r\n          if (distance > this.tolerance) {\r\n            this.addVertexToFace(vertex, absorbingFace);\r\n          } else {\r\n            this.unassigned.append(vertex);\r\n          } // now assign next vertex\r\n\r\n\r\n          vertex = nextVertex;\r\n        } while (vertex !== null);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  } // Reassigns as many vertices as possible from the unassigned list to the new faces\r\n\r\n\r\n  resolveUnassignedPoints(newFaces) {\r\n    if (this.unassigned.isEmpty() === false) {\r\n      let vertex = this.unassigned.first();\r\n\r\n      do {\r\n        // buffer 'next' reference, see .deleteFaceVertices()\r\n        const nextVertex = vertex.next;\r\n        let maxDistance = this.tolerance;\r\n        let maxFace = null;\r\n\r\n        for (let i = 0; i < newFaces.length; i++) {\r\n          const face = newFaces[i];\r\n\r\n          if (face.mark === Visible) {\r\n            const distance = face.distanceToPoint(vertex.point);\r\n\r\n            if (distance > maxDistance) {\r\n              maxDistance = distance;\r\n              maxFace = face;\r\n            }\r\n\r\n            if (maxDistance > 1000 * this.tolerance) break;\r\n          }\r\n        } // 'maxFace' can be null e.g. if there are identical vertices\r\n\r\n\r\n        if (maxFace !== null) {\r\n          this.addVertexToFace(vertex, maxFace);\r\n        }\r\n\r\n        vertex = nextVertex;\r\n      } while (vertex !== null);\r\n    }\r\n\r\n    return this;\r\n  } // Computes the extremes of a simplex which will be the initial hull\r\n\r\n\r\n  computeExtremes() {\r\n    const min = new Vector3();\r\n    const max = new Vector3();\r\n    const minVertices = [];\r\n    const maxVertices = []; // initially assume that the first vertex is the min/max\r\n\r\n    for (let i = 0; i < 3; i++) {\r\n      minVertices[i] = maxVertices[i] = this.vertices[0];\r\n    }\r\n\r\n    min.copy(this.vertices[0].point);\r\n    max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions\r\n\r\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\r\n      const vertex = this.vertices[i];\r\n      const point = vertex.point; // update the min coordinates\r\n\r\n      for (let j = 0; j < 3; j++) {\r\n        if (point.getComponent(j) < min.getComponent(j)) {\r\n          min.setComponent(j, point.getComponent(j));\r\n          minVertices[j] = vertex;\r\n        }\r\n      } // update the max coordinates\r\n\r\n\r\n      for (let j = 0; j < 3; j++) {\r\n        if (point.getComponent(j) > max.getComponent(j)) {\r\n          max.setComponent(j, point.getComponent(j));\r\n          maxVertices[j] = vertex;\r\n        }\r\n      }\r\n    } // use min/max vectors to compute an optimal epsilon\r\n\r\n\r\n    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\r\n    return {\r\n      min: minVertices,\r\n      max: maxVertices\r\n    };\r\n  } // Computes the initial simplex assigning to its faces all the points\r\n  // that are candidates to form part of the hull\r\n\r\n\r\n  computeInitialHull() {\r\n    const vertices = this.vertices;\r\n    const extremes = this.computeExtremes();\r\n    const min = extremes.min;\r\n    const max = extremes.max; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\r\n    // (max.x - min.x)\r\n    // (max.y - min.y)\r\n    // (max.z - min.z)\r\n\r\n    let maxDistance = 0;\r\n    let index = 0;\r\n\r\n    for (let i = 0; i < 3; i++) {\r\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\r\n\r\n      if (distance > maxDistance) {\r\n        maxDistance = distance;\r\n        index = i;\r\n      }\r\n    }\r\n\r\n    const v0 = min[index];\r\n    const v1 = max[index];\r\n    let v2;\r\n    let v3; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\r\n\r\n    maxDistance = 0;\r\n\r\n    _line3.set(v0.point, v1.point);\r\n\r\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\r\n      const vertex = vertices[i];\r\n\r\n      if (vertex !== v0 && vertex !== v1) {\r\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint);\r\n\r\n        const distance = _closestPoint.distanceToSquared(vertex.point);\r\n\r\n        if (distance > maxDistance) {\r\n          maxDistance = distance;\r\n          v2 = vertex;\r\n        }\r\n      }\r\n    } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\r\n\r\n\r\n    maxDistance = -1;\r\n\r\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\r\n\r\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\r\n      const vertex = vertices[i];\r\n\r\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\r\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point));\r\n\r\n        if (distance > maxDistance) {\r\n          maxDistance = distance;\r\n          v3 = vertex;\r\n        }\r\n      }\r\n    }\r\n\r\n    const faces = [];\r\n\r\n    if (_plane.distanceToPoint(v3.point) < 0) {\r\n      // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\r\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge\r\n\r\n      for (let i = 0; i < 3; i++) {\r\n        const j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\r\n\r\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\r\n\r\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\r\n      }\r\n    } else {\r\n      // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\r\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge\r\n\r\n      for (let i = 0; i < 3; i++) {\r\n        const j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\r\n\r\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3)); // join face[ i ] with face[ i + 1 ]\r\n\r\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\r\n      }\r\n    } // the initial hull is the tetrahedron\r\n\r\n\r\n    for (let i = 0; i < 4; i++) {\r\n      this.faces.push(faces[i]);\r\n    } // initial assignment of vertices to the faces of the tetrahedron\r\n\r\n\r\n    for (let i = 0, l = vertices.length; i < l; i++) {\r\n      const vertex = vertices[i];\r\n\r\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\r\n        maxDistance = this.tolerance;\r\n        let maxFace = null;\r\n\r\n        for (let j = 0; j < 4; j++) {\r\n          const distance = this.faces[j].distanceToPoint(vertex.point);\r\n\r\n          if (distance > maxDistance) {\r\n            maxDistance = distance;\r\n            maxFace = this.faces[j];\r\n          }\r\n        }\r\n\r\n        if (maxFace !== null) {\r\n          this.addVertexToFace(vertex, maxFace);\r\n        }\r\n      }\r\n    }\r\n\r\n    return this;\r\n  } // Removes inactive faces\r\n\r\n\r\n  reindexFaces() {\r\n    const activeFaces = [];\r\n\r\n    for (let i = 0; i < this.faces.length; i++) {\r\n      const face = this.faces[i];\r\n\r\n      if (face.mark === Visible) {\r\n        activeFaces.push(face);\r\n      }\r\n    }\r\n\r\n    this.faces = activeFaces;\r\n    return this;\r\n  } // Finds the next vertex to create faces with the current hull\r\n\r\n\r\n  nextVertexToAdd() {\r\n    // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\r\n    if (this.assigned.isEmpty() === false) {\r\n      let eyeVertex,\r\n          maxDistance = 0; // grap the first available face and start with the first visible vertex of that face\r\n\r\n      const eyeFace = this.assigned.first().face;\r\n      let vertex = eyeFace.outside; // now calculate the farthest vertex that face can see\r\n\r\n      do {\r\n        const distance = eyeFace.distanceToPoint(vertex.point);\r\n\r\n        if (distance > maxDistance) {\r\n          maxDistance = distance;\r\n          eyeVertex = vertex;\r\n        }\r\n\r\n        vertex = vertex.next;\r\n      } while (vertex !== null && vertex.face === eyeFace);\r\n\r\n      return eyeVertex;\r\n    }\r\n  } // Computes a chain of half edges in CCW order called the 'horizon'.\r\n  // For an edge to be part of the horizon it must join a face that can see\r\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\r\n\r\n\r\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\r\n    // moves face's vertices to the 'unassigned' vertex list\r\n    this.deleteFaceVertices(face);\r\n    face.mark = Deleted;\r\n    let edge;\r\n\r\n    if (crossEdge === null) {\r\n      edge = crossEdge = face.getEdge(0);\r\n    } else {\r\n      // start from the next edge since 'crossEdge' was already analyzed\r\n      // (actually 'crossEdge.twin' was the edge who called this method recursively)\r\n      edge = crossEdge.next;\r\n    }\r\n\r\n    do {\r\n      const twinEdge = edge.twin;\r\n      const oppositeFace = twinEdge.face;\r\n\r\n      if (oppositeFace.mark === Visible) {\r\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\r\n          // the opposite face can see the vertex, so proceed with next edge\r\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\r\n        } else {\r\n          // the opposite face can't see the vertex, so this edge is part of the horizon\r\n          horizon.push(edge);\r\n        }\r\n      }\r\n\r\n      edge = edge.next;\r\n    } while (edge !== crossEdge);\r\n\r\n    return this;\r\n  } // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\r\n\r\n\r\n  addAdjoiningFace(eyeVertex, horizonEdge) {\r\n    // all the half edges are created in ccw order thus the face is always pointing outside the hull\r\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\r\n    this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\r\n\r\n    face.getEdge(-1).setTwin(horizonEdge.twin);\r\n    return face.getEdge(0); // the half edge whose vertex is the eyeVertex\r\n  } //  Adds 'horizon.length' faces to the hull, each face will be linked with the\r\n  //  horizon opposite face and the face on the left/right\r\n\r\n\r\n  addNewFaces(eyeVertex, horizon) {\r\n    this.newFaces = [];\r\n    let firstSideEdge = null;\r\n    let previousSideEdge = null;\r\n\r\n    for (let i = 0; i < horizon.length; i++) {\r\n      const horizonEdge = horizon[i]; // returns the right side edge\r\n\r\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\r\n\r\n      if (firstSideEdge === null) {\r\n        firstSideEdge = sideEdge;\r\n      } else {\r\n        // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\r\n        sideEdge.next.setTwin(previousSideEdge);\r\n      }\r\n\r\n      this.newFaces.push(sideEdge.face);\r\n      previousSideEdge = sideEdge;\r\n    } // perform final join of new faces\r\n\r\n\r\n    firstSideEdge.next.setTwin(previousSideEdge);\r\n    return this;\r\n  } // Adds a vertex to the hull\r\n\r\n\r\n  addVertexToHull(eyeVertex) {\r\n    const horizon = [];\r\n    this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\r\n\r\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face);\r\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\r\n    this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces\r\n\r\n    this.resolveUnassignedPoints(this.newFaces);\r\n    return this;\r\n  }\r\n\r\n  cleanup() {\r\n    this.assigned.clear();\r\n    this.unassigned.clear();\r\n    this.newFaces = [];\r\n    return this;\r\n  }\r\n\r\n  compute() {\r\n    let vertex;\r\n    this.computeInitialHull(); // add all available vertices gradually to the hull\r\n\r\n    while ((vertex = this.nextVertexToAdd()) !== undefined) {\r\n      this.addVertexToHull(vertex);\r\n    }\r\n\r\n    this.reindexFaces();\r\n    this.cleanup();\r\n    return this;\r\n  }\r\n\r\n} //\r\n\r\n\r\nclass Face {\r\n  constructor() {\r\n    this.normal = new Vector3();\r\n    this.midpoint = new Vector3();\r\n    this.area = 0;\r\n    this.constant = 0; // signed distance from face to the origin\r\n\r\n    this.outside = null; // reference to a vertex in a vertex list this face can see\r\n\r\n    this.mark = Visible;\r\n    this.edge = null;\r\n  }\r\n\r\n  static create(a, b, c) {\r\n    const face = new Face();\r\n    const e0 = new HalfEdge(a, face);\r\n    const e1 = new HalfEdge(b, face);\r\n    const e2 = new HalfEdge(c, face); // join edges\r\n\r\n    e0.next = e2.prev = e1;\r\n    e1.next = e0.prev = e2;\r\n    e2.next = e1.prev = e0; // main half edge reference\r\n\r\n    face.edge = e0;\r\n    return face.compute();\r\n  }\r\n\r\n  getEdge(i) {\r\n    let edge = this.edge;\r\n\r\n    while (i > 0) {\r\n      edge = edge.next;\r\n      i--;\r\n    }\r\n\r\n    while (i < 0) {\r\n      edge = edge.prev;\r\n      i++;\r\n    }\r\n\r\n    return edge;\r\n  }\r\n\r\n  compute() {\r\n    const a = this.edge.tail();\r\n    const b = this.edge.head();\r\n    const c = this.edge.next.head();\r\n\r\n    _triangle.set(a.point, b.point, c.point);\r\n\r\n    _triangle.getNormal(this.normal);\r\n\r\n    _triangle.getMidpoint(this.midpoint);\r\n\r\n    this.area = _triangle.getArea();\r\n    this.constant = this.normal.dot(this.midpoint);\r\n    return this;\r\n  }\r\n\r\n  distanceToPoint(point) {\r\n    return this.normal.dot(point) - this.constant;\r\n  }\r\n\r\n} // Entity for a Doubly-Connected Edge List (DCEL).\r\n\r\n\r\nclass HalfEdge {\r\n  constructor(vertex, face) {\r\n    this.vertex = vertex;\r\n    this.prev = null;\r\n    this.next = null;\r\n    this.twin = null;\r\n    this.face = face;\r\n  }\r\n\r\n  head() {\r\n    return this.vertex;\r\n  }\r\n\r\n  tail() {\r\n    return this.prev ? this.prev.vertex : null;\r\n  }\r\n\r\n  length() {\r\n    const head = this.head();\r\n    const tail = this.tail();\r\n\r\n    if (tail !== null) {\r\n      return tail.point.distanceTo(head.point);\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  lengthSquared() {\r\n    const head = this.head();\r\n    const tail = this.tail();\r\n\r\n    if (tail !== null) {\r\n      return tail.point.distanceToSquared(head.point);\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  setTwin(edge) {\r\n    this.twin = edge;\r\n    edge.twin = this;\r\n    return this;\r\n  }\r\n\r\n} // A vertex as a double linked list node.\r\n\r\n\r\nclass VertexNode {\r\n  constructor(point) {\r\n    this.point = point;\r\n    this.prev = null;\r\n    this.next = null;\r\n    this.face = null; // the face that is able to see this vertex\r\n  }\r\n\r\n} // A double linked list that contains vertex nodes.\r\n\r\n\r\nclass VertexList {\r\n  constructor() {\r\n    this.head = null;\r\n    this.tail = null;\r\n  }\r\n\r\n  first() {\r\n    return this.head;\r\n  }\r\n\r\n  last() {\r\n    return this.tail;\r\n  }\r\n\r\n  clear() {\r\n    this.head = this.tail = null;\r\n    return this;\r\n  } // Inserts a vertex before the target vertex\r\n\r\n\r\n  insertBefore(target, vertex) {\r\n    vertex.prev = target.prev;\r\n    vertex.next = target;\r\n\r\n    if (vertex.prev === null) {\r\n      this.head = vertex;\r\n    } else {\r\n      vertex.prev.next = vertex;\r\n    }\r\n\r\n    target.prev = vertex;\r\n    return this;\r\n  } // Inserts a vertex after the target vertex\r\n\r\n\r\n  insertAfter(target, vertex) {\r\n    vertex.prev = target;\r\n    vertex.next = target.next;\r\n\r\n    if (vertex.next === null) {\r\n      this.tail = vertex;\r\n    } else {\r\n      vertex.next.prev = vertex;\r\n    }\r\n\r\n    target.next = vertex;\r\n    return this;\r\n  } // Appends a vertex to the end of the linked list\r\n\r\n\r\n  append(vertex) {\r\n    if (this.head === null) {\r\n      this.head = vertex;\r\n    } else {\r\n      this.tail.next = vertex;\r\n    }\r\n\r\n    vertex.prev = this.tail;\r\n    vertex.next = null; // the tail has no subsequent vertex\r\n\r\n    this.tail = vertex;\r\n    return this;\r\n  } // Appends a chain of vertices where 'vertex' is the head.\r\n\r\n\r\n  appendChain(vertex) {\r\n    if (this.head === null) {\r\n      this.head = vertex;\r\n    } else {\r\n      this.tail.next = vertex;\r\n    }\r\n\r\n    vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain\r\n\r\n    while (vertex.next !== null) {\r\n      vertex = vertex.next;\r\n    }\r\n\r\n    this.tail = vertex;\r\n    return this;\r\n  } // Removes a vertex from the linked list\r\n\r\n\r\n  remove(vertex) {\r\n    if (vertex.prev === null) {\r\n      this.head = vertex.next;\r\n    } else {\r\n      vertex.prev.next = vertex.next;\r\n    }\r\n\r\n    if (vertex.next === null) {\r\n      this.tail = vertex.prev;\r\n    } else {\r\n      vertex.next.prev = vertex.prev;\r\n    }\r\n\r\n    return this;\r\n  } // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\r\n\r\n\r\n  removeSubList(a, b) {\r\n    if (a.prev === null) {\r\n      this.head = b.next;\r\n    } else {\r\n      a.prev.next = b.next;\r\n    }\r\n\r\n    if (b.next === null) {\r\n      this.tail = a.prev;\r\n    } else {\r\n      b.next.prev = a.prev;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.head === null;\r\n  }\r\n\r\n}\r\n\r\nexport { ConvexHull };\r\n", "import { BufferGeometry, Float32BufferAttribute } from 'three';\r\nimport { ConvexHull } from '../math/ConvexHull.js';\r\n\r\nclass ConvexGeometry extends BufferGeometry {\r\n  constructor(points = []) {\r\n    super(); // buffers\r\n\r\n    const vertices = [];\r\n    const normals = [];\r\n\r\n    if (ConvexHull === undefined) {\r\n      console.error('THREE.ConvexGeometry: ConvexGeometry relies on ConvexHull');\r\n    }\r\n\r\n    const convexHull = new ConvexHull().setFromPoints(points); // generate vertices and normals\r\n\r\n    const faces = convexHull.faces;\r\n\r\n    for (let i = 0; i < faces.length; i++) {\r\n      const face = faces[i];\r\n      let edge = face.edge; // we move along a doubly-connected edge list to access all face points (see HalfEdge docs)\r\n\r\n      do {\r\n        const point = edge.head().point;\r\n        vertices.push(point.x, point.y, point.z);\r\n        normals.push(face.normal.x, face.normal.y, face.normal.z);\r\n        edge = edge.next;\r\n      } while (edge !== face.edge);\r\n    } // build geometry\r\n\r\n\r\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n  }\r\n\r\n}\r\n\r\nexport { ConvexGeometry };\r\n", "import { Line3, Plane, Vector3, Mesh } from 'three';\r\nimport { ConvexGeometry } from '../geometries/ConvexGeometry.js';\r\n\r\n/**\r\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\r\n *\r\n * Usage:\r\n *\r\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\r\n *\r\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\r\n *\r\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\r\n *\r\n * Requisites for the object:\r\n *\r\n *  - Mesh object must have a BufferGeometry (not Geometry) and a Material\r\n *\r\n *  - Vertex normals must be planar (not smoothed)\r\n *\r\n *  - The geometry must be convex (this is not checked in the library). You can create convex\r\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\r\n *  can also be used.\r\n *\r\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\r\n * Use with caution and read the code when using with other libs.\r\n *\r\n * @param {double} minSizeForBreak Min size a debris can have to break.\r\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\r\n *\r\n */\r\n\r\nvar ConvexObjectBreaker = function (minSizeForBreak, smallDelta) {\r\n  this.minSizeForBreak = minSizeForBreak || 1.4;\r\n  this.smallDelta = smallDelta || 0.0001;\r\n  this.tempLine1 = new Line3();\r\n  this.tempPlane1 = new Plane();\r\n  this.tempPlane2 = new Plane();\r\n  this.tempPlane_Cut = new Plane();\r\n  this.tempCM1 = new Vector3();\r\n  this.tempCM2 = new Vector3();\r\n  this.tempVector3 = new Vector3();\r\n  this.tempVector3_2 = new Vector3();\r\n  this.tempVector3_3 = new Vector3();\r\n  this.tempVector3_P0 = new Vector3();\r\n  this.tempVector3_P1 = new Vector3();\r\n  this.tempVector3_P2 = new Vector3();\r\n  this.tempVector3_N0 = new Vector3();\r\n  this.tempVector3_N1 = new Vector3();\r\n  this.tempVector3_AB = new Vector3();\r\n  this.tempVector3_CB = new Vector3();\r\n  this.tempResultObjects = {\r\n    object1: null,\r\n    object2: null\r\n  };\r\n  this.segments = [];\r\n  var n = 30 * 30;\r\n\r\n  for (let i = 0; i < n; i++) this.segments[i] = false;\r\n};\r\n\r\nConvexObjectBreaker.prototype = {\r\n  constructor: ConvexObjectBreaker,\r\n  prepareBreakableObject: function (object, mass, velocity, angularVelocity, breakable) {\r\n    // object is a Object3d (normally a Mesh), must have a BufferGeometry, and it must be convex.\r\n    // Its material property is propagated to its children (sub-pieces)\r\n    // mass must be > 0\r\n    if (!object.geometry.isBufferGeometry) {\r\n      console.error('THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.');\r\n    }\r\n\r\n    var userData = object.userData;\r\n    userData.mass = mass;\r\n    userData.velocity = velocity.clone();\r\n    userData.angularVelocity = angularVelocity.clone();\r\n    userData.breakable = breakable;\r\n  },\r\n\r\n  /*\r\n   * @param {int} maxRadialIterations Iterations for radial cuts.\r\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\r\n   *\r\n   * Returns the array of pieces\r\n   */\r\n  subdivideByImpact: function (object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\r\n    var debris = [];\r\n    var tempPlane1 = this.tempPlane1;\r\n    var tempPlane2 = this.tempPlane2;\r\n    this.tempVector3.addVectors(pointOfImpact, normal);\r\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\r\n    var maxTotalIterations = maxRandomIterations + maxRadialIterations;\r\n    var scope = this;\r\n\r\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\r\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\r\n        debris.push(subObject);\r\n        return;\r\n      }\r\n\r\n      var angle = Math.PI;\r\n\r\n      if (numIterations === 0) {\r\n        tempPlane2.normal.copy(tempPlane1.normal);\r\n        tempPlane2.constant = tempPlane1.constant;\r\n      } else {\r\n        if (numIterations <= maxRadialIterations) {\r\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle; // Rotate tempPlane2 at impact point around normal axis and the angle\r\n\r\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\r\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\r\n        } else {\r\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI; // Rotate tempPlane2 at object position around normal axis and the angle\r\n\r\n          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\r\n          scope.tempVector3_3.copy(normal).add(subObject.position);\r\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\r\n        }\r\n      } // Perform the cut\r\n\r\n\r\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\r\n      var obj1 = scope.tempResultObjects.object1;\r\n      var obj2 = scope.tempResultObjects.object2;\r\n\r\n      if (obj1) {\r\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1);\r\n      }\r\n\r\n      if (obj2) {\r\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1);\r\n      }\r\n    }\r\n\r\n    subdivideRadial(object, 0, 2 * Math.PI, 0);\r\n    return debris;\r\n  },\r\n  cutByPlane: function (object, plane, output) {\r\n    // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\r\n    // object2 can be null if the plane doesn't cut the object.\r\n    // object1 can be null only in case of internal error\r\n    // Returned value is number of pieces, 0 for error.\r\n    var geometry = object.geometry;\r\n    var coords = geometry.attributes.position.array;\r\n    var normals = geometry.attributes.normal.array;\r\n    var numPoints = coords.length / 3;\r\n    var numFaces = numPoints / 3;\r\n    var indices = geometry.getIndex();\r\n\r\n    if (indices) {\r\n      indices = indices.array;\r\n      numFaces = indices.length / 3;\r\n    }\r\n\r\n    function getVertexIndex(faceIdx, vert) {\r\n      // vert = 0, 1 or 2.\r\n      var idx = faceIdx * 3 + vert;\r\n      return indices ? indices[idx] : idx;\r\n    }\r\n\r\n    var points1 = [];\r\n    var points2 = [];\r\n    var delta = this.smallDelta; // Reset segments mark\r\n\r\n    var numPointPairs = numPoints * numPoints;\r\n\r\n    for (let i = 0; i < numPointPairs; i++) this.segments[i] = false;\r\n\r\n    var p0 = this.tempVector3_P0;\r\n    var p1 = this.tempVector3_P1;\r\n    var n0 = this.tempVector3_N0;\r\n    var n1 = this.tempVector3_N1; // Iterate through the faces to mark edges shared by coplanar faces\r\n\r\n    for (let i = 0; i < numFaces - 1; i++) {\r\n      var a1 = getVertexIndex(i, 0);\r\n      var b1 = getVertexIndex(i, 1);\r\n      var c1 = getVertexIndex(i, 2); // Assuming all 3 vertices have the same normal\r\n\r\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\r\n\r\n      for (let j = i + 1; j < numFaces; j++) {\r\n        var a2 = getVertexIndex(j, 0);\r\n        var b2 = getVertexIndex(j, 1);\r\n        var c2 = getVertexIndex(j, 2); // Assuming all 3 vertices have the same normal\r\n\r\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\r\n        var coplanar = 1 - n0.dot(n1) < delta;\r\n\r\n        if (coplanar) {\r\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\r\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\r\n              this.segments[a1 * numPoints + b1] = true;\r\n              this.segments[b1 * numPoints + a1] = true;\r\n            } else {\r\n              this.segments[c1 * numPoints + a1] = true;\r\n              this.segments[a1 * numPoints + c1] = true;\r\n            }\r\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\r\n            this.segments[c1 * numPoints + b1] = true;\r\n            this.segments[b1 * numPoints + c1] = true;\r\n          }\r\n        }\r\n      }\r\n    } // Transform the plane to object local space\r\n\r\n\r\n    var localPlane = this.tempPlane_Cut;\r\n    object.updateMatrix();\r\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane); // Iterate through the faces adding points to both pieces\r\n\r\n    for (let i = 0; i < numFaces; i++) {\r\n      var va = getVertexIndex(i, 0);\r\n      var vb = getVertexIndex(i, 1);\r\n      var vc = getVertexIndex(i, 2);\r\n\r\n      for (let segment = 0; segment < 3; segment++) {\r\n        var i0 = segment === 0 ? va : segment === 1 ? vb : vc;\r\n        var i1 = segment === 0 ? vb : segment === 1 ? vc : va;\r\n        var segmentState = this.segments[i0 * numPoints + i1];\r\n        if (segmentState) continue; // The segment already has been processed in another face\r\n        // Mark segment as processed (also inverted segment)\r\n\r\n        this.segments[i0 * numPoints + i1] = true;\r\n        this.segments[i1 * numPoints + i0] = true;\r\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\r\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]); // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\r\n\r\n        var mark0 = 0;\r\n        var d = localPlane.distanceToPoint(p0);\r\n\r\n        if (d > delta) {\r\n          mark0 = 2;\r\n          points2.push(p0.clone());\r\n        } else if (d < -delta) {\r\n          mark0 = 1;\r\n          points1.push(p0.clone());\r\n        } else {\r\n          mark0 = 3;\r\n          points1.push(p0.clone());\r\n          points2.push(p0.clone());\r\n        } // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\r\n\r\n\r\n        var mark1 = 0;\r\n        var d = localPlane.distanceToPoint(p1);\r\n\r\n        if (d > delta) {\r\n          mark1 = 2;\r\n          points2.push(p1.clone());\r\n        } else if (d < -delta) {\r\n          mark1 = 1;\r\n          points1.push(p1.clone());\r\n        } else {\r\n          mark1 = 3;\r\n          points1.push(p1.clone());\r\n          points2.push(p1.clone());\r\n        }\r\n\r\n        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\r\n          // Intersection of segment with the plane\r\n          this.tempLine1.start.copy(p0);\r\n          this.tempLine1.end.copy(p1);\r\n          var intersection = new Vector3();\r\n          intersection = localPlane.intersectLine(this.tempLine1, intersection);\r\n\r\n          if (intersection === undefined) {\r\n            // Shouldn't happen\r\n            console.error('Internal error: segment does not intersect plane.');\r\n            output.segmentedObject1 = null;\r\n            output.segmentedObject2 = null;\r\n            return 0;\r\n          }\r\n\r\n          points1.push(intersection);\r\n          points2.push(intersection.clone());\r\n        }\r\n      }\r\n    } // Calculate debris mass (very fast and imprecise):\r\n\r\n\r\n    var newMass = object.userData.mass * 0.5; // Calculate debris Center of Mass (again fast and imprecise)\r\n\r\n    this.tempCM1.set(0, 0, 0);\r\n    var radius1 = 0;\r\n    var numPoints1 = points1.length;\r\n\r\n    if (numPoints1 > 0) {\r\n      for (let i = 0; i < numPoints1; i++) this.tempCM1.add(points1[i]);\r\n\r\n      this.tempCM1.divideScalar(numPoints1);\r\n\r\n      for (let i = 0; i < numPoints1; i++) {\r\n        var p = points1[i];\r\n        p.sub(this.tempCM1);\r\n        radius1 = Math.max(radius1, p.x, p.y, p.z);\r\n      }\r\n\r\n      this.tempCM1.add(object.position);\r\n    }\r\n\r\n    this.tempCM2.set(0, 0, 0);\r\n    var radius2 = 0;\r\n    var numPoints2 = points2.length;\r\n\r\n    if (numPoints2 > 0) {\r\n      for (let i = 0; i < numPoints2; i++) this.tempCM2.add(points2[i]);\r\n\r\n      this.tempCM2.divideScalar(numPoints2);\r\n\r\n      for (let i = 0; i < numPoints2; i++) {\r\n        var p = points2[i];\r\n        p.sub(this.tempCM2);\r\n        radius2 = Math.max(radius2, p.x, p.y, p.z);\r\n      }\r\n\r\n      this.tempCM2.add(object.position);\r\n    }\r\n\r\n    var object1 = null;\r\n    var object2 = null;\r\n    var numObjects = 0;\r\n\r\n    if (numPoints1 > 4) {\r\n      object1 = new Mesh(new ConvexGeometry(points1), object.material);\r\n      object1.position.copy(this.tempCM1);\r\n      object1.quaternion.copy(object.quaternion);\r\n      this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\r\n      numObjects++;\r\n    }\r\n\r\n    if (numPoints2 > 4) {\r\n      object2 = new Mesh(new ConvexGeometry(points2), object.material);\r\n      object2.position.copy(this.tempCM2);\r\n      object2.quaternion.copy(object.quaternion);\r\n      this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\r\n      numObjects++;\r\n    }\r\n\r\n    output.object1 = object1;\r\n    output.object2 = object2;\r\n    return numObjects;\r\n  }\r\n};\r\n\r\nConvexObjectBreaker.transformFreeVector = function (v, m) {\r\n  // input:\r\n  // vector interpreted as a free vector\r\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\r\n  var x = v.x,\r\n      y = v.y,\r\n      z = v.z;\r\n  var e = m.elements;\r\n  v.x = e[0] * x + e[4] * y + e[8] * z;\r\n  v.y = e[1] * x + e[5] * y + e[9] * z;\r\n  v.z = e[2] * x + e[6] * y + e[10] * z;\r\n  return v;\r\n};\r\n\r\nConvexObjectBreaker.transformFreeVectorInverse = function (v, m) {\r\n  // input:\r\n  // vector interpreted as a free vector\r\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\r\n  var x = v.x,\r\n      y = v.y,\r\n      z = v.z;\r\n  var e = m.elements;\r\n  v.x = e[0] * x + e[1] * y + e[2] * z;\r\n  v.y = e[4] * x + e[5] * y + e[6] * z;\r\n  v.z = e[8] * x + e[9] * y + e[10] * z;\r\n  return v;\r\n};\r\n\r\nConvexObjectBreaker.transformTiedVectorInverse = function (v, m) {\r\n  // input:\r\n  // vector interpreted as a tied (ordinary) vector\r\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\r\n  var x = v.x,\r\n      y = v.y,\r\n      z = v.z;\r\n  var e = m.elements;\r\n  v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\r\n  v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\r\n  v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\r\n  return v;\r\n};\r\n\r\nConvexObjectBreaker.transformPlaneToLocalSpace = function () {\r\n  var v1 = new Vector3();\r\n  return function transformPlaneToLocalSpace(plane, m, resultPlane) {\r\n    resultPlane.normal.copy(plane.normal);\r\n    resultPlane.constant = plane.constant;\r\n    var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v1), m);\r\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m); // recalculate constant (like in setFromNormalAndCoplanarPoint)\r\n\r\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal);\r\n  };\r\n}();\r\n\r\nexport { ConvexObjectBreaker };\r\n", "import { Object3D, Vector3, Quaternion } from 'three';\r\n\r\nvar Gyroscope = function () {\r\n  Object3D.call(this);\r\n};\r\n\r\nGyroscope.prototype = Object.create(Object3D.prototype);\r\nGyroscope.prototype.constructor = Gyroscope;\r\n\r\nGyroscope.prototype.updateMatrixWorld = function () {\r\n  var translationObject = new Vector3();\r\n  var quaternionObject = new Quaternion();\r\n  var scaleObject = new Vector3();\r\n  var translationWorld = new Vector3();\r\n  var quaternionWorld = new Quaternion();\r\n  var scaleWorld = new Vector3();\r\n  return function updateMatrixWorld(force) {\r\n    this.matrixAutoUpdate && this.updateMatrix(); // update matrixWorld\r\n\r\n    if (this.matrixWorldNeedsUpdate || force) {\r\n      if (this.parent !== null) {\r\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\r\n        this.matrixWorld.decompose(translationWorld, quaternionWorld, scaleWorld);\r\n        this.matrix.decompose(translationObject, quaternionObject, scaleObject);\r\n        this.matrixWorld.compose(translationWorld, quaternionObject, scaleWorld);\r\n      } else {\r\n        this.matrixWorld.copy(this.matrix);\r\n      }\r\n\r\n      this.matrixWorldNeedsUpdate = false;\r\n      force = true;\r\n    } // update children\r\n\r\n\r\n    for (let i = 0, l = this.children.length; i < l; i++) {\r\n      this.children[i].updateMatrixWorld(force);\r\n    }\r\n  };\r\n}();\r\n\r\nexport { Gyroscope };\r\n", "import { Mesh, AnimationMixer, AnimationClip } from 'three';\r\n\r\nvar MorphAnimMesh = function (geometry, material) {\r\n  Mesh.call(this, geometry, material);\r\n  this.type = 'MorphAnimMesh';\r\n  this.mixer = new AnimationMixer(this);\r\n  this.activeAction = null;\r\n};\r\n\r\nMorphAnimMesh.prototype = Object.create(Mesh.prototype);\r\nMorphAnimMesh.prototype.constructor = MorphAnimMesh;\r\n\r\nMorphAnimMesh.prototype.setDirectionForward = function () {\r\n  this.mixer.timeScale = 1.0;\r\n};\r\n\r\nMorphAnimMesh.prototype.setDirectionBackward = function () {\r\n  this.mixer.timeScale = -1.0;\r\n};\r\n\r\nMorphAnimMesh.prototype.playAnimation = function (label, fps) {\r\n  if (this.activeAction) {\r\n    this.activeAction.stop();\r\n    this.activeAction = null;\r\n  }\r\n\r\n  var clip = AnimationClip.findByName(this, label);\r\n\r\n  if (clip) {\r\n    var action = this.mixer.clipAction(clip);\r\n    action.timeScale = clip.tracks.length * fps / clip.duration;\r\n    this.activeAction = action.play();\r\n  } else {\r\n    throw new Error('THREE.MorphAnimMesh: animations[' + label + '] undefined in .playAnimation()');\r\n  }\r\n};\r\n\r\nMorphAnimMesh.prototype.updateAnimation = function (delta) {\r\n  this.mixer.update(delta);\r\n};\r\n\r\nMorphAnimMesh.prototype.copy = function (source) {\r\n  Mesh.prototype.copy.call(this, source);\r\n  this.mixer = new AnimationMixer(this);\r\n  return this;\r\n};\r\n\r\nexport { MorphAnimMesh };\r\n", "import { BufferGeometry, Vector3, Quaternion, BufferAttribute, Raycaster } from 'three';\r\n\r\nvar RollerCoasterGeometry = function (curve, divisions) {\r\n  BufferGeometry.call(this);\r\n  var vertices = [];\r\n  var normals = [];\r\n  var colors = [];\r\n  var color1 = [1, 1, 1];\r\n  var color2 = [1, 1, 0];\r\n  var up = new Vector3(0, 1, 0);\r\n  var forward = new Vector3();\r\n  var right = new Vector3();\r\n  var quaternion = new Quaternion();\r\n  var prevQuaternion = new Quaternion();\r\n  prevQuaternion.setFromAxisAngle(up, Math.PI / 2);\r\n  var point = new Vector3();\r\n  var prevPoint = new Vector3();\r\n  prevPoint.copy(curve.getPointAt(0)); // shapes\r\n\r\n  var step = [new Vector3(-0.225, 0, 0), new Vector3(0, -0.05, 0), new Vector3(0, -0.175, 0), new Vector3(0, -0.05, 0), new Vector3(0.225, 0, 0), new Vector3(0, -0.175, 0)];\r\n  var PI2 = Math.PI * 2;\r\n  var sides = 5;\r\n  var tube1 = [];\r\n\r\n  for (let i = 0; i < sides; i++) {\r\n    var angle = i / sides * PI2;\r\n    tube1.push(new Vector3(Math.sin(angle) * 0.06, Math.cos(angle) * 0.06, 0));\r\n  }\r\n\r\n  var sides = 6;\r\n  var tube2 = [];\r\n\r\n  for (let i = 0; i < sides; i++) {\r\n    var angle = i / sides * PI2;\r\n    tube2.push(new Vector3(Math.sin(angle) * 0.025, Math.cos(angle) * 0.025, 0));\r\n  }\r\n\r\n  var vector = new Vector3();\r\n  var normal = new Vector3();\r\n\r\n  function drawShape(shape, color) {\r\n    normal.set(0, 0, -1).applyQuaternion(quaternion);\r\n\r\n    for (let j = 0; j < shape.length; j++) {\r\n      vector.copy(shape[j]);\r\n      vector.applyQuaternion(quaternion);\r\n      vector.add(point);\r\n      vertices.push(vector.x, vector.y, vector.z);\r\n      normals.push(normal.x, normal.y, normal.z);\r\n      colors.push(color[0], color[1], color[2]);\r\n    }\r\n\r\n    normal.set(0, 0, 1).applyQuaternion(quaternion);\r\n\r\n    for (let j = shape.length - 1; j >= 0; j--) {\r\n      vector.copy(shape[j]);\r\n      vector.applyQuaternion(quaternion);\r\n      vector.add(point);\r\n      vertices.push(vector.x, vector.y, vector.z);\r\n      normals.push(normal.x, normal.y, normal.z);\r\n      colors.push(color[0], color[1], color[2]);\r\n    }\r\n  }\r\n\r\n  var vector1 = new Vector3();\r\n  var vector2 = new Vector3();\r\n  var vector3 = new Vector3();\r\n  var vector4 = new Vector3();\r\n  var normal1 = new Vector3();\r\n  var normal2 = new Vector3();\r\n  var normal3 = new Vector3();\r\n  var normal4 = new Vector3();\r\n\r\n  function extrudeShape(shape, offset, color) {\r\n    for (let j = 0, jl = shape.length; j < jl; j++) {\r\n      var point1 = shape[j];\r\n      var point2 = shape[(j + 1) % jl];\r\n      vector1.copy(point1).add(offset);\r\n      vector1.applyQuaternion(quaternion);\r\n      vector1.add(point);\r\n      vector2.copy(point2).add(offset);\r\n      vector2.applyQuaternion(quaternion);\r\n      vector2.add(point);\r\n      vector3.copy(point2).add(offset);\r\n      vector3.applyQuaternion(prevQuaternion);\r\n      vector3.add(prevPoint);\r\n      vector4.copy(point1).add(offset);\r\n      vector4.applyQuaternion(prevQuaternion);\r\n      vector4.add(prevPoint);\r\n      vertices.push(vector1.x, vector1.y, vector1.z);\r\n      vertices.push(vector2.x, vector2.y, vector2.z);\r\n      vertices.push(vector4.x, vector4.y, vector4.z);\r\n      vertices.push(vector2.x, vector2.y, vector2.z);\r\n      vertices.push(vector3.x, vector3.y, vector3.z);\r\n      vertices.push(vector4.x, vector4.y, vector4.z); //\r\n\r\n      normal1.copy(point1);\r\n      normal1.applyQuaternion(quaternion);\r\n      normal1.normalize();\r\n      normal2.copy(point2);\r\n      normal2.applyQuaternion(quaternion);\r\n      normal2.normalize();\r\n      normal3.copy(point2);\r\n      normal3.applyQuaternion(prevQuaternion);\r\n      normal3.normalize();\r\n      normal4.copy(point1);\r\n      normal4.applyQuaternion(prevQuaternion);\r\n      normal4.normalize();\r\n      normals.push(normal1.x, normal1.y, normal1.z);\r\n      normals.push(normal2.x, normal2.y, normal2.z);\r\n      normals.push(normal4.x, normal4.y, normal4.z);\r\n      normals.push(normal2.x, normal2.y, normal2.z);\r\n      normals.push(normal3.x, normal3.y, normal3.z);\r\n      normals.push(normal4.x, normal4.y, normal4.z);\r\n      colors.push(color[0], color[1], color[2]);\r\n      colors.push(color[0], color[1], color[2]);\r\n      colors.push(color[0], color[1], color[2]);\r\n      colors.push(color[0], color[1], color[2]);\r\n      colors.push(color[0], color[1], color[2]);\r\n      colors.push(color[0], color[1], color[2]);\r\n    }\r\n  }\r\n\r\n  var offset = new Vector3();\r\n\r\n  for (let i = 1; i <= divisions; i++) {\r\n    point.copy(curve.getPointAt(i / divisions));\r\n    up.set(0, 1, 0);\r\n    forward.subVectors(point, prevPoint).normalize();\r\n    right.crossVectors(up, forward).normalize();\r\n    up.crossVectors(forward, right);\r\n    var angle = Math.atan2(forward.x, forward.z);\r\n    quaternion.setFromAxisAngle(up, angle);\r\n\r\n    if (i % 2 === 0) {\r\n      drawShape(step, color2);\r\n    }\r\n\r\n    extrudeShape(tube1, offset.set(0, -0.125, 0), color2);\r\n    extrudeShape(tube2, offset.set(0.2, 0, 0), color1);\r\n    extrudeShape(tube2, offset.set(-0.2, 0, 0), color1);\r\n    prevPoint.copy(point);\r\n    prevQuaternion.copy(quaternion);\r\n  } // console.log( vertices.length );\r\n\r\n\r\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\r\n  this.setAttribute('normal', new BufferAttribute(new Float32Array(normals), 3));\r\n  this.setAttribute('color', new BufferAttribute(new Float32Array(colors), 3));\r\n};\r\n\r\nRollerCoasterGeometry.prototype = Object.create(BufferGeometry.prototype);\r\n\r\nvar RollerCoasterLiftersGeometry = function (curve, divisions) {\r\n  BufferGeometry.call(this);\r\n  var vertices = [];\r\n  var normals = [];\r\n  var quaternion = new Quaternion();\r\n  var up = new Vector3(0, 1, 0);\r\n  var point = new Vector3();\r\n  var tangent = new Vector3(); // shapes\r\n\r\n  var tube1 = [new Vector3(0, 0.05, -0.05), new Vector3(0, 0.05, 0.05), new Vector3(0, -0.05, 0)];\r\n  var tube2 = [new Vector3(-0.05, 0, 0.05), new Vector3(-0.05, 0, -0.05), new Vector3(0.05, 0, 0)];\r\n  var tube3 = [new Vector3(0.05, 0, -0.05), new Vector3(0.05, 0, 0.05), new Vector3(-0.05, 0, 0)];\r\n  var vector1 = new Vector3();\r\n  var vector2 = new Vector3();\r\n  var vector3 = new Vector3();\r\n  var vector4 = new Vector3();\r\n  var normal1 = new Vector3();\r\n  var normal2 = new Vector3();\r\n  var normal3 = new Vector3();\r\n  var normal4 = new Vector3();\r\n\r\n  function extrudeShape(shape, fromPoint, toPoint) {\r\n    for (let j = 0, jl = shape.length; j < jl; j++) {\r\n      var point1 = shape[j];\r\n      var point2 = shape[(j + 1) % jl];\r\n      vector1.copy(point1);\r\n      vector1.applyQuaternion(quaternion);\r\n      vector1.add(fromPoint);\r\n      vector2.copy(point2);\r\n      vector2.applyQuaternion(quaternion);\r\n      vector2.add(fromPoint);\r\n      vector3.copy(point2);\r\n      vector3.applyQuaternion(quaternion);\r\n      vector3.add(toPoint);\r\n      vector4.copy(point1);\r\n      vector4.applyQuaternion(quaternion);\r\n      vector4.add(toPoint);\r\n      vertices.push(vector1.x, vector1.y, vector1.z);\r\n      vertices.push(vector2.x, vector2.y, vector2.z);\r\n      vertices.push(vector4.x, vector4.y, vector4.z);\r\n      vertices.push(vector2.x, vector2.y, vector2.z);\r\n      vertices.push(vector3.x, vector3.y, vector3.z);\r\n      vertices.push(vector4.x, vector4.y, vector4.z); //\r\n\r\n      normal1.copy(point1);\r\n      normal1.applyQuaternion(quaternion);\r\n      normal1.normalize();\r\n      normal2.copy(point2);\r\n      normal2.applyQuaternion(quaternion);\r\n      normal2.normalize();\r\n      normal3.copy(point2);\r\n      normal3.applyQuaternion(quaternion);\r\n      normal3.normalize();\r\n      normal4.copy(point1);\r\n      normal4.applyQuaternion(quaternion);\r\n      normal4.normalize();\r\n      normals.push(normal1.x, normal1.y, normal1.z);\r\n      normals.push(normal2.x, normal2.y, normal2.z);\r\n      normals.push(normal4.x, normal4.y, normal4.z);\r\n      normals.push(normal2.x, normal2.y, normal2.z);\r\n      normals.push(normal3.x, normal3.y, normal3.z);\r\n      normals.push(normal4.x, normal4.y, normal4.z);\r\n    }\r\n  }\r\n\r\n  var fromPoint = new Vector3();\r\n  var toPoint = new Vector3();\r\n\r\n  for (let i = 1; i <= divisions; i++) {\r\n    point.copy(curve.getPointAt(i / divisions));\r\n    tangent.copy(curve.getTangentAt(i / divisions));\r\n    var angle = Math.atan2(tangent.x, tangent.z);\r\n    quaternion.setFromAxisAngle(up, angle); //\r\n\r\n    if (point.y > 10) {\r\n      fromPoint.set(-0.75, -0.35, 0);\r\n      fromPoint.applyQuaternion(quaternion);\r\n      fromPoint.add(point);\r\n      toPoint.set(0.75, -0.35, 0);\r\n      toPoint.applyQuaternion(quaternion);\r\n      toPoint.add(point);\r\n      extrudeShape(tube1, fromPoint, toPoint);\r\n      fromPoint.set(-0.7, -0.3, 0);\r\n      fromPoint.applyQuaternion(quaternion);\r\n      fromPoint.add(point);\r\n      toPoint.set(-0.7, -point.y, 0);\r\n      toPoint.applyQuaternion(quaternion);\r\n      toPoint.add(point);\r\n      extrudeShape(tube2, fromPoint, toPoint);\r\n      fromPoint.set(0.7, -0.3, 0);\r\n      fromPoint.applyQuaternion(quaternion);\r\n      fromPoint.add(point);\r\n      toPoint.set(0.7, -point.y, 0);\r\n      toPoint.applyQuaternion(quaternion);\r\n      toPoint.add(point);\r\n      extrudeShape(tube3, fromPoint, toPoint);\r\n    } else {\r\n      fromPoint.set(0, -0.2, 0);\r\n      fromPoint.applyQuaternion(quaternion);\r\n      fromPoint.add(point);\r\n      toPoint.set(0, -point.y, 0);\r\n      toPoint.applyQuaternion(quaternion);\r\n      toPoint.add(point);\r\n      extrudeShape(tube3, fromPoint, toPoint);\r\n    }\r\n  }\r\n\r\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\r\n  this.setAttribute('normal', new BufferAttribute(new Float32Array(normals), 3));\r\n};\r\n\r\nRollerCoasterLiftersGeometry.prototype = Object.create(BufferGeometry.prototype);\r\n\r\nvar RollerCoasterShadowGeometry = function (curve, divisions) {\r\n  BufferGeometry.call(this);\r\n  var vertices = [];\r\n  var up = new Vector3(0, 1, 0);\r\n  var forward = new Vector3();\r\n  var quaternion = new Quaternion();\r\n  var prevQuaternion = new Quaternion();\r\n  prevQuaternion.setFromAxisAngle(up, Math.PI / 2);\r\n  var point = new Vector3();\r\n  var prevPoint = new Vector3();\r\n  prevPoint.copy(curve.getPointAt(0));\r\n  prevPoint.y = 0;\r\n  var vector1 = new Vector3();\r\n  var vector2 = new Vector3();\r\n  var vector3 = new Vector3();\r\n  var vector4 = new Vector3();\r\n\r\n  for (let i = 1; i <= divisions; i++) {\r\n    point.copy(curve.getPointAt(i / divisions));\r\n    point.y = 0;\r\n    forward.subVectors(point, prevPoint);\r\n    var angle = Math.atan2(forward.x, forward.z);\r\n    quaternion.setFromAxisAngle(up, angle);\r\n    vector1.set(-0.3, 0, 0);\r\n    vector1.applyQuaternion(quaternion);\r\n    vector1.add(point);\r\n    vector2.set(0.3, 0, 0);\r\n    vector2.applyQuaternion(quaternion);\r\n    vector2.add(point);\r\n    vector3.set(0.3, 0, 0);\r\n    vector3.applyQuaternion(prevQuaternion);\r\n    vector3.add(prevPoint);\r\n    vector4.set(-0.3, 0, 0);\r\n    vector4.applyQuaternion(prevQuaternion);\r\n    vector4.add(prevPoint);\r\n    vertices.push(vector1.x, vector1.y, vector1.z);\r\n    vertices.push(vector2.x, vector2.y, vector2.z);\r\n    vertices.push(vector4.x, vector4.y, vector4.z);\r\n    vertices.push(vector2.x, vector2.y, vector2.z);\r\n    vertices.push(vector3.x, vector3.y, vector3.z);\r\n    vertices.push(vector4.x, vector4.y, vector4.z);\r\n    prevPoint.copy(point);\r\n    prevQuaternion.copy(quaternion);\r\n  }\r\n\r\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\r\n};\r\n\r\nRollerCoasterShadowGeometry.prototype = Object.create(BufferGeometry.prototype);\r\n\r\nvar SkyGeometry = function () {\r\n  BufferGeometry.call(this);\r\n  var vertices = [];\r\n\r\n  for (let i = 0; i < 100; i++) {\r\n    var x = Math.random() * 800 - 400;\r\n    var y = Math.random() * 50 + 50;\r\n    var z = Math.random() * 800 - 400;\r\n    var size = Math.random() * 40 + 20;\r\n    vertices.push(x - size, y, z - size);\r\n    vertices.push(x + size, y, z - size);\r\n    vertices.push(x - size, y, z + size);\r\n    vertices.push(x + size, y, z - size);\r\n    vertices.push(x + size, y, z + size);\r\n    vertices.push(x - size, y, z + size);\r\n  }\r\n\r\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\r\n};\r\n\r\nSkyGeometry.prototype = Object.create(BufferGeometry.prototype);\r\n\r\nvar TreesGeometry = function (landscape) {\r\n  BufferGeometry.call(this);\r\n  var vertices = [];\r\n  var colors = [];\r\n  var raycaster = new Raycaster();\r\n  raycaster.ray.direction.set(0, -1, 0);\r\n\r\n  for (let i = 0; i < 2000; i++) {\r\n    var x = Math.random() * 500 - 250;\r\n    var z = Math.random() * 500 - 250;\r\n    raycaster.ray.origin.set(x, 50, z);\r\n    var intersections = raycaster.intersectObject(landscape);\r\n    if (intersections.length === 0) continue;\r\n    var y = intersections[0].point.y;\r\n    var height = Math.random() * 5 + 0.5;\r\n    var angle = Math.random() * Math.PI * 2;\r\n    vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));\r\n    vertices.push(x, y + height, z);\r\n    vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));\r\n    angle += Math.PI / 2;\r\n    vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));\r\n    vertices.push(x, y + height, z);\r\n    vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));\r\n    var random = Math.random() * 0.1;\r\n\r\n    for (let j = 0; j < 6; j++) {\r\n      colors.push(0.2 + random, 0.4 + random, 0);\r\n    }\r\n  }\r\n\r\n  this.setAttribute('position', new BufferAttribute(new Float32Array(vertices), 3));\r\n  this.setAttribute('color', new BufferAttribute(new Float32Array(colors), 3));\r\n};\r\n\r\nTreesGeometry.prototype = Object.create(BufferGeometry.prototype);\r\n\r\nexport { RollerCoasterGeometry, RollerCoasterLiftersGeometry, RollerCoasterShadowGeometry, SkyGeometry, TreesGeometry };\r\n", "import { Texture, LinearFilter, ClampToEdgeWrapping, MeshBasicMaterial, DoubleSide, Mesh, PlaneGeometry } from 'three';\r\n\r\n/**\r\n * This class has been made to hold a slice of a volume data\r\n * @class\r\n * @param   {Volume} volume    The associated volume\r\n * @param   {number}       [index=0] The index of the slice\r\n * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\r\n * @see Volume\r\n */\r\n\r\nvar VolumeSlice = function (volume, index, axis) {\r\n  var slice = this;\r\n  /**\r\n   * @member {Volume} volume The associated volume\r\n   */\r\n\r\n  this.volume = volume;\r\n  /**\r\n   * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\r\n   */\r\n\r\n  index = index || 0;\r\n  Object.defineProperty(this, 'index', {\r\n    get: function () {\r\n      return index;\r\n    },\r\n    set: function (value) {\r\n      index = value;\r\n      slice.geometryNeedsUpdate = true;\r\n      return index;\r\n    }\r\n  });\r\n  /**\r\n   * @member {String} axis The normal axis\r\n   */\r\n\r\n  this.axis = axis || 'z';\r\n  /**\r\n   * @member {HTMLCanvasElement} canvas The final canvas used for the texture\r\n   */\r\n\r\n  /**\r\n   * @member {CanvasRenderingContext2D} ctx Context of the canvas\r\n   */\r\n\r\n  this.canvas = document.createElement('canvas');\r\n  /**\r\n   * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\r\n   */\r\n\r\n  /**\r\n   * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\r\n   */\r\n\r\n  this.canvasBuffer = document.createElement('canvas');\r\n  this.updateGeometry();\r\n  var canvasMap = new Texture(this.canvas);\r\n  canvasMap.minFilter = LinearFilter;\r\n  canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\r\n  var material = new MeshBasicMaterial({\r\n    map: canvasMap,\r\n    side: DoubleSide,\r\n    transparent: true\r\n  });\r\n  /**\r\n   * @member {Mesh} mesh The mesh ready to get used in the scene\r\n   */\r\n\r\n  this.mesh = new Mesh(this.geometry, material);\r\n  this.mesh.matrixAutoUpdate = false;\r\n  /**\r\n   * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\r\n   */\r\n\r\n  this.geometryNeedsUpdate = true;\r\n  this.repaint();\r\n  /**\r\n   * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\r\n   */\r\n\r\n  /**\r\n   * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\r\n   */\r\n\r\n  /**\r\n   * @member {Function} sliceAccess Function that allow the slice to access right data\r\n   * @see Volume.extractPerpendicularPlane\r\n   * @param {Number} i The first coordinate\r\n   * @param {Number} j The second coordinate\r\n   * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\r\n   */\r\n};\r\n\r\nVolumeSlice.prototype = {\r\n  constructor: VolumeSlice,\r\n\r\n  /**\r\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\r\n   * @memberof VolumeSlice\r\n   */\r\n  repaint: function () {\r\n    if (this.geometryNeedsUpdate) {\r\n      this.updateGeometry();\r\n    }\r\n\r\n    var iLength = this.iLength,\r\n        jLength = this.jLength,\r\n        sliceAccess = this.sliceAccess,\r\n        volume = this.volume,\r\n        canvas = this.canvasBuffer,\r\n        ctx = this.ctxBuffer; // get the imageData and pixel array from the canvas\r\n\r\n    var imgData = ctx.getImageData(0, 0, iLength, jLength);\r\n    var data = imgData.data;\r\n    var volumeData = volume.data;\r\n    var upperThreshold = volume.upperThreshold;\r\n    var lowerThreshold = volume.lowerThreshold;\r\n    var windowLow = volume.windowLow;\r\n    var windowHigh = volume.windowHigh; // manipulate some pixel elements\r\n\r\n    var pixelCount = 0;\r\n\r\n    if (volume.dataType === 'label') {\r\n      //this part is currently useless but will be used when colortables will be handled\r\n      for (let j = 0; j < jLength; j++) {\r\n        for (let i = 0; i < iLength; i++) {\r\n          var label = volumeData[sliceAccess(i, j)];\r\n          label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\r\n          var color = this.colorMap[label];\r\n          data[4 * pixelCount] = color >> 24 & 0xff;\r\n          data[4 * pixelCount + 1] = color >> 16 & 0xff;\r\n          data[4 * pixelCount + 2] = color >> 8 & 0xff;\r\n          data[4 * pixelCount + 3] = color & 0xff;\r\n          pixelCount++;\r\n        }\r\n      }\r\n    } else {\r\n      for (let j = 0; j < jLength; j++) {\r\n        for (let i = 0; i < iLength; i++) {\r\n          var value = volumeData[sliceAccess(i, j)];\r\n          var alpha = 0xff; //apply threshold\r\n\r\n          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0; //apply window level\r\n\r\n          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\r\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\r\n          data[4 * pixelCount] = value;\r\n          data[4 * pixelCount + 1] = value;\r\n          data[4 * pixelCount + 2] = value;\r\n          data[4 * pixelCount + 3] = alpha;\r\n          pixelCount++;\r\n        }\r\n      }\r\n    }\r\n\r\n    ctx.putImageData(imgData, 0, 0);\r\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\r\n    this.mesh.material.map.needsUpdate = true;\r\n  },\r\n\r\n  /**\r\n   * @member {Function} Refresh the geometry according to axis and index\r\n   * @see Volume.extractPerpendicularPlane\r\n   * @memberof VolumeSlice\r\n   */\r\n  updateGeometry: function () {\r\n    var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\r\n    this.sliceAccess = extracted.sliceAccess;\r\n    this.jLength = extracted.jLength;\r\n    this.iLength = extracted.iLength;\r\n    this.matrix = extracted.matrix;\r\n    this.canvas.width = extracted.planeWidth;\r\n    this.canvas.height = extracted.planeHeight;\r\n    this.canvasBuffer.width = this.iLength;\r\n    this.canvasBuffer.height = this.jLength;\r\n    this.ctx = this.canvas.getContext('2d');\r\n    this.ctxBuffer = this.canvasBuffer.getContext('2d');\r\n    if (this.geometry) this.geometry.dispose(); // dispose existing geometry\r\n\r\n    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\r\n\r\n    if (this.mesh) {\r\n      this.mesh.geometry = this.geometry; //reset mesh matrix\r\n\r\n      this.mesh.matrix.identity();\r\n      this.mesh.applyMatrix4(this.matrix);\r\n    }\r\n\r\n    this.geometryNeedsUpdate = false;\r\n  }\r\n};\r\n\r\nexport { VolumeSlice };\r\n", "import { Matrix3, Matrix4, Vector3 } from 'three';\r\nimport { VolumeSlice } from './VolumeSlice.js';\r\n\r\n/**\r\n * This class had been written to handle the output of the NRRD loader.\r\n * It contains a volume of data and informations about it.\r\n * For now it only handles 3 dimensional data.\r\n * See the webgl_loader_nrrd.html example and the loaderNRRD.js file to see how to use this class.\r\n * @class\r\n * @param   {number}        xLength         Width of the volume\r\n * @param   {number}        yLength         Length of the volume\r\n * @param   {number}        zLength         Depth of the volume\r\n * @param   {string}        type            The type of data (uint8, uint16, ...)\r\n * @param   {ArrayBuffer}   arrayBuffer     The buffer with volume data\r\n */\r\n\r\nvar Volume = function (xLength, yLength, zLength, type, arrayBuffer) {\r\n  if (arguments.length > 0) {\r\n    /**\r\n     * @member {number} xLength Width of the volume in the IJK coordinate system\r\n     */\r\n    this.xLength = Number(xLength) || 1;\r\n    /**\r\n     * @member {number} yLength Height of the volume in the IJK coordinate system\r\n     */\r\n\r\n    this.yLength = Number(yLength) || 1;\r\n    /**\r\n     * @member {number} zLength Depth of the volume in the IJK coordinate system\r\n     */\r\n\r\n    this.zLength = Number(zLength) || 1;\r\n    /**\r\n     * @member {TypedArray} data Data of the volume\r\n     */\r\n\r\n    switch (type) {\r\n      case 'Uint8':\r\n      case 'uint8':\r\n      case 'uchar':\r\n      case 'unsigned char':\r\n      case 'uint8_t':\r\n        this.data = new Uint8Array(arrayBuffer);\r\n        break;\r\n\r\n      case 'Int8':\r\n      case 'int8':\r\n      case 'signed char':\r\n      case 'int8_t':\r\n        this.data = new Int8Array(arrayBuffer);\r\n        break;\r\n\r\n      case 'Int16':\r\n      case 'int16':\r\n      case 'short':\r\n      case 'short int':\r\n      case 'signed short':\r\n      case 'signed short int':\r\n      case 'int16_t':\r\n        this.data = new Int16Array(arrayBuffer);\r\n        break;\r\n\r\n      case 'Uint16':\r\n      case 'uint16':\r\n      case 'ushort':\r\n      case 'unsigned short':\r\n      case 'unsigned short int':\r\n      case 'uint16_t':\r\n        this.data = new Uint16Array(arrayBuffer);\r\n        break;\r\n\r\n      case 'Int32':\r\n      case 'int32':\r\n      case 'int':\r\n      case 'signed int':\r\n      case 'int32_t':\r\n        this.data = new Int32Array(arrayBuffer);\r\n        break;\r\n\r\n      case 'Uint32':\r\n      case 'uint32':\r\n      case 'uint':\r\n      case 'unsigned int':\r\n      case 'uint32_t':\r\n        this.data = new Uint32Array(arrayBuffer);\r\n        break;\r\n\r\n      case 'longlong':\r\n      case 'long long':\r\n      case 'long long int':\r\n      case 'signed long long':\r\n      case 'signed long long int':\r\n      case 'int64':\r\n      case 'int64_t':\r\n      case 'ulonglong':\r\n      case 'unsigned long long':\r\n      case 'unsigned long long int':\r\n      case 'uint64':\r\n      case 'uint64_t':\r\n        throw 'Error in Volume constructor : this type is not supported in JavaScript';\r\n\r\n      case 'Float32':\r\n      case 'float32':\r\n      case 'float':\r\n        this.data = new Float32Array(arrayBuffer);\r\n        break;\r\n\r\n      case 'Float64':\r\n      case 'float64':\r\n      case 'double':\r\n        this.data = new Float64Array(arrayBuffer);\r\n        break;\r\n\r\n      default:\r\n        this.data = new Uint8Array(arrayBuffer);\r\n    }\r\n\r\n    if (this.data.length !== this.xLength * this.yLength * this.zLength) {\r\n      throw 'Error in Volume constructor, lengths are not matching arrayBuffer size';\r\n    }\r\n  }\r\n  /**\r\n   * @member {Array}  spacing Spacing to apply to the volume from IJK to RAS coordinate system\r\n   */\r\n\r\n\r\n  this.spacing = [1, 1, 1];\r\n  /**\r\n   * @member {Array}  offset Offset of the volume in the RAS coordinate system\r\n   */\r\n\r\n  this.offset = [0, 0, 0];\r\n  /**\r\n   * @member {Martrix3} matrix The IJK to RAS matrix\r\n   */\r\n\r\n  this.matrix = new Matrix3();\r\n  this.matrix.identity();\r\n  /**\r\n   * @member {Martrix3} inverseMatrix The RAS to IJK matrix\r\n   */\r\n\r\n  /**\r\n   * @member {number} lowerThreshold The voxels with values under this threshold won't appear in the slices.\r\n   *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\r\n   */\r\n\r\n  var lowerThreshold = -Infinity;\r\n  Object.defineProperty(this, 'lowerThreshold', {\r\n    get: function () {\r\n      return lowerThreshold;\r\n    },\r\n    set: function (value) {\r\n      lowerThreshold = value;\r\n      this.sliceList.forEach(function (slice) {\r\n        slice.geometryNeedsUpdate = true;\r\n      });\r\n    }\r\n  });\r\n  /**\r\n   * @member {number} upperThreshold The voxels with values over this threshold won't appear in the slices.\r\n   *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\r\n   */\r\n\r\n  var upperThreshold = Infinity;\r\n  Object.defineProperty(this, 'upperThreshold', {\r\n    get: function () {\r\n      return upperThreshold;\r\n    },\r\n    set: function (value) {\r\n      upperThreshold = value;\r\n      this.sliceList.forEach(function (slice) {\r\n        slice.geometryNeedsUpdate = true;\r\n      });\r\n    }\r\n  });\r\n  /**\r\n   * @member {Array} sliceList The list of all the slices associated to this volume\r\n   */\r\n\r\n  this.sliceList = [];\r\n  /**\r\n   * @member {Array} RASDimensions This array holds the dimensions of the volume in the RAS space\r\n   */\r\n};\r\n\r\nVolume.prototype = {\r\n  constructor: Volume,\r\n\r\n  /**\r\n   * @member {Function} getData Shortcut for data[access(i,j,k)]\r\n   * @memberof Volume\r\n   * @param {number} i    First coordinate\r\n   * @param {number} j    Second coordinate\r\n   * @param {number} k    Third coordinate\r\n   * @returns {number}  value in the data array\r\n   */\r\n  getData: function (i, j, k) {\r\n    return this.data[k * this.xLength * this.yLength + j * this.xLength + i];\r\n  },\r\n\r\n  /**\r\n   * @member {Function} access compute the index in the data array corresponding to the given coordinates in IJK system\r\n   * @memberof Volume\r\n   * @param {number} i    First coordinate\r\n   * @param {number} j    Second coordinate\r\n   * @param {number} k    Third coordinate\r\n   * @returns {number}  index\r\n   */\r\n  access: function (i, j, k) {\r\n    return k * this.xLength * this.yLength + j * this.xLength + i;\r\n  },\r\n\r\n  /**\r\n   * @member {Function} reverseAccess Retrieve the IJK coordinates of the voxel corresponding of the given index in the data\r\n   * @memberof Volume\r\n   * @param {number} index index of the voxel\r\n   * @returns {Array}  [x,y,z]\r\n   */\r\n  reverseAccess: function (index) {\r\n    var z = Math.floor(index / (this.yLength * this.xLength));\r\n    var y = Math.floor((index - z * this.yLength * this.xLength) / this.xLength);\r\n    var x = index - z * this.yLength * this.xLength - y * this.xLength;\r\n    return [x, y, z];\r\n  },\r\n\r\n  /**\r\n   * @member {Function} map Apply a function to all the voxels, be careful, the value will be replaced\r\n   * @memberof Volume\r\n   * @param {Function} functionToMap A function to apply to every voxel, will be called with the following parameters :\r\n   *                                 value of the voxel\r\n   *                                 index of the voxel\r\n   *                                 the data (TypedArray)\r\n   * @param {Object}   context    You can specify a context in which call the function, default if this Volume\r\n   * @returns {Volume}   this\r\n   */\r\n  map: function (functionToMap, context) {\r\n    var length = this.data.length;\r\n    context = context || this;\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      this.data[i] = functionToMap.call(context, this.data[i], i, this.data);\r\n    }\r\n\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * @member {Function} extractPerpendicularPlane Compute the orientation of the slice and returns all the information relative to the geometry such as sliceAccess, the plane matrix (orientation and position in RAS coordinate) and the dimensions of the plane in both coordinate system.\r\n   * @memberof Volume\r\n   * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'\r\n   * @param {number}            index the index of the slice\r\n   * @returns {Object} an object containing all the usefull information on the geometry of the slice\r\n   */\r\n  extractPerpendicularPlane: function (axis, RASIndex) {\r\n    var iLength,\r\n        jLength,\r\n        sliceAccess,\r\n        planeMatrix = new Matrix4().identity(),\r\n        volume = this,\r\n        planeWidth,\r\n        planeHeight,\r\n        firstSpacing,\r\n        secondSpacing,\r\n        positionOffset,\r\n        IJKIndex;\r\n    var axisInIJK = new Vector3(),\r\n        firstDirection = new Vector3(),\r\n        secondDirection = new Vector3();\r\n    var dimensions = new Vector3(this.xLength, this.yLength, this.zLength);\r\n\r\n    switch (axis) {\r\n      case 'x':\r\n        axisInIJK.set(1, 0, 0);\r\n        firstDirection.set(0, 0, -1);\r\n        secondDirection.set(0, -1, 0);\r\n        firstSpacing = this.spacing[2];\r\n        secondSpacing = this.spacing[1];\r\n        IJKIndex = new Vector3(RASIndex, 0, 0);\r\n        planeMatrix.multiply(new Matrix4().makeRotationY(Math.PI / 2));\r\n        positionOffset = (volume.RASDimensions[0] - 1) / 2;\r\n        planeMatrix.setPosition(new Vector3(RASIndex - positionOffset, 0, 0));\r\n        break;\r\n\r\n      case 'y':\r\n        axisInIJK.set(0, 1, 0);\r\n        firstDirection.set(1, 0, 0);\r\n        secondDirection.set(0, 0, 1);\r\n        firstSpacing = this.spacing[0];\r\n        secondSpacing = this.spacing[2];\r\n        IJKIndex = new Vector3(0, RASIndex, 0);\r\n        planeMatrix.multiply(new Matrix4().makeRotationX(-Math.PI / 2));\r\n        positionOffset = (volume.RASDimensions[1] - 1) / 2;\r\n        planeMatrix.setPosition(new Vector3(0, RASIndex - positionOffset, 0));\r\n        break;\r\n\r\n      case 'z':\r\n      default:\r\n        axisInIJK.set(0, 0, 1);\r\n        firstDirection.set(1, 0, 0);\r\n        secondDirection.set(0, -1, 0);\r\n        firstSpacing = this.spacing[0];\r\n        secondSpacing = this.spacing[1];\r\n        IJKIndex = new Vector3(0, 0, RASIndex);\r\n        positionOffset = (volume.RASDimensions[2] - 1) / 2;\r\n        planeMatrix.setPosition(new Vector3(0, 0, RASIndex - positionOffset));\r\n        break;\r\n    }\r\n\r\n    firstDirection.applyMatrix4(volume.inverseMatrix).normalize();\r\n    firstDirection.argVar = 'i';\r\n    secondDirection.applyMatrix4(volume.inverseMatrix).normalize();\r\n    secondDirection.argVar = 'j';\r\n    axisInIJK.applyMatrix4(volume.inverseMatrix).normalize();\r\n    iLength = Math.floor(Math.abs(firstDirection.dot(dimensions)));\r\n    jLength = Math.floor(Math.abs(secondDirection.dot(dimensions)));\r\n    planeWidth = Math.abs(iLength * firstSpacing);\r\n    planeHeight = Math.abs(jLength * secondSpacing);\r\n    IJKIndex = Math.abs(Math.round(IJKIndex.applyMatrix4(volume.inverseMatrix).dot(axisInIJK)));\r\n    var base = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)];\r\n    var iDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\r\n      return Math.abs(x.dot(base[0])) > 0.9;\r\n    });\r\n    var jDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\r\n      return Math.abs(x.dot(base[1])) > 0.9;\r\n    });\r\n    var kDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\r\n      return Math.abs(x.dot(base[2])) > 0.9;\r\n    });\r\n\r\n    sliceAccess = function (i, j) {\r\n      var accessI, accessJ, accessK;\r\n      var si = iDirection === axisInIJK ? IJKIndex : iDirection.argVar === 'i' ? i : j;\r\n      var sj = jDirection === axisInIJK ? IJKIndex : jDirection.argVar === 'i' ? i : j;\r\n      var sk = kDirection === axisInIJK ? IJKIndex : kDirection.argVar === 'i' ? i : j; // invert indices if necessary\r\n\r\n      var accessI = iDirection.dot(base[0]) > 0 ? si : volume.xLength - 1 - si;\r\n      var accessJ = jDirection.dot(base[1]) > 0 ? sj : volume.yLength - 1 - sj;\r\n      var accessK = kDirection.dot(base[2]) > 0 ? sk : volume.zLength - 1 - sk;\r\n      return volume.access(accessI, accessJ, accessK);\r\n    };\r\n\r\n    return {\r\n      iLength: iLength,\r\n      jLength: jLength,\r\n      sliceAccess: sliceAccess,\r\n      matrix: planeMatrix,\r\n      planeWidth: planeWidth,\r\n      planeHeight: planeHeight\r\n    };\r\n  },\r\n\r\n  /**\r\n   * @member {Function} extractSlice Returns a slice corresponding to the given axis and index\r\n   *                        The coordinate are given in the Right Anterior Superior coordinate format\r\n   * @memberof Volume\r\n   * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'\r\n   * @param {number}            index the index of the slice\r\n   * @returns {VolumeSlice} the extracted slice\r\n   */\r\n  extractSlice: function (axis, index) {\r\n    var slice = new VolumeSlice(this, index, axis);\r\n    this.sliceList.push(slice);\r\n    return slice;\r\n  },\r\n\r\n  /**\r\n   * @member {Function} repaintAllSlices Call repaint on all the slices extracted from this volume\r\n   * @see VolumeSlice.repaint\r\n   * @memberof Volume\r\n   * @returns {Volume} this\r\n   */\r\n  repaintAllSlices: function () {\r\n    this.sliceList.forEach(function (slice) {\r\n      slice.repaint();\r\n    });\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * @member {Function} computeMinMax Compute the minimum and the maximum of the data in the volume\r\n   * @memberof Volume\r\n   * @returns {Array} [min,max]\r\n   */\r\n  computeMinMax: function () {\r\n    var min = Infinity;\r\n    var max = -Infinity; // buffer the length\r\n\r\n    var datasize = this.data.length;\r\n    var i = 0;\r\n\r\n    for (i = 0; i < datasize; i++) {\r\n      if (!isNaN(this.data[i])) {\r\n        var value = this.data[i];\r\n        min = Math.min(min, value);\r\n        max = Math.max(max, value);\r\n      }\r\n    }\r\n\r\n    this.min = min;\r\n    this.max = max;\r\n    return [min, max];\r\n  }\r\n};\r\n\r\nexport { Volume };\r\n", "import { Object3D, Vector3, Matrix4 } from 'three';\r\n\r\nclass CSS2DObject extends Object3D {\r\n  constructor(element = document.createElement('div')) {\r\n    super();\r\n    this.isCSS2DObject = true;\r\n    this.element = element;\r\n    this.element.style.position = 'absolute';\r\n    this.element.style.userSelect = 'none';\r\n    this.element.setAttribute('draggable', false);\r\n    this.addEventListener('removed', function () {\r\n      this.traverse(function (object) {\r\n        if (object.element instanceof Element && object.element.parentNode !== null) {\r\n          object.element.parentNode.removeChild(object.element);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  copy(source, recursive) {\r\n    super.copy(source, recursive);\r\n    this.element = source.element.cloneNode(true);\r\n    return this;\r\n  }\r\n\r\n}\r\n\r\nconst _vector = /*#__PURE__*/new Vector3();\r\n\r\nconst _viewMatrix = /*#__PURE__*/new Matrix4();\r\n\r\nconst _viewProjectionMatrix = /*#__PURE__*/new Matrix4();\r\n\r\nconst _a = /*#__PURE__*/new Vector3();\r\n\r\nconst _b = /*#__PURE__*/new Vector3();\r\n\r\nclass CSS2DRenderer {\r\n  constructor(parameters = {}) {\r\n    const _this = this;\r\n\r\n    let _width, _height;\r\n\r\n    let _widthHalf, _heightHalf;\r\n\r\n    const cache = {\r\n      objects: new WeakMap()\r\n    };\r\n    const domElement = parameters.element !== undefined ? parameters.element : document.createElement('div');\r\n    domElement.style.overflow = 'hidden';\r\n    this.domElement = domElement;\r\n\r\n    this.getSize = function () {\r\n      return {\r\n        width: _width,\r\n        height: _height\r\n      };\r\n    };\r\n\r\n    this.render = function (scene, camera) {\r\n      if (scene.matrixWorldAutoUpdate === true || scene.autoUpdate === true) scene.updateMatrixWorld();\r\n\r\n      if (camera.parent === null && (camera.matrixWorldAutoUpdate == null || camera.matrixWorldAutoUpdate === true)) {\r\n        camera.updateMatrixWorld();\r\n      }\r\n\r\n      _viewMatrix.copy(camera.matrixWorldInverse);\r\n\r\n      _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\r\n\r\n      renderObject(scene, scene, camera);\r\n      zOrder(scene);\r\n    };\r\n\r\n    this.setSize = function (width, height) {\r\n      _width = width;\r\n      _height = height;\r\n      _widthHalf = _width / 2;\r\n      _heightHalf = _height / 2;\r\n      domElement.style.width = width + 'px';\r\n      domElement.style.height = height + 'px';\r\n    };\r\n\r\n    function renderObject(object, scene, camera) {\r\n      if (object.isCSS2DObject) {\r\n        _vector.setFromMatrixPosition(object.matrixWorld);\r\n\r\n        _vector.applyMatrix4(_viewProjectionMatrix);\r\n\r\n        const visible = object.visible === true && _vector.z >= -1 && _vector.z <= 1 && object.layers.test(camera.layers) === true;\r\n        object.element.style.display = visible === true ? '' : 'none';\r\n\r\n        if (visible === true) {\r\n          object.onBeforeRender(_this, scene, camera);\r\n          const element = object.element;\r\n          element.style.transform = 'translate(-50%,-50%) translate(' + (_vector.x * _widthHalf + _widthHalf) + 'px,' + (-_vector.y * _heightHalf + _heightHalf) + 'px)';\r\n\r\n          if (element.parentNode !== domElement) {\r\n            domElement.appendChild(element);\r\n          }\r\n\r\n          object.onAfterRender(_this, scene, camera);\r\n        }\r\n\r\n        const objectData = {\r\n          distanceToCameraSquared: getDistanceToSquared(camera, object)\r\n        };\r\n        cache.objects.set(object, objectData);\r\n      }\r\n\r\n      for (let i = 0, l = object.children.length; i < l; i++) {\r\n        renderObject(object.children[i], scene, camera);\r\n      }\r\n    }\r\n\r\n    function getDistanceToSquared(object1, object2) {\r\n      _a.setFromMatrixPosition(object1.matrixWorld);\r\n\r\n      _b.setFromMatrixPosition(object2.matrixWorld);\r\n\r\n      return _a.distanceToSquared(_b);\r\n    }\r\n\r\n    function filterAndFlatten(scene) {\r\n      const result = [];\r\n      scene.traverse(function (object) {\r\n        if (object.isCSS2DObject) result.push(object);\r\n      });\r\n      return result;\r\n    }\r\n\r\n    function zOrder(scene) {\r\n      const sorted = filterAndFlatten(scene).sort(function (a, b) {\r\n        if (a.renderOrder !== b.renderOrder) {\r\n          return b.renderOrder - a.renderOrder;\r\n        }\r\n\r\n        const distanceA = cache.objects.get(a).distanceToCameraSquared;\r\n        const distanceB = cache.objects.get(b).distanceToCameraSquared;\r\n        return distanceA - distanceB;\r\n      });\r\n      const zMax = sorted.length;\r\n\r\n      for (let i = 0, l = sorted.length; i < l; i++) {\r\n        sorted[i].element.style.zIndex = zMax - i;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport { CSS2DObject, CSS2DRenderer };\r\n", "import { Object3D, Matrix4 } from 'three';\r\n\r\n/**\r\n * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs\r\n */\r\n\r\nvar CSS3DObject = function (element) {\r\n  Object3D.call(this);\r\n  this.element = element || document.createElement('div');\r\n  this.element.style.position = 'absolute';\r\n  this.element.style.pointerEvents = 'auto';\r\n  this.addEventListener('removed', function () {\r\n    this.traverse(function (object) {\r\n      if (object.element instanceof Element && object.element.parentNode !== null) {\r\n        object.element.parentNode.removeChild(object.element);\r\n      }\r\n    });\r\n  });\r\n};\r\n\r\nCSS3DObject.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n  constructor: CSS3DObject,\r\n  copy: function (source, recursive) {\r\n    Object3D.prototype.copy.call(this, source, recursive);\r\n    this.element = source.element.cloneNode(true);\r\n    return this;\r\n  }\r\n});\r\n\r\nvar CSS3DSprite = function (element) {\r\n  CSS3DObject.call(this, element);\r\n};\r\n\r\nCSS3DSprite.prototype = Object.create(CSS3DObject.prototype);\r\nCSS3DSprite.prototype.constructor = CSS3DSprite; //\r\n\r\nvar CSS3DRenderer = function () {\r\n  var _this = this;\r\n\r\n  var _width, _height;\r\n\r\n  var _widthHalf, _heightHalf;\r\n\r\n  var matrix = new Matrix4();\r\n  var cache = {\r\n    camera: {\r\n      fov: 0,\r\n      style: ''\r\n    },\r\n    objects: new WeakMap()\r\n  };\r\n  var domElement = document.createElement('div');\r\n  domElement.style.overflow = 'hidden';\r\n  this.domElement = domElement;\r\n  var cameraElement = document.createElement('div');\r\n  cameraElement.style.transformStyle = 'preserve-3d';\r\n  cameraElement.style.pointerEvents = 'none';\r\n  domElement.appendChild(cameraElement);\r\n\r\n  this.getSize = function () {\r\n    return {\r\n      width: _width,\r\n      height: _height\r\n    };\r\n  };\r\n\r\n  this.setSize = function (width, height) {\r\n    _width = width;\r\n    _height = height;\r\n    _widthHalf = _width / 2;\r\n    _heightHalf = _height / 2;\r\n    domElement.style.width = width + 'px';\r\n    domElement.style.height = height + 'px';\r\n    cameraElement.style.width = width + 'px';\r\n    cameraElement.style.height = height + 'px';\r\n  };\r\n\r\n  function epsilon(value) {\r\n    return Math.abs(value) < 1e-10 ? 0 : value;\r\n  }\r\n\r\n  function getCameraCSSMatrix(matrix) {\r\n    var elements = matrix.elements;\r\n    return 'matrix3d(' + epsilon(elements[0]) + ',' + epsilon(-elements[1]) + ',' + epsilon(elements[2]) + ',' + epsilon(elements[3]) + ',' + epsilon(elements[4]) + ',' + epsilon(-elements[5]) + ',' + epsilon(elements[6]) + ',' + epsilon(elements[7]) + ',' + epsilon(elements[8]) + ',' + epsilon(-elements[9]) + ',' + epsilon(elements[10]) + ',' + epsilon(elements[11]) + ',' + epsilon(elements[12]) + ',' + epsilon(-elements[13]) + ',' + epsilon(elements[14]) + ',' + epsilon(elements[15]) + ')';\r\n  }\r\n\r\n  function getObjectCSSMatrix(matrix) {\r\n    var elements = matrix.elements;\r\n    var matrix3d = 'matrix3d(' + epsilon(elements[0]) + ',' + epsilon(elements[1]) + ',' + epsilon(elements[2]) + ',' + epsilon(elements[3]) + ',' + epsilon(-elements[4]) + ',' + epsilon(-elements[5]) + ',' + epsilon(-elements[6]) + ',' + epsilon(-elements[7]) + ',' + epsilon(elements[8]) + ',' + epsilon(elements[9]) + ',' + epsilon(elements[10]) + ',' + epsilon(elements[11]) + ',' + epsilon(elements[12]) + ',' + epsilon(elements[13]) + ',' + epsilon(elements[14]) + ',' + epsilon(elements[15]) + ')';\r\n    return 'translate(-50%,-50%)' + matrix3d;\r\n  }\r\n\r\n  function renderObject(object, scene, camera, cameraCSSMatrix) {\r\n    if (object instanceof CSS3DObject) {\r\n      object.onBeforeRender(_this, scene, camera);\r\n      var style;\r\n\r\n      if (object instanceof CSS3DSprite) {\r\n        // http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/\r\n        matrix.copy(camera.matrixWorldInverse);\r\n        matrix.transpose();\r\n        matrix.copyPosition(object.matrixWorld);\r\n        matrix.scale(object.scale);\r\n        matrix.elements[3] = 0;\r\n        matrix.elements[7] = 0;\r\n        matrix.elements[11] = 0;\r\n        matrix.elements[15] = 1;\r\n        style = getObjectCSSMatrix(matrix);\r\n      } else {\r\n        style = getObjectCSSMatrix(object.matrixWorld);\r\n      }\r\n\r\n      var element = object.element;\r\n      var cachedObject = cache.objects.get(object);\r\n\r\n      if (cachedObject === undefined || cachedObject.style !== style) {\r\n        element.style.transform = style;\r\n        var objectData = {\r\n          style: style\r\n        };\r\n        cache.objects.set(object, objectData);\r\n      }\r\n\r\n      element.style.display = object.visible ? '' : 'none';\r\n\r\n      if (element.parentNode !== cameraElement) {\r\n        cameraElement.appendChild(element);\r\n      }\r\n\r\n      object.onAfterRender(_this, scene, camera);\r\n    }\r\n\r\n    for (let i = 0, l = object.children.length; i < l; i++) {\r\n      renderObject(object.children[i], scene, camera);\r\n    }\r\n  }\r\n\r\n  this.render = function (scene, camera) {\r\n    var fov = camera.projectionMatrix.elements[5] * _heightHalf;\r\n\r\n    if (cache.camera.fov !== fov) {\r\n      domElement.style.perspective = camera.isPerspectiveCamera ? fov + 'px' : '';\r\n      cache.camera.fov = fov;\r\n    }\r\n\r\n    if (scene.autoUpdate === true) scene.updateMatrixWorld();\r\n    if (camera.parent === null) camera.updateMatrixWorld();\r\n\r\n    if (camera.isOrthographicCamera) {\r\n      var tx = -(camera.right + camera.left) / 2;\r\n      var ty = (camera.top + camera.bottom) / 2;\r\n    }\r\n\r\n    var cameraCSSMatrix = camera.isOrthographicCamera ? 'scale(' + fov + ')' + 'translate(' + epsilon(tx) + 'px,' + epsilon(ty) + 'px)' + getCameraCSSMatrix(camera.matrixWorldInverse) : 'translateZ(' + fov + 'px)' + getCameraCSSMatrix(camera.matrixWorldInverse);\r\n    var style = cameraCSSMatrix + 'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';\r\n\r\n    if (cache.camera.style !== style) {\r\n      cameraElement.style.transform = style;\r\n      cache.camera.style = style;\r\n    }\r\n\r\n    renderObject(scene, scene, camera);\r\n  };\r\n};\r\n\r\nexport { CSS3DObject, CSS3DRenderer, CSS3DSprite };\r\n", "import { Vector3, Color, Vector2, Vector4, Box3, Matrix4, Frustum, Matrix3, DoubleSide } from 'three';\r\n\r\nvar RenderableObject = function () {\r\n  this.id = 0;\r\n  this.object = null;\r\n  this.z = 0;\r\n  this.renderOrder = 0;\r\n}; //\r\n\r\n\r\nvar RenderableFace = function () {\r\n  this.id = 0;\r\n  this.v1 = new RenderableVertex();\r\n  this.v2 = new RenderableVertex();\r\n  this.v3 = new RenderableVertex();\r\n  this.normalModel = new Vector3();\r\n  this.vertexNormalsModel = [new Vector3(), new Vector3(), new Vector3()];\r\n  this.vertexNormalsLength = 0;\r\n  this.color = new Color();\r\n  this.material = null;\r\n  this.uvs = [new Vector2(), new Vector2(), new Vector2()];\r\n  this.z = 0;\r\n  this.renderOrder = 0;\r\n}; //\r\n\r\n\r\nvar RenderableVertex = function () {\r\n  this.position = new Vector3();\r\n  this.positionWorld = new Vector3();\r\n  this.positionScreen = new Vector4();\r\n  this.visible = true;\r\n};\r\n\r\nRenderableVertex.prototype.copy = function (vertex) {\r\n  this.positionWorld.copy(vertex.positionWorld);\r\n  this.positionScreen.copy(vertex.positionScreen);\r\n}; //\r\n\r\n\r\nvar RenderableLine = function () {\r\n  this.id = 0;\r\n  this.v1 = new RenderableVertex();\r\n  this.v2 = new RenderableVertex();\r\n  this.vertexColors = [new Color(), new Color()];\r\n  this.material = null;\r\n  this.z = 0;\r\n  this.renderOrder = 0;\r\n}; //\r\n\r\n\r\nvar RenderableSprite = function () {\r\n  this.id = 0;\r\n  this.object = null;\r\n  this.x = 0;\r\n  this.y = 0;\r\n  this.z = 0;\r\n  this.rotation = 0;\r\n  this.scale = new Vector2();\r\n  this.material = null;\r\n  this.renderOrder = 0;\r\n}; //\r\n\r\n\r\nvar Projector = function () {\r\n  var _object,\r\n      _objectCount,\r\n      _objectPool = [],\r\n      _objectPoolLength = 0,\r\n      _vertex,\r\n      _vertexCount,\r\n      _vertexPool = [],\r\n      _vertexPoolLength = 0,\r\n      _face,\r\n      _faceCount,\r\n      _facePool = [],\r\n      _facePoolLength = 0,\r\n      _line,\r\n      _lineCount,\r\n      _linePool = [],\r\n      _linePoolLength = 0,\r\n      _sprite,\r\n      _spriteCount,\r\n      _spritePool = [],\r\n      _spritePoolLength = 0,\r\n      _renderData = {\r\n    objects: [],\r\n    lights: [],\r\n    elements: []\r\n  },\r\n      _vector3 = new Vector3(),\r\n      _vector4 = new Vector4(),\r\n      _clipBox = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1)),\r\n      _boundingBox = new Box3(),\r\n      _points3 = new Array(3),\r\n      _viewMatrix = new Matrix4(),\r\n      _viewProjectionMatrix = new Matrix4(),\r\n      _modelMatrix,\r\n      _modelViewProjectionMatrix = new Matrix4(),\r\n      _frustum = new Frustum(); //\r\n\r\n\r\n  this.projectVector = function (vector, camera) {\r\n    console.warn('THREE.Projector: .projectVector() is now vector.project().');\r\n    vector.project(camera);\r\n  };\r\n\r\n  this.unprojectVector = function (vector, camera) {\r\n    console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');\r\n    vector.unproject(camera);\r\n  };\r\n\r\n  this.pickingRay = function () {\r\n    console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');\r\n  }; //\r\n\r\n\r\n  var RenderList = function () {\r\n    var normals = [];\r\n    var colors = [];\r\n    var uvs = [];\r\n    var object = null;\r\n    var normalMatrix = new Matrix3();\r\n\r\n    function setObject(value) {\r\n      object = value;\r\n      normalMatrix.getNormalMatrix(object.matrixWorld);\r\n      normals.length = 0;\r\n      colors.length = 0;\r\n      uvs.length = 0;\r\n    }\r\n\r\n    function projectVertex(vertex) {\r\n      var position = vertex.position;\r\n      var positionWorld = vertex.positionWorld;\r\n      var positionScreen = vertex.positionScreen;\r\n      positionWorld.copy(position).applyMatrix4(_modelMatrix);\r\n      positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix);\r\n      var invW = 1 / positionScreen.w;\r\n      positionScreen.x *= invW;\r\n      positionScreen.y *= invW;\r\n      positionScreen.z *= invW;\r\n      vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 && positionScreen.y >= -1 && positionScreen.y <= 1 && positionScreen.z >= -1 && positionScreen.z <= 1;\r\n    }\r\n\r\n    function pushVertex(x, y, z) {\r\n      _vertex = getNextVertexInPool();\r\n\r\n      _vertex.position.set(x, y, z);\r\n\r\n      projectVertex(_vertex);\r\n    }\r\n\r\n    function pushNormal(x, y, z) {\r\n      normals.push(x, y, z);\r\n    }\r\n\r\n    function pushColor(r, g, b) {\r\n      colors.push(r, g, b);\r\n    }\r\n\r\n    function pushUv(x, y) {\r\n      uvs.push(x, y);\r\n    }\r\n\r\n    function checkTriangleVisibility(v1, v2, v3) {\r\n      if (v1.visible === true || v2.visible === true || v3.visible === true) return true;\r\n      _points3[0] = v1.positionScreen;\r\n      _points3[1] = v2.positionScreen;\r\n      _points3[2] = v3.positionScreen;\r\n      return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3));\r\n    }\r\n\r\n    function checkBackfaceCulling(v1, v2, v3) {\r\n      return (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0;\r\n    }\r\n\r\n    function pushLine(a, b) {\r\n      var v1 = _vertexPool[a];\r\n      var v2 = _vertexPool[b]; // Clip\r\n\r\n      v1.positionScreen.copy(v1.position).applyMatrix4(_modelViewProjectionMatrix);\r\n      v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix);\r\n\r\n      if (clipLine(v1.positionScreen, v2.positionScreen) === true) {\r\n        // Perform the perspective divide\r\n        v1.positionScreen.multiplyScalar(1 / v1.positionScreen.w);\r\n        v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w);\r\n        _line = getNextLineInPool();\r\n        _line.id = object.id;\r\n\r\n        _line.v1.copy(v1);\r\n\r\n        _line.v2.copy(v2);\r\n\r\n        _line.z = Math.max(v1.positionScreen.z, v2.positionScreen.z);\r\n        _line.renderOrder = object.renderOrder;\r\n        _line.material = object.material;\r\n\r\n        if (object.material.vertexColors) {\r\n          _line.vertexColors[0].fromArray(colors, a * 3);\r\n\r\n          _line.vertexColors[1].fromArray(colors, b * 3);\r\n        }\r\n\r\n        _renderData.elements.push(_line);\r\n      }\r\n    }\r\n\r\n    function pushTriangle(a, b, c, material) {\r\n      var v1 = _vertexPool[a];\r\n      var v2 = _vertexPool[b];\r\n      var v3 = _vertexPool[c];\r\n      if (checkTriangleVisibility(v1, v2, v3) === false) return;\r\n\r\n      if (material.side === DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {\r\n        _face = getNextFaceInPool();\r\n        _face.id = object.id;\r\n\r\n        _face.v1.copy(v1);\r\n\r\n        _face.v2.copy(v2);\r\n\r\n        _face.v3.copy(v3);\r\n\r\n        _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;\r\n        _face.renderOrder = object.renderOrder; // face normal\r\n\r\n        _vector3.subVectors(v3.position, v2.position);\r\n\r\n        _vector4.subVectors(v1.position, v2.position);\r\n\r\n        _vector3.cross(_vector4);\r\n\r\n        _face.normalModel.copy(_vector3);\r\n\r\n        _face.normalModel.applyMatrix3(normalMatrix).normalize();\r\n\r\n        for (let i = 0; i < 3; i++) {\r\n          var normal = _face.vertexNormalsModel[i];\r\n          normal.fromArray(normals, arguments[i] * 3);\r\n          normal.applyMatrix3(normalMatrix).normalize();\r\n          var uv = _face.uvs[i];\r\n          uv.fromArray(uvs, arguments[i] * 2);\r\n        }\r\n\r\n        _face.vertexNormalsLength = 3;\r\n        _face.material = material;\r\n\r\n        if (material.vertexColors) {\r\n          _face.color.fromArray(colors, a * 3);\r\n        }\r\n\r\n        _renderData.elements.push(_face);\r\n      }\r\n    }\r\n\r\n    return {\r\n      setObject: setObject,\r\n      projectVertex: projectVertex,\r\n      checkTriangleVisibility: checkTriangleVisibility,\r\n      checkBackfaceCulling: checkBackfaceCulling,\r\n      pushVertex: pushVertex,\r\n      pushNormal: pushNormal,\r\n      pushColor: pushColor,\r\n      pushUv: pushUv,\r\n      pushLine: pushLine,\r\n      pushTriangle: pushTriangle\r\n    };\r\n  };\r\n\r\n  var renderList = new RenderList();\r\n\r\n  function projectObject(object) {\r\n    if (object.visible === false) return;\r\n\r\n    if (object.isLight) {\r\n      _renderData.lights.push(object);\r\n    } else if (object.isMesh || object.isLine || object.isPoints) {\r\n      if (object.material.visible === false) return;\r\n      if (object.frustumCulled === true && _frustum.intersectsObject(object) === false) return;\r\n      addObject(object);\r\n    } else if (object.isSprite) {\r\n      if (object.material.visible === false) return;\r\n      if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false) return;\r\n      addObject(object);\r\n    }\r\n\r\n    var children = object.children;\r\n\r\n    for (let i = 0, l = children.length; i < l; i++) {\r\n      projectObject(children[i]);\r\n    }\r\n  }\r\n\r\n  function addObject(object) {\r\n    _object = getNextObjectInPool();\r\n    _object.id = object.id;\r\n    _object.object = object;\r\n\r\n    _vector3.setFromMatrixPosition(object.matrixWorld);\r\n\r\n    _vector3.applyMatrix4(_viewProjectionMatrix);\r\n\r\n    _object.z = _vector3.z;\r\n    _object.renderOrder = object.renderOrder;\r\n\r\n    _renderData.objects.push(_object);\r\n  }\r\n\r\n  this.projectScene = function (scene, camera, sortObjects, sortElements) {\r\n    _faceCount = 0;\r\n    _lineCount = 0;\r\n    _spriteCount = 0;\r\n    _renderData.elements.length = 0;\r\n    if (scene.autoUpdate === true) scene.updateMatrixWorld();\r\n    if (camera.parent === null) camera.updateMatrixWorld();\r\n\r\n    _viewMatrix.copy(camera.matrixWorldInverse);\r\n\r\n    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\r\n\r\n    _frustum.setFromProjectionMatrix(_viewProjectionMatrix); //\r\n\r\n\r\n    _objectCount = 0;\r\n    _renderData.objects.length = 0;\r\n    _renderData.lights.length = 0;\r\n    projectObject(scene);\r\n\r\n    if (sortObjects === true) {\r\n      _renderData.objects.sort(painterSort);\r\n    } //\r\n\r\n\r\n    var objects = _renderData.objects;\r\n\r\n    for (let o = 0, ol = objects.length; o < ol; o++) {\r\n      var object = objects[o].object;\r\n      var geometry = object.geometry;\r\n      renderList.setObject(object);\r\n      _modelMatrix = object.matrixWorld;\r\n      _vertexCount = 0;\r\n\r\n      if (object.isMesh) {\r\n        if (geometry.isBufferGeometry) {\r\n          var material = object.material;\r\n          var isMultiMaterial = Array.isArray(material);\r\n          var attributes = geometry.attributes;\r\n          var groups = geometry.groups;\r\n          if (attributes.position === undefined) continue;\r\n          var positions = attributes.position.array;\r\n\r\n          for (let i = 0, l = positions.length; i < l; i += 3) {\r\n            var x = positions[i];\r\n            var y = positions[i + 1];\r\n            var z = positions[i + 2];\r\n\r\n            if (material.morphTargets === true) {\r\n              var morphTargets = geometry.morphAttributes.position;\r\n              var morphTargetsRelative = geometry.morphTargetsRelative;\r\n              var morphInfluences = object.morphTargetInfluences;\r\n\r\n              for (let t = 0, tl = morphTargets.length; t < tl; t++) {\r\n                var influence = morphInfluences[t];\r\n                if (influence === 0) continue;\r\n                var target = morphTargets[t];\r\n\r\n                if (morphTargetsRelative) {\r\n                  x += target.getX(i / 3) * influence;\r\n                  y += target.getY(i / 3) * influence;\r\n                  z += target.getZ(i / 3) * influence;\r\n                } else {\r\n                  x += (target.getX(i / 3) - positions[i]) * influence;\r\n                  y += (target.getY(i / 3) - positions[i + 1]) * influence;\r\n                  z += (target.getZ(i / 3) - positions[i + 2]) * influence;\r\n                }\r\n              }\r\n            }\r\n\r\n            renderList.pushVertex(x, y, z);\r\n          }\r\n\r\n          if (attributes.normal !== undefined) {\r\n            var normals = attributes.normal.array;\r\n\r\n            for (let i = 0, l = normals.length; i < l; i += 3) {\r\n              renderList.pushNormal(normals[i], normals[i + 1], normals[i + 2]);\r\n            }\r\n          }\r\n\r\n          if (attributes.color !== undefined) {\r\n            var colors = attributes.color.array;\r\n\r\n            for (let i = 0, l = colors.length; i < l; i += 3) {\r\n              renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);\r\n            }\r\n          }\r\n\r\n          if (attributes.uv !== undefined) {\r\n            var uvs = attributes.uv.array;\r\n\r\n            for (let i = 0, l = uvs.length; i < l; i += 2) {\r\n              renderList.pushUv(uvs[i], uvs[i + 1]);\r\n            }\r\n          }\r\n\r\n          if (geometry.index !== null) {\r\n            var indices = geometry.index.array;\r\n\r\n            if (groups.length > 0) {\r\n              for (let g = 0; g < groups.length; g++) {\r\n                var group = groups[g];\r\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;\r\n                if (material === undefined) continue;\r\n\r\n                for (let i = group.start, l = group.start + group.count; i < l; i += 3) {\r\n                  renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);\r\n                }\r\n              }\r\n            } else {\r\n              for (let i = 0, l = indices.length; i < l; i += 3) {\r\n                renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material);\r\n              }\r\n            }\r\n          } else {\r\n            if (groups.length > 0) {\r\n              for (let g = 0; g < groups.length; g++) {\r\n                var group = groups[g];\r\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;\r\n                if (material === undefined) continue;\r\n\r\n                for (let i = group.start, l = group.start + group.count; i < l; i += 3) {\r\n                  renderList.pushTriangle(i, i + 1, i + 2, material);\r\n                }\r\n              }\r\n            } else {\r\n              for (let i = 0, l = positions.length / 3; i < l; i += 3) {\r\n                renderList.pushTriangle(i, i + 1, i + 2, material);\r\n              }\r\n            }\r\n          }\r\n        } else if (geometry.isGeometry) {\r\n          console.error('THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.');\r\n          return;\r\n        }\r\n      } else if (object.isLine) {\r\n        _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\r\n\r\n        if (geometry.isBufferGeometry) {\r\n          var attributes = geometry.attributes;\r\n\r\n          if (attributes.position !== undefined) {\r\n            var positions = attributes.position.array;\r\n\r\n            for (let i = 0, l = positions.length; i < l; i += 3) {\r\n              renderList.pushVertex(positions[i], positions[i + 1], positions[i + 2]);\r\n            }\r\n\r\n            if (attributes.color !== undefined) {\r\n              var colors = attributes.color.array;\r\n\r\n              for (let i = 0, l = colors.length; i < l; i += 3) {\r\n                renderList.pushColor(colors[i], colors[i + 1], colors[i + 2]);\r\n              }\r\n            }\r\n\r\n            if (geometry.index !== null) {\r\n              var indices = geometry.index.array;\r\n\r\n              for (let i = 0, l = indices.length; i < l; i += 2) {\r\n                renderList.pushLine(indices[i], indices[i + 1]);\r\n              }\r\n            } else {\r\n              var step = object.isLineSegments ? 2 : 1;\r\n\r\n              for (let i = 0, l = positions.length / 3 - 1; i < l; i += step) {\r\n                renderList.pushLine(i, i + 1);\r\n              }\r\n            }\r\n          }\r\n        } else if (geometry.isGeometry) {\r\n          console.error('THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.');\r\n          return;\r\n        }\r\n      } else if (object.isPoints) {\r\n        _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\r\n\r\n        if (geometry.isGeometry) {\r\n          console.error('THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.');\r\n          return;\r\n        } else if (geometry.isBufferGeometry) {\r\n          var attributes = geometry.attributes;\r\n\r\n          if (attributes.position !== undefined) {\r\n            var positions = attributes.position.array;\r\n\r\n            for (let i = 0, l = positions.length; i < l; i += 3) {\r\n              _vector4.set(positions[i], positions[i + 1], positions[i + 2], 1);\r\n\r\n              _vector4.applyMatrix4(_modelViewProjectionMatrix);\r\n\r\n              pushPoint(_vector4, object, camera);\r\n            }\r\n          }\r\n        }\r\n      } else if (object.isSprite) {\r\n        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\r\n\r\n        _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);\r\n\r\n        _vector4.applyMatrix4(_viewProjectionMatrix);\r\n\r\n        pushPoint(_vector4, object, camera);\r\n      }\r\n    }\r\n\r\n    if (sortElements === true) {\r\n      _renderData.elements.sort(painterSort);\r\n    }\r\n\r\n    return _renderData;\r\n  };\r\n\r\n  function pushPoint(_vector4, object, camera) {\r\n    var invW = 1 / _vector4.w;\r\n    _vector4.z *= invW;\r\n\r\n    if (_vector4.z >= -1 && _vector4.z <= 1) {\r\n      _sprite = getNextSpriteInPool();\r\n      _sprite.id = object.id;\r\n      _sprite.x = _vector4.x * invW;\r\n      _sprite.y = _vector4.y * invW;\r\n      _sprite.z = _vector4.z;\r\n      _sprite.renderOrder = object.renderOrder;\r\n      _sprite.object = object;\r\n      _sprite.rotation = object.rotation;\r\n      _sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector4.x + camera.projectionMatrix.elements[0]) / (_vector4.w + camera.projectionMatrix.elements[12]));\r\n      _sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector4.y + camera.projectionMatrix.elements[5]) / (_vector4.w + camera.projectionMatrix.elements[13]));\r\n      _sprite.material = object.material;\r\n\r\n      _renderData.elements.push(_sprite);\r\n    }\r\n  } // Pools\r\n\r\n\r\n  function getNextObjectInPool() {\r\n    if (_objectCount === _objectPoolLength) {\r\n      var object = new RenderableObject();\r\n\r\n      _objectPool.push(object);\r\n\r\n      _objectPoolLength++;\r\n      _objectCount++;\r\n      return object;\r\n    }\r\n\r\n    return _objectPool[_objectCount++];\r\n  }\r\n\r\n  function getNextVertexInPool() {\r\n    if (_vertexCount === _vertexPoolLength) {\r\n      var vertex = new RenderableVertex();\r\n\r\n      _vertexPool.push(vertex);\r\n\r\n      _vertexPoolLength++;\r\n      _vertexCount++;\r\n      return vertex;\r\n    }\r\n\r\n    return _vertexPool[_vertexCount++];\r\n  }\r\n\r\n  function getNextFaceInPool() {\r\n    if (_faceCount === _facePoolLength) {\r\n      var face = new RenderableFace();\r\n\r\n      _facePool.push(face);\r\n\r\n      _facePoolLength++;\r\n      _faceCount++;\r\n      return face;\r\n    }\r\n\r\n    return _facePool[_faceCount++];\r\n  }\r\n\r\n  function getNextLineInPool() {\r\n    if (_lineCount === _linePoolLength) {\r\n      var line = new RenderableLine();\r\n\r\n      _linePool.push(line);\r\n\r\n      _linePoolLength++;\r\n      _lineCount++;\r\n      return line;\r\n    }\r\n\r\n    return _linePool[_lineCount++];\r\n  }\r\n\r\n  function getNextSpriteInPool() {\r\n    if (_spriteCount === _spritePoolLength) {\r\n      var sprite = new RenderableSprite();\r\n\r\n      _spritePool.push(sprite);\r\n\r\n      _spritePoolLength++;\r\n      _spriteCount++;\r\n      return sprite;\r\n    }\r\n\r\n    return _spritePool[_spriteCount++];\r\n  } //\r\n\r\n\r\n  function painterSort(a, b) {\r\n    if (a.renderOrder !== b.renderOrder) {\r\n      return a.renderOrder - b.renderOrder;\r\n    } else if (a.z !== b.z) {\r\n      return b.z - a.z;\r\n    } else if (a.id !== b.id) {\r\n      return a.id - b.id;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function clipLine(s1, s2) {\r\n    var alpha1 = 0,\r\n        alpha2 = 1,\r\n        // Calculate the boundary coordinate of each vertex for the near and far clip planes,\r\n    // Z = -1 and Z = +1, respectively.\r\n    bc1near = s1.z + s1.w,\r\n        bc2near = s2.z + s2.w,\r\n        bc1far = -s1.z + s1.w,\r\n        bc2far = -s2.z + s2.w;\r\n\r\n    if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {\r\n      // Both vertices lie entirely within all clip planes.\r\n      return true;\r\n    } else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) {\r\n      // Both vertices lie entirely outside one of the clip planes.\r\n      return false;\r\n    } else {\r\n      // The line segment spans at least one clip plane.\r\n      if (bc1near < 0) {\r\n        // v1 lies outside the near plane, v2 inside\r\n        alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));\r\n      } else if (bc2near < 0) {\r\n        // v2 lies outside the near plane, v1 inside\r\n        alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));\r\n      }\r\n\r\n      if (bc1far < 0) {\r\n        // v1 lies outside the far plane, v2 inside\r\n        alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));\r\n      } else if (bc2far < 0) {\r\n        // v2 lies outside the far plane, v2 inside\r\n        alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));\r\n      }\r\n\r\n      if (alpha2 < alpha1) {\r\n        // The line segment spans two boundaries, but is outside both of them.\r\n        // (This can't happen when we're only clipping against just near/far but good\r\n        //  to leave the check here for future usage if other clip planes are added.)\r\n        return false;\r\n      } else {\r\n        // Update the s1 and s2 vertices to match the clipped line segment.\r\n        s1.lerp(s2, alpha1);\r\n        s2.lerp(s1, 1 - alpha2);\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexport { Projector, RenderableFace, RenderableLine, RenderableObject, RenderableSprite, RenderableVertex };\r\n", "import { Object3D, Box2, Color, Vector3, Matrix3, Matrix4, Camera } from 'three';\r\nimport { Projector, RenderableSprite, RenderableLine, RenderableFace } from './Projector.js';\r\n\r\nvar SVGObject = function (node) {\r\n  Object3D.call(this);\r\n  this.node = node;\r\n};\r\n\r\nSVGObject.prototype = Object.create(Object3D.prototype);\r\nSVGObject.prototype.constructor = SVGObject;\r\n\r\nvar SVGRenderer = function () {\r\n  var _this = this,\r\n      _renderData,\r\n      _elements,\r\n      _lights,\r\n      _projector = new Projector(),\r\n      _svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),\r\n      _svgWidth,\r\n      _svgHeight,\r\n      _svgWidthHalf,\r\n      _svgHeightHalf,\r\n      _v1,\r\n      _v2,\r\n      _v3,\r\n      _clipBox = new Box2(),\r\n      _elemBox = new Box2(),\r\n      _color = new Color(),\r\n      _diffuseColor = new Color(),\r\n      _ambientLight = new Color(),\r\n      _directionalLights = new Color(),\r\n      _pointLights = new Color(),\r\n      _clearColor = new Color(),\r\n      _vector3 = new Vector3(),\r\n      // Needed for PointLight\r\n  _centroid = new Vector3(),\r\n      _normal = new Vector3(),\r\n      _normalViewMatrix = new Matrix3(),\r\n      _viewMatrix = new Matrix4(),\r\n      _viewProjectionMatrix = new Matrix4(),\r\n      _svgPathPool = [],\r\n      _svgNode,\r\n      _pathCount = 0,\r\n      _currentPath,\r\n      _currentStyle,\r\n      _quality = 1,\r\n      _precision = null;\r\n\r\n  this.domElement = _svg;\r\n  this.autoClear = true;\r\n  this.sortObjects = true;\r\n  this.sortElements = true;\r\n  this.overdraw = 0.5;\r\n  this.info = {\r\n    render: {\r\n      vertices: 0,\r\n      faces: 0\r\n    }\r\n  };\r\n\r\n  this.setQuality = function (quality) {\r\n    switch (quality) {\r\n      case 'high':\r\n        _quality = 1;\r\n        break;\r\n\r\n      case 'low':\r\n        _quality = 0;\r\n        break;\r\n    }\r\n  };\r\n\r\n  this.setClearColor = function (color) {\r\n    _clearColor.set(color);\r\n  };\r\n\r\n  this.setPixelRatio = function () {};\r\n\r\n  this.setSize = function (width, height) {\r\n    _svgWidth = width;\r\n    _svgHeight = height;\r\n    _svgWidthHalf = _svgWidth / 2;\r\n    _svgHeightHalf = _svgHeight / 2;\r\n\r\n    _svg.setAttribute('viewBox', -_svgWidthHalf + ' ' + -_svgHeightHalf + ' ' + _svgWidth + ' ' + _svgHeight);\r\n\r\n    _svg.setAttribute('width', _svgWidth);\r\n\r\n    _svg.setAttribute('height', _svgHeight);\r\n\r\n    _clipBox.min.set(-_svgWidthHalf, -_svgHeightHalf);\r\n\r\n    _clipBox.max.set(_svgWidthHalf, _svgHeightHalf);\r\n  };\r\n\r\n  this.getSize = function () {\r\n    return {\r\n      width: _svgWidth,\r\n      height: _svgHeight\r\n    };\r\n  };\r\n\r\n  this.setPrecision = function (precision) {\r\n    _precision = precision;\r\n  };\r\n\r\n  function removeChildNodes() {\r\n    _pathCount = 0;\r\n\r\n    while (_svg.childNodes.length > 0) {\r\n      _svg.removeChild(_svg.childNodes[0]);\r\n    }\r\n  }\r\n\r\n  function convert(c) {\r\n    return _precision !== null ? c.toFixed(_precision) : c;\r\n  }\r\n\r\n  this.clear = function () {\r\n    removeChildNodes();\r\n    _svg.style.backgroundColor = _clearColor.getStyle();\r\n  };\r\n\r\n  this.render = function (scene, camera) {\r\n    if (camera instanceof Camera === false) {\r\n      console.error('THREE.SVGRenderer.render: camera is not an instance of Camera.');\r\n      return;\r\n    }\r\n\r\n    var background = scene.background;\r\n\r\n    if (background && background.isColor) {\r\n      removeChildNodes();\r\n      _svg.style.backgroundColor = background.getStyle();\r\n    } else if (this.autoClear === true) {\r\n      this.clear();\r\n    }\r\n\r\n    _this.info.render.vertices = 0;\r\n    _this.info.render.faces = 0;\r\n\r\n    _viewMatrix.copy(camera.matrixWorldInverse);\r\n\r\n    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\r\n\r\n    _renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements);\r\n    _elements = _renderData.elements;\r\n    _lights = _renderData.lights;\r\n\r\n    _normalViewMatrix.getNormalMatrix(camera.matrixWorldInverse);\r\n\r\n    calculateLights(_lights); // reset accumulated path\r\n\r\n    _currentPath = '';\r\n    _currentStyle = '';\r\n\r\n    for (let e = 0, el = _elements.length; e < el; e++) {\r\n      var element = _elements[e];\r\n      var material = element.material;\r\n      if (material === undefined || material.opacity === 0) continue;\r\n\r\n      _elemBox.makeEmpty();\r\n\r\n      if (element instanceof RenderableSprite) {\r\n        _v1 = element;\r\n        _v1.x *= _svgWidthHalf;\r\n        _v1.y *= -_svgHeightHalf;\r\n        renderSprite(_v1, element, material);\r\n      } else if (element instanceof RenderableLine) {\r\n        _v1 = element.v1;\r\n        _v2 = element.v2;\r\n        _v1.positionScreen.x *= _svgWidthHalf;\r\n        _v1.positionScreen.y *= -_svgHeightHalf;\r\n        _v2.positionScreen.x *= _svgWidthHalf;\r\n        _v2.positionScreen.y *= -_svgHeightHalf;\r\n\r\n        _elemBox.setFromPoints([_v1.positionScreen, _v2.positionScreen]);\r\n\r\n        if (_clipBox.intersectsBox(_elemBox) === true) {\r\n          renderLine(_v1, _v2, element, material);\r\n        }\r\n      } else if (element instanceof RenderableFace) {\r\n        _v1 = element.v1;\r\n        _v2 = element.v2;\r\n        _v3 = element.v3;\r\n        if (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1) continue;\r\n        if (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1) continue;\r\n        if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1) continue;\r\n        _v1.positionScreen.x *= _svgWidthHalf;\r\n        _v1.positionScreen.y *= -_svgHeightHalf;\r\n        _v2.positionScreen.x *= _svgWidthHalf;\r\n        _v2.positionScreen.y *= -_svgHeightHalf;\r\n        _v3.positionScreen.x *= _svgWidthHalf;\r\n        _v3.positionScreen.y *= -_svgHeightHalf;\r\n\r\n        if (this.overdraw > 0) {\r\n          expand(_v1.positionScreen, _v2.positionScreen, this.overdraw);\r\n          expand(_v2.positionScreen, _v3.positionScreen, this.overdraw);\r\n          expand(_v3.positionScreen, _v1.positionScreen, this.overdraw);\r\n        }\r\n\r\n        _elemBox.setFromPoints([_v1.positionScreen, _v2.positionScreen, _v3.positionScreen]);\r\n\r\n        if (_clipBox.intersectsBox(_elemBox) === true) {\r\n          renderFace3(_v1, _v2, _v3, element, material);\r\n        }\r\n      }\r\n    }\r\n\r\n    flushPath(); // just to flush last svg:path\r\n\r\n    scene.traverseVisible(function (object) {\r\n      if (object instanceof SVGObject) {\r\n        _vector3.setFromMatrixPosition(object.matrixWorld);\r\n\r\n        _vector3.applyMatrix4(_viewProjectionMatrix);\r\n\r\n        if (_vector3.z < -1 || _vector3.z > 1) return;\r\n        var x = _vector3.x * _svgWidthHalf;\r\n        var y = -_vector3.y * _svgHeightHalf;\r\n        var node = object.node;\r\n        node.setAttribute('transform', 'translate(' + x + ',' + y + ')');\r\n\r\n        _svg.appendChild(node);\r\n      }\r\n    });\r\n  };\r\n\r\n  function calculateLights(lights) {\r\n    _ambientLight.setRGB(0, 0, 0);\r\n\r\n    _directionalLights.setRGB(0, 0, 0);\r\n\r\n    _pointLights.setRGB(0, 0, 0);\r\n\r\n    for (let l = 0, ll = lights.length; l < ll; l++) {\r\n      var light = lights[l];\r\n      var lightColor = light.color;\r\n\r\n      if (light.isAmbientLight) {\r\n        _ambientLight.r += lightColor.r;\r\n        _ambientLight.g += lightColor.g;\r\n        _ambientLight.b += lightColor.b;\r\n      } else if (light.isDirectionalLight) {\r\n        _directionalLights.r += lightColor.r;\r\n        _directionalLights.g += lightColor.g;\r\n        _directionalLights.b += lightColor.b;\r\n      } else if (light.isPointLight) {\r\n        _pointLights.r += lightColor.r;\r\n        _pointLights.g += lightColor.g;\r\n        _pointLights.b += lightColor.b;\r\n      }\r\n    }\r\n  }\r\n\r\n  function calculateLight(lights, position, normal, color) {\r\n    for (let l = 0, ll = lights.length; l < ll; l++) {\r\n      var light = lights[l];\r\n      var lightColor = light.color;\r\n\r\n      if (light.isDirectionalLight) {\r\n        var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld).normalize();\r\n\r\n        var amount = normal.dot(lightPosition);\r\n        if (amount <= 0) continue;\r\n        amount *= light.intensity;\r\n        color.r += lightColor.r * amount;\r\n        color.g += lightColor.g * amount;\r\n        color.b += lightColor.b * amount;\r\n      } else if (light.isPointLight) {\r\n        var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld);\r\n\r\n        var amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize());\r\n        if (amount <= 0) continue;\r\n        amount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1);\r\n        if (amount == 0) continue;\r\n        amount *= light.intensity;\r\n        color.r += lightColor.r * amount;\r\n        color.g += lightColor.g * amount;\r\n        color.b += lightColor.b * amount;\r\n      }\r\n    }\r\n  }\r\n\r\n  function renderSprite(v1, element, material) {\r\n    var scaleX = element.scale.x * _svgWidthHalf;\r\n    var scaleY = element.scale.y * _svgHeightHalf;\r\n\r\n    if (material.isPointsMaterial) {\r\n      scaleX *= material.size;\r\n      scaleY *= material.size;\r\n    }\r\n\r\n    var path = 'M' + convert(v1.x - scaleX * 0.5) + ',' + convert(v1.y - scaleY * 0.5) + 'h' + convert(scaleX) + 'v' + convert(scaleY) + 'h' + convert(-scaleX) + 'z';\r\n    var style = '';\r\n\r\n    if (material.isSpriteMaterial || material.isPointsMaterial) {\r\n      style = 'fill:' + material.color.getStyle() + ';fill-opacity:' + material.opacity;\r\n    }\r\n\r\n    addPath(style, path);\r\n  }\r\n\r\n  function renderLine(v1, v2, element, material) {\r\n    var path = 'M' + convert(v1.positionScreen.x) + ',' + convert(v1.positionScreen.y) + 'L' + convert(v2.positionScreen.x) + ',' + convert(v2.positionScreen.y);\r\n\r\n    if (material.isLineBasicMaterial) {\r\n      var style = 'fill:none;stroke:' + material.color.getStyle() + ';stroke-opacity:' + material.opacity + ';stroke-width:' + material.linewidth + ';stroke-linecap:' + material.linecap;\r\n\r\n      if (material.isLineDashedMaterial) {\r\n        style = style + ';stroke-dasharray:' + material.dashSize + ',' + material.gapSize;\r\n      }\r\n\r\n      addPath(style, path);\r\n    }\r\n  }\r\n\r\n  function renderFace3(v1, v2, v3, element, material) {\r\n    _this.info.render.vertices += 3;\r\n    _this.info.render.faces++;\r\n    var path = 'M' + convert(v1.positionScreen.x) + ',' + convert(v1.positionScreen.y) + 'L' + convert(v2.positionScreen.x) + ',' + convert(v2.positionScreen.y) + 'L' + convert(v3.positionScreen.x) + ',' + convert(v3.positionScreen.y) + 'z';\r\n    var style = '';\r\n\r\n    if (material.isMeshBasicMaterial) {\r\n      _color.copy(material.color);\r\n\r\n      if (material.vertexColors) {\r\n        _color.multiply(element.color);\r\n      }\r\n    } else if (material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial) {\r\n      _diffuseColor.copy(material.color);\r\n\r\n      if (material.vertexColors) {\r\n        _diffuseColor.multiply(element.color);\r\n      }\r\n\r\n      _color.copy(_ambientLight);\r\n\r\n      _centroid.copy(v1.positionWorld).add(v2.positionWorld).add(v3.positionWorld).divideScalar(3);\r\n\r\n      calculateLight(_lights, _centroid, element.normalModel, _color);\r\n\r\n      _color.multiply(_diffuseColor).add(material.emissive);\r\n    } else if (material.isMeshNormalMaterial) {\r\n      _normal.copy(element.normalModel).applyMatrix3(_normalViewMatrix).normalize();\r\n\r\n      _color.setRGB(_normal.x, _normal.y, _normal.z).multiplyScalar(0.5).addScalar(0.5);\r\n    }\r\n\r\n    if (material.wireframe) {\r\n      style = 'fill:none;stroke:' + _color.getStyle() + ';stroke-opacity:' + material.opacity + ';stroke-width:' + material.wireframeLinewidth + ';stroke-linecap:' + material.wireframeLinecap + ';stroke-linejoin:' + material.wireframeLinejoin;\r\n    } else {\r\n      style = 'fill:' + _color.getStyle() + ';fill-opacity:' + material.opacity;\r\n    }\r\n\r\n    addPath(style, path);\r\n  } // Hide anti-alias gaps\r\n\r\n\r\n  function expand(v1, v2, pixels) {\r\n    var x = v2.x - v1.x,\r\n        y = v2.y - v1.y,\r\n        det = x * x + y * y,\r\n        idet;\r\n    if (det === 0) return;\r\n    idet = pixels / Math.sqrt(det);\r\n    x *= idet;\r\n    y *= idet;\r\n    v2.x += x;\r\n    v2.y += y;\r\n    v1.x -= x;\r\n    v1.y -= y;\r\n  }\r\n\r\n  function addPath(style, path) {\r\n    if (_currentStyle === style) {\r\n      _currentPath += path;\r\n    } else {\r\n      flushPath();\r\n      _currentStyle = style;\r\n      _currentPath = path;\r\n    }\r\n  }\r\n\r\n  function flushPath() {\r\n    if (_currentPath) {\r\n      _svgNode = getPathNode(_pathCount++);\r\n\r\n      _svgNode.setAttribute('d', _currentPath);\r\n\r\n      _svgNode.setAttribute('style', _currentStyle);\r\n\r\n      _svg.appendChild(_svgNode);\r\n    }\r\n\r\n    _currentPath = '';\r\n    _currentStyle = '';\r\n  }\r\n\r\n  function getPathNode(id) {\r\n    if (_svgPathPool[id] == null) {\r\n      _svgPathPool[id] = document.createElementNS('http://www.w3.org/2000/svg', 'path');\r\n\r\n      if (_quality == 0) {\r\n        _svgPathPool[id].setAttribute('shape-rendering', 'crispEdges'); //optimizeSpeed\r\n\r\n      }\r\n\r\n      return _svgPathPool[id];\r\n    }\r\n\r\n    return _svgPathPool[id];\r\n  }\r\n};\r\n\r\nexport { SVGObject, SVGRenderer };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { DataTexture, RGBAFormat, FloatType, RepeatWrapping, NearestFilter, Mesh, InstancedMesh, Matrix4, DynamicDrawUsage } from 'three';\r\n\r\n// Original src: https://github.com/zz85/threejs-path-flow\r\nconst CHANNELS = 4;\r\nconst TEXTURE_WIDTH = 1024;\r\nconst TEXTURE_HEIGHT = 4;\r\n\r\n/**\r\n * Make a new DataTexture to store the descriptions of the curves.\r\n *\r\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\r\n */\r\nconst initSplineTexture = (numberOfCurves = 1) => {\r\n  const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);\r\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType);\r\n  dataTexture.wrapS = RepeatWrapping;\r\n  dataTexture.wrapT = RepeatWrapping;\r\n  dataTexture.magFilter = NearestFilter;\r\n  dataTexture.needsUpdate = true;\r\n  return dataTexture;\r\n};\r\n/**\r\n * Write the curve description to the data texture\r\n *\r\n * @param { DataTexture } texture The DataTexture to write to\r\n * @param { Curve } splineCurve The curve to describe\r\n * @param { number } offset Which curve slot to write to\r\n */\r\n\r\nconst updateSplineTexture = (texture, splineCurve, offset = 0) => {\r\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\r\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\r\n  splineCurve.updateArcLengths();\r\n  const points = splineCurve.getSpacedPoints(numberOfPoints);\r\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\r\n\r\n  for (let i = 0; i < numberOfPoints; i++) {\r\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH);\r\n    const rowIndex = i % TEXTURE_WIDTH;\r\n    let pt = points[i];\r\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\r\n    pt = frenetFrames.tangents[i];\r\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\r\n    pt = frenetFrames.normals[i];\r\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\r\n    pt = frenetFrames.binormals[i];\r\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\r\n  }\r\n\r\n  texture.needsUpdate = true;\r\n};\r\n\r\nconst setTextureValue = (texture, index, x, y, z, o) => {\r\n  const image = texture.image;\r\n  const {\r\n    data\r\n  } = image;\r\n  const i = CHANNELS * TEXTURE_WIDTH * o; // Row Offset\r\n\r\n  data[index * CHANNELS + i + 0] = x;\r\n  data[index * CHANNELS + i + 1] = y;\r\n  data[index * CHANNELS + i + 2] = z;\r\n  data[index * CHANNELS + i + 3] = 1;\r\n};\r\n\r\n/**\r\n * Create a new set of uniforms for describing the curve modifier\r\n *\r\n * @param { DataTexture } Texture which holds the curve description\r\n */\r\nconst getUniforms = splineTexture => ({\r\n  spineTexture: {\r\n    value: splineTexture\r\n  },\r\n  pathOffset: {\r\n    type: 'f',\r\n    value: 0\r\n  },\r\n  // time of path curve\r\n  pathSegment: {\r\n    type: 'f',\r\n    value: 1\r\n  },\r\n  // fractional length of path\r\n  spineOffset: {\r\n    type: 'f',\r\n    value: 161\r\n  },\r\n  spineLength: {\r\n    type: 'f',\r\n    value: 400\r\n  },\r\n  flow: {\r\n    type: 'i',\r\n    value: 1\r\n  }\r\n});\r\nfunction modifyShader(material, uniforms, numberOfCurves = 1) {\r\n  if (material.__ok) return;\r\n  material.__ok = true;\r\n\r\n  material.onBeforeCompile = shader => {\r\n    if (shader.__modified) return;\r\n    shader.__modified = true;\r\n    Object.assign(shader.uniforms, uniforms);\r\n    const vertexShader =\r\n    /* glsl */\r\n    `\r\n\t\tuniform sampler2D spineTexture;\r\n\t\tuniform float pathOffset;\r\n\t\tuniform float pathSegment;\r\n\t\tuniform float spineOffset;\r\n\t\tuniform float spineLength;\r\n\t\tuniform int flow;\r\n\r\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\r\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\r\n\r\n\t\t${shader.vertexShader}\r\n\t\t` // chunk import moved in front of modified shader below\r\n    .replace('#include <beginnormal_vertex>', '') // vec3 transformedNormal declaration overriden below\r\n    .replace('#include <defaultnormal_vertex>', '') // vec3 transformed declaration overriden below\r\n    .replace('#include <begin_vertex>', '') // shader override\r\n    .replace(/void\\s*main\\s*\\(\\)\\s*\\{/,\r\n    /* glsl */\r\n    `\r\n        void main() {\r\n        #include <beginnormal_vertex>\r\n\r\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\r\n\r\n        bool bend = flow > 0;\r\n        float xWeight = bend ? 0. : 1.;\r\n\r\n        #ifdef USE_INSTANCING\r\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\r\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\r\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\r\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\r\n        #else\r\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\r\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\r\n        #endif\r\n\r\n        mt = mod(mt, textureStacks);\r\n        float rowOffset = floor(mt);\r\n\r\n        #ifdef USE_INSTANCING\r\n        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\r\n        #endif\r\n\r\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\r\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\r\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\r\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\r\n        mat3 basis = mat3(a, b, c);\r\n\r\n        vec3 transformed = basis\r\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\r\n          + spinePos;\r\n\r\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\r\n\t\t\t`).replace('#include <project_vertex>',\r\n    /* glsl */\r\n    `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\r\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`);\r\n    shader.vertexShader = vertexShader;\r\n  };\r\n}\r\n/**\r\n * A helper class for making meshes bend aroudn curves\r\n */\r\n\r\nclass Flow {\r\n  /**\r\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\r\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\r\n   */\r\n  constructor(mesh, numberOfCurves = 1) {\r\n    _defineProperty(this, \"curveArray\", void 0);\r\n\r\n    _defineProperty(this, \"curveLengthArray\", void 0);\r\n\r\n    _defineProperty(this, \"object3D\", void 0);\r\n\r\n    _defineProperty(this, \"splineTexure\", void 0);\r\n\r\n    _defineProperty(this, \"uniforms\", void 0);\r\n\r\n    const obj3D = mesh.clone();\r\n    const splineTexure = initSplineTexture(numberOfCurves);\r\n    const uniforms = getUniforms(splineTexure);\r\n    obj3D.traverse(child => {\r\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\r\n        child.material = child.material.clone();\r\n        modifyShader(child.material, uniforms, numberOfCurves);\r\n      }\r\n    });\r\n    this.curveArray = new Array(numberOfCurves);\r\n    this.curveLengthArray = new Array(numberOfCurves);\r\n    this.object3D = obj3D;\r\n    this.splineTexure = splineTexure;\r\n    this.uniforms = uniforms;\r\n  }\r\n\r\n  updateCurve(index, curve) {\r\n    if (index >= this.curveArray.length) throw Error('Index out of range for Flow');\r\n    const curveLength = curve.getLength();\r\n    this.uniforms.spineLength.value = curveLength;\r\n    this.curveLengthArray[index] = curveLength;\r\n    this.curveArray[index] = curve;\r\n    updateSplineTexture(this.splineTexure, curve, index);\r\n  }\r\n\r\n  moveAlongCurve(amount) {\r\n    this.uniforms.pathOffset.value += amount;\r\n  }\r\n\r\n}\r\nconst matrix = new Matrix4();\r\n/**\r\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\r\n */\r\n\r\nclass InstancedFlow extends Flow {\r\n  /**\r\n   *\r\n   * @param {number} count The number of instanced elements\r\n   * @param {number} curveCount The number of curves to preallocate for\r\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\r\n   * @param {Material} material The material to use for the instanced mesh\r\n   */\r\n  constructor(count, curveCount, geometry, material) {\r\n    const mesh = new InstancedMesh(geometry, material, count);\r\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\r\n    super(mesh, curveCount);\r\n\r\n    _defineProperty(this, \"offsets\", void 0);\r\n\r\n    _defineProperty(this, \"whichCurve\", void 0);\r\n\r\n    this.offsets = new Array(count).fill(0);\r\n    this.whichCurve = new Array(count).fill(0);\r\n  }\r\n  /**\r\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\r\n   * This writes that information to the matrix and marks it as needing update.\r\n   *\r\n   * @param {number} index of the instanced element to update\r\n   */\r\n\r\n\r\n  writeChanges(index) {\r\n    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\r\n    this.object3D.setMatrixAt(index, matrix);\r\n    this.object3D.instanceMatrix.needsUpdate = true;\r\n  }\r\n  /**\r\n   * Move an individual element along the curve by a specific amount\r\n   *\r\n   * @param {number} index Which element to update\r\n   * @param {number} offset Move by how much\r\n   */\r\n\r\n\r\n  moveIndividualAlongCurve(index, offset) {\r\n    this.offsets[index] += offset;\r\n    this.writeChanges(index);\r\n  }\r\n  /**\r\n   * Select which curve to use for an element\r\n   *\r\n   * @param {number} index the index of the instanced element to update\r\n   * @param {number} curveNo the index of the curve it should use\r\n   */\r\n\r\n\r\n  setCurve(index, curveNo) {\r\n    if (isNaN(curveNo)) throw Error('curve index being set is Not a Number (NaN)');\r\n    this.whichCurve[index] = curveNo;\r\n    this.writeChanges(index);\r\n  }\r\n\r\n}\r\n\r\nexport { Flow, InstancedFlow, getUniforms, initSplineTexture, modifyShader, updateSplineTexture };\r\n", "import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from 'three';\r\nimport { getWithKey } from '../types/helpers.js';\r\n\r\n/**\r\n * @param  {Array<BufferGeometry>} geometries\r\n * @param  {Boolean} useGroups\r\n * @return {BufferGeometry}\r\n */\r\nconst mergeBufferGeometries = (geometries, useGroups) => {\r\n  const isIndexed = geometries[0].index !== null;\r\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\r\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\r\n  const attributes = {};\r\n  const morphAttributes = {};\r\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\r\n  const mergedGeometry = new BufferGeometry();\r\n  let offset = 0;\r\n  geometries.forEach((geom, i) => {\r\n    let attributesCount = 0; // ensure that all geometries are indexed, or none\r\n\r\n    if (isIndexed !== (geom.index !== null)) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\r\n      return null;\r\n    } // gather attributes, exit early if they're different\r\n\r\n\r\n    for (let name in geom.attributes) {\r\n      if (!attributesUsed.has(name)) {\r\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\r\n        return null;\r\n      }\r\n\r\n      if (attributes[name] === undefined) {\r\n        attributes[name] = [];\r\n      }\r\n\r\n      attributes[name].push(geom.attributes[name]);\r\n      attributesCount++;\r\n    } // ensure geometries have the same number of attributes\r\n\r\n\r\n    if (attributesCount !== attributesUsed.size) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\r\n      return null;\r\n    } // gather morph attributes, exit early if they're different\r\n\r\n\r\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\r\n      return null;\r\n    }\r\n\r\n    for (let name in geom.morphAttributes) {\r\n      if (!morphAttributesUsed.has(name)) {\r\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\r\n        return null;\r\n      }\r\n\r\n      if (morphAttributes[name] === undefined) morphAttributes[name] = [];\r\n      morphAttributes[name].push(geom.morphAttributes[name]);\r\n    } // gather .userData\r\n\r\n\r\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\r\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\r\n\r\n    if (useGroups) {\r\n      let count;\r\n\r\n      if (geom.index) {\r\n        count = geom.index.count;\r\n      } else if (geom.attributes.position !== undefined) {\r\n        count = geom.attributes.position.count;\r\n      } else {\r\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\r\n        return null;\r\n      }\r\n\r\n      mergedGeometry.addGroup(offset, count, i);\r\n      offset += count;\r\n    }\r\n  }); // merge indices\r\n\r\n  if (isIndexed) {\r\n    let indexOffset = 0;\r\n    const mergedIndex = [];\r\n    geometries.forEach(geom => {\r\n      const index = geom.index;\r\n\r\n      for (let j = 0; j < index.count; ++j) {\r\n        mergedIndex.push(index.getX(j) + indexOffset);\r\n      }\r\n\r\n      indexOffset += geom.attributes.position.count;\r\n    });\r\n    mergedGeometry.setIndex(mergedIndex);\r\n  } // merge attributes\r\n\r\n\r\n  for (let name in attributes) {\r\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\r\n\r\n    if (!mergedAttribute) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\r\n      return null;\r\n    }\r\n\r\n    mergedGeometry.setAttribute(name, mergedAttribute);\r\n  } // merge morph attributes\r\n\r\n\r\n  for (let name in morphAttributes) {\r\n    const numMorphTargets = morphAttributes[name][0].length;\r\n    if (numMorphTargets === 0) break;\r\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\r\n    mergedGeometry.morphAttributes[name] = [];\r\n\r\n    for (let i = 0; i < numMorphTargets; ++i) {\r\n      const morphAttributesToMerge = [];\r\n\r\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\r\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\r\n      }\r\n\r\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\r\n\r\n      if (!mergedMorphAttribute) {\r\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\r\n        return null;\r\n      }\r\n\r\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\r\n    }\r\n  }\r\n\r\n  return mergedGeometry;\r\n};\r\n/**\r\n * @param {Array<BufferAttribute>} attributes\r\n * @return {BufferAttribute}\r\n */\r\n\r\nconst mergeBufferAttributes = attributes => {\r\n  let TypedArray = undefined;\r\n  let itemSize = undefined;\r\n  let normalized = undefined;\r\n  let arrayLength = 0;\r\n  attributes.forEach(attr => {\r\n    if (TypedArray === undefined) {\r\n      TypedArray = attr.array.constructor;\r\n    }\r\n\r\n    if (TypedArray !== attr.array.constructor) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\r\n      return null;\r\n    }\r\n\r\n    if (itemSize === undefined) itemSize = attr.itemSize;\r\n\r\n    if (itemSize !== attr.itemSize) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\r\n      return null;\r\n    }\r\n\r\n    if (normalized === undefined) normalized = attr.normalized;\r\n\r\n    if (normalized !== attr.normalized) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\r\n      return null;\r\n    }\r\n\r\n    arrayLength += attr.array.length;\r\n  });\r\n\r\n  if (TypedArray && itemSize) {\r\n    // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\r\n    const array = new TypedArray(arrayLength);\r\n    let offset = 0;\r\n    attributes.forEach(attr => {\r\n      array.set(attr.array, offset);\r\n      offset += attr.array.length;\r\n    });\r\n    return new BufferAttribute(array, itemSize, normalized);\r\n  }\r\n};\r\n/**\r\n * @param {Array<BufferAttribute>} attributes\r\n * @return {Array<InterleavedBufferAttribute>}\r\n */\r\n\r\nconst interleaveAttributes = attributes => {\r\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\r\n  // a set of InterleavedBufferAttributes for each attribute\r\n  let TypedArray = undefined;\r\n  let arrayLength = 0;\r\n  let stride = 0; // calculate the the length and type of the interleavedBuffer\r\n\r\n  for (let i = 0, l = attributes.length; i < l; ++i) {\r\n    const attribute = attributes[i];\r\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\r\n\r\n    if (TypedArray !== attribute.array.constructor) {\r\n      console.error('AttributeBuffers of different types cannot be interleaved');\r\n      return null;\r\n    }\r\n\r\n    arrayLength += attribute.array.length;\r\n    stride += attribute.itemSize;\r\n  } // Create the set of buffer attributes\r\n  // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\r\n\r\n\r\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\r\n  let offset = 0;\r\n  const res = [];\r\n  const getters = ['getX', 'getY', 'getZ', 'getW'];\r\n  const setters = ['setX', 'setY', 'setZ', 'setW'];\r\n\r\n  for (let j = 0, l = attributes.length; j < l; j++) {\r\n    const attribute = attributes[j];\r\n    const itemSize = attribute.itemSize;\r\n    const count = attribute.count;\r\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\r\n    res.push(iba);\r\n    offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\r\n    // at the appropriate offset\r\n\r\n    for (let c = 0; c < count; c++) {\r\n      for (let k = 0; k < itemSize; k++) {\r\n        const set = getWithKey(iba, setters[k]);\r\n        const get = getWithKey(attribute, getters[k]);\r\n        set(c, get(c));\r\n      }\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n/**\r\n * @param {Array<BufferGeometry>} geometry\r\n * @return {number}\r\n */\r\n\r\nfunction estimateBytesUsed(geometry) {\r\n  // Return the estimated memory used by this geometry in bytes\r\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\r\n  // for InterleavedBufferAttributes.\r\n  let mem = 0;\r\n\r\n  for (let name in geometry.attributes) {\r\n    const attr = geometry.getAttribute(name);\r\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\r\n  }\r\n\r\n  const indices = geometry.getIndex();\r\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\r\n  return mem;\r\n}\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {number} tolerance\r\n * @return {BufferGeometry>}\r\n */\r\n\r\nfunction mergeVertices(geometry, tolerance = 1e-4) {\r\n  tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\r\n  // if it's already available.\r\n\r\n  const hashToIndex = {};\r\n  const indices = geometry.getIndex();\r\n  const positions = geometry.getAttribute('position');\r\n  const vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\r\n\r\n  let nextIndex = 0; // attributes and new attribute arrays\r\n\r\n  const attributeNames = Object.keys(geometry.attributes);\r\n  const attrArrays = {};\r\n  const morphAttrsArrays = {};\r\n  const newIndices = [];\r\n  const getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\r\n\r\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\r\n    const name = attributeNames[i];\r\n    attrArrays[name] = [];\r\n    const morphAttr = geometry.morphAttributes[name];\r\n\r\n    if (morphAttr) {\r\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\r\n    }\r\n  } // convert the error tolerance to an amount of decimal places to truncate to\r\n\r\n\r\n  const decimalShift = Math.log10(1 / tolerance);\r\n  const shiftMultiplier = Math.pow(10, decimalShift);\r\n\r\n  for (let i = 0; i < vertexCount; i++) {\r\n    const index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'\r\n\r\n    let hash = '';\r\n\r\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\r\n      const name = attributeNames[j];\r\n      const attribute = geometry.getAttribute(name);\r\n      const itemSize = attribute.itemSize;\r\n\r\n      for (let k = 0; k < itemSize; k++) {\r\n        // double tilde truncates the decimal value\r\n        // @ts-ignore no\r\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\r\n      }\r\n    } // Add another reference to the vertex if it's already\r\n    // used by another index\r\n\r\n\r\n    if (hash in hashToIndex) {\r\n      newIndices.push(hashToIndex[hash]);\r\n    } else {\r\n      // copy data to the new index in the attribute arrays\r\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\r\n        const name = attributeNames[j];\r\n        const attribute = geometry.getAttribute(name);\r\n        const morphAttr = geometry.morphAttributes[name];\r\n        const itemSize = attribute.itemSize;\r\n        const newarray = attrArrays[name];\r\n        const newMorphArrays = morphAttrsArrays[name];\r\n\r\n        for (let k = 0; k < itemSize; k++) {\r\n          const getterFunc = getters[k]; // @ts-ignore\r\n\r\n          newarray.push(attribute[getterFunc](index));\r\n\r\n          if (morphAttr) {\r\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\r\n              // @ts-ignore\r\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      hashToIndex[hash] = nextIndex;\r\n      newIndices.push(nextIndex);\r\n      nextIndex++;\r\n    }\r\n  } // Generate typed arrays from new attribute arrays and update\r\n  // the attributeBuffers\r\n\r\n\r\n  const result = geometry.clone();\r\n\r\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\r\n    const name = attributeNames[i];\r\n    const oldAttribute = geometry.getAttribute(name); //@ts-expect-error  something to do with functions and constructors and new\r\n\r\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\r\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\r\n    result.setAttribute(name, attribute); // Update the attribute arrays\r\n\r\n    if (name in morphAttrsArrays) {\r\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\r\n        const oldMorphAttribute = geometry.morphAttributes[name][j]; //@ts-expect-error something to do with functions and constructors and new\r\n\r\n        const buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\r\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\r\n        result.morphAttributes[name][j] = morphAttribute;\r\n      }\r\n    }\r\n  } // indices\r\n\r\n\r\n  result.setIndex(newIndices);\r\n  return result;\r\n}\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {number} drawMode\r\n * @return {BufferGeometry}\r\n */\r\n\r\nfunction toTrianglesDrawMode(geometry, drawMode) {\r\n  if (drawMode === TrianglesDrawMode) {\r\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\r\n    return geometry;\r\n  }\r\n\r\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\r\n    let index = geometry.getIndex(); // generate index if not present\r\n\r\n    if (index === null) {\r\n      const indices = [];\r\n      const position = geometry.getAttribute('position');\r\n\r\n      if (position !== undefined) {\r\n        for (let i = 0; i < position.count; i++) {\r\n          indices.push(i);\r\n        }\r\n\r\n        geometry.setIndex(indices);\r\n        index = geometry.getIndex();\r\n      } else {\r\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\r\n        return geometry;\r\n      }\r\n    } //\r\n\r\n\r\n    const numberOfTriangles = index.count - 2;\r\n    const newIndices = [];\r\n\r\n    if (index) {\r\n      if (drawMode === TriangleFanDrawMode) {\r\n        // gl.TRIANGLE_FAN\r\n        for (let i = 1; i <= numberOfTriangles; i++) {\r\n          newIndices.push(index.getX(0));\r\n          newIndices.push(index.getX(i));\r\n          newIndices.push(index.getX(i + 1));\r\n        }\r\n      } else {\r\n        // gl.TRIANGLE_STRIP\r\n        for (let i = 0; i < numberOfTriangles; i++) {\r\n          if (i % 2 === 0) {\r\n            newIndices.push(index.getX(i));\r\n            newIndices.push(index.getX(i + 1));\r\n            newIndices.push(index.getX(i + 2));\r\n          } else {\r\n            newIndices.push(index.getX(i + 2));\r\n            newIndices.push(index.getX(i + 1));\r\n            newIndices.push(index.getX(i));\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (newIndices.length / 3 !== numberOfTriangles) {\r\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\r\n    } // build final geometry\r\n\r\n\r\n    const newGeometry = geometry.clone();\r\n    newGeometry.setIndex(newIndices);\r\n    newGeometry.clearGroups();\r\n    return newGeometry;\r\n  } else {\r\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\r\n    return geometry;\r\n  }\r\n}\r\n/**\r\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\r\n * Helpful for Raytracing or Decals.\r\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\r\n * @return {Object} An Object with original position/normal attributes and morphed ones.\r\n */\r\n\r\nfunction computeMorphedAttributes(object) {\r\n  if (object.geometry.isBufferGeometry !== true) {\r\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\r\n    return null;\r\n  }\r\n\r\n  const _vA = new Vector3();\r\n\r\n  const _vB = new Vector3();\r\n\r\n  const _vC = new Vector3();\r\n\r\n  const _tempA = new Vector3();\r\n\r\n  const _tempB = new Vector3();\r\n\r\n  const _tempC = new Vector3();\r\n\r\n  const _morphA = new Vector3();\r\n\r\n  const _morphB = new Vector3();\r\n\r\n  const _morphC = new Vector3();\r\n\r\n  function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\r\n    _vA.fromBufferAttribute(attribute, a);\r\n\r\n    _vB.fromBufferAttribute(attribute, b);\r\n\r\n    _vC.fromBufferAttribute(attribute, c);\r\n\r\n    const morphInfluences = object.morphTargetInfluences;\r\n\r\n    if ( // @ts-expect-error\r\n    material.morphTargets && morphAttribute && morphInfluences) {\r\n      _morphA.set(0, 0, 0);\r\n\r\n      _morphB.set(0, 0, 0);\r\n\r\n      _morphC.set(0, 0, 0);\r\n\r\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\r\n        const influence = morphInfluences[i];\r\n        const morph = morphAttribute[i];\r\n        if (influence === 0) continue;\r\n\r\n        _tempA.fromBufferAttribute(morph, a);\r\n\r\n        _tempB.fromBufferAttribute(morph, b);\r\n\r\n        _tempC.fromBufferAttribute(morph, c);\r\n\r\n        if (morphTargetsRelative) {\r\n          _morphA.addScaledVector(_tempA, influence);\r\n\r\n          _morphB.addScaledVector(_tempB, influence);\r\n\r\n          _morphC.addScaledVector(_tempC, influence);\r\n        } else {\r\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\r\n\r\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\r\n\r\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\r\n        }\r\n      }\r\n\r\n      _vA.add(_morphA);\r\n\r\n      _vB.add(_morphB);\r\n\r\n      _vC.add(_morphC);\r\n    }\r\n\r\n    if (object.isSkinnedMesh) {\r\n      // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\r\n      object.boneTransform(a, _vA); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\r\n\r\n      object.boneTransform(b, _vB); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\r\n\r\n      object.boneTransform(c, _vC);\r\n    }\r\n\r\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\r\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\r\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\r\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\r\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\r\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\r\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\r\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\r\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\r\n  }\r\n\r\n  const geometry = object.geometry;\r\n  const material = object.material;\r\n  let a, b, c;\r\n  const index = geometry.index;\r\n  const positionAttribute = geometry.attributes.position;\r\n  const morphPosition = geometry.morphAttributes.position;\r\n  const morphTargetsRelative = geometry.morphTargetsRelative;\r\n  const normalAttribute = geometry.attributes.normal;\r\n  const morphNormal = geometry.morphAttributes.position;\r\n  const groups = geometry.groups;\r\n  const drawRange = geometry.drawRange;\r\n  let i, j, il, jl;\r\n  let group, groupMaterial;\r\n  let start, end;\r\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\r\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\r\n\r\n  if (index !== null) {\r\n    // indexed buffer geometry\r\n    if (Array.isArray(material)) {\r\n      for (i = 0, il = groups.length; i < il; i++) {\r\n        group = groups[i];\r\n        groupMaterial = material[group.materialIndex];\r\n        start = Math.max(group.start, drawRange.start);\r\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\r\n\r\n        for (j = start, jl = end; j < jl; j += 3) {\r\n          a = index.getX(j);\r\n          b = index.getX(j + 1);\r\n          c = index.getX(j + 2);\r\n\r\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\r\n\r\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\r\n        }\r\n      }\r\n    } else {\r\n      start = Math.max(0, drawRange.start);\r\n      end = Math.min(index.count, drawRange.start + drawRange.count);\r\n\r\n      for (i = start, il = end; i < il; i += 3) {\r\n        a = index.getX(i);\r\n        b = index.getX(i + 1);\r\n        c = index.getX(i + 2);\r\n\r\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\r\n\r\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\r\n      }\r\n    }\r\n  } else if (positionAttribute !== undefined) {\r\n    // non-indexed buffer geometry\r\n    if (Array.isArray(material)) {\r\n      for (i = 0, il = groups.length; i < il; i++) {\r\n        group = groups[i];\r\n        groupMaterial = material[group.materialIndex];\r\n        start = Math.max(group.start, drawRange.start);\r\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\r\n\r\n        for (j = start, jl = end; j < jl; j += 3) {\r\n          a = j;\r\n          b = j + 1;\r\n          c = j + 2;\r\n\r\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\r\n\r\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\r\n        }\r\n      }\r\n    } else {\r\n      start = Math.max(0, drawRange.start);\r\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\r\n\r\n      for (i = start, il = end; i < il; i += 3) {\r\n        a = i;\r\n        b = i + 1;\r\n        c = i + 2;\r\n\r\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\r\n\r\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\r\n      }\r\n    }\r\n  }\r\n\r\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\r\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\r\n  return {\r\n    positionAttribute: positionAttribute,\r\n    normalAttribute: normalAttribute,\r\n    morphedPositionAttribute: morphedPositionAttribute,\r\n    morphedNormalAttribute: morphedNormalAttribute\r\n  };\r\n}\r\n\r\nexport { computeMorphedAttributes, estimateBytesUsed, interleaveAttributes, mergeBufferAttributes, mergeBufferGeometries, mergeVertices, toTrianglesDrawMode };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from 'three';\r\nimport { mergeVertices } from '../utils/BufferGeometryUtils.js';\r\n\r\nconst cb = new Vector3(),\r\n      ab = new Vector3();\r\n\r\nfunction pushIfUnique(array, object) {\r\n  if (array.indexOf(object) === -1) array.push(object);\r\n}\r\n\r\nfunction removeFromArray(array, object) {\r\n  const k = array.indexOf(object);\r\n  if (k > -1) array.splice(k, 1);\r\n}\r\n\r\nclass Vertex {\r\n  constructor(v, id) {\r\n    _defineProperty(this, \"position\", void 0);\r\n\r\n    _defineProperty(this, \"id\", void 0);\r\n\r\n    _defineProperty(this, \"faces\", void 0);\r\n\r\n    _defineProperty(this, \"neighbors\", void 0);\r\n\r\n    _defineProperty(this, \"collapseCost\", void 0);\r\n\r\n    _defineProperty(this, \"collapseNeighbor\", void 0);\r\n\r\n    _defineProperty(this, \"minCost\", 0);\r\n\r\n    _defineProperty(this, \"totalCost\", 0);\r\n\r\n    _defineProperty(this, \"costCount\", 0);\r\n\r\n    this.position = v;\r\n    this.id = id; // old index id\r\n\r\n    this.faces = []; // faces vertex is connected\r\n\r\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\r\n    // these will be computed in computeEdgeCostAtVertex()\r\n\r\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\r\n\r\n    this.collapseNeighbor = null; // best candinate for collapsing\r\n  }\r\n\r\n  addUniqueNeighbor(vertex) {\r\n    pushIfUnique(this.neighbors, vertex);\r\n  }\r\n\r\n  removeIfNonNeighbor(n) {\r\n    const neighbors = this.neighbors;\r\n    const faces = this.faces;\r\n    const offset = neighbors.indexOf(n);\r\n    if (offset === -1) return;\r\n\r\n    for (let i = 0; i < faces.length; i++) {\r\n      if (faces[i].hasVertex(n)) return;\r\n    }\r\n\r\n    neighbors.splice(offset, 1);\r\n  }\r\n\r\n} // we use a triangle class to represent structure of face slightly differently\r\n\r\n\r\nclass Triangle {\r\n  constructor(v1, v2, v3, a, b, c) {\r\n    _defineProperty(this, \"a\", void 0);\r\n\r\n    _defineProperty(this, \"b\", void 0);\r\n\r\n    _defineProperty(this, \"c\", void 0);\r\n\r\n    _defineProperty(this, \"v1\", void 0);\r\n\r\n    _defineProperty(this, \"v2\", void 0);\r\n\r\n    _defineProperty(this, \"v3\", void 0);\r\n\r\n    _defineProperty(this, \"normal\", new Vector3());\r\n\r\n    this.a = a;\r\n    this.b = b;\r\n    this.c = c;\r\n    this.v1 = v1;\r\n    this.v2 = v2;\r\n    this.v3 = v3;\r\n    this.computeNormal();\r\n    v1.faces.push(this);\r\n    v1.addUniqueNeighbor(v2);\r\n    v1.addUniqueNeighbor(v3);\r\n    v2.faces.push(this);\r\n    v2.addUniqueNeighbor(v1);\r\n    v2.addUniqueNeighbor(v3);\r\n    v3.faces.push(this);\r\n    v3.addUniqueNeighbor(v1);\r\n    v3.addUniqueNeighbor(v2);\r\n  }\r\n\r\n  computeNormal() {\r\n    const vA = this.v1.position;\r\n    const vB = this.v2.position;\r\n    const vC = this.v3.position;\r\n    cb.subVectors(vC, vB);\r\n    ab.subVectors(vA, vB);\r\n    cb.cross(ab).normalize();\r\n    this.normal.copy(cb);\r\n  }\r\n\r\n  hasVertex(v) {\r\n    return v === this.v1 || v === this.v2 || v === this.v3;\r\n  }\r\n\r\n  replaceVertex(oldv, newv) {\r\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\r\n    removeFromArray(oldv.faces, this);\r\n    newv.faces.push(this);\r\n    oldv.removeIfNonNeighbor(this.v1);\r\n    this.v1.removeIfNonNeighbor(oldv);\r\n    oldv.removeIfNonNeighbor(this.v2);\r\n    this.v2.removeIfNonNeighbor(oldv);\r\n    oldv.removeIfNonNeighbor(this.v3);\r\n    this.v3.removeIfNonNeighbor(oldv);\r\n    this.v1.addUniqueNeighbor(this.v2);\r\n    this.v1.addUniqueNeighbor(this.v3);\r\n    this.v2.addUniqueNeighbor(this.v1);\r\n    this.v2.addUniqueNeighbor(this.v3);\r\n    this.v3.addUniqueNeighbor(this.v1);\r\n    this.v3.addUniqueNeighbor(this.v2);\r\n    this.computeNormal();\r\n  }\r\n\r\n}\r\n/**\r\n *\tSimplification Geometry Modifier\r\n *    - based on code and technique\r\n *\t  - by Stan Melax in 1998\r\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\r\n *    - http://www.melax.com/polychop/\r\n */\r\n\r\n\r\nclass SimplifyModifier {\r\n  constructor() {\r\n    _defineProperty(this, \"computeEdgeCollapseCost\", (u, v) => {\r\n      // if we collapse edge uv by moving u to v then how\r\n      // much different will the model change, i.e. the \"error\".\r\n      const edgelength = v.position.distanceTo(u.position);\r\n      let curvature = 0;\r\n      const sideFaces = [];\r\n      let i,\r\n          il = u.faces.length,\r\n          face,\r\n          sideFace; // find the \"sides\" triangles that are on the edge uv\r\n\r\n      for (i = 0; i < il; i++) {\r\n        face = u.faces[i];\r\n\r\n        if (face.hasVertex(v)) {\r\n          sideFaces.push(face);\r\n        }\r\n      } // use the triangle facing most away from the sides\r\n      // to determine our curvature term\r\n\r\n\r\n      for (i = 0; i < il; i++) {\r\n        let minCurvature = 1;\r\n        face = u.faces[i];\r\n\r\n        for (let j = 0; j < sideFaces.length; j++) {\r\n          sideFace = sideFaces[j]; // use dot product of face normals.\r\n\r\n          const dotProd = face.normal.dot(sideFace.normal);\r\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\r\n        }\r\n\r\n        curvature = Math.max(curvature, minCurvature);\r\n      } // crude approach in attempt to preserve borders\r\n      // though it seems not to be totally correct\r\n\r\n\r\n      const borders = 0;\r\n\r\n      if (sideFaces.length < 2) {\r\n        // we add some arbitrary cost for borders,\r\n        // borders += 10;\r\n        curvature = 1;\r\n      }\r\n\r\n      const amt = edgelength * curvature + borders;\r\n      return amt;\r\n    });\r\n\r\n    _defineProperty(this, \"computeEdgeCostAtVertex\", v => {\r\n      // compute the edge collapse cost for all edges that start\r\n      // from vertex v.  Since we are only interested in reducing\r\n      // the object by selecting the min cost edge at each step, we\r\n      // only cache the cost of the least cost edge at this vertex\r\n      // (in member variable collapse) as well as the value of the\r\n      // cost (in member variable collapseCost).\r\n      if (v.neighbors.length === 0) {\r\n        // collapse if no neighbors.\r\n        v.collapseNeighbor = null;\r\n        v.collapseCost = -0.01;\r\n        return;\r\n      }\r\n\r\n      v.collapseCost = 100000;\r\n      v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\r\n\r\n      for (let i = 0; i < v.neighbors.length; i++) {\r\n        const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i]);\r\n\r\n        if (!v.collapseNeighbor) {\r\n          v.collapseNeighbor = v.neighbors[i];\r\n          v.collapseCost = collapseCost;\r\n          v.minCost = collapseCost;\r\n          v.totalCost = 0;\r\n          v.costCount = 0;\r\n        }\r\n\r\n        v.costCount++;\r\n        v.totalCost += collapseCost;\r\n\r\n        if (collapseCost < v.minCost) {\r\n          v.collapseNeighbor = v.neighbors[i];\r\n          v.minCost = collapseCost;\r\n        }\r\n      } // we average the cost of collapsing at this vertex\r\n\r\n\r\n      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\r\n    });\r\n\r\n    _defineProperty(this, \"removeFace\", (f, faces) => {\r\n      removeFromArray(faces, f);\r\n      if (f.v1) removeFromArray(f.v1.faces, f);\r\n      if (f.v2) removeFromArray(f.v2.faces, f);\r\n      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\r\n\r\n      const vs = [f.v1, f.v2, f.v3];\r\n      let v1, v2;\r\n\r\n      for (let i = 0; i < 3; i++) {\r\n        v1 = vs[i];\r\n        v2 = vs[(i + 1) % 3];\r\n        if (!v1 || !v2) continue;\r\n        v1.removeIfNonNeighbor(v2);\r\n        v2.removeIfNonNeighbor(v1);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"collapse\", (vertices, faces, u, v) => {\r\n      // u and v are pointers to vertices of an edge\r\n      // Collapse the edge uv by moving vertex u onto v\r\n      if (!v) {\r\n        // u is a vertex all by itself so just delete it..\r\n        this.removeVertex(u, vertices);\r\n        return;\r\n      }\r\n\r\n      let i;\r\n      const tmpVertices = [];\r\n\r\n      for (i = 0; i < u.neighbors.length; i++) {\r\n        tmpVertices.push(u.neighbors[i]);\r\n      } // delete triangles on edge uv:\r\n\r\n\r\n      for (i = u.faces.length - 1; i >= 0; i--) {\r\n        if (u.faces[i].hasVertex(v)) {\r\n          this.removeFace(u.faces[i], faces);\r\n        }\r\n      } // update remaining triangles to have v instead of u\r\n\r\n\r\n      for (i = u.faces.length - 1; i >= 0; i--) {\r\n        u.faces[i].replaceVertex(u, v);\r\n      }\r\n\r\n      this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\r\n\r\n      for (i = 0; i < tmpVertices.length; i++) {\r\n        this.computeEdgeCostAtVertex(tmpVertices[i]);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"minimumCostEdge\", vertices => {\r\n      // O(n * n) approach. TODO optimize this\r\n      let least = vertices[0];\r\n\r\n      for (let i = 0; i < vertices.length; i++) {\r\n        if (vertices[i].collapseCost < least.collapseCost) {\r\n          least = vertices[i];\r\n        }\r\n      }\r\n\r\n      return least;\r\n    });\r\n\r\n    _defineProperty(this, \"modify\", (geometry, count) => {\r\n      geometry = geometry.clone();\r\n      const attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\r\n\r\n      for (let name in attributes) {\r\n        if (name !== 'position') geometry.deleteAttribute(name);\r\n      }\r\n\r\n      geometry = mergeVertices(geometry); //\r\n      // put data of original geometry in different data structures\r\n      //\r\n\r\n      const vertices = [];\r\n      const faces = []; // add vertices\r\n\r\n      const positionAttribute = geometry.getAttribute('position');\r\n\r\n      for (let i = 0; i < positionAttribute.count; i++) {\r\n        const v = new Vector3().fromBufferAttribute(positionAttribute, i);\r\n        const vertex = new Vertex(v, i);\r\n        vertices.push(vertex);\r\n      } // add faces\r\n\r\n\r\n      const geomIndex = geometry.getIndex();\r\n\r\n      if (geomIndex !== null) {\r\n        for (let i = 0; i < geomIndex.count; i += 3) {\r\n          const a = geomIndex.getX(i);\r\n          const b = geomIndex.getX(i + 1);\r\n          const c = geomIndex.getX(i + 2);\r\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\r\n          faces.push(triangle);\r\n        }\r\n      } else {\r\n        for (let i = 0; i < positionAttribute.count; i += 3) {\r\n          const a = i;\r\n          const b = i + 1;\r\n          const c = i + 2;\r\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\r\n          faces.push(triangle);\r\n        }\r\n      } // compute all edge collapse costs\r\n\r\n\r\n      for (let i = 0, il = vertices.length; i < il; i++) {\r\n        this.computeEdgeCostAtVertex(vertices[i]);\r\n      }\r\n\r\n      let nextVertex;\r\n      let z = count;\r\n\r\n      while (z--) {\r\n        nextVertex = this.minimumCostEdge(vertices);\r\n\r\n        if (!nextVertex) {\r\n          console.log('THREE.SimplifyModifier: No next vertex');\r\n          break;\r\n        } else {\r\n          this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\r\n        }\r\n      } //\r\n\r\n\r\n      const simplifiedGeometry = new BufferGeometry();\r\n      const position = [];\r\n      let index = []; //\r\n\r\n      for (let i = 0; i < vertices.length; i++) {\r\n        const vertex = vertices[i].position;\r\n        position.push(vertex.x, vertex.y, vertex.z);\r\n      } //\r\n\r\n\r\n      for (let i = 0; i < faces.length; i++) {\r\n        const face = faces[i];\r\n        const a = vertices.indexOf(face.v1);\r\n        const b = vertices.indexOf(face.v2);\r\n        const c = vertices.indexOf(face.v3);\r\n        index.push(a, b, c);\r\n      } //\r\n\r\n\r\n      simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\r\n      simplifiedGeometry.setIndex(index);\r\n      return simplifiedGeometry;\r\n    });\r\n  }\r\n\r\n  removeVertex(v, vertices) {\r\n    console.assert(v.faces.length === 0);\r\n\r\n    while (v.neighbors.length) {\r\n      const n = v.neighbors.pop();\r\n      removeFromArray(n.neighbors, v);\r\n    }\r\n\r\n    removeFromArray(vertices, v);\r\n  }\r\n\r\n}\r\n\r\nexport { SimplifyModifier };\r\n", "const NodeShaderStage = {\r\n  Vertex: 'vertex',\r\n  Fragment: 'fragment'\r\n};\r\nconst NodeUpdateType = {\r\n  None: 'none',\r\n  Frame: 'frame',\r\n  Object: 'object'\r\n};\r\n\r\nexport { NodeShaderStage, NodeUpdateType };\r\n", "import { Color, Vector2, Vector3, Vector4, Matrix3, Matrix4 } from 'three';\r\n\r\nconst getNodesKeys = object => {\r\n  const props = [];\r\n\r\n  for (const name in object) {\r\n    const value = object[name];\r\n\r\n    if (value && value.isNode === true) {\r\n      props.push(name);\r\n    }\r\n  }\r\n\r\n  return props;\r\n};\r\nconst getValueType = value => {\r\n  if (typeof value === 'number') {\r\n    return 'float';\r\n  } else if (typeof value === 'boolean') {\r\n    return 'bool';\r\n  } else if ((value === null || value === void 0 ? void 0 : value.isVector2) === true) {\r\n    return 'vec2';\r\n  } else if ((value === null || value === void 0 ? void 0 : value.isVector3) === true) {\r\n    return 'vec3';\r\n  } else if ((value === null || value === void 0 ? void 0 : value.isVector4) === true) {\r\n    return 'vec4';\r\n  } else if ((value === null || value === void 0 ? void 0 : value.isMatrix3) === true) {\r\n    return 'mat3';\r\n  } else if ((value === null || value === void 0 ? void 0 : value.isMatrix4) === true) {\r\n    return 'mat4';\r\n  } else if ((value === null || value === void 0 ? void 0 : value.isColor) === true) {\r\n    return 'color';\r\n  }\r\n\r\n  return null;\r\n};\r\nconst getValueFromType = (type, ...params) => {\r\n  const last4 = type === null || type === void 0 ? void 0 : type.slice(-4);\r\n\r\n  if (type === 'color') {\r\n    return new Color(...params);\r\n  } else if (last4 === 'vec2') {\r\n    return new Vector2(...params);\r\n  } else if (last4 === 'vec3') {\r\n    return new Vector3(...params);\r\n  } else if (last4 === 'vec4') {\r\n    return new Vector4(...params);\r\n  } else if (last4 === 'mat3') {\r\n    return new Matrix3(...params);\r\n  } else if (last4 === 'mat4') {\r\n    return new Matrix4(...params);\r\n  } else if (type === 'bool') {\r\n    return false;\r\n  } else if (type === 'float' || type === 'int' || type === 'uint') {\r\n    return 0;\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nexport { getNodesKeys, getValueFromType, getValueType };\r\n", "import { NodeUpdateType } from './constants.js';\r\nimport { getNodesKeys } from './NodeUtils.js';\r\nimport { MathUtils } from 'three';\r\n\r\nlet _nodeId = 0;\r\n\r\nclass Node {\r\n  constructor(nodeType = null) {\r\n    this.nodeType = nodeType;\r\n    this.updateType = NodeUpdateType.None;\r\n    this.uuid = MathUtils.generateUUID();\r\n    Object.defineProperty(this, 'id', {\r\n      value: _nodeId++\r\n    });\r\n  }\r\n\r\n  get type() {\r\n    return this.constructor.name;\r\n  }\r\n\r\n  getHash() {\r\n    return this.uuid;\r\n  }\r\n\r\n  getUpdateType() {\r\n    return this.updateType;\r\n  }\r\n\r\n  getNodeType() {\r\n    return this.nodeType;\r\n  }\r\n\r\n  update() {\r\n    console.warn('Abstract function.');\r\n  }\r\n\r\n  generate() {\r\n    console.warn('Abstract function.');\r\n  }\r\n\r\n  analyze(builder) {\r\n    const hash = this.getHash(builder);\r\n    const sharedNode = builder.getNodeFromHash(hash);\r\n\r\n    if (sharedNode !== undefined && this !== sharedNode) {\r\n      return sharedNode.analyze(builder);\r\n    }\r\n\r\n    const nodeData = builder.getDataFromNode(this);\r\n    nodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\r\n    const nodeKeys = getNodesKeys(this);\r\n\r\n    for (const property of nodeKeys) {\r\n      this[property].analyze(builder);\r\n    }\r\n  }\r\n\r\n  build(builder, output = null) {\r\n    const hash = this.getHash(builder);\r\n    const sharedNode = builder.getNodeFromHash(hash);\r\n\r\n    if (sharedNode !== undefined && this !== sharedNode) {\r\n      return sharedNode.build(builder, output);\r\n    }\r\n\r\n    builder.addNode(this);\r\n    builder.addStack(this);\r\n    const nodeData = builder.getDataFromNode(this);\r\n    const isGenerateOnce = this.generate.length === 1;\r\n    let snippet = null;\r\n\r\n    if (isGenerateOnce) {\r\n      const type = this.getNodeType(builder);\r\n      snippet = nodeData.snippet;\r\n\r\n      if (snippet === undefined) {\r\n        snippet = this.generate(builder) || '';\r\n        nodeData.snippet = snippet;\r\n      }\r\n\r\n      snippet = builder.format(snippet, type, output);\r\n    } else {\r\n      snippet = this.generate(builder, output) || '';\r\n    }\r\n\r\n    builder.removeStack(this);\r\n    return snippet;\r\n  }\r\n\r\n  serialize(json) {\r\n    const nodeKeys = getNodesKeys(this);\r\n\r\n    if (nodeKeys.length > 0) {\r\n      const inputNodes = {};\r\n\r\n      for (const property of nodeKeys) {\r\n        inputNodes[property] = this[property].toJSON(json.meta).uuid;\r\n      }\r\n\r\n      json.inputNodes = inputNodes;\r\n    }\r\n  }\r\n\r\n  deserialize(json) {\r\n    if (json.inputNodes !== undefined) {\r\n      const nodes = json.meta.nodes;\r\n\r\n      for (const property in json.inputNodes) {\r\n        const uuid = json.inputNodes[property];\r\n        this[property] = nodes[uuid];\r\n      }\r\n    }\r\n  }\r\n\r\n  toJSON(meta) {\r\n    const {\r\n      uuid,\r\n      type\r\n    } = this;\r\n    const isRoot = meta === undefined || typeof meta === 'string';\r\n\r\n    if (isRoot) {\r\n      meta = {\r\n        textures: {},\r\n        images: {},\r\n        nodes: {}\r\n      };\r\n    } // serialize\r\n\r\n\r\n    let data = meta.nodes[uuid];\r\n\r\n    if (data === undefined) {\r\n      data = {\r\n        uuid,\r\n        type,\r\n        meta,\r\n        metadata: {\r\n          version: 4.5,\r\n          type: 'Node',\r\n          generator: 'Node.toJSON'\r\n        }\r\n      };\r\n      meta.nodes[data.uuid] = data;\r\n      this.serialize(data);\r\n      delete data.meta;\r\n    } // TODO: Copied from Object3D.toJSON\r\n\r\n\r\n    function extractFromCache(cache) {\r\n      const values = [];\r\n\r\n      for (const key in cache) {\r\n        const data = cache[key];\r\n        delete data.metadata;\r\n        values.push(data);\r\n      }\r\n\r\n      return values;\r\n    }\r\n\r\n    if (isRoot) {\r\n      const textures = extractFromCache(meta.textures);\r\n      const images = extractFromCache(meta.images);\r\n      const nodes = extractFromCache(meta.nodes);\r\n      if (textures.length > 0) data.textures = textures;\r\n      if (images.length > 0) data.images = images;\r\n      if (nodes.length > 0) data.nodes = nodes;\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n}\r\n\r\nNode.prototype.isNode = true;\r\n\r\nexport default Node;\r\n", "import Node from './Node.js';\r\nimport { getValueType, getValueFromType } from './NodeUtils.js';\r\n\r\nclass InputNode extends Node {\r\n  constructor(value, nodeType = null) {\r\n    super(nodeType);\r\n    this.value = value;\r\n  }\r\n\r\n  getNodeType() {\r\n    if (this.nodeType === null) {\r\n      return getValueType(this.value);\r\n    }\r\n\r\n    return this.nodeType;\r\n  }\r\n\r\n  getInputType(builder) {\r\n    return this.getNodeType(builder);\r\n  }\r\n\r\n  serialize(data) {\r\n    var _this$value, _this$value$toArray;\r\n\r\n    super.serialize(data);\r\n    data.value = ((_this$value = this.value) === null || _this$value === void 0 ? void 0 : (_this$value$toArray = _this$value.toArray) === null || _this$value$toArray === void 0 ? void 0 : _this$value$toArray.call(_this$value)) || this.value;\r\n    data.valueType = getValueType(this.value);\r\n    data.nodeType = this.nodeType;\r\n  }\r\n\r\n  deserialize(data) {\r\n    var _this$value2, _this$value2$fromArra;\r\n\r\n    super.deserialize(data);\r\n    this.nodeType = data.nodeType;\r\n    this.value = getValueFromType(data.valueType);\r\n    this.value = ((_this$value2 = this.value) === null || _this$value2 === void 0 ? void 0 : (_this$value2$fromArra = _this$value2.fromArray) === null || _this$value2$fromArra === void 0 ? void 0 : _this$value2$fromArra.call(_this$value2, data.value)) || data.value;\r\n  }\r\n\r\n  generate() {\r\n    console.warn('Abstract function.');\r\n  }\r\n\r\n}\r\n\r\nInputNode.prototype.isInputNode = true;\r\n\r\nexport default InputNode;\r\n", "import InputNode from './InputNode.js';\r\n\r\nclass UniformNode extends InputNode {\r\n  getUniformHash(builder) {\r\n    return this.getHash(builder);\r\n  }\r\n\r\n  generate(builder, output) {\r\n    const type = this.getNodeType(builder);\r\n    const hash = this.getUniformHash(builder);\r\n    let sharedNode = builder.getNodeFromHash(hash);\r\n\r\n    if (sharedNode === undefined) {\r\n      builder.setHashNode(this, hash);\r\n      sharedNode = this;\r\n    }\r\n\r\n    const sharedNodeType = sharedNode.getInputType(builder);\r\n    const nodeUniform = builder.getUniformFromNode(sharedNode, builder.shaderStage, sharedNodeType);\r\n    const propertyName = builder.getPropertyName(nodeUniform);\r\n    return builder.format(propertyName, type, output);\r\n  }\r\n\r\n}\r\n\r\nUniformNode.prototype.isUniformNode = true;\r\n\r\nexport default UniformNode;\r\n", "import UniformNode from './UniformNode.js';\r\n\r\nclass ArrayUniformNode extends UniformNode {\r\n  constructor(nodes = []) {\r\n    super();\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  getNodeType(builder) {\r\n    return this.nodes[0].getNodeType(builder);\r\n  }\r\n\r\n}\r\n\r\nArrayUniformNode.prototype.isArrayUniformNode = true;\r\n\r\nexport default ArrayUniformNode;\r\n", "import Node from './Node.js';\r\nimport { NodeShaderStage } from './constants.js';\r\n\r\nclass VaryNode extends Node {\r\n  constructor(node, name = null) {\r\n    super();\r\n    this.node = node;\r\n    this.name = name;\r\n  }\r\n\r\n  getHash(builder) {\r\n    return this.name || super.getHash(builder);\r\n  }\r\n\r\n  getNodeType(builder) {\r\n    // VaryNode is auto type\r\n    return this.node.getNodeType(builder);\r\n  }\r\n\r\n  generate(builder) {\r\n    const type = this.getNodeType(builder);\r\n    const node = this.node;\r\n    const name = this.name;\r\n    const nodeVary = builder.getVaryFromNode(this, type);\r\n\r\n    if (name !== null) {\r\n      nodeVary.name = name;\r\n    }\r\n\r\n    const propertyName = builder.getPropertyName(nodeVary, NodeShaderStage.Vertex); // force node run in vertex stage\r\n\r\n    builder.flowNodeFromShaderStage(NodeShaderStage.Vertex, node, type, propertyName);\r\n    return builder.getPropertyName(nodeVary);\r\n  }\r\n\r\n}\r\n\r\nexport default VaryNode;\r\n", "import Node from './Node.js';\r\nimport VaryNode from './VaryNode.js';\r\n\r\nclass AttributeNode extends Node {\r\n  constructor(attributeName, nodeType) {\r\n    super(nodeType);\r\n    this._attributeName = attributeName;\r\n  }\r\n\r\n  getHash(builder) {\r\n    return this.getAttributeName(builder);\r\n  }\r\n\r\n  setAttributeName(attributeName) {\r\n    this._attributeName = attributeName;\r\n    return this;\r\n  }\r\n\r\n  getAttributeName() {\r\n    return this._attributeName;\r\n  }\r\n\r\n  generate(builder) {\r\n    const attribute = builder.getAttribute(this.getAttributeName(builder), this.getNodeType(builder));\r\n\r\n    if (builder.isShaderStage('vertex')) {\r\n      return attribute.name;\r\n    } else {\r\n      const nodeVary = new VaryNode(this);\r\n      return nodeVary.build(builder, attribute.type);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default AttributeNode;\r\n", "import Node from './Node.js';\r\n\r\nclass BypassNode extends Node {\r\n  constructor(returnNode, callNode) {\r\n    super();\r\n    this.outputNode = returnNode;\r\n    this.callNode = callNode;\r\n  }\r\n\r\n  getNodeType(builder) {\r\n    return this.outputNode.getNodeType(builder);\r\n  }\r\n\r\n  generate(builder, output) {\r\n    const snippet = this.callNode.build(builder, 'void');\r\n\r\n    if (snippet !== '') {\r\n      builder.addFlowCode(snippet);\r\n    }\r\n\r\n    return this.outputNode.build(builder, output);\r\n  }\r\n\r\n}\r\n\r\nBypassNode.prototype.isBypassNode = true;\r\n\r\nexport default BypassNode;\r\n", "import Node from './Node.js';\r\n\r\nclass CodeNode extends Node {\r\n  constructor(code = '', nodeType = 'code') {\r\n    super(nodeType);\r\n    this.code = code;\r\n    this._includes = [];\r\n  }\r\n\r\n  setIncludes(includes) {\r\n    this._includes = includes;\r\n    return this;\r\n  }\r\n\r\n  getIncludes() {\r\n    return this._includes;\r\n  }\r\n\r\n  generate(builder) {\r\n    const includes = this.getIncludes(builder);\r\n\r\n    for (const include of includes) {\r\n      include.build(builder);\r\n    }\r\n\r\n    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));\r\n    nodeCode.code = this.code;\r\n    return nodeCode.code;\r\n  }\r\n\r\n}\r\n\r\nCodeNode.prototype.isCodeNode = true;\r\n\r\nexport default CodeNode;\r\n", "import InputNode from './InputNode.js';\r\n\r\nclass ConstNode extends InputNode {\r\n  generateConst(builder) {\r\n    return builder.getConst(this.getNodeType(builder), this.value);\r\n  }\r\n\r\n  generate(builder, output) {\r\n    const type = this.getNodeType(builder);\r\n    return builder.format(this.generateConst(builder), type, output);\r\n  }\r\n\r\n}\r\n\r\nConstNode.prototype.isConstNode = true;\r\n\r\nexport default ConstNode;\r\n", "import Node from './Node.js';\r\n\r\nclass ContextNode extends Node {\r\n  constructor(node, context = {}) {\r\n    super();\r\n    this.node = node;\r\n    this.context = context;\r\n  }\r\n\r\n  getNodeType(builder) {\r\n    return this.node.getNodeType(builder);\r\n  }\r\n\r\n  generate(builder, output) {\r\n    const previousContext = builder.getContext();\r\n    builder.setContext(Object.assign({}, builder.context, this.context));\r\n    const snippet = this.node.build(builder, output);\r\n    builder.setContext(previousContext);\r\n    return snippet;\r\n  }\r\n\r\n}\r\n\r\nContextNode.prototype.isContextNode = true;\r\n\r\nexport default ContextNode;\r\n", "import Node from './Node.js';\r\n\r\nclass TempNode extends Node {\r\n  constructor(type) {\r\n    super(type);\r\n  }\r\n\r\n  build(builder, output) {\r\n    const type = builder.getVectorType(this.getNodeType(builder, output));\r\n    const nodeData = builder.getDataFromNode(this);\r\n\r\n    if (builder.context.temp !== false && type !== 'void ' && output !== 'void' && nodeData.dependenciesCount > 1) {\r\n      if (nodeData.snippet === undefined) {\r\n        const snippet = super.build(builder, type);\r\n        const nodeVar = builder.getVarFromNode(this, type);\r\n        const propertyName = builder.getPropertyName(nodeVar);\r\n        builder.addFlowCode(`${propertyName} = ${snippet}`);\r\n        nodeData.snippet = snippet;\r\n        nodeData.propertyName = propertyName;\r\n      }\r\n\r\n      return builder.format(nodeData.propertyName, type, output);\r\n    }\r\n\r\n    return super.build(builder, output);\r\n  }\r\n\r\n}\r\n\r\nexport default TempNode;\r\n", "import TempNode from './TempNode.js';\r\n\r\nclass ExpressionNode extends TempNode {\r\n  constructor(snipped = '', nodeType = 'void') {\r\n    super(nodeType);\r\n    this.snipped = snipped;\r\n  }\r\n\r\n  generate(builder) {\r\n    const type = this.getNodeType(builder);\r\n    const snipped = this.snipped;\r\n\r\n    if (type === 'void') {\r\n      builder.addFlowCode(snipped);\r\n    } else {\r\n      return `( ${snipped} )`;\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default ExpressionNode;\r\n", "class NodeAttribute {\r\n  constructor(name, type) {\r\n    this.name = name;\r\n    this.type = type;\r\n  }\r\n\r\n}\r\n\r\nNodeAttribute.prototype.isNodeAttribute = true;\r\n\r\nexport default NodeAttribute;\r\n", "class NodeUniform {\r\n  constructor(name, type, node, needsUpdate = undefined) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.node = node;\r\n    this.needsUpdate = needsUpdate;\r\n  }\r\n\r\n  get value() {\r\n    return this.node.value;\r\n  }\r\n\r\n  set value(val) {\r\n    this.node.value = val;\r\n  }\r\n\r\n}\r\n\r\nNodeUniform.prototype.isNodeUniform = true;\r\n\r\nexport default NodeUniform;\r\n", "class NodeVary {\r\n  constructor(name, type) {\r\n    this.name = name;\r\n    this.type = type;\r\n  }\r\n\r\n}\r\n\r\nNodeVary.prototype.isNodeVary = true;\r\n\r\nexport default NodeVary;\r\n", "class NodeVar {\r\n  constructor(name, type) {\r\n    this.name = name;\r\n    this.type = type;\r\n  }\r\n\r\n}\r\n\r\nNodeVar.prototype.isNodeVar = true;\r\n\r\nexport default NodeVar;\r\n", "import NodeUniform from './NodeUniform.js';\r\nimport NodeAttribute from './NodeAttribute.js';\r\nimport NodeVary from './NodeVary.js';\r\nimport NodeVar from './NodeVar.js';\r\nimport NodeCode from './NodeCode.js';\r\nimport NodeKeywords from './NodeKeywords.js';\r\nimport { NodeUpdateType } from './constants.js';\r\nimport { REVISION, LinearEncoding } from 'three';\r\n\r\nconst shaderStages = ['fragment', 'vertex'];\r\nconst vector = ['x', 'y', 'z', 'w'];\r\n\r\nconst toFloat = value => {\r\n  value = Number(value);\r\n  return value + (value % 1 ? '' : '.0');\r\n};\r\n\r\nclass NodeBuilder {\r\n  constructor(object, renderer, parser) {\r\n    this.object = object;\r\n    this.material = object.material;\r\n    this.renderer = renderer;\r\n    this.parser = parser;\r\n    this.nodes = [];\r\n    this.updateNodes = [];\r\n    this.hashNodes = {};\r\n    this.vertexShader = null;\r\n    this.fragmentShader = null;\r\n    this.flowNodes = {\r\n      vertex: [],\r\n      fragment: []\r\n    };\r\n    this.flowCode = {\r\n      vertex: '',\r\n      fragment: ''\r\n    };\r\n    this.uniforms = {\r\n      vertex: [],\r\n      fragment: [],\r\n      index: 0\r\n    };\r\n    this.codes = {\r\n      vertex: [],\r\n      fragment: []\r\n    };\r\n    this.attributes = [];\r\n    this.varys = [];\r\n    this.vars = {\r\n      vertex: [],\r\n      fragment: []\r\n    };\r\n    this.flow = {\r\n      code: ''\r\n    };\r\n    this.stack = [];\r\n    this.context = {\r\n      keywords: new NodeKeywords(),\r\n      material: object.material\r\n    };\r\n    this.nodesData = new WeakMap();\r\n    this.flowsData = new WeakMap();\r\n    this.shaderStage = null;\r\n    this.node = null;\r\n  }\r\n\r\n  addStack(node) {\r\n    /*\r\n    if ( this.stack.indexOf( node ) !== - 1 ) {\r\n    console.warn( 'Recursive node: ', node );\r\n    }\r\n    */\r\n    this.stack.push(node);\r\n  }\r\n\r\n  removeStack(node) {\r\n    const lastStack = this.stack.pop();\r\n\r\n    if (lastStack !== node) {\r\n      throw new Error('NodeBuilder: Invalid node stack!');\r\n    }\r\n  }\r\n\r\n  setHashNode(node, hash) {\r\n    this.hashNodes[hash] = node;\r\n  }\r\n\r\n  addNode(node) {\r\n    if (this.nodes.indexOf(node) === -1) {\r\n      const updateType = node.getUpdateType(this);\r\n\r\n      if (updateType !== NodeUpdateType.None) {\r\n        this.updateNodes.push(node);\r\n      }\r\n\r\n      this.nodes.push(node);\r\n      this.setHashNode(node, node.getHash(this));\r\n    }\r\n  }\r\n\r\n  getMethod(method) {\r\n    return method;\r\n  }\r\n\r\n  getNodeFromHash(hash) {\r\n    return this.hashNodes[hash];\r\n  }\r\n\r\n  addFlow(shaderStage, node) {\r\n    this.flowNodes[shaderStage].push(node);\r\n    return node;\r\n  }\r\n\r\n  setContext(context) {\r\n    this.context = context;\r\n  }\r\n\r\n  getContext() {\r\n    return this.context;\r\n  }\r\n\r\n  getTexture() {\r\n    console.warn('Abstract function.');\r\n  }\r\n\r\n  getTextureBias() {\r\n    console.warn('Abstract function.');\r\n  }\r\n\r\n  getCubeTexture() {\r\n    console.warn('Abstract function.');\r\n  }\r\n\r\n  getCubeTextureBias() {\r\n    console.warn('Abstract function.');\r\n  } // @TODO: rename to .generateConst()\r\n\r\n\r\n  getConst(type, value) {\r\n    if (type === 'float') return toFloat(value);\r\n    if (type === 'int') return `${Math.round(value)}`;\r\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\r\n    if (type === 'bool') return value ? 'true' : 'false';\r\n\r\n    if (type === 'color') {\r\n      return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\r\n    }\r\n\r\n    const typeLength = this.getTypeLength(type);\r\n    const componentType = this.getComponentType(type);\r\n\r\n    const getConst = value => this.getConst(componentType, value);\r\n\r\n    if (typeLength === 2) {\r\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\r\n    } else if (typeLength === 3) {\r\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\r\n    } else if (typeLength === 4) {\r\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\r\n    }\r\n\r\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\r\n  }\r\n\r\n  getType(type) {\r\n    return type;\r\n  }\r\n\r\n  generateMethod(method) {\r\n    return method;\r\n  }\r\n\r\n  getAttribute(name, type) {\r\n    const attributes = this.attributes; // find attribute\r\n\r\n    for (const attribute of attributes) {\r\n      if (attribute.name === name) {\r\n        return attribute;\r\n      }\r\n    } // create a new if no exist\r\n\r\n\r\n    const attribute = new NodeAttribute(name, type);\r\n    attributes.push(attribute);\r\n    return attribute;\r\n  }\r\n\r\n  getPropertyName(node\r\n  /*, shaderStage*/\r\n  ) {\r\n    return node.name;\r\n  }\r\n\r\n  isVector(type) {\r\n    return /vec\\d/.test(type);\r\n  }\r\n\r\n  isMatrix(type) {\r\n    return /mat\\d/.test(type);\r\n  }\r\n\r\n  isReference(type) {\r\n    return type === 'void' || type === 'property' || type === 'sampler';\r\n  }\r\n\r\n  isShaderStage(shaderStage) {\r\n    return this.shaderStage === shaderStage;\r\n  }\r\n\r\n  getTextureEncodingFromMap(map) {\r\n    let encoding;\r\n\r\n    if (map && map.isTexture) {\r\n      encoding = map.encoding;\r\n    } else if (map && map.isWebGLRenderTarget) {\r\n      encoding = map.texture.encoding;\r\n    } else {\r\n      encoding = LinearEncoding;\r\n    }\r\n\r\n    return encoding;\r\n  }\r\n\r\n  getComponentType(type) {\r\n    type = this.getVectorType(type);\r\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\r\n    if (componentType === null) return null;\r\n    if (componentType[1] === 'b') return 'bool';\r\n    if (componentType[1] === 'i') return 'int';\r\n    if (componentType[1] === 'u') return 'uint';\r\n    return 'float';\r\n  }\r\n\r\n  getVectorType(type) {\r\n    if (type === 'color') return 'vec3';\r\n    if (type === 'texture') return 'vec4';\r\n    return type;\r\n  }\r\n\r\n  getTypeFromLength(type) {\r\n    if (type === 1) return 'float';\r\n    if (type === 2) return 'vec2';\r\n    if (type === 3) return 'vec3';\r\n    if (type === 4) return 'vec4';\r\n    return 0;\r\n  }\r\n\r\n  getTypeLength(type) {\r\n    const vecType = this.getVectorType(type);\r\n    const vecNum = /vec([2-4])/.exec(vecType);\r\n    if (vecNum !== null) return Number(vecNum[1]);\r\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\r\n    return 0;\r\n  }\r\n\r\n  getVectorFromMatrix(type) {\r\n    return type.replace('mat', 'vec');\r\n  }\r\n\r\n  getDataFromNode(node, shaderStage = this.shaderStage) {\r\n    let nodeData = this.nodesData.get(node);\r\n\r\n    if (nodeData === undefined) {\r\n      nodeData = {\r\n        vertex: {},\r\n        fragment: {}\r\n      };\r\n      this.nodesData.set(node, nodeData);\r\n    }\r\n\r\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\r\n  }\r\n\r\n  getUniformFromNode(node, shaderStage, type) {\r\n    const nodeData = this.getDataFromNode(node, shaderStage);\r\n    let nodeUniform = nodeData.uniform;\r\n\r\n    if (nodeUniform === undefined) {\r\n      const index = this.uniforms.index++;\r\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\r\n      this.uniforms[shaderStage].push(nodeUniform);\r\n      nodeData.uniform = nodeUniform;\r\n    }\r\n\r\n    return nodeUniform;\r\n  }\r\n\r\n  getVarFromNode(node, type, shaderStage = this.shaderStage) {\r\n    const nodeData = this.getDataFromNode(node, shaderStage);\r\n    let nodeVar = nodeData.variable;\r\n\r\n    if (nodeVar === undefined) {\r\n      const vars = this.vars[shaderStage];\r\n      const index = vars.length;\r\n      nodeVar = new NodeVar('nodeVar' + index, type);\r\n      vars.push(nodeVar);\r\n      nodeData.variable = nodeVar;\r\n    }\r\n\r\n    return nodeVar;\r\n  }\r\n\r\n  getVaryFromNode(node, type) {\r\n    const nodeData = this.getDataFromNode(node, null);\r\n    let nodeVary = nodeData.vary;\r\n\r\n    if (nodeVary === undefined) {\r\n      const varys = this.varys;\r\n      const index = varys.length;\r\n      nodeVary = new NodeVary('nodeVary' + index, type);\r\n      varys.push(nodeVary);\r\n      nodeData.vary = nodeVary;\r\n    }\r\n\r\n    return nodeVary;\r\n  }\r\n\r\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\r\n    const nodeData = this.getDataFromNode(node);\r\n    let nodeCode = nodeData.code;\r\n\r\n    if (nodeCode === undefined) {\r\n      const codes = this.codes[shaderStage];\r\n      const index = codes.length;\r\n      nodeCode = new NodeCode('nodeCode' + index, type);\r\n      codes.push(nodeCode);\r\n      nodeData.code = nodeCode;\r\n    }\r\n\r\n    return nodeCode;\r\n  }\r\n\r\n  addFlowCode(code) {\r\n    this.flow.code += code;\r\n  }\r\n\r\n  getFlowData(shaderStage, node) {\r\n    return this.flowsData.get(node);\r\n  }\r\n\r\n  flowNode(node) {\r\n    this.node = node;\r\n    const output = node.getNodeType(this);\r\n    const flowData = this.flowChildNode(node, output);\r\n    this.flowsData.set(node, flowData);\r\n    this.node = null;\r\n    return flowData;\r\n  }\r\n\r\n  flowChildNode(node, output = null) {\r\n    const previousFlow = this.flow;\r\n    const flow = {\r\n      code: ''\r\n    };\r\n    this.flow = flow;\r\n    flow.result = node.build(this, output);\r\n    this.flow = previousFlow;\r\n    return flow;\r\n  }\r\n\r\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\r\n    const previousShaderStage = this.shaderStage;\r\n    this.setShaderStage(shaderStage);\r\n    const flowData = this.flowChildNode(node, output);\r\n\r\n    if (propertyName !== null) {\r\n      flowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\r\n    }\r\n\r\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\r\n    this.setShaderStage(previousShaderStage);\r\n    return flowData;\r\n  }\r\n\r\n  getAttributes() {\r\n    console.warn('Abstract function.');\r\n  }\r\n\r\n  getVarys() {\r\n    console.warn('Abstract function.');\r\n  }\r\n\r\n  getVars(shaderStage) {\r\n    let snippet = '';\r\n    const vars = this.vars[shaderStage];\r\n\r\n    for (let index = 0; index < vars.length; index++) {\r\n      const variable = vars[index];\r\n      snippet += `${variable.type} ${variable.name}; `;\r\n    }\r\n\r\n    return snippet;\r\n  }\r\n\r\n  getUniforms() {\r\n    console.warn('Abstract function.');\r\n  }\r\n\r\n  getCodes(shaderStage) {\r\n    const codes = this.codes[shaderStage];\r\n    let code = '';\r\n\r\n    for (const nodeCode of codes) {\r\n      code += nodeCode.code + '\\n';\r\n    }\r\n\r\n    return code;\r\n  }\r\n\r\n  getHash() {\r\n    return this.vertexShader + this.fragmentShader;\r\n  }\r\n\r\n  getShaderStage() {\r\n    return this.shaderStage;\r\n  }\r\n\r\n  setShaderStage(shaderStage) {\r\n    this.shaderStage = shaderStage;\r\n  }\r\n\r\n  buildCode() {\r\n    console.warn('Abstract function.');\r\n  }\r\n\r\n  build() {\r\n    // stage 1: analyze nodes to possible optimization and validation\r\n    for (const shaderStage of shaderStages) {\r\n      this.setShaderStage(shaderStage);\r\n      const flowNodes = this.flowNodes[shaderStage];\r\n\r\n      for (const node of flowNodes) {\r\n        node.analyze(this);\r\n      }\r\n    } // stage 2: pre-build vertex code used in fragment shader\r\n\r\n\r\n    if (this.context.vertex && this.context.vertex.isNode) {\r\n      this.flowNodeFromShaderStage('vertex', this.context.vertex);\r\n    } // stage 3: generate shader\r\n\r\n\r\n    for (const shaderStage of shaderStages) {\r\n      this.setShaderStage(shaderStage);\r\n      const flowNodes = this.flowNodes[shaderStage];\r\n\r\n      for (const node of flowNodes) {\r\n        this.flowNode(node, shaderStage);\r\n      }\r\n    }\r\n\r\n    this.setShaderStage(null); // stage 4: build code for a specific output\r\n\r\n    this.buildCode();\r\n    return this;\r\n  }\r\n\r\n  format(snippet, fromType, toType) {\r\n    fromType = this.getVectorType(fromType);\r\n    toType = this.getVectorType(toType);\r\n\r\n    if (fromType === toType || toType === null || this.isReference(toType)) {\r\n      return snippet;\r\n    }\r\n\r\n    const fromTypeLength = this.getTypeLength(fromType);\r\n    const toTypeLength = this.getTypeLength(toType);\r\n\r\n    if (fromTypeLength === 0) {\r\n      // fromType is matrix-like\r\n      const vectorType = this.getVectorFromMatrix(fromType);\r\n      return this.format(`( ${snippet} * ${this.getType(vectorType)}( 1.0 ) )`, vectorType, toType);\r\n    }\r\n\r\n    if (toTypeLength === 0) {\r\n      // toType is matrix-like\r\n      // ignore for now\r\n      //return `${ this.getType( toType ) }( ${ snippet } )`;\r\n      return snippet;\r\n    }\r\n\r\n    if (fromTypeLength === toTypeLength) {\r\n      return `${this.getType(toType)}( ${snippet} )`;\r\n    }\r\n\r\n    if (fromTypeLength > toTypeLength) {\r\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);\r\n    }\r\n\r\n    if (toTypeLength === 4) {\r\n      // toType is vec4-like\r\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\r\n    }\r\n\r\n    if (fromTypeLength === 2) {\r\n      // fromType is vec2-like and toType is vec3-like\r\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\r\n    }\r\n\r\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\r\n  }\r\n\r\n  getSignature() {\r\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\r\n  }\r\n\r\n}\r\n\r\nexport default NodeBuilder;\r\nexport { shaderStages, vector };\r\n", "class NodeFunctionInput {\r\n  constructor(type, name, count = null, qualifier = '', isConst = false) {\r\n    this.type = type;\r\n    this.name = name;\r\n    this.count = count;\r\n    this.qualifier = qualifier;\r\n    this.isConst = isConst;\r\n  }\r\n\r\n}\r\n\r\nNodeFunctionInput.isNodeFunctionInput = true;\r\n\r\nexport default NodeFunctionInput;\r\n", "import Node from './Node.js';\r\n\r\nclass PropertyNode extends Node {\r\n  constructor(name = null, nodeType = 'vec4') {\r\n    super(nodeType);\r\n    this.name = name;\r\n  }\r\n\r\n  getHash(builder) {\r\n    return this.name || super.getHash(builder);\r\n  }\r\n\r\n  generate(builder) {\r\n    const nodeVary = builder.getVarFromNode(this, this.getNodeType(builder));\r\n    const name = this.name;\r\n\r\n    if (name !== null) {\r\n      nodeVary.name = name;\r\n    }\r\n\r\n    return builder.getPropertyName(nodeVary);\r\n  }\r\n\r\n}\r\n\r\nexport default PropertyNode;\r\n", "import Node from './Node.js';\r\n\r\nclass VarNode extends Node {\r\n  constructor(node, name = null, nodeType = null) {\r\n    super(nodeType);\r\n    this.node = node;\r\n    this.name = name;\r\n  }\r\n\r\n  getHash(builder) {\r\n    return this.name || super.getHash(builder);\r\n  }\r\n\r\n  getNodeType(builder) {\r\n    return super.getNodeType(builder) || this.node.getNodeType(builder);\r\n  }\r\n\r\n  generate(builder) {\r\n    const type = builder.getVectorType(this.getNodeType(builder));\r\n    const node = this.node;\r\n    const name = this.name;\r\n    const snippet = node.build(builder, type);\r\n    const nodeVar = builder.getVarFromNode(this, type);\r\n\r\n    if (name !== null) {\r\n      nodeVar.name = name;\r\n    }\r\n\r\n    const propertyName = builder.getPropertyName(nodeVar);\r\n    builder.addFlowCode(`${propertyName} = ${snippet}`);\r\n    return propertyName;\r\n  }\r\n\r\n}\r\n\r\nVarNode.prototype.isVarNode = true;\r\n\r\nexport default VarNode;\r\n", "import UniformNode from '../core/UniformNode.js';\r\n\r\nclass BufferNode extends UniformNode {\r\n  constructor(value, bufferType, bufferCount = 0) {\r\n    super(value, bufferType);\r\n    this.bufferType = bufferType;\r\n    this.bufferCount = bufferCount;\r\n  }\r\n\r\n  getInputType() {\r\n    return 'buffer';\r\n  }\r\n\r\n}\r\n\r\nBufferNode.prototype.isBufferNode = true;\r\n\r\nexport default BufferNode;\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { Vector3 } from 'three';\r\nimport Node from '../core/Node.js';\r\nimport UniformNode from '../core/UniformNode.js';\r\nimport { NodeUpdateType } from '../core/constants.js';\r\n\r\nclass Object3DNode extends Node {\r\n  constructor(scope = Object3DNode.VIEW_MATRIX, object3d = null) {\r\n    super();\r\n    this.scope = scope;\r\n    this.object3d = object3d;\r\n    this.updateType = NodeUpdateType.Object;\r\n    this._uniformNode = new UniformNode(null);\r\n  }\r\n\r\n  getNodeType() {\r\n    const scope = this.scope;\r\n\r\n    if (scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX) {\r\n      return 'mat4';\r\n    } else if (scope === Object3DNode.NORMAL_MATRIX) {\r\n      return 'mat3';\r\n    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION) {\r\n      return 'vec3';\r\n    }\r\n  }\r\n\r\n  update(frame) {\r\n    const object = this.object3d !== null ? this.object3d : frame.object;\r\n    const uniformNode = this._uniformNode;\r\n    const camera = frame.camera;\r\n    const scope = this.scope;\r\n\r\n    if (scope === Object3DNode.VIEW_MATRIX) {\r\n      uniformNode.value = object.modelViewMatrix;\r\n    } else if (scope === Object3DNode.NORMAL_MATRIX) {\r\n      uniformNode.value = object.normalMatrix;\r\n    } else if (scope === Object3DNode.WORLD_MATRIX) {\r\n      uniformNode.value = object.matrixWorld;\r\n    } else if (scope === Object3DNode.POSITION) {\r\n      uniformNode.value.setFromMatrixPosition(object.matrixWorld);\r\n    } else if (scope === Object3DNode.VIEW_POSITION) {\r\n      uniformNode.value.setFromMatrixPosition(object.matrixWorld);\r\n      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);\r\n    }\r\n  }\r\n\r\n  generate(builder) {\r\n    const scope = this.scope;\r\n\r\n    if (scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX) {\r\n      this._uniformNode.nodeType = 'mat4';\r\n    } else if (scope === Object3DNode.NORMAL_MATRIX) {\r\n      this._uniformNode.nodeType = 'mat3';\r\n    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION) {\r\n      this._uniformNode.nodeType = 'vec3';\r\n      this._uniformNode.value = new Vector3();\r\n    }\r\n\r\n    return this._uniformNode.build(builder);\r\n  }\r\n\r\n  serialize(data) {\r\n    super.serialize(data);\r\n    data.scope = this.scope;\r\n  }\r\n\r\n  deserialize(data) {\r\n    super.deserialize(data);\r\n    this.scope = data.scope;\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(Object3DNode, \"VIEW_MATRIX\", 'viewMatrix');\r\n\r\n_defineProperty(Object3DNode, \"NORMAL_MATRIX\", 'normalMatrix');\r\n\r\n_defineProperty(Object3DNode, \"WORLD_MATRIX\", 'worldMatrix');\r\n\r\n_defineProperty(Object3DNode, \"POSITION\", 'position');\r\n\r\n_defineProperty(Object3DNode, \"VIEW_POSITION\", 'viewPosition');\r\n\r\nexport default Object3DNode;\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport Object3DNode from './Object3DNode.js';\r\n\r\nclass CameraNode extends Object3DNode {\r\n  constructor(scope = CameraNode.POSITION) {\r\n    super(scope);\r\n  }\r\n\r\n  getNodeType(builder) {\r\n    const scope = this.scope;\r\n\r\n    if (scope === CameraNode.PROJECTION_MATRIX) {\r\n      return 'mat4';\r\n    }\r\n\r\n    return super.getNodeType(builder);\r\n  }\r\n\r\n  update(frame) {\r\n    const camera = frame.camera;\r\n    const uniformNode = this._uniformNode;\r\n    const scope = this.scope;\r\n\r\n    if (scope === CameraNode.PROJECTION_MATRIX) {\r\n      uniformNode.value = camera.projectionMatrix;\r\n    } else if (scope === CameraNode.VIEW_MATRIX) {\r\n      uniformNode.value = camera.matrixWorldInverse;\r\n    } else {\r\n      this.object3d = camera;\r\n      super.update(frame);\r\n    }\r\n  }\r\n\r\n  generate(builder) {\r\n    const scope = this.scope;\r\n\r\n    if (scope === CameraNode.PROJECTION_MATRIX) {\r\n      this._uniformNode.nodeType = 'mat4';\r\n    }\r\n\r\n    return super.generate(builder);\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(CameraNode, \"PROJECTION_MATRIX\", 'projectionMatrix');\r\n\r\nexport default CameraNode;\r\n", "import AttributeNode from '../core/AttributeNode.js';\r\n\r\nclass UVNode extends AttributeNode {\r\n  constructor(index = 0) {\r\n    super(null, 'vec2');\r\n    this.index = index;\r\n  }\r\n\r\n  getAttributeName() {\r\n    const index = this.index;\r\n    return 'uv' + (index > 0 ? index + 1 : '');\r\n  }\r\n\r\n  serialize(data) {\r\n    super.serialize(data);\r\n    data.index = this.index;\r\n  }\r\n\r\n  deserialize(data) {\r\n    super.deserialize(data);\r\n    this.index = data.index;\r\n  }\r\n\r\n}\r\n\r\nUVNode.prototype.isUVNode = true;\r\n\r\nexport default UVNode;\r\n", "import UniformNode from '../core/UniformNode.js';\r\nimport UVNode from './UVNode.js';\r\n\r\nclass TextureNode extends UniformNode {\r\n  constructor(value, uvNode = new UVNode(), biasNode = null) {\r\n    super(value, 'vec4');\r\n    this.uvNode = uvNode;\r\n    this.biasNode = biasNode;\r\n  }\r\n\r\n  getUniformHash() {\r\n    return this.value.uuid;\r\n  }\r\n\r\n  getInputType() {\r\n    return 'texture';\r\n  }\r\n\r\n  generate(builder, output) {\r\n    const texture = this.value;\r\n\r\n    if (!texture || texture.isTexture !== true) {\r\n      throw new Error('TextureNode: Need a three.js texture.');\r\n    }\r\n\r\n    const textureProperty = super.generate(builder, 'texture');\r\n\r\n    if (output === 'sampler') {\r\n      return textureProperty + '_sampler';\r\n    } else if (builder.isReference(output)) {\r\n      return textureProperty;\r\n    } else {\r\n      const nodeData = builder.getDataFromNode(this);\r\n      let snippet = nodeData.snippet;\r\n\r\n      if (snippet === undefined) {\r\n        const uvSnippet = this.uvNode.build(builder, 'vec2');\r\n        const biasNode = this.biasNode;\r\n\r\n        if (biasNode !== null) {\r\n          const biasSnippet = biasNode.build(builder, 'float');\r\n          snippet = builder.getTextureBias(textureProperty, uvSnippet, biasSnippet);\r\n        } else {\r\n          snippet = builder.getTexture(textureProperty, uvSnippet);\r\n        }\r\n\r\n        nodeData.snippet = snippet;\r\n      }\r\n\r\n      return builder.format(snippet, 'vec4', output);\r\n    }\r\n  }\r\n\r\n  serialize(data) {\r\n    super.serialize(data);\r\n    data.value = this.value.toJSON(data.meta).uuid;\r\n  }\r\n\r\n  deserialize(data) {\r\n    super.deserialize(data);\r\n    this.value = data.meta.textures[data.value];\r\n  }\r\n\r\n}\r\n\r\nTextureNode.prototype.isTextureNode = true;\r\n\r\nexport default TextureNode;\r\n", "import Object3DNode from './Object3DNode.js';\r\n\r\nclass ModelNode extends Object3DNode {\r\n  constructor(scope = ModelNode.VIEW_MATRIX) {\r\n    super(scope);\r\n  }\r\n\r\n}\r\n\r\nexport default ModelNode;\r\n", "import Node from '../core/Node.js';\r\n\r\nclass JoinNode extends Node {\r\n  constructor(nodes = []) {\r\n    super();\r\n    this.nodes = nodes;\r\n  }\r\n\r\n  getNodeType(builder) {\r\n    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));\r\n  }\r\n\r\n  generate(builder) {\r\n    const type = this.getNodeType(builder);\r\n    const nodes = this.nodes;\r\n    const snippetValues = [];\r\n\r\n    for (let i = 0; i < nodes.length; i++) {\r\n      const input = nodes[i];\r\n      const inputSnippet = input.build(builder);\r\n      snippetValues.push(inputSnippet);\r\n    }\r\n\r\n    return `${builder.getType(type)}( ${snippetValues.join(', ')} )`;\r\n  }\r\n\r\n}\r\n\r\nexport default JoinNode;\r\n", "import Node from '../core/Node.js';\r\nimport { vector } from '../core/NodeBuilder.js';\r\n\r\nclass SplitNode extends Node {\r\n  constructor(node, components = 'x') {\r\n    super();\r\n    this.node = node;\r\n    this.components = components;\r\n  }\r\n\r\n  getVectorLength() {\r\n    let vectorLength = this.components.length;\r\n\r\n    for (const c of this.components) {\r\n      vectorLength = Math.max(vector.indexOf(c) + 1, vectorLength);\r\n    }\r\n\r\n    return vectorLength;\r\n  }\r\n\r\n  getNodeType(builder) {\r\n    return builder.getTypeFromLength(this.components.length);\r\n  }\r\n\r\n  generate(builder) {\r\n    const node = this.node;\r\n    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));\r\n\r\n    if (nodeTypeLength > 1) {\r\n      let type = null;\r\n      const componentsLength = this.getVectorLength();\r\n\r\n      if (componentsLength >= nodeTypeLength) {\r\n        // need expand the input node\r\n        type = builder.getTypeFromLength(this.getVectorLength());\r\n      }\r\n\r\n      const nodeSnippet = node.build(builder, type);\r\n      return `${nodeSnippet}.${this.components}`;\r\n    } else {\r\n      // ignore components if node is a float\r\n      return node.build(builder);\r\n    }\r\n  }\r\n\r\n  serialize(data) {\r\n    super.serialize(data);\r\n    data.components = this.components;\r\n  }\r\n\r\n  deserialize(data) {\r\n    super.deserialize(data);\r\n    this.components = data.components;\r\n  }\r\n\r\n}\r\n\r\nexport default SplitNode;\r\n", "import TempNode from '../core/TempNode.js';\r\n\r\nclass OperatorNode extends TempNode {\r\n  constructor(op, aNode, bNode, ...params) {\r\n    super();\r\n    this.op = op;\r\n\r\n    if (params.length > 0) {\r\n      let finalBNode = bNode;\r\n\r\n      for (let i = 0; i < params.length; i++) {\r\n        finalBNode = new OperatorNode(op, finalBNode, params[i]);\r\n      }\r\n\r\n      bNode = finalBNode;\r\n    }\r\n\r\n    this.aNode = aNode;\r\n    this.bNode = bNode;\r\n  }\r\n\r\n  getNodeType(builder, output) {\r\n    const op = this.op;\r\n    const aNode = this.aNode;\r\n    const bNode = this.bNode;\r\n    const typeA = aNode.getNodeType(builder);\r\n    const typeB = bNode.getNodeType(builder);\r\n\r\n    if (typeA === 'void' || typeB === 'void') {\r\n      return 'void';\r\n    } else if (op === '=' || op === '%') {\r\n      return typeA;\r\n    } else if (op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<') {\r\n      return 'int';\r\n    } else if (op === '==' || op === '&&' || op === '||' || op === '^^') {\r\n      return 'bool';\r\n    } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\r\n      const typeLength = builder.getTypeLength(output);\r\n      return typeLength > 1 ? `bvec${typeLength}` : 'bool';\r\n    } else {\r\n      if (typeA === 'float' && builder.isMatrix(typeB)) {\r\n        return typeB;\r\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\r\n        // matrix x vector\r\n        return builder.getVectorFromMatrix(typeA);\r\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\r\n        // vector x matrix\r\n        return builder.getVectorFromMatrix(typeB);\r\n      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {\r\n        // anytype x anytype: use the greater length vector\r\n        return typeB;\r\n      }\r\n\r\n      return typeA;\r\n    }\r\n  }\r\n\r\n  generate(builder, output) {\r\n    const op = this.op;\r\n    const aNode = this.aNode;\r\n    const bNode = this.bNode;\r\n    const type = this.getNodeType(builder, output);\r\n    let typeA = null;\r\n    let typeB = null;\r\n\r\n    if (type !== 'void') {\r\n      typeA = aNode.getNodeType(builder);\r\n      typeB = bNode.getNodeType(builder);\r\n\r\n      if (op === '=') {\r\n        typeB = typeA;\r\n      } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {\r\n        if (builder.isVector(typeA)) {\r\n          typeB = typeA;\r\n        } else {\r\n          typeA = typeB = 'float';\r\n        }\r\n      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {\r\n        // matrix x vector\r\n        typeB = builder.getVectorFromMatrix(typeA);\r\n      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {\r\n        // vector x matrix\r\n        typeA = builder.getVectorFromMatrix(typeB);\r\n      } else {\r\n        // anytype x anytype\r\n        typeA = typeB = type;\r\n      }\r\n    } else {\r\n      typeA = typeB = type;\r\n    }\r\n\r\n    const a = aNode.build(builder, typeA);\r\n    const b = bNode.build(builder, typeB);\r\n    const outputLength = builder.getTypeLength(output);\r\n\r\n    if (output !== 'void') {\r\n      if (op === '=') {\r\n        builder.addFlowCode(`${a} ${this.op} ${b}`);\r\n        return a;\r\n      } else if (op === '>' && outputLength > 1) {\r\n        return builder.format(`${builder.getMethod('greaterThan')}( ${a}, ${b} )`, type, output);\r\n      } else if (op === '<=' && outputLength > 1) {\r\n        return builder.format(`${builder.getMethod('lessThanEqual')}( ${a}, ${b} )`, type, output);\r\n      } else {\r\n        return builder.format(`( ${a} ${this.op} ${b} )`, type, output);\r\n      }\r\n    } else if (typeA !== 'void') {\r\n      return builder.format(`${a} ${this.op} ${b}`, type, output);\r\n    }\r\n  }\r\n\r\n  serialize(data) {\r\n    super.serialize(data);\r\n    data.op = this.op;\r\n  }\r\n\r\n  deserialize(data) {\r\n    super.deserialize(data);\r\n    this.op = data.op;\r\n  }\r\n\r\n}\r\n\r\nexport default OperatorNode;\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport TempNode from '../core/TempNode.js';\r\nimport ExpressionNode from '../core/ExpressionNode.js';\r\nimport JoinNode from '../utils/JoinNode.js';\r\nimport SplitNode from '../utils/SplitNode.js';\r\nimport OperatorNode from './OperatorNode.js';\r\n\r\nclass MathNode extends TempNode {\r\n  // 1 input\r\n  // 2 inputs\r\n  // 3 inputs\r\n  constructor(method, aNode, bNode = null, cNode = null) {\r\n    super();\r\n    this.method = method;\r\n    this.aNode = aNode;\r\n    this.bNode = bNode;\r\n    this.cNode = cNode;\r\n  }\r\n\r\n  getInputType(builder) {\r\n    const aType = this.aNode.getNodeType(builder);\r\n    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;\r\n    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;\r\n    const aLen = builder.getTypeLength(aType);\r\n    const bLen = builder.getTypeLength(bType);\r\n    const cLen = builder.getTypeLength(cType);\r\n\r\n    if (aLen > bLen && aLen > cLen) {\r\n      return aType;\r\n    } else if (bLen > cLen) {\r\n      return bType;\r\n    } else if (cLen > aLen) {\r\n      return cType;\r\n    }\r\n\r\n    return aType;\r\n  }\r\n\r\n  getNodeType(builder) {\r\n    const method = this.method;\r\n\r\n    if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {\r\n      return 'float';\r\n    } else if (method === MathNode.CROSS) {\r\n      return 'vec3';\r\n    } else {\r\n      return this.getInputType(builder);\r\n    }\r\n  }\r\n\r\n  generate(builder, output) {\r\n    const method = this.method;\r\n    const type = this.getNodeType(builder);\r\n    const inputType = this.getInputType(builder);\r\n    const a = this.aNode;\r\n    const b = this.bNode;\r\n    const c = this.cNode;\r\n    const isWebGL = builder.renderer.isWebGLRenderer === true;\r\n\r\n    if (isWebGL && (method === MathNode.DFDX || method === MathNode.DFDY) && output === 'vec3') {\r\n      // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\r\n      return new JoinNode([new MathNode(method, new SplitNode(a, 'x')), new MathNode(method, new SplitNode(a, 'y')), new MathNode(method, new SplitNode(a, 'z'))]).build(builder);\r\n    } else if (method === MathNode.TRANSFORM_DIRECTION) {\r\n      // dir can be either a direction vector or a normal vector\r\n      // upper-left 3x3 of matrix is assumed to be orthogonal\r\n      let tA = a;\r\n      let tB = b;\r\n\r\n      if (builder.isMatrix(tA.getNodeType(builder))) {\r\n        tB = new ExpressionNode(`${builder.getType('vec4')}( ${tB.build(builder, 'vec3')}, 0.0 )`, 'vec4');\r\n      } else {\r\n        tA = new ExpressionNode(`${builder.getType('vec4')}( ${tA.build(builder, 'vec3')}, 0.0 )`, 'vec4');\r\n      }\r\n\r\n      const mulNode = new SplitNode(new OperatorNode('*', tA, tB), 'xyz');\r\n      return new MathNode(MathNode.NORMALIZE, mulNode).build(builder);\r\n    } else if (method === MathNode.SATURATE) {\r\n      return builder.format(`clamp( ${a.build(builder, inputType)}, 0.0, 1.0 )`, type, output);\r\n    } else if (method === MathNode.NEGATE) {\r\n      return builder.format('( -' + a.build(builder, inputType) + ' )', type, output);\r\n    } else if (method === MathNode.INVERT) {\r\n      return builder.format('( 1.0 - ' + a.build(builder, inputType) + ' )', type, output);\r\n    } else {\r\n      const params = [];\r\n\r\n      if (method === MathNode.CROSS) {\r\n        params.push(a.build(builder, type), b.build(builder, type));\r\n      } else if (method === MathNode.STEP) {\r\n        params.push(a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? 'float' : inputType), b.build(builder, inputType));\r\n      } else if (isWebGL && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {\r\n        params.push(a.build(builder, inputType), b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? 'float' : inputType));\r\n      } else if (method === MathNode.REFRACT) {\r\n        params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, 'float'));\r\n      } else if (method === MathNode.MIX) {\r\n        params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? 'float' : inputType));\r\n      } else {\r\n        params.push(a.build(builder, inputType));\r\n\r\n        if (c !== null) {\r\n          params.push(b.build(builder, inputType), c.build(builder, inputType));\r\n        } else if (b !== null) {\r\n          params.push(b.build(builder, inputType));\r\n        }\r\n      }\r\n\r\n      return builder.format(`${builder.getMethod(method)}( ${params.join(', ')} )`, type, output);\r\n    }\r\n  }\r\n\r\n  serialize(data) {\r\n    super.serialize(data);\r\n    data.method = this.method;\r\n  }\r\n\r\n  deserialize(data) {\r\n    super.deserialize(data);\r\n    this.method = data.method;\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(MathNode, \"RAD\", 'radians');\r\n\r\n_defineProperty(MathNode, \"DEG\", 'degrees');\r\n\r\n_defineProperty(MathNode, \"EXP\", 'exp');\r\n\r\n_defineProperty(MathNode, \"EXP2\", 'exp2');\r\n\r\n_defineProperty(MathNode, \"LOG\", 'log');\r\n\r\n_defineProperty(MathNode, \"LOG2\", 'log2');\r\n\r\n_defineProperty(MathNode, \"SQRT\", 'sqrt');\r\n\r\n_defineProperty(MathNode, \"INV_SQRT\", 'inversesqrt');\r\n\r\n_defineProperty(MathNode, \"FLOOR\", 'floor');\r\n\r\n_defineProperty(MathNode, \"CEIL\", 'ceil');\r\n\r\n_defineProperty(MathNode, \"NORMALIZE\", 'normalize');\r\n\r\n_defineProperty(MathNode, \"FRACT\", 'fract');\r\n\r\n_defineProperty(MathNode, \"SIN\", 'sin');\r\n\r\n_defineProperty(MathNode, \"COS\", 'cos');\r\n\r\n_defineProperty(MathNode, \"TAN\", 'tan');\r\n\r\n_defineProperty(MathNode, \"ASIN\", 'asin');\r\n\r\n_defineProperty(MathNode, \"ACOS\", 'acos');\r\n\r\n_defineProperty(MathNode, \"ATAN\", 'atan');\r\n\r\n_defineProperty(MathNode, \"ABS\", 'abs');\r\n\r\n_defineProperty(MathNode, \"SIGN\", 'sign');\r\n\r\n_defineProperty(MathNode, \"LENGTH\", 'length');\r\n\r\n_defineProperty(MathNode, \"NEGATE\", 'negate');\r\n\r\n_defineProperty(MathNode, \"INVERT\", 'invert');\r\n\r\n_defineProperty(MathNode, \"DFDX\", 'dFdx');\r\n\r\n_defineProperty(MathNode, \"DFDY\", 'dFdy');\r\n\r\n_defineProperty(MathNode, \"SATURATE\", 'saturate');\r\n\r\n_defineProperty(MathNode, \"ROUND\", 'round');\r\n\r\n_defineProperty(MathNode, \"MIN\", 'min');\r\n\r\n_defineProperty(MathNode, \"MAX\", 'max');\r\n\r\n_defineProperty(MathNode, \"MOD\", 'mod');\r\n\r\n_defineProperty(MathNode, \"STEP\", 'step');\r\n\r\n_defineProperty(MathNode, \"REFLECT\", 'reflect');\r\n\r\n_defineProperty(MathNode, \"DISTANCE\", 'distance');\r\n\r\n_defineProperty(MathNode, \"DOT\", 'dot');\r\n\r\n_defineProperty(MathNode, \"CROSS\", 'cross');\r\n\r\n_defineProperty(MathNode, \"POW\", 'pow');\r\n\r\n_defineProperty(MathNode, \"TRANSFORM_DIRECTION\", 'transformDirection');\r\n\r\n_defineProperty(MathNode, \"MIX\", 'mix');\r\n\r\n_defineProperty(MathNode, \"CLAMP\", 'clamp');\r\n\r\n_defineProperty(MathNode, \"REFRACT\", 'refract');\r\n\r\n_defineProperty(MathNode, \"SMOOTHSTEP\", 'smoothstep');\r\n\r\n_defineProperty(MathNode, \"FACEFORWARD\", 'faceforward');\r\n\r\nexport default MathNode;\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport Node from '../core/Node.js';\r\nimport AttributeNode from '../core/AttributeNode.js';\r\nimport VaryNode from '../core/VaryNode.js';\r\nimport ModelNode from './ModelNode.js';\r\nimport MathNode from '../math/MathNode.js';\r\nimport OperatorNode from '../math/OperatorNode.js';\r\n\r\nclass PositionNode extends Node {\r\n  constructor(scope = PositionNode.LOCAL) {\r\n    super('vec3');\r\n    this.scope = scope;\r\n  }\r\n\r\n  getHash() {\r\n    return `position-${this.scope}`;\r\n  }\r\n\r\n  generate(builder) {\r\n    const scope = this.scope;\r\n    let outputNode = null;\r\n\r\n    if (scope === PositionNode.GEOMETRY) {\r\n      outputNode = new AttributeNode('position', 'vec3');\r\n    } else if (scope === PositionNode.LOCAL) {\r\n      outputNode = new VaryNode(new PositionNode(PositionNode.GEOMETRY));\r\n    } else if (scope === PositionNode.WORLD) {\r\n      const vertexPositionNode = new MathNode(MathNode.TRANSFORM_DIRECTION, new ModelNode(ModelNode.WORLD_MATRIX), new PositionNode(PositionNode.LOCAL));\r\n      outputNode = new VaryNode(vertexPositionNode);\r\n    } else if (scope === PositionNode.VIEW) {\r\n      const vertexPositionNode = new OperatorNode('*', new ModelNode(ModelNode.VIEW_MATRIX), new PositionNode(PositionNode.LOCAL));\r\n      outputNode = new VaryNode(vertexPositionNode);\r\n    } else if (scope === PositionNode.VIEW_DIRECTION) {\r\n      const vertexPositionNode = new MathNode(MathNode.NEGATE, new PositionNode(PositionNode.VIEW));\r\n      outputNode = new MathNode(MathNode.NORMALIZE, new VaryNode(vertexPositionNode));\r\n    }\r\n\r\n    return outputNode.build(builder, this.getNodeType(builder));\r\n  }\r\n\r\n  serialize(data) {\r\n    super.serialize(data);\r\n    data.scope = this.scope;\r\n  }\r\n\r\n  deserialize(data) {\r\n    super.deserialize(data);\r\n    this.scope = data.scope;\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(PositionNode, \"GEOMETRY\", 'geometry');\r\n\r\n_defineProperty(PositionNode, \"LOCAL\", 'local');\r\n\r\n_defineProperty(PositionNode, \"WORLD\", 'world');\r\n\r\n_defineProperty(PositionNode, \"VIEW\", 'view');\r\n\r\n_defineProperty(PositionNode, \"VIEW_DIRECTION\", 'viewDirection');\r\n\r\nexport default PositionNode;\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport Node from '../core/Node.js';\r\nimport AttributeNode from '../core/AttributeNode.js';\r\nimport VaryNode from '../core/VaryNode.js';\r\nimport ModelNode from './ModelNode.js';\r\nimport CameraNode from './CameraNode.js';\r\nimport OperatorNode from '../math/OperatorNode.js';\r\nimport MathNode from '../math/MathNode.js';\r\n\r\nclass NormalNode extends Node {\r\n  constructor(scope = NormalNode.LOCAL) {\r\n    super('vec3');\r\n    this.scope = scope;\r\n  }\r\n\r\n  getHash() {\r\n    return `normal-${this.scope}`;\r\n  }\r\n\r\n  generate(builder) {\r\n    const scope = this.scope;\r\n    let outputNode = null;\r\n\r\n    if (scope === NormalNode.GEOMETRY) {\r\n      outputNode = new AttributeNode('normal', 'vec3');\r\n    } else if (scope === NormalNode.LOCAL) {\r\n      outputNode = new VaryNode(new NormalNode(NormalNode.GEOMETRY));\r\n    } else if (scope === NormalNode.VIEW) {\r\n      const vertexNormalNode = new OperatorNode('*', new ModelNode(ModelNode.NORMAL_MATRIX), new NormalNode(NormalNode.LOCAL));\r\n      outputNode = new MathNode(MathNode.NORMALIZE, new VaryNode(vertexNormalNode));\r\n    } else if (scope === NormalNode.WORLD) {\r\n      // To use INVERSE_TRANSFORM_DIRECTION only inverse the param order like this: MathNode( ..., Vector, Matrix );\r\n      const vertexNormalNode = new MathNode(MathNode.TRANSFORM_DIRECTION, new NormalNode(NormalNode.VIEW), new CameraNode(CameraNode.VIEW_MATRIX));\r\n      outputNode = new MathNode(MathNode.NORMALIZE, new VaryNode(vertexNormalNode));\r\n    }\r\n\r\n    return outputNode.build(builder);\r\n  }\r\n\r\n  serialize(data) {\r\n    super.serialize(data);\r\n    data.scope = this.scope;\r\n  }\r\n\r\n  deserialize(data) {\r\n    super.deserialize(data);\r\n    this.scope = data.scope;\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(NormalNode, \"GEOMETRY\", 'geometry');\r\n\r\n_defineProperty(NormalNode, \"LOCAL\", 'local');\r\n\r\n_defineProperty(NormalNode, \"WORLD\", 'world');\r\n\r\n_defineProperty(NormalNode, \"VIEW\", 'view');\r\n\r\nexport default NormalNode;\r\n", "import Node from '../core/Node.js';\r\nimport PropertyNode from '../core/PropertyNode.js';\r\nimport ContextNode from '../core/ContextNode.js';\r\n\r\nclass CondNode extends Node {\r\n  constructor(node, ifNode, elseNode) {\r\n    super();\r\n    this.node = node;\r\n    this.ifNode = ifNode;\r\n    this.elseNode = elseNode;\r\n  }\r\n\r\n  getNodeType(builder) {\r\n    const ifType = this.ifNode.getNodeType(builder);\r\n    const elseType = this.elseNode.getNodeType(builder);\r\n\r\n    if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {\r\n      return elseType;\r\n    }\r\n\r\n    return ifType;\r\n  }\r\n\r\n  generate(builder) {\r\n    const type = this.getNodeType(builder);\r\n    const context = {\r\n      temp: false\r\n    };\r\n    const nodeProperty = new PropertyNode(null, type).build(builder);\r\n    const nodeSnippet = new ContextNode(this.node\r\n    /*, context*/\r\n    ).build(builder, 'bool'),\r\n          ifSnippet = new ContextNode(this.ifNode, context).build(builder, type),\r\n          elseSnippet = new ContextNode(this.elseNode, context).build(builder, type);\r\n    builder.addFlowCode(`if ( ${nodeSnippet} ) {\r\n\r\n\\t\\t${nodeProperty} = ${ifSnippet};\r\n\r\n\\t} else {\r\n\r\n\\t\\t${nodeProperty} = ${elseSnippet};\r\n\r\n\\t}`);\r\n    return nodeProperty;\r\n  }\r\n\r\n}\r\n\r\nexport default CondNode;\r\n", "import Node from '../core/Node.js';\r\n\r\nclass ArrayElementNode extends Node {\r\n  constructor(node, indexNode) {\r\n    super();\r\n    this.node = node;\r\n    this.indexNode = indexNode;\r\n  }\r\n\r\n  getNodeType(builder) {\r\n    return this.node.getNodeType(builder);\r\n  }\r\n\r\n  generate(builder) {\r\n    const nodeSnippet = this.node.build(builder);\r\n    const indexSnippet = this.indexNode.build(builder, 'int');\r\n    return `${nodeSnippet}[ ${indexSnippet} ]`;\r\n  }\r\n\r\n}\r\n\r\nexport default ArrayElementNode;\r\n", "import Node from '../core/Node.js';\r\n\r\nclass ConvertNode extends Node {\r\n  constructor(node, convertTo) {\r\n    super();\r\n    this.node = node;\r\n    this.convertTo = convertTo;\r\n  }\r\n\r\n  getNodeType() {\r\n    return this.convertTo;\r\n  }\r\n\r\n  generate(builder) {\r\n    const convertTo = this.convertTo;\r\n    const node = this.node;\r\n\r\n    if (builder.isReference(convertTo) === false) {\r\n      const convertToSnippet = builder.getType(convertTo);\r\n      const nodeSnippet = node.build(builder, convertTo);\r\n      return `${builder.getVectorType(convertToSnippet)}( ${nodeSnippet} )`;\r\n    } else {\r\n      return node.build(builder, convertTo);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default ConvertNode;\r\n", "import PropertyNode from './core/PropertyNode.js';\r\nimport VarNode from './core/VarNode.js';\r\nimport AttributeNode from './core/AttributeNode.js';\r\nimport ConstNode from './core/ConstNode.js';\r\nimport UniformNode from './core/UniformNode.js';\r\nimport BufferNode from './accessors/BufferNode.js';\r\nimport PositionNode from './accessors/PositionNode.js';\r\nimport NormalNode from './accessors/NormalNode.js';\r\nimport CameraNode from './accessors/CameraNode.js';\r\nimport ModelNode from './accessors/ModelNode.js';\r\nimport TextureNode from './accessors/TextureNode.js';\r\nimport UVNode from './accessors/UVNode.js';\r\nimport OperatorNode from './math/OperatorNode.js';\r\nimport CondNode from './math/CondNode.js';\r\nimport MathNode from './math/MathNode.js';\r\nimport ArrayElementNode from './utils/ArrayElementNode.js';\r\nimport ConvertNode from './utils/ConvertNode.js';\r\nimport JoinNode from './utils/JoinNode.js';\r\nimport SplitNode from './utils/SplitNode.js';\r\nimport { getValueFromType } from './core/NodeUtils.js';\r\n\r\n// core nodes\r\nconst NodeHandler = {\r\n  construct(NodeClosure, params) {\r\n    const inputs = params.shift();\r\n    return NodeClosure(new ShaderNodeObjects(inputs), ...params);\r\n  },\r\n\r\n  get: function (node, prop) {\r\n    if (typeof prop === 'string' && node[prop] === undefined) {\r\n      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {\r\n        // accessing properties ( swizzle )\r\n        prop = prop.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');\r\n        return new ShaderNodeObject(new SplitNode(node, prop));\r\n      } else if (/^\\d+$/.test(prop) === true) {\r\n        // accessing array\r\n        return new ShaderNodeObject(new ArrayElementNode(node, uint(Number(prop))));\r\n      }\r\n    }\r\n\r\n    return node[prop];\r\n  }\r\n};\r\nconst nodeObjects = new WeakMap();\r\n\r\nconst ShaderNodeObject = function (obj) {\r\n  const type = typeof obj;\r\n\r\n  if (type === 'number' || type === 'boolean') {\r\n    return new ShaderNodeObject(getAutoTypedConstNode(obj));\r\n  } else if (type === 'object') {\r\n    if (obj.isNode === true) {\r\n      let nodeObject = nodeObjects.get(obj);\r\n\r\n      if (nodeObject === undefined) {\r\n        nodeObject = new Proxy(obj, NodeHandler);\r\n        nodeObjects.set(obj, nodeObject);\r\n        nodeObjects.set(nodeObject, nodeObject);\r\n      }\r\n\r\n      return nodeObject;\r\n    }\r\n  }\r\n\r\n  return obj;\r\n};\r\n\r\nconst ShaderNodeObjects = function (objects) {\r\n  for (const name in objects) {\r\n    objects[name] = new ShaderNodeObject(objects[name]);\r\n  }\r\n\r\n  return objects;\r\n};\r\n\r\nconst getShaderNodeArray = array => {\r\n  const len = array.length;\r\n\r\n  for (let i = 0; i < len; i++) {\r\n    array[i] = new ShaderNodeObject(array[i]);\r\n  }\r\n\r\n  return array;\r\n};\r\n\r\nconst ShaderNodeProxy = function (NodeClass, scope = null, factor = null) {\r\n  if (scope === null) {\r\n    return (...params) => {\r\n      return new ShaderNodeObject(new NodeClass(...getShaderNodeArray(params)));\r\n    };\r\n  } else if (factor === null) {\r\n    return (...params) => {\r\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params)));\r\n    };\r\n  } else {\r\n    factor = new ShaderNodeObject(factor);\r\n    return (...params) => {\r\n      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params), factor));\r\n    };\r\n  }\r\n};\r\n\r\nconst ShaderNodeScript = function (jsFunc) {\r\n  return (inputs, builder) => {\r\n    new ShaderNodeObjects(inputs);\r\n    return new ShaderNodeObject(jsFunc(inputs, builder));\r\n  };\r\n};\r\n\r\nconst bools = [false, true];\r\nconst uints = [0, 1, 2, 3];\r\nconst ints = [-1, -2];\r\nconst floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];\r\nconst boolsCacheMap = new Map();\r\n\r\nfor (let bool of bools) boolsCacheMap.set(bool, new ConstNode(bool));\r\n\r\nconst uintsCacheMap = new Map();\r\n\r\nfor (let uint of uints) uintsCacheMap.set(uint, new ConstNode(uint, 'uint'));\r\n\r\nconst intsCacheMap = new Map([...uintsCacheMap].map(el => new ConstNode(el.value, 'int')));\r\n\r\nfor (let int of ints) intsCacheMap.set(int, new ConstNode(int, 'int'));\r\n\r\nconst floatsCacheMap = new Map([...intsCacheMap].map(el => new ConstNode(el.value)));\r\n\r\nfor (let float of floats) floatsCacheMap.set(float, new ConstNode(float));\r\n\r\nfor (let float of floats) floatsCacheMap.set(-float, new ConstNode(-float));\r\n\r\nconst constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);\r\n\r\nconst getAutoTypedConstNode = value => {\r\n  if (constNodesCacheMap.has(value)) {\r\n    return constNodesCacheMap.get(value);\r\n  } else if (value.isNode === true) {\r\n    return value;\r\n  } else {\r\n    return new ConstNode(value);\r\n  }\r\n};\r\n\r\nconst ConvertType = function (type, cacheMap = null) {\r\n  return (...params) => {\r\n    if (params.length === 0) {\r\n      return nodeObject(new ConstNode(getValueFromType(type), type));\r\n    } else {\r\n      if (type === 'color' && params[0].isNode !== true) {\r\n        params = [getValueFromType(type, ...params)];\r\n      }\r\n\r\n      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {\r\n        return cacheMap.get(params[0]);\r\n      }\r\n\r\n      const nodes = params.map(getAutoTypedConstNode);\r\n      return nodeObject(new ConvertNode(nodes.length === 1 ? nodes[0] : new JoinNode(nodes), type));\r\n    }\r\n  };\r\n}; //\r\n// Node Material Shader Syntax\r\n//\r\n\r\n\r\nconst ShaderNode = new Proxy(ShaderNodeScript, NodeHandler);\r\nconst nodeObject = val => {\r\n  return new ShaderNodeObject(val);\r\n};\r\nconst uniform = value => {\r\n  var _value$node;\r\n\r\n  // TODO: get ConstNode from .traverse() in the future\r\n  value = value.isNode === true ? ((_value$node = value.node) === null || _value$node === void 0 ? void 0 : _value$node.value) || value.value : value;\r\n  return nodeObject(new UniformNode(value, value.nodeType));\r\n};\r\nconst label = (node, name) => {\r\n  node = nodeObject(node);\r\n\r\n  if (node.isVarNode === true) {\r\n    node.name = name;\r\n    return node;\r\n  }\r\n\r\n  return nodeObject(new VarNode(node, name));\r\n};\r\nconst temp = node => nodeObject(new VarNode(nodeObject(node)));\r\nconst color = new ConvertType('color');\r\nconst float = new ConvertType('float', floatsCacheMap);\r\nconst int = new ConvertType('int', intsCacheMap);\r\nconst uint = new ConvertType('uint', uintsCacheMap);\r\nconst bool = new ConvertType('bool', boolsCacheMap);\r\nconst vec2 = new ConvertType('vec2');\r\nconst ivec2 = new ConvertType('ivec2');\r\nconst uvec2 = new ConvertType('uvec2');\r\nconst bvec2 = new ConvertType('bvec2');\r\nconst vec3 = new ConvertType('vec3');\r\nconst ivec3 = new ConvertType('ivec3');\r\nconst uvec3 = new ConvertType('uvec3');\r\nconst bvec3 = new ConvertType('bvec3');\r\nconst vec4 = new ConvertType('vec4');\r\nconst ivec4 = new ConvertType('ivec4');\r\nconst uvec4 = new ConvertType('uvec4');\r\nconst bvec4 = new ConvertType('bvec4');\r\nconst mat3 = new ConvertType('mat3');\r\nconst imat3 = new ConvertType('imat3');\r\nconst umat3 = new ConvertType('umat3');\r\nconst bmat3 = new ConvertType('bmat3');\r\nconst mat4 = new ConvertType('mat4');\r\nconst imat4 = new ConvertType('imat4');\r\nconst umat4 = new ConvertType('umat4');\r\nconst bmat4 = new ConvertType('bmat4');\r\nconst join = (...params) => nodeObject(new JoinNode(getShaderNodeArray(params)));\r\nconst uv = (...params) => nodeObject(new UVNode(...params));\r\nconst attribute = (...params) => nodeObject(new AttributeNode(...params));\r\nconst buffer = (...params) => nodeObject(new BufferNode(...params));\r\nconst texture = (...params) => nodeObject(new TextureNode(...params));\r\nconst sampler = texture => nodeObject(new ConvertNode(texture.isNode === true ? texture : new TextureNode(texture), 'sampler'));\r\nconst cond = (...params) => nodeObject(new CondNode(...getShaderNodeArray(params)));\r\nconst addTo = (varNode, ...params) => {\r\n  varNode.node = add(varNode.node, ...getShaderNodeArray(params));\r\n  return nodeObject(varNode);\r\n};\r\nconst add = new ShaderNodeProxy(OperatorNode, '+');\r\nconst sub = new ShaderNodeProxy(OperatorNode, '-');\r\nconst mul = new ShaderNodeProxy(OperatorNode, '*');\r\nconst div = new ShaderNodeProxy(OperatorNode, '/');\r\nconst remainder = new ShaderNodeProxy(OperatorNode, '%');\r\nconst equal = new ShaderNodeProxy(OperatorNode, '==');\r\nconst assign = new ShaderNodeProxy(OperatorNode, '=');\r\nconst lessThan = new ShaderNodeProxy(OperatorNode, '<');\r\nconst greaterThan = new ShaderNodeProxy(OperatorNode, '>');\r\nconst lessThanEqual = new ShaderNodeProxy(OperatorNode, '<=');\r\nconst greaterThanEqual = new ShaderNodeProxy(OperatorNode, '>=');\r\nconst and = new ShaderNodeProxy(OperatorNode, '&&');\r\nconst or = new ShaderNodeProxy(OperatorNode, '||');\r\nconst xor = new ShaderNodeProxy(OperatorNode, '^^');\r\nconst bitAnd = new ShaderNodeProxy(OperatorNode, '&');\r\nconst bitOr = new ShaderNodeProxy(OperatorNode, '|');\r\nconst bitXor = new ShaderNodeProxy(OperatorNode, '^');\r\nconst shiftLeft = new ShaderNodeProxy(OperatorNode, '<<');\r\nconst shiftRight = new ShaderNodeProxy(OperatorNode, '>>');\r\nconst element = new ShaderNodeProxy(ArrayElementNode);\r\nconst normalGeometry = new ShaderNodeObject(new NormalNode(NormalNode.GEOMETRY));\r\nconst normalLocal = new ShaderNodeObject(new NormalNode(NormalNode.LOCAL));\r\nconst normalWorld = new ShaderNodeObject(new NormalNode(NormalNode.WORLD));\r\nconst normalView = new ShaderNodeObject(new NormalNode(NormalNode.VIEW));\r\nconst transformedNormalView = new ShaderNodeObject(new VarNode(new NormalNode(NormalNode.VIEW), 'TransformedNormalView', 'vec3'));\r\nconst positionLocal = new ShaderNodeObject(new PositionNode(PositionNode.LOCAL));\r\nconst positionWorld = new ShaderNodeObject(new PositionNode(PositionNode.WORLD));\r\nconst positionView = new ShaderNodeObject(new PositionNode(PositionNode.VIEW));\r\nconst positionViewDirection = new ShaderNodeObject(new PositionNode(PositionNode.VIEW_DIRECTION));\r\nconst viewMatrix = new ShaderNodeObject(new ModelNode(ModelNode.VIEW_MATRIX));\r\nconst cameraPosition = new ShaderNodeObject(new CameraNode(CameraNode.POSITION));\r\nconst diffuseColor = new ShaderNodeObject(new PropertyNode('DiffuseColor', 'vec4'));\r\nconst roughness = new ShaderNodeObject(new PropertyNode('Roughness', 'float'));\r\nconst metalness = new ShaderNodeObject(new PropertyNode('Metalness', 'float'));\r\nconst alphaTest = new ShaderNodeObject(new PropertyNode('AlphaTest', 'float'));\r\nconst specularColor = new ShaderNodeObject(new PropertyNode('SpecularColor', 'color'));\r\nconst abs = new ShaderNodeProxy(MathNode, 'abs');\r\nconst acos = new ShaderNodeProxy(MathNode, 'acos');\r\nconst asin = new ShaderNodeProxy(MathNode, 'asin');\r\nconst atan = new ShaderNodeProxy(MathNode, 'atan');\r\nconst ceil = new ShaderNodeProxy(MathNode, 'ceil');\r\nconst clamp = new ShaderNodeProxy(MathNode, 'clamp');\r\nconst cos = new ShaderNodeProxy(MathNode, 'cos');\r\nconst cross = new ShaderNodeProxy(MathNode, 'cross');\r\nconst degrees = new ShaderNodeProxy(MathNode, 'degrees');\r\nconst dFdx = new ShaderNodeProxy(MathNode, 'dFdx');\r\nconst dFdy = new ShaderNodeProxy(MathNode, 'dFdy');\r\nconst distance = new ShaderNodeProxy(MathNode, 'distance');\r\nconst dot = new ShaderNodeProxy(MathNode, 'dot');\r\nconst exp = new ShaderNodeProxy(MathNode, 'exp');\r\nconst exp2 = new ShaderNodeProxy(MathNode, 'exp2');\r\nconst faceforward = new ShaderNodeProxy(MathNode, 'faceforward');\r\nconst floor = new ShaderNodeProxy(MathNode, 'floor');\r\nconst fract = new ShaderNodeProxy(MathNode, 'fract');\r\nconst invert = new ShaderNodeProxy(MathNode, 'invert');\r\nconst inversesqrt = new ShaderNodeProxy(MathNode, 'inversesqrt');\r\nconst length = new ShaderNodeProxy(MathNode, 'length');\r\nconst log = new ShaderNodeProxy(MathNode, 'log');\r\nconst log2 = new ShaderNodeProxy(MathNode, 'log2');\r\nconst max = new ShaderNodeProxy(MathNode, 'max');\r\nconst min = new ShaderNodeProxy(MathNode, 'min');\r\nconst mix = new ShaderNodeProxy(MathNode, 'mix');\r\nconst mod = new ShaderNodeProxy(MathNode, 'mod');\r\nconst negate = new ShaderNodeProxy(MathNode, 'negate');\r\nconst normalize = new ShaderNodeProxy(MathNode, 'normalize');\r\nconst pow = new ShaderNodeProxy(MathNode, 'pow');\r\nconst pow2 = new ShaderNodeProxy(MathNode, 'pow', 2);\r\nconst pow3 = new ShaderNodeProxy(MathNode, 'pow', 3);\r\nconst pow4 = new ShaderNodeProxy(MathNode, 'pow', 4);\r\nconst radians = new ShaderNodeProxy(MathNode, 'radians');\r\nconst reflect = new ShaderNodeProxy(MathNode, 'reflect');\r\nconst refract = new ShaderNodeProxy(MathNode, 'refract');\r\nconst round = new ShaderNodeProxy(MathNode, 'round');\r\nconst saturate = new ShaderNodeProxy(MathNode, 'saturate');\r\nconst sign = new ShaderNodeProxy(MathNode, 'sign');\r\nconst sin = new ShaderNodeProxy(MathNode, 'sin');\r\nconst smoothstep = new ShaderNodeProxy(MathNode, 'smoothstep');\r\nconst sqrt = new ShaderNodeProxy(MathNode, 'sqrt');\r\nconst step = new ShaderNodeProxy(MathNode, 'step');\r\nconst tan = new ShaderNodeProxy(MathNode, 'tan');\r\nconst transformDirection = new ShaderNodeProxy(MathNode, 'transformDirection');\r\nconst EPSILON = float(1e-6);\r\nconst INFINITY = float(1e6);\r\n\r\nexport { EPSILON, INFINITY, ShaderNode, abs, acos, add, addTo, alphaTest, and, asin, assign, atan, attribute, bitAnd, bitOr, bitXor, bmat3, bmat4, bool, buffer, bvec2, bvec3, bvec4, cameraPosition, ceil, clamp, color, cond, cos, cross, dFdx, dFdy, degrees, diffuseColor, distance, div, dot, element, equal, exp, exp2, faceforward, float, floor, fract, greaterThan, greaterThanEqual, imat3, imat4, int, inversesqrt, invert, ivec2, ivec3, ivec4, join, label, length, lessThan, lessThanEqual, log, log2, mat3, mat4, max, metalness, min, mix, mod, mul, negate, nodeObject, normalGeometry, normalLocal, normalView, normalWorld, normalize, or, positionLocal, positionView, positionViewDirection, positionWorld, pow, pow2, pow3, pow4, radians, reflect, refract, remainder, roughness, round, sampler, saturate, shiftLeft, shiftRight, sign, sin, smoothstep, specularColor, sqrt, step, sub, tan, temp, texture, transformDirection, transformedNormalView, uint, umat3, umat4, uniform, uv, uvec2, uvec3, uvec4, vec2, vec3, vec4, viewMatrix, xor };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport Node from '../core/Node.js';\r\nimport { normalize, sub, positionWorld, cameraPosition, reflect, normalWorld, nodeObject, join, negate } from '../ShaderNode.js';\r\n\r\nclass ReflectNode extends Node {\r\n  constructor(scope = ReflectNode.CUBE) {\r\n    super('vec3');\r\n    this.scope = scope;\r\n  }\r\n\r\n  getHash() {\r\n    return `reflect-${this.scope}`;\r\n  }\r\n\r\n  generate(builder) {\r\n    const scope = this.scope;\r\n\r\n    if (scope === ReflectNode.VECTOR) {\r\n      const cameraToFrag = normalize(sub(positionWorld, cameraPosition));\r\n      const reflectVec = reflect(cameraToFrag, normalWorld);\r\n      return reflectVec.build(builder);\r\n    } else if (scope === ReflectNode.CUBE) {\r\n      const reflectVec = nodeObject(new ReflectNode(ReflectNode.VECTOR));\r\n      const cubeUV = join(negate(reflectVec.x), reflectVec.yz);\r\n      return cubeUV.build(builder);\r\n    }\r\n  }\r\n\r\n  serialize(data) {\r\n    super.serialize(data);\r\n    data.scope = this.scope;\r\n  }\r\n\r\n  deserialize(data) {\r\n    super.deserialize(data);\r\n    this.scope = data.scope;\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(ReflectNode, \"VECTOR\", 'vector');\r\n\r\n_defineProperty(ReflectNode, \"CUBE\", 'cube');\r\n\r\nexport default ReflectNode;\r\n", "import TextureNode from './TextureNode.js';\r\nimport UniformNode from '../core/UniformNode.js';\r\nimport ReflectNode from './ReflectNode.js';\r\n\r\nclass CubeTextureNode extends TextureNode {\r\n  constructor(value, uvNode = new ReflectNode(), biasNode = null) {\r\n    super(value, uvNode, biasNode);\r\n  }\r\n\r\n  getInputType() {\r\n    return 'cubeTexture';\r\n  }\r\n\r\n  generate(builder, output) {\r\n    const texture = this.value;\r\n\r\n    if (!texture || texture.isCubeTexture !== true) {\r\n      throw new Error('CubeTextureNode: Need a three.js cube texture.');\r\n    }\r\n\r\n    const textureProperty = UniformNode.prototype.generate.call(this, builder, 'cubeTexture');\r\n\r\n    if (output === 'sampler') {\r\n      return textureProperty + '_sampler';\r\n    } else if (builder.isReference(output)) {\r\n      return textureProperty;\r\n    } else {\r\n      const nodeData = builder.getDataFromNode(this);\r\n      let snippet = nodeData.snippet;\r\n\r\n      if (snippet === undefined) {\r\n        const uvSnippet = this.uvNode.build(builder, 'vec3');\r\n        const biasNode = this.biasNode;\r\n\r\n        if (biasNode !== null) {\r\n          const biasSnippet = biasNode.build(builder, 'float');\r\n          snippet = builder.getCubeTextureBias(textureProperty, uvSnippet, biasSnippet);\r\n        } else {\r\n          snippet = builder.getCubeTexture(textureProperty, uvSnippet);\r\n        }\r\n\r\n        nodeData.snippet = snippet;\r\n      }\r\n\r\n      return builder.format(snippet, 'vec4', output);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nCubeTextureNode.prototype.isCubeTextureNode = true;\r\n\r\nexport default CubeTextureNode;\r\n", "import Node from '../core/Node.js';\r\nimport UniformNode from '../core/UniformNode.js';\r\nimport { NodeUpdateType } from '../core/constants.js';\r\n\r\nclass ReferenceNode extends Node {\r\n  constructor(property, uniformType, object = null) {\r\n    super();\r\n    this.property = property;\r\n    this.uniformType = uniformType;\r\n    this.object = object;\r\n    this.node = null;\r\n    this.updateType = NodeUpdateType.Object;\r\n    this.setNodeType(uniformType);\r\n  }\r\n\r\n  setNodeType(uniformType) {\r\n    this.node = new UniformNode(null, uniformType);\r\n    this.nodeType = uniformType;\r\n\r\n    if (uniformType === 'color') {\r\n      this.nodeType = 'vec3';\r\n    } else if (uniformType === 'texture') {\r\n      this.nodeType = 'vec4';\r\n    }\r\n  }\r\n\r\n  getNodeType() {\r\n    return this.uniformType;\r\n  }\r\n\r\n  update(frame) {\r\n    const object = this.object !== null ? this.object : frame.object;\r\n    const value = object[this.property];\r\n    this.node.value = value;\r\n  }\r\n\r\n  generate(builder) {\r\n    return this.node.build(builder, this.getNodeType(builder));\r\n  }\r\n\r\n}\r\n\r\nexport default ReferenceNode;\r\n", "import ReferenceNode from './ReferenceNode.js';\r\n\r\nclass MaterialReferenceNode extends ReferenceNode {\r\n  constructor(property, inputType, material = null) {\r\n    super(property, inputType, material);\r\n    this.material = material;\r\n  }\r\n\r\n  update(frame) {\r\n    this.object = this.material !== null ? this.material : frame.material;\r\n    super.update(frame);\r\n  }\r\n\r\n}\r\n\r\nexport default MaterialReferenceNode;\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport Node from '../core/Node.js';\r\nimport OperatorNode from '../math/OperatorNode.js';\r\nimport MaterialReferenceNode from './MaterialReferenceNode.js';\r\n\r\nclass MaterialNode extends Node {\r\n  constructor(scope = MaterialNode.COLOR) {\r\n    super();\r\n    this.scope = scope;\r\n  }\r\n\r\n  getNodeType(builder) {\r\n    const scope = this.scope;\r\n    const material = builder.context.material;\r\n\r\n    if (scope === MaterialNode.COLOR) {\r\n      return material.map !== null ? 'vec4' : 'vec3';\r\n    } else if (scope === MaterialNode.OPACITY) {\r\n      return 'float';\r\n    } else if (scope === MaterialNode.SPECULAR) {\r\n      return 'vec3';\r\n    } else if (scope === MaterialNode.ROUGHNESS || scope === MaterialNode.METALNESS) {\r\n      return 'float';\r\n    }\r\n  }\r\n\r\n  generate(builder, output) {\r\n    const material = builder.context.material;\r\n    const scope = this.scope;\r\n    let node = null;\r\n\r\n    if (scope === MaterialNode.ALPHA_TEST) {\r\n      node = new MaterialReferenceNode('alphaTest', 'float');\r\n    } else if (scope === MaterialNode.COLOR) {\r\n      const colorNode = new MaterialReferenceNode('color', 'color');\r\n\r\n      if (material.map !== null && material.map !== undefined && material.map.isTexture === true) {\r\n        node = new OperatorNode('*', colorNode, new MaterialReferenceNode('map', 'texture'));\r\n      } else {\r\n        node = colorNode;\r\n      }\r\n    } else if (scope === MaterialNode.OPACITY) {\r\n      const opacityNode = new MaterialReferenceNode('opacity', 'float');\r\n\r\n      if (material.alphaMap !== null && material.alphaMap !== undefined && material.alphaMap.isTexture === true) {\r\n        node = new OperatorNode('*', opacityNode, new MaterialReferenceNode('alphaMap', 'texture'));\r\n      } else {\r\n        node = opacityNode;\r\n      }\r\n    } else if (scope === MaterialNode.SPECULAR) {\r\n      const specularColorNode = new MaterialReferenceNode('specularColor', 'color');\r\n\r\n      if (material.specularColorMap !== null && material.specularColorMap !== undefined && material.specularColorMap.isTexture === true) {\r\n        node = new OperatorNode('*', specularColorNode, new MaterialReferenceNode('specularColorMap', 'texture'));\r\n      } else {\r\n        node = specularColorNode;\r\n      }\r\n    } else {\r\n      const outputType = this.getNodeType(builder);\r\n      node = new MaterialReferenceNode(scope, outputType);\r\n    }\r\n\r\n    return node.build(builder, output);\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(MaterialNode, \"ALPHA_TEST\", 'alphaTest');\r\n\r\n_defineProperty(MaterialNode, \"COLOR\", 'color');\r\n\r\n_defineProperty(MaterialNode, \"OPACITY\", 'opacity');\r\n\r\n_defineProperty(MaterialNode, \"SPECULAR\", 'specular');\r\n\r\n_defineProperty(MaterialNode, \"ROUGHNESS\", 'roughness');\r\n\r\n_defineProperty(MaterialNode, \"METALNESS\", 'metalness');\r\n\r\nexport default MaterialNode;\r\n", "import Node from '../core/Node.js';\r\n\r\nclass PointUVNode extends Node {\r\n  constructor() {\r\n    super('vec2');\r\n  }\r\n\r\n  generate() {\r\n    return 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';\r\n  }\r\n\r\n}\r\n\r\nPointUVNode.prototype.isPointUVNode = true;\r\n\r\nexport default PointUVNode;\r\n", "import Node from '../core/Node.js';\r\nimport { ShaderNode, element, mul, positionLocal, add, transformDirection, normalLocal, assign, attribute, uniform, mat4, buffer } from '../ShaderNode.js';\r\nimport { NodeUpdateType } from '../core/constants.js';\r\n\r\nconst Skinning = new ShaderNode((inputs, builder) => {\r\n  const {\r\n    index,\r\n    weight,\r\n    bindMatrix,\r\n    bindMatrixInverse,\r\n    boneMatrices\r\n  } = inputs;\r\n  const boneMatX = element(boneMatrices, index.x);\r\n  const boneMatY = element(boneMatrices, index.y);\r\n  const boneMatZ = element(boneMatrices, index.z);\r\n  const boneMatW = element(boneMatrices, index.w); // POSITION\r\n\r\n  const skinVertex = mul(bindMatrix, positionLocal);\r\n  const skinned = add(mul(mul(boneMatX, skinVertex), weight.x), mul(mul(boneMatY, skinVertex), weight.y), mul(mul(boneMatZ, skinVertex), weight.z), mul(mul(boneMatW, skinVertex), weight.w));\r\n  const skinPosition = mul(bindMatrixInverse, skinned).xyz; // NORMAL\r\n\r\n  let skinMatrix = add(mul(weight.x, boneMatX), mul(weight.y, boneMatY), mul(weight.z, boneMatZ), mul(weight.w, boneMatW));\r\n  skinMatrix = mul(mul(bindMatrixInverse, skinMatrix), bindMatrix);\r\n  const skinNormal = transformDirection(skinMatrix, normalLocal).xyz; // ASSIGNS\r\n\r\n  assign(positionLocal, skinPosition).build(builder);\r\n  assign(normalLocal, skinNormal).build(builder);\r\n});\r\n\r\nclass SkinningNode extends Node {\r\n  constructor(skinnedMesh) {\r\n    super('void');\r\n    this.skinnedMesh = skinnedMesh;\r\n    this.updateType = NodeUpdateType.Object; //\r\n\r\n    this.skinIndexNode = attribute('skinIndex', 'uvec4');\r\n    this.skinWeightNode = attribute('skinWeight', 'vec4');\r\n    this.bindMatrixNode = uniform(mat4(skinnedMesh.bindMatrix));\r\n    this.bindMatrixInverseNode = uniform(mat4(skinnedMesh.bindMatrixInverse));\r\n    this.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length);\r\n  }\r\n\r\n  generate(builder) {\r\n    Skinning({\r\n      index: this.skinIndexNode,\r\n      weight: this.skinWeightNode,\r\n      bindMatrix: this.bindMatrixNode,\r\n      bindMatrixInverse: this.bindMatrixInverseNode,\r\n      boneMatrices: this.boneMatricesNode\r\n    }, builder);\r\n  }\r\n\r\n  update() {\r\n    this.skinnedMesh.skeleton.update();\r\n  }\r\n\r\n}\r\n\r\nexport default SkinningNode;\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport Node from '../core/Node.js';\r\nimport { ShaderNode, sub, mul, pow, vec3, lessThanEqual, mix, join } from '../ShaderNode.js';\r\nimport { LinearEncoding, sRGBEncoding } from 'three';\r\n\r\nconst LinearToLinear = new ShaderNode(inputs => {\r\n  return inputs.value;\r\n});\r\nconst LinearTosRGB = new ShaderNode(inputs => {\r\n  const {\r\n    value\r\n  } = inputs;\r\n  const rgb = value.rgb;\r\n  const a = sub(mul(pow(value.rgb, vec3(0.41666)), 1.055), vec3(0.055));\r\n  const b = mul(rgb, 12.92);\r\n  const factor = vec3(lessThanEqual(rgb, vec3(0.0031308)));\r\n  const rgbResult = mix(a, b, factor);\r\n  return join(rgbResult.r, rgbResult.g, rgbResult.b, value.a);\r\n});\r\nconst EncodingLib = {\r\n  LinearToLinear,\r\n  LinearTosRGB\r\n};\r\n\r\nclass ColorSpaceNode extends Node {\r\n  constructor(method, node) {\r\n    super('vec4');\r\n    this.method = method;\r\n    this.node = node;\r\n  }\r\n\r\n  fromEncoding(encoding) {\r\n    let method = null;\r\n\r\n    if (encoding === LinearEncoding) {\r\n      method = 'Linear';\r\n    } else if (encoding === sRGBEncoding) {\r\n      method = 'sRGB';\r\n    }\r\n\r\n    this.method = 'LinearTo' + method;\r\n    return this;\r\n  }\r\n\r\n  generate(builder) {\r\n    const type = this.getNodeType(builder);\r\n    const method = this.method;\r\n    const node = this.node;\r\n\r\n    if (method !== ColorSpaceNode.LINEAR_TO_LINEAR) {\r\n      const encodingFunctionNode = EncodingLib[method];\r\n      return encodingFunctionNode({\r\n        value: node\r\n      }).build(builder, type);\r\n    } else {\r\n      return node.build(builder, type);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(ColorSpaceNode, \"LINEAR_TO_LINEAR\", 'LinearToLinear');\r\n\r\n_defineProperty(ColorSpaceNode, \"LINEAR_TO_SRGB\", 'LinearTosRGB');\r\n\r\nexport default ColorSpaceNode;\r\nexport { LinearToLinear, LinearTosRGB };\r\n", "import TempNode from '../core/TempNode.js';\r\nimport ModelNode from '../accessors/ModelNode.js';\r\nimport { ShaderNode, dFdx, dFdy, cross, add, mul, max, dot, cond, inversesqrt, equal, normalize, sub, join, positionView, normalView, uv } from '../ShaderNode.js';\r\nimport { TangentSpaceNormalMap, ObjectSpaceNormalMap } from 'three';\r\n\r\n// http://www.thetenthplanet.de/archives/1180\r\n\r\nconst perturbNormal2ArbNode = new ShaderNode(inputs => {\r\n  const {\r\n    eye_pos,\r\n    surf_norm,\r\n    mapN,\r\n    faceDirection,\r\n    uv\r\n  } = inputs;\r\n  const q0 = dFdx(eye_pos.xyz);\r\n  const q1 = dFdy(eye_pos.xyz);\r\n  const st0 = dFdx(uv.st);\r\n  const st1 = dFdy(uv.st);\r\n  const N = surf_norm; // normalized\r\n\r\n  const q1perp = cross(q1, N);\r\n  const q0perp = cross(N, q0);\r\n  const T = add(mul(q1perp, st0.x), mul(q0perp, st1.x));\r\n  const B = add(mul(q1perp, st0.y), mul(q0perp, st1.y));\r\n  const det = max(dot(T, T), dot(B, B));\r\n  const scale = cond(equal(det, 0), 0, mul(faceDirection, inversesqrt(det)));\r\n  return normalize(add(mul(T, mul(mapN.x, scale)), mul(B, mul(mapN.y, scale)), mul(N, mapN.z)));\r\n});\r\n\r\nclass NormalMapNode extends TempNode {\r\n  constructor(node, scaleNode = null) {\r\n    super('vec3');\r\n    this.node = node;\r\n    this.scaleNode = scaleNode;\r\n    this.normalMapType = TangentSpaceNormalMap;\r\n  }\r\n\r\n  generate(builder) {\r\n    const type = this.getNodeType(builder);\r\n    const {\r\n      normalMapType,\r\n      scaleNode\r\n    } = this;\r\n    const normalOP = mul(this.node, 2.0);\r\n    let normalMap = sub(normalOP, 1.0);\r\n\r\n    if (scaleNode !== null) {\r\n      const normalMapScale = mul(normalMap.xy, scaleNode);\r\n      normalMap = join(normalMapScale, normalMap.z);\r\n    }\r\n\r\n    if (normalMapType === ObjectSpaceNormalMap) {\r\n      const vertexNormalNode = mul(new ModelNode(ModelNode.NORMAL_MATRIX), normalMap);\r\n      const normal = normalize(vertexNormalNode);\r\n      return normal.build(builder, type);\r\n    } else if (normalMapType === TangentSpaceNormalMap) {\r\n      const perturbNormal2ArbCall = perturbNormal2ArbNode({\r\n        eye_pos: positionView,\r\n        surf_norm: normalView,\r\n        mapN: normalMap,\r\n        faceDirection: 1.0,\r\n        uv: uv()\r\n      });\r\n      return perturbNormal2ArbCall.build(builder, type);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default NormalMapNode;\r\n", "import { ShaderNode, exp2, mul, sub, add, cond, pow, saturate, div, negate, and, greaterThan, pow2, sqrt, max, EPSILON, normalize, positionViewDirection, dot, transformedNormalView, addTo, diffuseColor, specularColor, roughness } from '../ShaderNode.js';\r\n\r\nconst F_Schlick = new ShaderNode(inputs => {\r\n  const {\r\n    f0,\r\n    f90,\r\n    dotVH\r\n  } = inputs; // Original approximation by Christophe Schlick '94\r\n  // float fresnel = pow( 1.0 - dotVH, 5.0 );\r\n  // Optimized variant (presented by Epic at SIGGRAPH '13)\r\n  // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\r\n\r\n  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));\r\n  return add(mul(f0, sub(1.0, fresnel)), mul(f90, fresnel));\r\n}); // validated\r\n\r\nconst BRDF_Lambert = new ShaderNode(inputs => {\r\n  return mul(1 / Math.PI, inputs.diffuseColor); // punctual light\r\n}); // validated\r\n\r\nconst getDistanceAttenuation = new ShaderNode(inputs => {\r\n  const {\r\n    lightDistance,\r\n    cutoffDistance,\r\n    decayExponent\r\n  } = inputs;\r\n  return cond(and(greaterThan(cutoffDistance, 0), greaterThan(decayExponent, 0)), pow(saturate(add(div(negate(lightDistance), cutoffDistance), 1.0)), decayExponent), 1.0);\r\n}); // validated\r\n//\r\n// STANDARD\r\n//\r\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\r\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n\r\nconst V_GGX_SmithCorrelated = new ShaderNode(inputs => {\r\n  const {\r\n    alpha,\r\n    dotNL,\r\n    dotNV\r\n  } = inputs;\r\n  const a2 = pow2(alpha);\r\n  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNV)))));\r\n  const gl = mul(dotNV, sqrt(add(a2, mul(sub(1.0, a2), pow2(dotNL)))));\r\n  return div(0.5, max(add(gv, gl), EPSILON));\r\n}); // validated\r\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\r\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\r\n// alpha is \"roughness squared\" in Disney’s reparameterization\r\n\r\nconst D_GGX = new ShaderNode(inputs => {\r\n  const {\r\n    alpha,\r\n    dotNH\r\n  } = inputs;\r\n  const a2 = pow2(alpha);\r\n  const denom = add(mul(pow2(dotNH), sub(a2, 1.0)), 1.0); // avoid alpha = 0 with dotNH = 1\r\n\r\n  return mul(1 / Math.PI, div(a2, pow2(denom)));\r\n}); // validated\r\n// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility\r\n\r\nconst BRDF_GGX = new ShaderNode(inputs => {\r\n  const {\r\n    lightDirection,\r\n    f0,\r\n    f90,\r\n    roughness\r\n  } = inputs;\r\n  const alpha = pow2(roughness); // UE4's roughness\r\n\r\n  const halfDir = normalize(add(lightDirection, positionViewDirection));\r\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\r\n  const dotNV = saturate(dot(transformedNormalView, positionViewDirection));\r\n  const dotNH = saturate(dot(transformedNormalView, halfDir));\r\n  const dotVH = saturate(dot(positionViewDirection, halfDir));\r\n  const F = F_Schlick({\r\n    f0,\r\n    f90,\r\n    dotVH\r\n  });\r\n  const V = V_GGX_SmithCorrelated({\r\n    alpha,\r\n    dotNL,\r\n    dotNV\r\n  });\r\n  const D = D_GGX({\r\n    alpha,\r\n    dotNH\r\n  });\r\n  return mul(F, mul(V, D));\r\n}); // validated\r\n\r\nconst RE_Direct_Physical = new ShaderNode(inputs => {\r\n  const {\r\n    lightDirection,\r\n    lightColor,\r\n    directDiffuse,\r\n    directSpecular\r\n  } = inputs;\r\n  const dotNL = saturate(dot(transformedNormalView, lightDirection));\r\n  let irradiance = mul(dotNL, lightColor);\r\n  irradiance = mul(irradiance, Math.PI); // punctual light\r\n\r\n  addTo(directDiffuse, mul(irradiance, BRDF_Lambert({\r\n    diffuseColor: diffuseColor.rgb\r\n  })));\r\n  addTo(directSpecular, mul(irradiance, BRDF_GGX({\r\n    lightDirection,\r\n    f0: specularColor,\r\n    f90: 1,\r\n    roughness\r\n  })));\r\n});\r\nconst PhysicalLightingModel = new ShaderNode((inputs\r\n/*, builder*/\r\n) => {\r\n  // PHYSICALLY_CORRECT_LIGHTS <-> builder.renderer.physicallyCorrectLights === true\r\n  RE_Direct_Physical(inputs);\r\n});\r\n\r\nexport { BRDF_GGX, BRDF_Lambert, D_GGX, F_Schlick, PhysicalLightingModel, RE_Direct_Physical, V_GGX_SmithCorrelated, getDistanceAttenuation };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport UniformNode from '../core/UniformNode.js';\r\nimport { NodeUpdateType } from '../core/constants.js';\r\n\r\nclass TimerNode extends UniformNode {\r\n  constructor(scope = TimerNode.LOCAL) {\r\n    super(0);\r\n    this.scope = scope;\r\n    this.scale = 1;\r\n    this.updateType = NodeUpdateType.Frame;\r\n  }\r\n\r\n  update(frame) {\r\n    const scope = this.scope;\r\n    const scale = this.scale;\r\n\r\n    if (scope === TimerNode.LOCAL) {\r\n      this.value += frame.deltaTime * scale;\r\n    } else if (scope === TimerNode.DELTA) {\r\n      this.value = frame.deltaTime * scale;\r\n    } else {\r\n      // global\r\n      this.value = frame.time * scale;\r\n    }\r\n  }\r\n\r\n  serialize(data) {\r\n    super.serialize(data);\r\n    data.scope = this.scope;\r\n    data.scale = this.scale;\r\n  }\r\n\r\n  deserialize(data) {\r\n    super.deserialize(data);\r\n    this.scope = data.scope;\r\n    this.scale = data.scale;\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(TimerNode, \"LOCAL\", 'local');\r\n\r\n_defineProperty(TimerNode, \"GLOBAL\", 'global');\r\n\r\n_defineProperty(TimerNode, \"DELTA\", 'delta');\r\n\r\nexport default TimerNode;\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport Node from '../core/Node.js';\r\nimport TimerNode from './TimerNode.js';\r\nimport { add, mul, sin, round, fract, abs, sub } from '../ShaderNode.js';\r\n\r\nclass OscNode extends Node {\r\n  constructor(method = OscNode.SINE, timeNode = new TimerNode()) {\r\n    super();\r\n    this.method = method;\r\n    this.timeNode = timeNode;\r\n  }\r\n\r\n  getNodeType(builder) {\r\n    return this.timeNode.getNodeType(builder);\r\n  }\r\n\r\n  generate(builder) {\r\n    const method = this.method;\r\n    const timeNode = this.timeNode;\r\n    let outputNode = null;\r\n\r\n    if (method === OscNode.SINE) {\r\n      outputNode = add(mul(sin(mul(add(timeNode, 0.75), Math.PI * 2)), 0.5), 0.5);\r\n    } else if (method === OscNode.SQUARE) {\r\n      outputNode = round(fract(timeNode));\r\n    } else if (method === OscNode.TRIANGLE) {\r\n      outputNode = abs(sub(1, mul(fract(add(timeNode, 0.5)), 2)));\r\n    } else if (method === OscNode.SAWTOOTH) {\r\n      outputNode = fract(timeNode);\r\n    }\r\n\r\n    return outputNode.build(builder);\r\n  }\r\n\r\n  serialize(data) {\r\n    super.serialize(data);\r\n    data.method = this.method;\r\n  }\r\n\r\n  deserialize(data) {\r\n    super.deserialize(data);\r\n    this.method = data.method;\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(OscNode, \"SINE\", 'sine');\r\n\r\n_defineProperty(OscNode, \"SQUARE\", 'square');\r\n\r\n_defineProperty(OscNode, \"TRIANGLE\", 'triangle');\r\n\r\n_defineProperty(OscNode, \"SAWTOOTH\", 'sawtooth');\r\n\r\nexport default OscNode;\r\n", "import Node from '../core/Node.js';\r\nimport { ShaderNode, mul, floor, mod, add, sign, uv } from '../ShaderNode.js';\r\n\r\nconst checkerShaderNode = new ShaderNode(inputs => {\r\n  const uv = mul(inputs.uv, 2.0);\r\n  const cx = floor(uv.x);\r\n  const cy = floor(uv.y);\r\n  const result = mod(add(cx, cy), 2.0);\r\n  return sign(result);\r\n});\r\n\r\nclass CheckerNode extends Node {\r\n  constructor(uvNode = uv()) {\r\n    super('float');\r\n    this.uvNode = uvNode;\r\n  }\r\n\r\n  generate(builder) {\r\n    return checkerShaderNode({\r\n      uv: this.uvNode\r\n    }).build(builder);\r\n  }\r\n\r\n}\r\n\r\nexport default CheckerNode;\r\n", "import Node from '../core/Node.js';\r\n\r\nclass FogNode extends Node {\r\n  constructor(colorNode, factorNode) {\r\n    super('float');\r\n    this.colorNode = colorNode;\r\n    this.factorNode = factorNode;\r\n  }\r\n\r\n  generate(builder) {\r\n    return this.factorNode.build(builder, 'float');\r\n  }\r\n\r\n}\r\n\r\nFogNode.prototype.isFogNode = true;\r\n\r\nexport default FogNode;\r\n", "import FogNode from './FogNode.js';\r\nimport { smoothstep, negate, positionView } from '../ShaderNode.js';\r\n\r\nclass FogRangeNode extends FogNode {\r\n  constructor(colorNode, nearNode, farNode) {\r\n    super(colorNode);\r\n    this.nearNode = nearNode;\r\n    this.farNode = farNode;\r\n  }\r\n\r\n  generate(builder) {\r\n    this.factorNode = smoothstep(this.nearNode, this.farNode, negate(positionView.z));\r\n    return super.generate(builder);\r\n  }\r\n\r\n}\r\n\r\nFogRangeNode.prototype.isFogRangeNode = true;\r\n\r\nexport default FogRangeNode;\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { PropertyBinding, InterpolateLinear, Vector3, RGBAFormat, ShaderMaterial, MeshStandardMaterial, MeshBasicMaterial, MeshPhysicalMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshToonMaterial, MeshLambertMaterial, DoubleSide, LineSegments, LineLoop, Line, Points, MeshDepthMaterial, InterleavedBufferAttribute, BufferAttribute, Object3D, Material, OrthographicCamera, PerspectiveCamera, MathUtils, InterpolateDiscrete, SkinnedMesh, Matrix4, Mesh, Camera, Scene, DirectionalLight, PointLight, SpotLight, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from 'three';\r\n\r\nclass GLTFExporter {\r\n  constructor() {\r\n    _defineProperty(this, \"pluginCallbacks\", void 0);\r\n\r\n    this.pluginCallbacks = [];\r\n    this.register(function (writer) {\r\n      return new GLTFLightExtension(writer);\r\n    });\r\n    this.register(function (writer) {\r\n      return new GLTFMaterialsUnlitExtension(writer);\r\n    });\r\n    this.register(function (writer) {\r\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\r\n    });\r\n    this.register(function (writer) {\r\n      return new GLTFMaterialsTransmissionExtension(writer);\r\n    });\r\n    this.register(function (writer) {\r\n      return new GLTFMaterialsVolumeExtension(writer);\r\n    });\r\n  }\r\n\r\n  register(callback) {\r\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\r\n      this.pluginCallbacks.push(callback);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  unregister(callback) {\r\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\r\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  parse(input, onDone, options) {\r\n    const writer = new GLTFWriter();\r\n    const plugins = [];\r\n\r\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\r\n      plugins.push(this.pluginCallbacks[i](writer));\r\n    }\r\n\r\n    writer.setPlugins(plugins);\r\n    writer.write(input, onDone, options);\r\n  }\r\n  /**\r\n   * Static utility functions\r\n   */\r\n\r\n\r\n} //------------------------------------------------------------------------------\r\n// Constants\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n_defineProperty(GLTFExporter, \"Utils\", {\r\n  insertKeyframe: function (track, time) {\r\n    const tolerance = 0.001; // 1ms\r\n\r\n    const valueSize = track.getValueSize(); // @ts-expect-error\r\n\r\n    const times = new track.TimeBufferType(track.times.length + 1); // @ts-expect-error\r\n\r\n    const values = new track.ValueBufferType(track.values.length + valueSize);\r\n    /**\r\n     * NOTE: createInterpolant does not exist in the type, but it does exist as a property of the class\r\n     * https://github.com/mrdoob/three.js/blob/77480d339d737b7505b335101ffd3cf29a30738d/src/animation/KeyframeTrack.js#L117\r\n     */\r\n    // @ts-expect-error\r\n\r\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\r\n    let index;\r\n\r\n    if (track.times.length === 0) {\r\n      times[0] = time;\r\n\r\n      for (let i = 0; i < valueSize; i++) {\r\n        values[i] = 0;\r\n      }\r\n\r\n      index = 0;\r\n    } else if (time < track.times[0]) {\r\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\r\n      times[0] = time;\r\n      times.set(track.times, 1);\r\n      values.set(interpolant.evaluate(time), 0);\r\n      values.set(track.values, valueSize);\r\n      index = 0;\r\n    } else if (time > track.times[track.times.length - 1]) {\r\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\r\n        return track.times.length - 1;\r\n      }\r\n\r\n      times[times.length - 1] = time;\r\n      times.set(track.times, 0);\r\n      values.set(track.values, 0);\r\n      values.set(interpolant.evaluate(time), track.values.length);\r\n      index = times.length - 1;\r\n    } else {\r\n      for (let i = 0; i < track.times.length; i++) {\r\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\r\n\r\n        if (track.times[i] < time && track.times[i + 1] > time) {\r\n          times.set(track.times.slice(0, i + 1), 0);\r\n          times[i + 1] = time;\r\n          times.set(track.times.slice(i + 1), i + 2);\r\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\r\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\r\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\r\n          index = i + 1;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    track.times = times;\r\n    track.values = values;\r\n    return index;\r\n  },\r\n  mergeMorphTargetTracks: function (clip, root) {\r\n    const tracks = [];\r\n    const mergedTracks = {};\r\n    const sourceTracks = clip.tracks;\r\n\r\n    for (let i = 0; i < sourceTracks.length; ++i) {\r\n      let sourceTrack = sourceTracks[i];\r\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\r\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\r\n\r\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\r\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\r\n        tracks.push(sourceTrack);\r\n        continue;\r\n      }\r\n\r\n      if ( // @ts-expect-error\r\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && // @ts-expect-error\r\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\r\n        // @ts-expect-error\r\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\r\n          // This should never happen, because glTF morph target animations\r\n          // affect all targets already.\r\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\r\n        }\r\n\r\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\r\n        sourceTrack = sourceTrack.clone();\r\n        sourceTrack.setInterpolation(InterpolateLinear);\r\n      }\r\n\r\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\r\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\r\n\r\n      if (targetIndex === undefined) {\r\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\r\n      }\r\n\r\n      let mergedTrack; // If this is the first time we've seen this object, create a new\r\n      // track to store merged keyframe data for each morph target.\r\n\r\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\r\n        mergedTrack = sourceTrack.clone(); // @ts-expect-error\r\n\r\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\r\n\r\n        for (let j = 0; j < mergedTrack.times.length; j++) {\r\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\r\n        } // We need to take into consideration the intended target node\r\n        // of our original un-merged morphTarget animation.\r\n\r\n\r\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\r\n        mergedTrack.values = values;\r\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\r\n        tracks.push(mergedTrack);\r\n        continue;\r\n      } // @ts-expect-error\r\n\r\n\r\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\r\n      mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\r\n      // interpolated) value from the source track.\r\n\r\n      for (let j = 0; j < mergedTrack.times.length; j++) {\r\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\r\n      } // For every existing keyframe of the source track, write a (possibly\r\n      // new) keyframe to the merged track. Values from the previous loop may\r\n      // be written again, but keyframes are de-duplicated.\r\n\r\n\r\n      for (let j = 0; j < sourceTrack.times.length; j++) {\r\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\r\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\r\n      }\r\n    }\r\n\r\n    clip.tracks = tracks;\r\n    return clip;\r\n  }\r\n});\r\n\r\nconst WEBGL_CONSTANTS = {\r\n  POINTS: 0x0000,\r\n  LINES: 0x0001,\r\n  LINE_LOOP: 0x0002,\r\n  LINE_STRIP: 0x0003,\r\n  TRIANGLES: 0x0004,\r\n  TRIANGLE_STRIP: 0x0005,\r\n  TRIANGLE_FAN: 0x0006,\r\n  UNSIGNED_BYTE: 0x1401,\r\n  UNSIGNED_SHORT: 0x1403,\r\n  FLOAT: 0x1406,\r\n  UNSIGNED_INT: 0x1405,\r\n  ARRAY_BUFFER: 0x8892,\r\n  ELEMENT_ARRAY_BUFFER: 0x8893,\r\n  NEAREST: 0x2600,\r\n  LINEAR: 0x2601,\r\n  NEAREST_MIPMAP_NEAREST: 0x2700,\r\n  LINEAR_MIPMAP_NEAREST: 0x2701,\r\n  NEAREST_MIPMAP_LINEAR: 0x2702,\r\n  LINEAR_MIPMAP_LINEAR: 0x2703,\r\n  CLAMP_TO_EDGE: 33071,\r\n  MIRRORED_REPEAT: 33648,\r\n  REPEAT: 10497\r\n};\r\nconst THREE_TO_WEBGL = {};\r\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\r\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\r\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\r\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\r\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\r\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\r\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\r\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\r\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\r\nconst PATH_PROPERTIES = {\r\n  scale: 'scale',\r\n  position: 'translation',\r\n  quaternion: 'rotation',\r\n  morphTargetInfluences: 'weights'\r\n}; // GLB constants\r\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\r\n\r\nconst GLB_HEADER_BYTES = 12;\r\nconst GLB_HEADER_MAGIC = 0x46546c67;\r\nconst GLB_VERSION = 2;\r\nconst GLB_CHUNK_PREFIX_BYTES = 8;\r\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\r\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\r\n/**\r\n * Writer\r\n */\r\n\r\nclass GLTFWriter {\r\n  constructor() {\r\n    _defineProperty(this, \"plugins\", void 0);\r\n\r\n    _defineProperty(this, \"options\", void 0);\r\n\r\n    _defineProperty(this, \"pending\", void 0);\r\n\r\n    _defineProperty(this, \"buffers\", void 0);\r\n\r\n    _defineProperty(this, \"byteOffset\", void 0);\r\n\r\n    _defineProperty(this, \"nodeMap\", void 0);\r\n\r\n    _defineProperty(this, \"skins\", void 0);\r\n\r\n    _defineProperty(this, \"extensionsUsed\", void 0);\r\n\r\n    _defineProperty(this, \"uids\", void 0);\r\n\r\n    _defineProperty(this, \"uid\", void 0);\r\n\r\n    _defineProperty(this, \"json\", void 0);\r\n\r\n    _defineProperty(this, \"cache\", void 0);\r\n\r\n    _defineProperty(this, \"cachedCanvas\", void 0);\r\n\r\n    this.plugins = [];\r\n    this.options = {};\r\n    this.pending = [];\r\n    this.buffers = [];\r\n    this.byteOffset = 0;\r\n    this.nodeMap = new Map();\r\n    this.skins = [];\r\n    this.extensionsUsed = {};\r\n    this.uids = new Map();\r\n    this.uid = 0;\r\n    this.json = {\r\n      asset: {\r\n        version: '2.0',\r\n        generator: 'THREE.GLTFExporter'\r\n      }\r\n    };\r\n    this.cache = {\r\n      meshes: new Map(),\r\n      attributes: new Map(),\r\n      attributesNormalized: new Map(),\r\n      materials: new Map(),\r\n      textures: new Map(),\r\n      images: new Map()\r\n    };\r\n    this.cachedCanvas = null;\r\n  }\r\n\r\n  setPlugins(plugins) {\r\n    this.plugins = plugins;\r\n  }\r\n  /**\r\n   * Parse scenes and generate GLTF output\r\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\r\n   * @param  {Function} onDone  Callback on completed\r\n   * @param  {Object} options options\r\n   */\r\n\r\n\r\n  write(input, onDone, options) {\r\n    this.options = Object.assign({}, {\r\n      // default options\r\n      binary: false,\r\n      trs: false,\r\n      onlyVisible: true,\r\n      truncateDrawRange: true,\r\n      embedImages: true,\r\n      maxTextureSize: Infinity,\r\n      animations: [],\r\n      includeCustomExtensions: false\r\n    }, options);\r\n\r\n    if (this.options.animations !== undefined && this.options.animations.length > 0) {\r\n      // Only TRS properties, and not matrices, may be targeted by animation.\r\n      this.options.trs = true;\r\n    }\r\n\r\n    this.processInput(input);\r\n    const writer = this;\r\n    Promise.all(this.pending).then(() => {\r\n      const buffers = writer.buffers;\r\n      const json = writer.json;\r\n      const options = writer.options;\r\n      const extensionsUsed = writer.extensionsUsed; // Merge buffers.\r\n\r\n      const blob = new Blob(buffers, {\r\n        type: 'application/octet-stream'\r\n      }); // Declare extensions.\r\n\r\n      const extensionsUsedList = Object.keys(extensionsUsed);\r\n      if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\r\n\r\n      if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\r\n\r\n      if (options.binary) {\r\n        // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\r\n        const reader = new window.FileReader();\r\n        reader.readAsArrayBuffer(blob);\r\n\r\n        reader.onloadend = () => {\r\n          if (reader.result !== null && typeof reader.result !== 'string') {\r\n            // Binary chunk.\r\n            const binaryChunk = this.getPaddedArrayBuffer(reader.result);\r\n            const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\r\n            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\r\n            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\r\n\r\n            const jsonChunk = this.getPaddedArrayBuffer(this.stringToArrayBuffer(JSON.stringify(json)), 0x20);\r\n            const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\r\n            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\r\n            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\r\n\r\n            const header = new ArrayBuffer(GLB_HEADER_BYTES);\r\n            const headerView = new DataView(header);\r\n            headerView.setUint32(0, GLB_HEADER_MAGIC, true);\r\n            headerView.setUint32(4, GLB_VERSION, true);\r\n            const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\r\n            headerView.setUint32(8, totalByteLength, true);\r\n            const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\r\n              type: 'application/octet-stream'\r\n            });\r\n            const glbReader = new window.FileReader();\r\n            glbReader.readAsArrayBuffer(glbBlob);\r\n\r\n            glbReader.onloadend = function () {\r\n              if (glbReader.result !== null && typeof glbReader.result !== 'string') {\r\n                onDone(glbReader.result);\r\n              }\r\n            };\r\n          }\r\n        };\r\n      } else {\r\n        if (json.buffers && json.buffers.length > 0) {\r\n          const reader = new window.FileReader();\r\n          reader.readAsDataURL(blob);\r\n\r\n          reader.onloadend = function () {\r\n            const base64data = reader.result;\r\n\r\n            if (json.buffers !== undefined && base64data !== null) {\r\n              json.buffers[0].uri = base64data;\r\n              onDone(json);\r\n            }\r\n          };\r\n        } else {\r\n          onDone(json);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Serializes a userData.\r\n   *\r\n   * @param {THREE.Object3D|THREE.Material} object\r\n   * @param {Object} objectDef\r\n   */\r\n\r\n\r\n  serializeUserData(object, objectDef) {\r\n    if (Object.keys(object.userData).length === 0) return;\r\n    const options = this.options;\r\n    const extensionsUsed = this.extensionsUsed;\r\n\r\n    try {\r\n      const json = JSON.parse(JSON.stringify(object.userData));\r\n\r\n      if (options.includeCustomExtensions && json.gltfExtensions) {\r\n        if (objectDef.extensions === undefined) objectDef.extensions = {};\r\n\r\n        for (const extensionName in json.gltfExtensions) {\r\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\r\n          extensionsUsed[extensionName] = true;\r\n        }\r\n\r\n        delete json.gltfExtensions;\r\n      }\r\n\r\n      if (Object.keys(json).length > 0) objectDef.extras = json;\r\n    } catch (error) {\r\n      if (error instanceof Error) {\r\n        console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' \" + \"won't be serialized because of JSON.stringify error - \" + error.message);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Assign and return a temporal unique id for an object\r\n   * especially which doesn't have .uuid\r\n   * @param  {Object} object\r\n   * @return {Integer}\r\n   */\r\n\r\n\r\n  getUID(object) {\r\n    if (!this.uids.has(object)) this.uids.set(object, this.uid++);\r\n    return this.uids.get(object);\r\n  }\r\n  /**\r\n   * Checks if normal attribute values are normalized.\r\n   *\r\n   * @param {BufferAttribute} normal\r\n   * @returns {Boolean}\r\n   */\r\n\r\n\r\n  isNormalizedNormalAttribute(normal) {\r\n    const cache = this.cache;\r\n    if (cache.attributesNormalized.has(normal)) return false;\r\n    const v = new Vector3();\r\n\r\n    for (let i = 0, il = normal.count; i < il; i++) {\r\n      // 0.0005 is from glTF-validator\r\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n  /**\r\n   * Creates normalized normal buffer attribute.\r\n   *\r\n   * @param {BufferAttribute} normal\r\n   * @returns {BufferAttribute}\r\n   *\r\n   */\r\n\r\n\r\n  createNormalizedNormalAttribute(normal) {\r\n    const cache = this.cache;\r\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\r\n    const attribute = normal.clone();\r\n    const v = new Vector3();\r\n\r\n    for (let i = 0, il = attribute.count; i < il; i++) {\r\n      v.fromBufferAttribute(attribute, i);\r\n\r\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\r\n        // if values can't be normalized set (1, 0, 0)\r\n        v.setX(1.0);\r\n      } else {\r\n        v.normalize();\r\n      }\r\n\r\n      attribute.setXYZ(i, v.x, v.y, v.z);\r\n    }\r\n\r\n    cache.attributesNormalized.set(normal, attribute);\r\n    return attribute;\r\n  }\r\n  /**\r\n   * Applies a texture transform, if present, to the map definition. Requires\r\n   * the KHR_texture_transform extension.\r\n   *\r\n   * @param {Object} mapDef\r\n   * @param {THREE.Texture} texture\r\n   */\r\n\r\n\r\n  applyTextureTransform(mapDef, texture) {\r\n    let didTransform = false;\r\n    const transformDef = {};\r\n\r\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\r\n      transformDef.offset = texture.offset.toArray();\r\n      didTransform = true;\r\n    }\r\n\r\n    if (texture.rotation !== 0) {\r\n      transformDef.rotation = texture.rotation;\r\n      didTransform = true;\r\n    }\r\n\r\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\r\n      transformDef.scale = texture.repeat.toArray();\r\n      didTransform = true;\r\n    }\r\n\r\n    if (didTransform) {\r\n      mapDef.extensions = mapDef.extensions || {};\r\n      mapDef.extensions['KHR_texture_transform'] = transformDef;\r\n      this.extensionsUsed['KHR_texture_transform'] = true;\r\n    }\r\n  }\r\n  /**\r\n   * Process a buffer to append to the default one.\r\n   * @param  {ArrayBuffer} buffer\r\n   * @return {Integer}\r\n   */\r\n\r\n\r\n  processBuffer(buffer) {\r\n    const json = this.json;\r\n    const buffers = this.buffers;\r\n    if (!json.buffers) json.buffers = [{\r\n      byteLength: 0\r\n    }]; // All buffers are merged before export.\r\n\r\n    buffers.push(buffer);\r\n    return 0;\r\n  }\r\n  /**\r\n   * Process and generate a BufferView\r\n   * @param  {BufferAttribute} attribute\r\n   * @param  {number} componentType\r\n   * @param  {number} start\r\n   * @param  {number} count\r\n   * @param  {number} target (Optional) Target usage of the BufferView\r\n   * @return {Object}\r\n   */\r\n\r\n\r\n  processBufferView(attribute, componentType, start, count, target) {\r\n    const json = this.json;\r\n    if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\r\n\r\n    let componentSize;\r\n\r\n    if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\r\n      componentSize = 1;\r\n    } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\r\n      componentSize = 2;\r\n    } else {\r\n      componentSize = 4;\r\n    }\r\n\r\n    const byteLength = this.getPaddedBufferSize(count * attribute.itemSize * componentSize);\r\n    const dataView = new DataView(new ArrayBuffer(byteLength));\r\n    let offset = 0;\r\n\r\n    for (let i = start; i < start + count; i++) {\r\n      for (let a = 0; a < attribute.itemSize; a++) {\r\n        let value;\r\n\r\n        if (attribute.itemSize > 4) {\r\n          // no support for interleaved data for itemSize > 4\r\n          value = attribute.array[i * attribute.itemSize + a];\r\n        } else {\r\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\r\n        }\r\n\r\n        if (value !== undefined) {\r\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\r\n            dataView.setFloat32(offset, value, true);\r\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\r\n            dataView.setUint32(offset, value, true);\r\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\r\n            dataView.setUint16(offset, value, true);\r\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\r\n            dataView.setUint8(offset, value);\r\n          }\r\n        }\r\n\r\n        offset += componentSize;\r\n      }\r\n    }\r\n\r\n    const bufferViewDef = {\r\n      buffer: this.processBuffer(dataView.buffer),\r\n      byteOffset: this.byteOffset,\r\n      byteLength: byteLength\r\n    };\r\n    if (target !== undefined) bufferViewDef.target = target;\r\n\r\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\r\n      // Only define byteStride for vertex attributes.\r\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\r\n    }\r\n\r\n    this.byteOffset += byteLength;\r\n    json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\r\n\r\n    const output = {\r\n      id: json.bufferViews.length - 1,\r\n      byteLength: 0\r\n    };\r\n    return output;\r\n  }\r\n  /**\r\n   * Process and generate a BufferView from an image Blob.\r\n   * @param {Blob} blob\r\n   * @return {Promise<Integer>}\r\n   */\r\n\r\n\r\n  processBufferViewImage(blob) {\r\n    const writer = this;\r\n    const json = writer.json;\r\n    if (!json.bufferViews) json.bufferViews = [];\r\n    return new Promise(resolve => {\r\n      const reader = new window.FileReader();\r\n      reader.readAsArrayBuffer(blob);\r\n\r\n      reader.onloadend = () => {\r\n        if (reader.result !== null && typeof reader.result !== 'string' && json.bufferViews !== undefined) {\r\n          const buffer = this.getPaddedArrayBuffer(reader.result);\r\n          const bufferViewDef = {\r\n            buffer: writer.processBuffer(buffer),\r\n            byteOffset: writer.byteOffset,\r\n            byteLength: buffer.byteLength\r\n          };\r\n          writer.byteOffset += buffer.byteLength;\r\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\r\n        }\r\n      };\r\n    });\r\n  }\r\n  /**\r\n   * Process attribute to generate an accessor\r\n   * @param  {BufferAttribute} attribute Attribute to process\r\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\r\n   * @param  {Integer} start (Optional)\r\n   * @param  {Integer} count (Optional)\r\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\r\n   */\r\n\r\n\r\n  processAccessor(attribute, geometry, start, count) {\r\n    const options = this.options;\r\n    const json = this.json;\r\n    const types = {\r\n      1: 'SCALAR',\r\n      2: 'VEC2',\r\n      3: 'VEC3',\r\n      4: 'VEC4',\r\n      16: 'MAT4'\r\n    };\r\n    let componentType; // Detect the component type of the attribute array (float, uint or ushort)\r\n\r\n    if (attribute.array.constructor === Float32Array) {\r\n      componentType = WEBGL_CONSTANTS.FLOAT;\r\n    } else if (attribute.array.constructor === Uint32Array) {\r\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\r\n    } else if (attribute.array.constructor === Uint16Array) {\r\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\r\n    } else if (attribute.array.constructor === Uint8Array) {\r\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\r\n    } else {\r\n      throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\r\n    }\r\n\r\n    if (start === undefined) start = 0;\r\n    if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\r\n\r\n    if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\r\n      const end = start + count;\r\n      const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\r\n      start = Math.max(start, geometry.drawRange.start);\r\n      count = Math.min(end, end2) - start;\r\n      if (count < 0) count = 0;\r\n    } // Skip creating an accessor if the attribute doesn't have data to export\r\n\r\n\r\n    if (count === 0) return null;\r\n    const minMax = this.getMinMax(attribute, start, count);\r\n    let bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\r\n    // animation samplers, target must not be set.\r\n\r\n    if (geometry !== undefined) {\r\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\r\n    }\r\n\r\n    if (bufferViewTarget !== undefined) {\r\n      const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\r\n      const accessorDef = {\r\n        bufferView: bufferView.id,\r\n        byteOffset: bufferView.byteOffset,\r\n        componentType: componentType,\r\n        count: count,\r\n        max: minMax.max,\r\n        min: minMax.min,\r\n        type: types[attribute.itemSize]\r\n      };\r\n      if (attribute.normalized) accessorDef.normalized = true;\r\n      if (!json.accessors) json.accessors = [];\r\n      return json.accessors.push(accessorDef) - 1;\r\n    }\r\n  }\r\n  /**\r\n   * Process image\r\n   * @param  {Image} image to process\r\n   * @param  {Integer} format of the image (RGBAFormat)\r\n   * @param  {Boolean} flipY before writing out the image\r\n   * @return {Integer}     Index of the processed texture in the \"images\" array\r\n   */\r\n\r\n\r\n  processImage(image, format, flipY) {\r\n    const writer = this;\r\n    const cache = writer.cache;\r\n    const json = writer.json;\r\n    const options = writer.options;\r\n    const pending = writer.pending;\r\n    if (!cache.images.has(image)) cache.images.set(image, {});\r\n    const cachedImages = cache.images.get(image);\r\n    const mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\r\n    const key = mimeType + ':flipY/' + flipY.toString();\r\n    if (cachedImages !== undefined && cachedImages[key] !== undefined) return cachedImages[key];\r\n    if (!json.images) json.images = [];\r\n    const imageDef = {\r\n      mimeType: mimeType\r\n    };\r\n\r\n    if (options.embedImages && options.maxTextureSize !== undefined) {\r\n      const canvas = this.cachedCanvas = this.cachedCanvas || document.createElement('canvas');\r\n      canvas.width = Math.min(image.width, options.maxTextureSize);\r\n      canvas.height = Math.min(image.height, options.maxTextureSize);\r\n      const ctx = canvas.getContext('2d');\r\n\r\n      if (flipY) {\r\n        ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, canvas.height);\r\n        ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);\r\n      }\r\n\r\n      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\r\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\r\n      } else {\r\n        if (format !== RGBAFormat) {\r\n          console.error('GLTFExporter: Only RGBA format is supported.');\r\n        }\r\n\r\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\r\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\r\n        }\r\n\r\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\r\n\r\n        if (image instanceof ImageData) {\r\n          for (let i = 0; i < data.length; i += 4) {\r\n            data[i + 0] = image.data[i + 0];\r\n            data[i + 1] = image.data[i + 1];\r\n            data[i + 2] = image.data[i + 2];\r\n            data[i + 3] = image.data[i + 3];\r\n          }\r\n        }\r\n\r\n        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\r\n      }\r\n\r\n      if (options.binary) {\r\n        pending.push(new Promise(function (resolve) {\r\n          canvas.toBlob(function (blob) {\r\n            if (blob !== null) {\r\n              writer.processBufferViewImage(blob).then(function (bufferViewIndex) {\r\n                imageDef.bufferView = bufferViewIndex; // @ts-expect-error\r\n\r\n                resolve();\r\n              });\r\n            }\r\n          }, mimeType);\r\n        }));\r\n      } else {\r\n        imageDef.uri = canvas.toDataURL(mimeType);\r\n      }\r\n    } else if (image instanceof Image) {\r\n      imageDef.uri = image.src;\r\n    }\r\n\r\n    const index = json.images.push(imageDef) - 1;\r\n    if (cachedImages !== undefined) cachedImages[key] = index;\r\n    return index;\r\n  }\r\n  /**\r\n   * Process sampler\r\n   * @param  {Texture} map Texture to process\r\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\r\n   */\r\n\r\n\r\n  processSampler(map) {\r\n    const json = this.json;\r\n    if (!json.samplers) json.samplers = [];\r\n    const samplerDef = {\r\n      magFilter: THREE_TO_WEBGL[map.magFilter],\r\n      minFilter: THREE_TO_WEBGL[map.minFilter],\r\n      wrapS: THREE_TO_WEBGL[map.wrapS],\r\n      wrapT: THREE_TO_WEBGL[map.wrapT]\r\n    };\r\n    return json.samplers.push(samplerDef) - 1;\r\n  }\r\n  /**\r\n   * Process texture\r\n   * @param  {Texture} map Map to process\r\n   * @return {Integer} Index of the processed texture in the \"textures\" array\r\n   */\r\n\r\n\r\n  processTexture(map) {\r\n    const cache = this.cache;\r\n    const json = this.json;\r\n    if (cache.textures.has(map)) return cache.textures.get(map);\r\n    if (!json.textures) json.textures = [];\r\n    const textureDef = {\r\n      sampler: this.processSampler(map),\r\n      source: this.processImage(map.image, map.format, map.flipY)\r\n    };\r\n    if (map.name) textureDef.name = map.name;\r\n\r\n    this._invokeAll(function (ext) {\r\n      ext.writeTexture && ext.writeTexture(map, textureDef);\r\n    });\r\n\r\n    const index = json.textures.push(textureDef) - 1;\r\n    cache.textures.set(map, index);\r\n    return index;\r\n  }\r\n  /**\r\n   * Process material\r\n   * @param  {THREE.Material} material Material to process\r\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\r\n   */\r\n\r\n\r\n  processMaterial(material) {\r\n    const cache = this.cache;\r\n    const json = this.json;\r\n    if (cache.materials.has(material)) return cache.materials.get(material);\r\n\r\n    if (material instanceof ShaderMaterial && material.isShaderMaterial) {\r\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\r\n      return null;\r\n    }\r\n\r\n    if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\r\n\r\n    const materialDef = {\r\n      pbrMetallicRoughness: {}\r\n    };\r\n\r\n    if (!(material instanceof MeshStandardMaterial && material.isMeshStandardMaterial && material instanceof MeshBasicMaterial && // @ts-expect-error\r\n    material.isMeshBasicMaterial)) {\r\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\r\n    }\r\n\r\n    if (material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) {\r\n      // pbrMetallicRoughness.baseColorFactor\r\n      const color = material.color.toArray().concat([material.opacity]);\r\n\r\n      if (!this.equalArray(color, [1, 1, 1, 1])) {\r\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\r\n      }\r\n    }\r\n\r\n    if (material instanceof MeshStandardMaterial && material.isMeshStandardMaterial) {\r\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\r\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\r\n    } else {\r\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\r\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\r\n    } // pbrMetallicRoughness.metallicRoughnessTexture\r\n\r\n\r\n    if (material instanceof MeshStandardMaterial && material.metalnessMap || material instanceof MeshStandardMaterial && material.roughnessMap) {\r\n      if (material.metalnessMap === material.roughnessMap && material.metalnessMap !== null) {\r\n        const metalRoughMapDef = {\r\n          index: this.processTexture(material.metalnessMap)\r\n        };\r\n        this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\r\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\r\n      } else {\r\n        console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\r\n      }\r\n    } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\r\n\r\n\r\n    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.map) {\r\n      const baseColorMapDef = {\r\n        index: this.processTexture(material.map)\r\n      };\r\n      this.applyTextureTransform(baseColorMapDef, material.map);\r\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\r\n    }\r\n\r\n    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.emissive) {\r\n      // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\r\n      const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);\r\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\r\n\r\n      if (maxEmissiveComponent > 1) {\r\n        emissive.multiplyScalar(1 / maxEmissiveComponent);\r\n        console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');\r\n      }\r\n\r\n      if (maxEmissiveComponent > 0) {\r\n        materialDef.emissiveFactor = emissive.toArray();\r\n      } // emissiveTexture\r\n\r\n\r\n      if (material.emissiveMap) {\r\n        const emissiveMapDef = {\r\n          index: this.processTexture(material.emissiveMap)\r\n        };\r\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\r\n        materialDef.emissiveTexture = emissiveMapDef;\r\n      }\r\n    } // normalTexture\r\n\r\n\r\n    if ((material instanceof MeshMatcapMaterial || material instanceof MeshNormalMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.normalMap) {\r\n      const normalMapDef = {\r\n        index: this.processTexture(material.normalMap)\r\n      };\r\n\r\n      if (material.normalScale && material.normalScale.x !== 1) {\r\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\r\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n        normalMapDef.scale = material.normalScale.x;\r\n      }\r\n\r\n      this.applyTextureTransform(normalMapDef, material.normalMap);\r\n      materialDef.normalTexture = normalMapDef;\r\n    } // occlusionTexture\r\n\r\n\r\n    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.aoMap) {\r\n      const occlusionMapDef = {\r\n        index: this.processTexture(material.aoMap),\r\n        texCoord: 1\r\n      };\r\n\r\n      if (material.aoMapIntensity !== 1.0) {\r\n        occlusionMapDef.strength = material.aoMapIntensity;\r\n      }\r\n\r\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\r\n      materialDef.occlusionTexture = occlusionMapDef;\r\n    } // alphaMode\r\n\r\n\r\n    if (material.transparent) {\r\n      materialDef.alphaMode = 'BLEND';\r\n    } else {\r\n      if (material.alphaTest > 0.0) {\r\n        materialDef.alphaMode = 'MASK';\r\n        materialDef.alphaCutoff = material.alphaTest;\r\n      }\r\n    } // doubleSided\r\n\r\n\r\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\r\n    if (material.name !== '') materialDef.name = material.name;\r\n    this.serializeUserData(material, materialDef);\r\n\r\n    this._invokeAll(function (ext) {\r\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\r\n    });\r\n\r\n    const index = json.materials.push(materialDef) - 1;\r\n    cache.materials.set(material, index);\r\n    return index;\r\n  }\r\n  /**\r\n   * Process mesh\r\n   * @param  {THREE.Mesh} mesh Mesh to process\r\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\r\n   */\r\n\r\n\r\n  processMesh(mesh) {\r\n    const cache = this.cache;\r\n    const json = this.json;\r\n    const meshCacheKeyParts = [mesh.geometry.uuid];\r\n\r\n    if (Array.isArray(mesh.material)) {\r\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\r\n        meshCacheKeyParts.push(mesh.material[i].uuid);\r\n      }\r\n    } else {\r\n      meshCacheKeyParts.push(mesh.material.uuid);\r\n    }\r\n\r\n    const meshCacheKey = meshCacheKeyParts.join(':');\r\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\r\n    const geometry = mesh.geometry;\r\n    let mode; // Use the correct mode\r\n\r\n    if (mesh instanceof LineSegments && mesh.isLineSegments) {\r\n      mode = WEBGL_CONSTANTS.LINES;\r\n    } else if (mesh instanceof LineLoop && mesh.isLineLoop) {\r\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\r\n    } else if (mesh instanceof Line && mesh.isLine) {\r\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\r\n    } else if (mesh instanceof Points && mesh.isPoints) {\r\n      mode = WEBGL_CONSTANTS.POINTS;\r\n    } else {\r\n      mode = (mesh.material instanceof MeshBasicMaterial || mesh.material instanceof MeshDepthMaterial || mesh.material instanceof MeshLambertMaterial || mesh.material instanceof MeshNormalMaterial || mesh.material instanceof MeshPhongMaterial || mesh.material instanceof MeshStandardMaterial || mesh.material instanceof MeshToonMaterial || mesh.material instanceof ShaderMaterial) && mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\r\n    }\r\n\r\n    if (!geometry.isBufferGeometry) {\r\n      throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\r\n    }\r\n\r\n    const meshDef = {};\r\n    const attributes = {};\r\n    const primitives = [];\r\n    const targets = []; // Conversion between attributes names in threejs and gltf spec\r\n\r\n    const nameConversion = {\r\n      uv: 'TEXCOORD_0',\r\n      uv2: 'TEXCOORD_1',\r\n      color: 'COLOR_0',\r\n      skinWeight: 'WEIGHTS_0',\r\n      skinIndex: 'JOINTS_0'\r\n    };\r\n    const originalNormal = geometry.getAttribute('normal');\r\n\r\n    if (originalNormal !== undefined && !(originalNormal instanceof InterleavedBufferAttribute) && !this.isNormalizedNormalAttribute(originalNormal)) {\r\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\r\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\r\n    } // @QUESTION Detect if .vertexColors = true?\r\n    // For every attribute create an accessor\r\n\r\n\r\n    let modifiedAttribute = null;\r\n\r\n    for (let attributeName in geometry.attributes) {\r\n      // Ignore morph target attributes, which are exported later.\r\n      if (attributeName.substr(0, 5) === 'morph') continue;\r\n      const attribute = geometry.attributes[attributeName];\r\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\r\n      // listed in the spec; non-spec attributes are considered custom.\r\n\r\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\r\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\r\n\r\n      if (cache.attributes.has(this.getUID(attribute))) {\r\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\r\n        continue;\r\n      } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\r\n\r\n\r\n      modifiedAttribute = null;\r\n      const array = attribute.array;\r\n\r\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\r\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\r\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\r\n      }\r\n\r\n      const accessor = modifiedAttribute !== null && this.processAccessor(modifiedAttribute || attribute, geometry);\r\n\r\n      if (accessor) {\r\n        attributes[attributeName] = accessor;\r\n        cache.attributes.set(this.getUID(attribute), accessor);\r\n      }\r\n    }\r\n\r\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\r\n\r\n    if (Object.keys(attributes).length === 0) return null; // Morph targets\r\n\r\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\r\n      const weights = [];\r\n      const targetNames = [];\r\n      const reverseDictionary = {};\r\n\r\n      if (mesh.morphTargetDictionary !== undefined) {\r\n        for (const key in mesh.morphTargetDictionary) {\r\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\r\n        }\r\n      }\r\n\r\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\r\n        const target = {};\r\n        let warned = false;\r\n\r\n        for (const attributeName in geometry.morphAttributes) {\r\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\r\n          // Three.js doesn't support TANGENT yet.\r\n          if (attributeName !== 'position' && attributeName !== 'normal') {\r\n            if (!warned) {\r\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\r\n              warned = true;\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          const attribute = geometry.morphAttributes[attributeName][i];\r\n          const gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\r\n          //\r\n          // glTF 2.0 Specification:\r\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\r\n\r\n          const baseAttribute = geometry.attributes[attributeName];\r\n\r\n          if (cache.attributes.has(this.getUID(attribute))) {\r\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\r\n            continue;\r\n          } // Clones attribute not to override\r\n\r\n\r\n          const relativeAttribute = attribute.clone();\r\n\r\n          if (!geometry.morphTargetsRelative) {\r\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\r\n              relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\r\n            }\r\n          }\r\n\r\n          const accessor = this.processAccessor(relativeAttribute, geometry);\r\n\r\n          if (accessor != undefined) {\r\n            target[gltfAttributeName] = accessor;\r\n          }\r\n\r\n          cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\r\n        }\r\n\r\n        targets.push(target);\r\n        weights.push(mesh.morphTargetInfluences[i]);\r\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\r\n      }\r\n\r\n      meshDef.weights = weights;\r\n\r\n      if (targetNames.length > 0) {\r\n        meshDef.extras = {};\r\n        meshDef.extras.targetNames = targetNames;\r\n      }\r\n    }\r\n\r\n    const isMultiMaterial = Array.isArray(mesh.material);\r\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\r\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\r\n    const groups = isMultiMaterial ? geometry.groups : [{\r\n      materialIndex: 0,\r\n      start: undefined,\r\n      count: undefined\r\n    }];\r\n\r\n    for (let i = 0, il = groups.length; i < il; i++) {\r\n      const primitive = {\r\n        mode: mode,\r\n        attributes: attributes\r\n      };\r\n\r\n      if (geometry instanceof Object3D || geometry instanceof Material) {\r\n        this.serializeUserData(geometry, primitive);\r\n      }\r\n\r\n      if (targets.length > 0) primitive.targets = targets;\r\n\r\n      if (geometry.index !== null) {\r\n        let cacheKey = this.getUID(geometry.index);\r\n\r\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\r\n          // @ts-expect-error\r\n          cacheKey += `:${groups[i].start}:${groups[i].count}`;\r\n        }\r\n\r\n        if (cache.attributes.has(cacheKey)) {\r\n          primitive.indices = cache.attributes.get(cacheKey);\r\n        } else {\r\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\r\n          cache.attributes.set(cacheKey, primitive.indices);\r\n        }\r\n\r\n        if (primitive.indices === null) delete primitive.indices;\r\n      }\r\n\r\n      const materialIndex = groups[i].materialIndex;\r\n\r\n      if (materialIndex !== undefined && Array.isArray(materials)) {\r\n        const targetMaterials = materials[materialIndex];\r\n\r\n        if (!Array.isArray(targetMaterials)) {\r\n          const material = this.processMaterial(targetMaterials);\r\n          if (material !== null) primitive.material = material;\r\n          primitives.push(primitive);\r\n        }\r\n      }\r\n    }\r\n\r\n    meshDef.primitives = primitives;\r\n    if (!json.meshes) json.meshes = [];\r\n\r\n    this._invokeAll(function (ext) {\r\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\r\n    });\r\n\r\n    const index = json.meshes.push(meshDef) - 1;\r\n    cache.meshes.set(meshCacheKey, index);\r\n    return index;\r\n  }\r\n  /**\r\n   * Process camera\r\n   * @param  {THREE.Camera} camera Camera to process\r\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\r\n   */\r\n\r\n\r\n  processCamera(camera) {\r\n    const json = this.json;\r\n    if (!json.cameras) json.cameras = [];\r\n    const isOrtho = camera instanceof OrthographicCamera && camera.isOrthographicCamera;\r\n    const cameraDef = {\r\n      type: isOrtho ? 'orthographic' : 'perspective'\r\n    };\r\n\r\n    if (camera instanceof OrthographicCamera && isOrtho) {\r\n      cameraDef.orthographic = {\r\n        xmag: camera.right * 2,\r\n        ymag: camera.top * 2,\r\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\r\n        znear: camera.near < 0 ? 0 : camera.near\r\n      };\r\n    } else if (camera instanceof PerspectiveCamera) {\r\n      cameraDef.perspective = {\r\n        aspectRatio: camera.aspect,\r\n        yfov: MathUtils.degToRad(camera.fov),\r\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\r\n        znear: camera.near < 0 ? 0 : camera.near\r\n      };\r\n    } // Question: Is saving \"type\" as name intentional?\r\n\r\n\r\n    if (camera.name !== '') cameraDef.name = camera.type;\r\n    return json.cameras.push(cameraDef) - 1;\r\n  }\r\n  /**\r\n   * Creates glTF animation entry from AnimationClip object.\r\n   *\r\n   * Status:\r\n   * - Only properties listed in PATH_PROPERTIES may be animated.\r\n   *\r\n   * @param {THREE.AnimationClip} clip\r\n   * @param {THREE.Object3D} root\r\n   * @return {number|null}\r\n   */\r\n\r\n\r\n  processAnimation(clip, root) {\r\n    const json = this.json;\r\n    const nodeMap = this.nodeMap;\r\n    if (!json.animations) json.animations = [];\r\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\r\n    const tracks = clip.tracks;\r\n    const channels = [];\r\n    const samplers = [];\r\n\r\n    for (let i = 0; i < tracks.length; ++i) {\r\n      const track = tracks[i];\r\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\r\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\r\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\r\n\r\n      if (trackBinding.objectName === 'bones') {\r\n        if (trackNode.isSkinnedMesh) {\r\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\r\n        } else {\r\n          trackNode = undefined;\r\n        }\r\n      }\r\n\r\n      if (!trackNode || !trackProperty) {\r\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\r\n        return null;\r\n      }\r\n\r\n      const inputItemSize = 1;\r\n      let outputItemSize = track.values.length / track.times.length;\r\n\r\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\r\n        outputItemSize /= trackNode.morphTargetInfluences.length;\r\n      }\r\n\r\n      let interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\r\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\r\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\r\n      // valid value from .getInterpolation().\r\n      // @ts-expect-error\r\n\r\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\r\n        interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\r\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\r\n        // but needs to be stored as VEC3 so dividing by 3 here.\r\n\r\n        outputItemSize /= 3;\r\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\r\n        interpolation = 'STEP';\r\n      } else {\r\n        interpolation = 'LINEAR';\r\n      }\r\n\r\n      samplers.push({\r\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\r\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\r\n        interpolation: interpolation\r\n      });\r\n      channels.push({\r\n        sampler: samplers.length - 1,\r\n        target: {\r\n          node: nodeMap.get(trackNode),\r\n          path: trackProperty\r\n        }\r\n      });\r\n    }\r\n\r\n    json.animations.push({\r\n      name: clip.name || 'clip_' + json.animations.length,\r\n      samplers: samplers,\r\n      channels: channels\r\n    });\r\n    return json.animations.length - 1;\r\n  }\r\n  /**\r\n   * @param {THREE.Object3D} object\r\n   * @return {number|null}\r\n   */\r\n\r\n\r\n  processSkin(object) {\r\n    const json = this.json;\r\n    const nodeMap = this.nodeMap;\r\n\r\n    if (json.nodes !== undefined && object instanceof SkinnedMesh) {\r\n      const node = json.nodes[nodeMap.get(object)];\r\n      const skeleton = object.skeleton;\r\n      if (skeleton === undefined) return null;\r\n      const rootJoint = object.skeleton.bones[0];\r\n      if (rootJoint === undefined) return null;\r\n      const joints = [];\r\n      const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\r\n      const temporaryBoneInverse = new Matrix4();\r\n\r\n      for (let i = 0; i < skeleton.bones.length; ++i) {\r\n        joints.push(nodeMap.get(skeleton.bones[i]));\r\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\r\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\r\n      }\r\n\r\n      if (json.skins === undefined) json.skins = [];\r\n      json.skins.push({\r\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\r\n        joints: joints,\r\n        skeleton: nodeMap.get(rootJoint)\r\n      });\r\n      const skinIndex = node.skin = json.skins.length - 1;\r\n      return skinIndex;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n  /**\r\n   * Process Object3D node\r\n   * @param  {THREE.Object3D} node Object3D to processNode\r\n   * @return {Integer} Index of the node in the nodes list\r\n   */\r\n\r\n\r\n  processNode(object) {\r\n    const json = this.json;\r\n    const options = this.options;\r\n    const nodeMap = this.nodeMap;\r\n    if (!json.nodes) json.nodes = [];\r\n    const nodeDef = {};\r\n\r\n    if (options.trs) {\r\n      const rotation = object.quaternion.toArray();\r\n      const position = object.position.toArray();\r\n      const scale = object.scale.toArray();\r\n\r\n      if (!this.equalArray(rotation, [0, 0, 0, 1])) {\r\n        nodeDef.rotation = rotation;\r\n      }\r\n\r\n      if (!this.equalArray(position, [0, 0, 0])) {\r\n        nodeDef.translation = position;\r\n      }\r\n\r\n      if (!this.equalArray(scale, [1, 1, 1])) {\r\n        nodeDef.scale = scale;\r\n      }\r\n    } else {\r\n      if (object.matrixAutoUpdate) {\r\n        object.updateMatrix();\r\n      }\r\n\r\n      if (!this.isIdentityMatrix(object.matrix)) {\r\n        nodeDef.matrix = object.matrix.elements;\r\n      }\r\n    } // We don't export empty strings name because it represents no-name in Three.js.\r\n\r\n\r\n    if (object.name !== '') nodeDef.name = String(object.name);\r\n    this.serializeUserData(object, nodeDef);\r\n\r\n    if ((object instanceof Mesh && object.isMesh || object instanceof Line && object.isLine || object instanceof Points && object.isPoints) && object instanceof Mesh) {\r\n      const meshIndex = this.processMesh(object);\r\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\r\n    } else if (object instanceof Camera && object.isCamera) {\r\n      nodeDef.camera = this.processCamera(object);\r\n    }\r\n\r\n    if (object instanceof SkinnedMesh && object.isSkinnedMesh) this.skins.push(object);\r\n\r\n    if (object.children.length > 0) {\r\n      const children = [];\r\n\r\n      for (let i = 0, l = object.children.length; i < l; i++) {\r\n        const child = object.children[i];\r\n\r\n        if (child.visible || !options.onlyVisible) {\r\n          const nodeIndex = this.processNode(child);\r\n          if (nodeIndex !== null) children.push(nodeIndex);\r\n        }\r\n      }\r\n\r\n      if (children.length > 0) nodeDef.children = children;\r\n    }\r\n\r\n    this._invokeAll(function (ext) {\r\n      ext.writeNode && ext.writeNode(object, nodeDef);\r\n    });\r\n\r\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\r\n    nodeMap.set(object, nodeIndex);\r\n    return nodeIndex;\r\n  }\r\n  /**\r\n   * Process Scene\r\n   * @param  {Scene} node Scene to process\r\n   */\r\n\r\n\r\n  processScene(scene) {\r\n    const json = this.json;\r\n    const options = this.options;\r\n\r\n    if (!json.scenes) {\r\n      json.scenes = [];\r\n      json.scene = 0;\r\n    }\r\n\r\n    const sceneDef = {};\r\n    if (scene.name !== '') sceneDef.name = scene.name;\r\n    json.scenes.push(sceneDef);\r\n    const nodes = [];\r\n\r\n    for (let i = 0, l = scene.children.length; i < l; i++) {\r\n      const child = scene.children[i];\r\n\r\n      if (child.visible || !options.onlyVisible) {\r\n        const nodeIndex = this.processNode(child);\r\n        if (nodeIndex !== null) nodes.push(nodeIndex);\r\n      }\r\n    }\r\n\r\n    if (nodes.length > 0) sceneDef.nodes = nodes;\r\n    this.serializeUserData(scene, sceneDef);\r\n  }\r\n\r\n  processObjects(objects) {\r\n    const scene = new Scene();\r\n    scene.name = 'AuxScene';\r\n\r\n    for (let i = 0; i < objects.length; i++) {\r\n      // We push directly to children instead of calling `add` to prevent\r\n      // modify the .parent and break its original scene and hierarchy\r\n      scene.children.push(objects[i]);\r\n    }\r\n\r\n    this.processScene(scene);\r\n  }\r\n  /**\r\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\r\n   */\r\n\r\n\r\n  processInput(input) {\r\n    const options = this.options;\r\n    input = input instanceof Array ? input : [input];\r\n\r\n    this._invokeAll(function (ext) {\r\n      ext.beforeParse && ext.beforeParse(input);\r\n    });\r\n\r\n    const objectsWithoutScene = [];\r\n\r\n    for (let i = 0; i < input.length; i++) {\r\n      const inputScene = input[i];\r\n\r\n      if (inputScene instanceof Scene) {\r\n        this.processScene(inputScene);\r\n      } else {\r\n        objectsWithoutScene.push(input[i]);\r\n      }\r\n    }\r\n\r\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\r\n\r\n    for (let i = 0; i < this.skins.length; ++i) {\r\n      this.processSkin(this.skins[i]);\r\n    }\r\n\r\n    for (let i = 0; options.animations !== undefined && i < options.animations.length; ++i) {\r\n      this.processAnimation(options.animations[i], input[0]);\r\n    }\r\n\r\n    this._invokeAll(function (ext) {\r\n      ext.afterParse && ext.afterParse(input);\r\n    });\r\n  }\r\n\r\n  _invokeAll(func) {\r\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\r\n      func(this.plugins[i]);\r\n    }\r\n  } //------------------------------------------------------------------------------\r\n  // Utility functions\r\n  //------------------------------------------------------------------------------\r\n\r\n  /**\r\n   * Compare two arrays\r\n   * @param  {Array} array1 Array 1 to compare\r\n   * @param  {Array} array2 Array 2 to compare\r\n   * @return {Boolean}        Returns true if both arrays are equal\r\n   */\r\n\r\n\r\n  equalArray(array1, array2) {\r\n    return array1.length === array2.length && array1.every(function (element, index) {\r\n      return element === array2[index];\r\n    });\r\n  }\r\n  /**\r\n   * Converts a string to an ArrayBuffer.\r\n   * @param  {string} text\r\n   * @return {ArrayBuffer}\r\n   */\r\n\r\n\r\n  stringToArrayBuffer(text) {\r\n    if (window.TextEncoder !== undefined) {\r\n      return new TextEncoder().encode(text).buffer;\r\n    }\r\n\r\n    const array = new Uint8Array(new ArrayBuffer(text.length));\r\n\r\n    for (let i = 0, il = text.length; i < il; i++) {\r\n      const value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\r\n\r\n      array[i] = value > 0xff ? 0x20 : value;\r\n    }\r\n\r\n    return array.buffer;\r\n  }\r\n\r\n  isIdentityMatrix(matrix) {\r\n    return this.equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\r\n  }\r\n\r\n  getMinMax(attribute, start, count) {\r\n    const output = {\r\n      min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\r\n      max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\r\n    };\r\n\r\n    for (let i = start; i < start + count; i++) {\r\n      for (let a = 0; a < attribute.itemSize; a++) {\r\n        let value;\r\n\r\n        if (attribute.itemSize > 4) {\r\n          // no support for interleaved data for itemSize > 4\r\n          value = attribute.array[i * attribute.itemSize + a];\r\n        } else {\r\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\r\n        }\r\n\r\n        if (value !== undefined) {\r\n          output.min[a] = Math.min(output.min[a], value);\r\n          output.max[a] = Math.max(output.max[a], value);\r\n        }\r\n      }\r\n    }\r\n\r\n    return output;\r\n  }\r\n  /**\r\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\r\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\r\n   */\r\n\r\n\r\n  getPaddedBufferSize(bufferSize) {\r\n    return Math.ceil(bufferSize / 4) * 4;\r\n  }\r\n  /**\r\n   * Returns a buffer aligned to 4-byte boundary.\r\n   *\r\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\r\n   * @param {Integer} paddingByte (Optional)\r\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\r\n   */\r\n\r\n\r\n  getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\r\n    const paddedLength = this.getPaddedBufferSize(arrayBuffer.byteLength);\r\n\r\n    if (paddedLength !== arrayBuffer.byteLength) {\r\n      const array = new Uint8Array(paddedLength);\r\n      array.set(new Uint8Array(arrayBuffer));\r\n\r\n      if (paddingByte !== 0) {\r\n        for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\r\n          array[i] = paddingByte;\r\n        }\r\n      }\r\n\r\n      return array.buffer;\r\n    }\r\n\r\n    return arrayBuffer;\r\n  }\r\n\r\n}\r\n/**\r\n * Punctual Lights Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n */\r\n\r\n\r\nclass GLTFLightExtension {\r\n  constructor(writer) {\r\n    _defineProperty(this, \"writer\", void 0);\r\n\r\n    _defineProperty(this, \"name\", void 0);\r\n\r\n    this.writer = writer;\r\n    this.name = 'KHR_lights_punctual';\r\n  }\r\n\r\n  writeNode(light, nodeDef) {\r\n    if (!light.isLight) return;\r\n\r\n    if (!(light instanceof DirectionalLight && light.isDirectionalLight) && // @ts-expect-error\r\n    !(light instanceof PointLight && light.isPointLight) && !(light instanceof SpotLight && light.isSpotLight)) {\r\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\r\n      return;\r\n    }\r\n\r\n    const writer = this.writer;\r\n    const json = writer.json;\r\n    const extensionsUsed = writer.extensionsUsed;\r\n    const lightDef = {};\r\n    if (light.name) lightDef.name = light.name;\r\n    lightDef.color = light.color.toArray();\r\n    lightDef.intensity = light.intensity;\r\n\r\n    if (light instanceof DirectionalLight && light.isDirectionalLight) {\r\n      lightDef.type = 'directional';\r\n    } else if (light instanceof PointLight && // @ts-expect-error\r\n    light.isPointLight) {\r\n      lightDef.type = 'point';\r\n      if (light.distance > 0) lightDef.range = light.distance;\r\n    } else if (light instanceof SpotLight && light.isSpotLight) {\r\n      lightDef.type = 'spot';\r\n      if (light.distance > 0) lightDef.range = light.distance;\r\n      lightDef.spot = {};\r\n      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\r\n      lightDef.spot.outerConeAngle = light.angle;\r\n    }\r\n\r\n    if (!(light instanceof DirectionalLight) && light.decay !== undefined && light.decay !== 2) {\r\n      console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\r\n    }\r\n\r\n    if (!(light instanceof PointLight) && light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\r\n      console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\r\n    }\r\n\r\n    if (!extensionsUsed[this.name]) {\r\n      json.extensions = json.extensions || {};\r\n      json.extensions[this.name] = {\r\n        lights: []\r\n      };\r\n      extensionsUsed[this.name] = true;\r\n    }\r\n\r\n    if (json.extensions !== undefined) {\r\n      const lights = json.extensions[this.name].lights;\r\n      lights.push(lightDef);\r\n      nodeDef.extensions = nodeDef.extensions || {};\r\n      nodeDef.extensions[this.name] = {\r\n        light: lights.length - 1\r\n      };\r\n    }\r\n  }\r\n\r\n}\r\n/**\r\n * Unlit Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n */\r\n\r\n\r\nclass GLTFMaterialsUnlitExtension {\r\n  constructor(writer) {\r\n    _defineProperty(this, \"writer\", void 0);\r\n\r\n    _defineProperty(this, \"name\", void 0);\r\n\r\n    this.writer = writer;\r\n    this.name = 'KHR_materials_unlit';\r\n  }\r\n\r\n  writeMaterial(material, materialDef) {\r\n    if (!(material instanceof MeshBasicMaterial && // @ts-expect-error\r\n    material.isMeshBasicMaterial)) {\r\n      return;\r\n    }\r\n\r\n    const writer = this.writer;\r\n    const extensionsUsed = writer.extensionsUsed;\r\n    materialDef.extensions = materialDef.extensions || {};\r\n    materialDef.extensions[this.name] = {};\r\n    extensionsUsed[this.name] = true;\r\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\r\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\r\n  }\r\n\r\n}\r\n/**\r\n * Specular-Glossiness Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\r\n */\r\n\r\n\r\nclass GLTFMaterialsPBRSpecularGlossiness {\r\n  constructor(writer) {\r\n    _defineProperty(this, \"writer\", void 0);\r\n\r\n    _defineProperty(this, \"name\", void 0);\r\n\r\n    this.writer = writer;\r\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\r\n  }\r\n\r\n  writeMaterial(material, materialDef) {\r\n    // @ts-expect-error\r\n    if (!material.isGLTFSpecularGlossinessMaterial) return;\r\n    const writer = this.writer;\r\n    const extensionsUsed = writer.extensionsUsed;\r\n    const extensionDef = {};\r\n\r\n    if (materialDef.pbrMetallicRoughness.baseColorFactor) {\r\n      extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\r\n    }\r\n\r\n    if (material instanceof MeshPhongMaterial) {\r\n      const specularFactor = [1, 1, 1];\r\n      material.specular.toArray(specularFactor, 0);\r\n      extensionDef.specularFactor = specularFactor;\r\n      extensionDef.glossinessFactor = // @ts-expect-error\r\n      material.glossiness;\r\n    }\r\n\r\n    if (materialDef.pbrMetallicRoughness.baseColorTexture) {\r\n      extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\r\n    }\r\n\r\n    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial) && material.specularMap) {\r\n      const specularMapDef = {\r\n        index: writer.processTexture(material.specularMap)\r\n      };\r\n      writer.applyTextureTransform(specularMapDef, material.specularMap);\r\n      extensionDef.specularGlossinessTexture = specularMapDef;\r\n    }\r\n\r\n    materialDef.extensions = materialDef.extensions || {};\r\n    materialDef.extensions[this.name] = extensionDef;\r\n    extensionsUsed[this.name] = true;\r\n  }\r\n\r\n}\r\n/**\r\n * Transmission Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n */\r\n\r\n\r\nclass GLTFMaterialsTransmissionExtension {\r\n  constructor(writer) {\r\n    _defineProperty(this, \"writer\", void 0);\r\n\r\n    _defineProperty(this, \"name\", void 0);\r\n\r\n    this.writer = writer;\r\n    this.name = 'KHR_materials_transmission';\r\n  }\r\n\r\n  writeMaterial(material, materialDef) {\r\n    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\r\n    material.isMeshPhysicalMaterial) || material.transmission === 0) {\r\n      return;\r\n    }\r\n\r\n    const writer = this.writer;\r\n    const extensionsUsed = writer.extensionsUsed;\r\n    const extensionDef = {};\r\n    extensionDef.transmissionFactor = material.transmission;\r\n\r\n    if (material.transmissionMap) {\r\n      const transmissionMapDef = {\r\n        index: writer.processTexture(material.transmissionMap)\r\n      };\r\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\r\n      extensionDef.transmissionTexture = transmissionMapDef;\r\n    }\r\n\r\n    materialDef.extensions = materialDef.extensions || {};\r\n    materialDef.extensions[this.name] = extensionDef;\r\n    extensionsUsed[this.name] = true;\r\n  }\r\n\r\n}\r\n/**\r\n * Materials Volume Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\r\n */\r\n\r\n\r\nclass GLTFMaterialsVolumeExtension {\r\n  constructor(writer) {\r\n    _defineProperty(this, \"writer\", void 0);\r\n\r\n    _defineProperty(this, \"name\", void 0);\r\n\r\n    this.writer = writer;\r\n    this.name = 'KHR_materials_volume';\r\n  }\r\n\r\n  writeMaterial(material, materialDef) {\r\n    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\r\n    material.isMeshPhysicalMaterial) || material.thickness === 0) {\r\n      return;\r\n    }\r\n\r\n    const writer = this.writer;\r\n    const extensionsUsed = writer.extensionsUsed;\r\n    const extensionDef = {};\r\n    extensionDef.thickness = material.thickness;\r\n\r\n    if (material.thicknessMap) {\r\n      const thicknessMapDef = {\r\n        index: writer.processTexture(material.thicknessMap)\r\n      };\r\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\r\n      extensionDef.thicknessTexture = thicknessMapDef;\r\n    }\r\n\r\n    extensionDef.attenuationDistance = material.attenuationDistance;\r\n    extensionDef.attenuationColor = //@ts-expect-error\r\n    material.attenuationTint.toArray();\r\n    materialDef.extensions = materialDef.extensions || {};\r\n    materialDef.extensions[this.name] = extensionDef;\r\n    extensionsUsed[this.name] = true;\r\n  }\r\n\r\n}\r\n\r\nexport { GLTFExporter };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { BufferGeometry, Mesh, Points } from 'three';\r\n\r\n/**\r\n * Export draco compressed files from threejs geometry objects.\r\n *\r\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\r\n *\r\n * The exporter receives a options object containing\r\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\r\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\r\n *  - encoderMethod\r\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\r\n *  - exportUvs\r\n *  - exportNormals\r\n */\r\n\r\nclass DRACOExporter {\r\n  // Encoder methods\r\n  // Geometry type\r\n  // Attribute type\r\n  parse(object, options = {\r\n    decodeSpeed: 5,\r\n    encodeSpeed: 5,\r\n    encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\r\n    quantization: [16, 8, 8, 8, 8],\r\n    exportUvs: true,\r\n    exportNormals: true,\r\n    exportColor: false\r\n  }) {\r\n    if (object instanceof BufferGeometry && object.isBufferGeometry) {\r\n      throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.');\r\n    }\r\n\r\n    if (DracoEncoderModule === undefined) {\r\n      throw new Error('THREE.DRACOExporter: required the draco_encoder to work.');\r\n    }\r\n\r\n    const geometry = object.geometry;\r\n    const dracoEncoder = DracoEncoderModule();\r\n    const encoder = new dracoEncoder.Encoder();\r\n    let builder;\r\n    let dracoObject;\r\n\r\n    if (!geometry.isBufferGeometry) {\r\n      throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.');\r\n    }\r\n\r\n    if (object instanceof Mesh && object.isMesh) {\r\n      builder = new dracoEncoder.MeshBuilder();\r\n      dracoObject = new dracoEncoder.Mesh();\r\n      const vertices = geometry.getAttribute('position'); // @ts-expect-error\r\n\r\n      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\r\n      const faces = geometry.getIndex();\r\n\r\n      if (faces !== null) {\r\n        // @ts-expect-error\r\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\r\n      } else {\r\n        const faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\r\n\r\n        for (let i = 0; i < faces.length; i++) {\r\n          faces[i] = i;\r\n        }\r\n\r\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces);\r\n      }\r\n\r\n      if (options.exportNormals) {\r\n        const normals = geometry.getAttribute('normal');\r\n\r\n        if (normals !== undefined) {\r\n          // @ts-expect-error\r\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\r\n        }\r\n      }\r\n\r\n      if (options.exportUvs) {\r\n        const uvs = geometry.getAttribute('uv');\r\n\r\n        if (uvs !== undefined) {\r\n          // @ts-expect-error\r\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\r\n        }\r\n      }\r\n\r\n      if (options.exportColor) {\r\n        const colors = geometry.getAttribute('color');\r\n\r\n        if (colors !== undefined) {\r\n          // @ts-expect-error\r\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\r\n        }\r\n      }\r\n    } else if (object instanceof Points && object.isPoints) {\r\n      // @ts-expect-error\r\n      builder = new dracoEncoder.PointCloudBuilder(); // @ts-expect-error\r\n\r\n      dracoObject = new dracoEncoder.PointCloud();\r\n      const vertices = geometry.getAttribute('position');\r\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\r\n\r\n      if (options.exportColor) {\r\n        const colors = geometry.getAttribute('color');\r\n\r\n        if (colors !== undefined) {\r\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\r\n        }\r\n      }\r\n    } else {\r\n      throw new Error('DRACOExporter: Unsupported object type.');\r\n    } //Compress using draco encoder\r\n\r\n\r\n    const encodedData = new dracoEncoder.DracoInt8Array(); //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\r\n\r\n    const encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5;\r\n    const decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5;\r\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed); // Sets the desired encoding method for a given geometry.\r\n\r\n    if (options.encoderMethod !== undefined) {\r\n      encoder.SetEncodingMethod(options.encoderMethod);\r\n    } // Sets the quantization (number of bits used to represent) compression options for a named attribute.\r\n    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\r\n\r\n\r\n    if (options.quantization !== undefined) {\r\n      for (let i = 0; i < 5; i++) {\r\n        if (options.quantization[i] !== undefined) {\r\n          encoder.SetAttributeQuantization(i, options.quantization[i]);\r\n        }\r\n      }\r\n    }\r\n\r\n    let length;\r\n\r\n    if (object instanceof Mesh && object.isMesh) {\r\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\r\n    } else {\r\n      // @ts-expect-error\r\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\r\n    }\r\n\r\n    dracoEncoder.destroy(dracoObject);\r\n\r\n    if (length === 0) {\r\n      throw new Error('THREE.DRACOExporter: Draco encoding failed.');\r\n    } //Copy encoded data to buffer.\r\n\r\n\r\n    const outputData = new Int8Array(new ArrayBuffer(length));\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      outputData[i] = encodedData.GetValue(i);\r\n    }\r\n\r\n    dracoEncoder.destroy(encodedData);\r\n    dracoEncoder.destroy(encoder);\r\n    dracoEncoder.destroy(builder);\r\n    return outputData;\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(DRACOExporter, \"MESH_EDGEBREAKER_ENCODING\", 1);\r\n\r\n_defineProperty(DRACOExporter, \"MESH_SEQUENTIAL_ENCODING\", 0);\r\n\r\n_defineProperty(DRACOExporter, \"POINT_CLOUD\", 0);\r\n\r\n_defineProperty(DRACOExporter, \"TRIANGULAR_MESH\", 1);\r\n\r\n_defineProperty(DRACOExporter, \"INVALID\", -1);\r\n\r\n_defineProperty(DRACOExporter, \"POSITION\", 0);\r\n\r\n_defineProperty(DRACOExporter, \"NORMAL\", 1);\r\n\r\n_defineProperty(DRACOExporter, \"COLOR\", 2);\r\n\r\n_defineProperty(DRACOExporter, \"TEX_COORD\", 3);\r\n\r\n_defineProperty(DRACOExporter, \"GENERIC\", 4);\r\n\r\nexport { DRACOExporter };\r\n", "import { NumberKeyframeTrack, AnimationClip, Vector3, VectorKeyframeTrack, BooleanKeyframeTrack, ColorKeyframeTrack } from 'three';\r\n\r\nconst AnimationClipCreator = () => {};\r\n\r\nAnimationClipCreator.CreateRotationAnimation = (period, axis) => {\r\n  const times = [0, period],\r\n        values = [0, 360];\r\n  axis = axis || 'x';\r\n  const trackName = `.rotation[${axis}]`;\r\n  const track = new NumberKeyframeTrack(trackName, times, values);\r\n  return new AnimationClip(null, period, [track]);\r\n};\r\n\r\nAnimationClipCreator.CreateScaleAxisAnimation = (period, axis) => {\r\n  const times = [0, period],\r\n        values = [0, 1];\r\n  axis = axis || 'x';\r\n  const trackName = `.scale[${axis}]`;\r\n  const track = new NumberKeyframeTrack(trackName, times, values);\r\n  return new AnimationClip(null, period, [track]);\r\n};\r\n\r\nAnimationClipCreator.CreateShakeAnimation = (duration, shakeScale) => {\r\n  const times = [],\r\n        values = [],\r\n        tmp = new Vector3();\r\n\r\n  for (let i = 0; i < duration * 10; i++) {\r\n    times.push(i / 10);\r\n    tmp.set(Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0).multiply(shakeScale).toArray(values, values.length);\r\n  }\r\n\r\n  const trackName = '.position';\r\n  const track = new VectorKeyframeTrack(trackName, times, values);\r\n  return new AnimationClip(null, duration, [track]);\r\n};\r\n\r\nAnimationClipCreator.CreatePulsationAnimation = (duration, pulseScale) => {\r\n  const times = [],\r\n        values = [],\r\n        tmp = new Vector3();\r\n\r\n  for (let i = 0; i < duration * 10; i++) {\r\n    times.push(i / 10);\r\n    const scaleFactor = Math.random() * pulseScale;\r\n    tmp.set(scaleFactor, scaleFactor, scaleFactor).toArray(values, values.length);\r\n  }\r\n\r\n  const trackName = '.scale';\r\n  const track = new VectorKeyframeTrack(trackName, times, values);\r\n  return new AnimationClip(null, duration, [track]);\r\n};\r\n\r\nAnimationClipCreator.CreateVisibilityAnimation = duration => {\r\n  const times = [0, duration / 2, duration],\r\n        values = [true, false, true];\r\n  const trackName = '.visible';\r\n  const track = new BooleanKeyframeTrack(trackName, times, values);\r\n  return new AnimationClip(null, duration, [track]);\r\n};\r\n\r\nAnimationClipCreator.CreateMaterialColorAnimation = (duration, colors) => {\r\n  const times = [],\r\n        values = [],\r\n        timeStep = duration / colors.length;\r\n\r\n  for (let i = 0; i <= colors.length; i++) {\r\n    times.push(i * timeStep);\r\n    values.push(colors[i % colors.length]);\r\n  }\r\n\r\n  const trackName = '.material[0].color';\r\n  const track = new ColorKeyframeTrack(trackName, times, values);\r\n  return new AnimationClip(null, duration, [track]);\r\n};\r\n\r\nexport { AnimationClipCreator };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { Object3D, Matrix4, Vector3, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, Mesh, Line, Quaternion, BufferGeometry, BufferAttribute } from 'three';\r\n\r\nclass CCDIKHelper extends Object3D {\r\n  constructor(mesh, iks = [], sphereSize = 0.25) {\r\n    super();\r\n\r\n    _defineProperty(this, \"_m\", new Matrix4());\r\n\r\n    _defineProperty(this, \"_v\", new Vector3());\r\n\r\n    this.root = mesh;\r\n    this.iks = iks;\r\n    this.matrix.copy(mesh.matrixWorld);\r\n    this.matrixAutoUpdate = false;\r\n    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);\r\n    this.targetSphereMaterial = new MeshBasicMaterial({\r\n      color: new Color(0xff8888),\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      transparent: true\r\n    });\r\n    this.effectorSphereMaterial = new MeshBasicMaterial({\r\n      color: new Color(0x88ff88),\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      transparent: true\r\n    });\r\n    this.linkSphereMaterial = new MeshBasicMaterial({\r\n      color: new Color(0x8888ff),\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      transparent: true\r\n    });\r\n    this.lineMaterial = new LineBasicMaterial({\r\n      color: new Color(0xff0000),\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      transparent: true\r\n    });\r\n\r\n    function createLineGeometry(ik) {\r\n      const geometry = new BufferGeometry();\r\n      const vertices = new Float32Array((2 + ik.links.length) * 3);\r\n      geometry.setAttribute('position', new BufferAttribute(vertices, 3));\r\n      return geometry;\r\n    }\r\n\r\n    const scope = this;\r\n\r\n    function createTargetMesh() {\r\n      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\r\n    }\r\n\r\n    function createEffectorMesh() {\r\n      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\r\n    }\r\n\r\n    function createLinkMesh() {\r\n      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\r\n    }\r\n\r\n    function createLine(ik) {\r\n      return new Line(createLineGeometry(ik), scope.lineMaterial);\r\n    }\r\n\r\n    for (let i = 0, il = iks.length; i < il; i++) {\r\n      const ik = iks[i];\r\n      this.add(createTargetMesh());\r\n      this.add(createEffectorMesh());\r\n\r\n      for (let j = 0, jl = ik.links.length; j < jl; j++) {\r\n        this.add(createLinkMesh());\r\n      }\r\n\r\n      this.add(createLine(ik));\r\n    }\r\n  }\r\n\r\n  _getPosition(bone, matrixWorldInv) {\r\n    return this._v.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\r\n  }\r\n\r\n  _setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\r\n    const v = this._getPosition(bone, matrixWorldInv);\r\n\r\n    array[index * 3 + 0] = v.x;\r\n    array[index * 3 + 1] = v.y;\r\n    array[index * 3 + 2] = v.z;\r\n  }\r\n\r\n  updateMatrixWorld(force) {\r\n    const mesh = this.root;\r\n\r\n    if (this.visible) {\r\n      let offset = 0;\r\n      const iks = this.iks;\r\n      const bones = mesh.skeleton.bones;\r\n\r\n      this._m.copy(mesh.matrixWorld).invert();\r\n\r\n      for (let i = 0, il = iks.length; i < il; i++) {\r\n        const ik = iks[i];\r\n        const targetBone = bones[ik.target];\r\n        const effectorBone = bones[ik.effector];\r\n        const targetMesh = this.children[offset++];\r\n        const effectorMesh = this.children[offset++];\r\n        targetMesh.position.copy(this._getPosition(targetBone, this._m));\r\n        effectorMesh.position.copy(this._getPosition(effectorBone, this._m));\r\n\r\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\r\n          const link = ik.links[j];\r\n          const linkBone = bones[link.index];\r\n          const linkMesh = this.children[offset++];\r\n          linkMesh.position.copy(this._getPosition(linkBone, this._m));\r\n        }\r\n\r\n        const line = this.children[offset++];\r\n        const array = line.geometry.attributes.position.array;\r\n\r\n        this._setPositionOfBoneToAttributeArray(array, 0, targetBone, this._m);\r\n\r\n        this._setPositionOfBoneToAttributeArray(array, 1, effectorBone, this._m);\r\n\r\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\r\n          const link = ik.links[j];\r\n          const linkBone = bones[link.index];\r\n\r\n          this._setPositionOfBoneToAttributeArray(array, j + 2, linkBone, this._m);\r\n        }\r\n\r\n        line.geometry.attributes.position.needsUpdate = true;\r\n      }\r\n    }\r\n\r\n    this.matrix.copy(mesh.matrixWorld);\r\n    super.updateMatrixWorld(force);\r\n  }\r\n\r\n}\r\n/**\r\n * CCD Algorithm\r\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\r\n *\r\n * // ik parameter example\r\n * //\r\n * // target, effector, index in links are bone index in skeleton.bones.\r\n * // the bones relation should be\r\n * // <-- parent                                  child -->\r\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\r\n * iks = [ {\r\n *\ttarget: 1,\r\n *\teffector: 2,\r\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\r\n *\titeration: 10,\r\n *\tminAngle: 0.0,\r\n *\tmaxAngle: 1.0,\r\n * } ];\r\n */\r\n\r\n\r\nclass CCDIKSolver {\r\n  constructor(mesh, iks) {\r\n    _defineProperty(this, \"q\", new Quaternion());\r\n\r\n    _defineProperty(this, \"targetPos\", new Vector3());\r\n\r\n    _defineProperty(this, \"targetVec\", new Vector3());\r\n\r\n    _defineProperty(this, \"effectorPos\", new Vector3());\r\n\r\n    _defineProperty(this, \"effectorVec\", new Vector3());\r\n\r\n    _defineProperty(this, \"linkPos\", new Vector3());\r\n\r\n    _defineProperty(this, \"invLinkQ\", new Quaternion());\r\n\r\n    _defineProperty(this, \"linkScale\", new Vector3());\r\n\r\n    _defineProperty(this, \"axis\", new Vector3());\r\n\r\n    _defineProperty(this, \"vector\", new Vector3());\r\n\r\n    this.mesh = mesh;\r\n    this.iks = iks;\r\n    const bones = this.mesh.skeleton.bones;\r\n\r\n    for (let i = 0, il = this.iks.length; i < il; i++) {\r\n      const ik = this.iks[i];\r\n      const effector = bones[ik.effector];\r\n      const links = ik.links;\r\n      let link0, link1;\r\n      link0 = effector;\r\n\r\n      for (let j = 0, jl = links.length; j < jl; j++) {\r\n        link1 = bones[links[j].index];\r\n\r\n        if (link0.parent !== link1) {\r\n          console.warn(`THREE.CCDIKSolver: bone ${link0.name} is not the child of bone ${link1.name}`);\r\n        }\r\n\r\n        link0 = link1;\r\n      }\r\n    }\r\n  }\r\n\r\n  update() {\r\n    const bones = this.mesh.skeleton.bones;\r\n    const iks = this.iks; // for reference overhead reduction in loop\r\n\r\n    const math = Math;\r\n\r\n    for (let i = 0, il = iks.length; i < il; i++) {\r\n      const ik = iks[i];\r\n      const effector = bones[ik.effector];\r\n      const target = bones[ik.target]; // don't use getWorldPosition() here for the performance\r\n      // because it calls updateMatrixWorld( true ) inside.\r\n\r\n      this.targetPos.setFromMatrixPosition(target.matrixWorld);\r\n      const links = ik.links;\r\n      const iteration = ik.iteration !== undefined ? ik.iteration : 1;\r\n\r\n      for (let j = 0; j < iteration; j++) {\r\n        let rotated = false;\r\n\r\n        for (let k = 0, kl = links.length; k < kl; k++) {\r\n          const link = bones[links[k].index]; // skip this link and following links.\r\n          // this skip is used for MMD performance optimization.\r\n\r\n          if (links[k].enabled === false) break;\r\n          const limitation = links[k].limitation;\r\n          const rotationMin = links[k].rotationMin;\r\n          const rotationMax = links[k].rotationMax; // don't use getWorldPosition/Quaternion() here for the performance\r\n          // because they call updateMatrixWorld( true ) inside.\r\n\r\n          link.matrixWorld.decompose(this.linkPos, this.invLinkQ, this.linkScale);\r\n          this.invLinkQ.invert();\r\n          this.effectorPos.setFromMatrixPosition(effector.matrixWorld); // work in link world\r\n\r\n          this.effectorVec.subVectors(this.effectorPos, this.linkPos);\r\n          this.effectorVec.applyQuaternion(this.invLinkQ);\r\n          this.effectorVec.normalize();\r\n          this.targetVec.subVectors(this.targetPos, this.linkPos);\r\n          this.targetVec.applyQuaternion(this.invLinkQ);\r\n          this.targetVec.normalize();\r\n          let angle = this.targetVec.dot(this.effectorVec);\r\n\r\n          if (angle > 1.0) {\r\n            angle = 1.0;\r\n          } else if (angle < -1.0) {\r\n            angle = -1.0;\r\n          }\r\n\r\n          angle = math.acos(angle); // skip if changing angle is too small to prevent vibration of bone\r\n          // Refer to http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\r\n\r\n          if (angle < 1e-5) continue;\r\n\r\n          if (ik.minAngle !== undefined && angle < ik.minAngle) {\r\n            angle = ik.minAngle;\r\n          }\r\n\r\n          if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\r\n            angle = ik.maxAngle;\r\n          }\r\n\r\n          this.axis.crossVectors(this.effectorVec, this.targetVec);\r\n          this.axis.normalize();\r\n          this.q.setFromAxisAngle(this.axis, angle);\r\n          link.quaternion.multiply(this.q); // TODO: re-consider the limitation specification\r\n\r\n          if (limitation !== undefined) {\r\n            let c = link.quaternion.w;\r\n            if (c > 1.0) c = 1.0;\r\n            const c2 = math.sqrt(1 - c * c);\r\n            link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\r\n          }\r\n\r\n          if (rotationMin !== undefined) {\r\n            link.rotation.setFromVector3(this.vector.setFromEuler(link.rotation).max(rotationMin));\r\n          }\r\n\r\n          if (rotationMax !== undefined) {\r\n            link.rotation.setFromVector3(this.vector.setFromEuler(link.rotation).min(rotationMax));\r\n          }\r\n\r\n          link.updateMatrixWorld(true);\r\n          rotated = true;\r\n        }\r\n\r\n        if (!rotated) break;\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  createHelper() {\r\n    return new CCDIKHelper(this.mesh, this.mesh.geometry.userData.MMD.iks);\r\n  }\r\n\r\n}\r\n\r\nexport { CCDIKHelper, CCDIKSolver };\r\n", "import { Object3D, Vector3, Quaternion, Matrix4, Mesh, Euler, Bone, MeshBasicMaterial, Color, BoxGeometry, SphereGeometry, CylinderGeometry } from 'three';\r\n\r\n/**\r\n * Dependencies\r\n *  - Ammo.js https://github.com/kripken/ammo.js\r\n *\r\n * MMDPhysics calculates physics with Ammo(Bullet based JavaScript Physics engine)\r\n * for MMD model loaded by MMDLoader.\r\n *\r\n * TODO\r\n *  - Physics in Worker\r\n */\r\n\r\n/* global Ammo */\r\n\r\nconst MMDPhysics = (() => {\r\n  /**\r\n   * @param {THREE.SkinnedMesh} mesh\r\n   * @param {Array<Object>} rigidBodyParams\r\n   * @param {Array<Object>} (optional) constraintParams\r\n   * @param {Object} params - (optional)\r\n   * @param {Number} params.unitStep - Default is 1 / 65.\r\n   * @param {Integer} params.maxStepNum - Default is 3.\r\n   * @param {Vector3} params.gravity - Default is ( 0, - 9.8 * 10, 0 )\r\n   */\r\n  function MMDPhysics(mesh, rigidBodyParams, constraintParams, params) {\r\n    if (typeof Ammo === 'undefined') {\r\n      throw new Error('THREE.MMDPhysics: Import ammo.js https://github.com/kripken/ammo.js');\r\n    }\r\n\r\n    constraintParams = constraintParams || [];\r\n    params = params || {};\r\n    this.manager = new ResourceManager();\r\n    this.mesh = mesh;\r\n    /*\r\n     * I don't know why but 1/60 unitStep easily breaks models\r\n     * so I set it 1/65 so far.\r\n     * Don't set too small unitStep because\r\n     * the smaller unitStep can make the performance worse.\r\n     */\r\n\r\n    this.unitStep = params.unitStep !== undefined ? params.unitStep : 1 / 65;\r\n    this.maxStepNum = params.maxStepNum !== undefined ? params.maxStepNum : 3;\r\n    this.gravity = new Vector3(0, -9.8 * 10, 0);\r\n    if (params.gravity !== undefined) this.gravity.copy(params.gravity);\r\n    this.world = params.world !== undefined ? params.world : null; // experimental\r\n\r\n    this.bodies = [];\r\n    this.constraints = [];\r\n\r\n    this._init(mesh, rigidBodyParams, constraintParams);\r\n  }\r\n\r\n  MMDPhysics.prototype = {\r\n    constructor: MMDPhysics,\r\n\r\n    /**\r\n     * Advances Physics calculation and updates bones.\r\n     *\r\n     * @param {Number} delta - time in second\r\n     * @return {MMDPhysics}\r\n     */\r\n    update: function (delta) {\r\n      const manager = this.manager;\r\n      const mesh = this.mesh; // rigid bodies and constrains are for\r\n      // mesh's world scale (1, 1, 1).\r\n      // Convert to (1, 1, 1) if it isn't.\r\n\r\n      let isNonDefaultScale = false;\r\n      const position = manager.allocThreeVector3();\r\n      const quaternion = manager.allocThreeQuaternion();\r\n      const scale = manager.allocThreeVector3();\r\n      mesh.matrixWorld.decompose(position, quaternion, scale);\r\n\r\n      if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {\r\n        isNonDefaultScale = true;\r\n      }\r\n\r\n      let parent;\r\n\r\n      if (isNonDefaultScale) {\r\n        parent = mesh.parent;\r\n        if (parent !== null) mesh.parent = null;\r\n        scale.copy(this.mesh.scale);\r\n        mesh.scale.set(1, 1, 1);\r\n        mesh.updateMatrixWorld(true);\r\n      } // calculate physics and update bones\r\n\r\n\r\n      this._updateRigidBodies();\r\n\r\n      this._stepSimulation(delta);\r\n\r\n      this._updateBones(); // restore mesh if converted above\r\n\r\n\r\n      if (isNonDefaultScale) {\r\n        if (parent !== null) mesh.parent = parent;\r\n        mesh.scale.copy(scale);\r\n      }\r\n\r\n      manager.freeThreeVector3(scale);\r\n      manager.freeThreeQuaternion(quaternion);\r\n      manager.freeThreeVector3(position);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Resets rigid bodies transorm to current bone's.\r\n     *\r\n     * @return {MMDPhysics}\r\n     */\r\n    reset: function () {\r\n      for (let i = 0, il = this.bodies.length; i < il; i++) {\r\n        this.bodies[i].reset();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Warm ups Rigid bodies. Calculates cycles steps.\r\n     *\r\n     * @param {Integer} cycles\r\n     * @return {MMDPhysics}\r\n     */\r\n    warmup: function (cycles) {\r\n      for (let i = 0; i < cycles; i++) {\r\n        this.update(1 / 60);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets gravity.\r\n     *\r\n     * @param {Vector3} gravity\r\n     * @return {MMDPhysicsHelper}\r\n     */\r\n    setGravity: function (gravity) {\r\n      this.world.setGravity(new Ammo.btVector3(gravity.x, gravity.y, gravity.z));\r\n      this.gravity.copy(gravity);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Creates MMDPhysicsHelper\r\n     *\r\n     * @return {MMDPhysicsHelper}\r\n     */\r\n    createHelper: function () {\r\n      return new MMDPhysicsHelper(this.mesh, this);\r\n    },\r\n    // private methods\r\n    _init: function (mesh, rigidBodyParams, constraintParams) {\r\n      const manager = this.manager; // rigid body/constraint parameters are for\r\n      // mesh's default world transform as position(0, 0, 0),\r\n      // quaternion(0, 0, 0, 1) and scale(0, 0, 0)\r\n\r\n      let parent = mesh.parent;\r\n      if (parent !== null) parent = null;\r\n      const currentPosition = manager.allocThreeVector3();\r\n      const currentQuaternion = manager.allocThreeQuaternion();\r\n      const currentScale = manager.allocThreeVector3();\r\n      currentPosition.copy(mesh.position);\r\n      currentQuaternion.copy(mesh.quaternion);\r\n      currentScale.copy(mesh.scale);\r\n      mesh.position.set(0, 0, 0);\r\n      mesh.quaternion.set(0, 0, 0, 1);\r\n      mesh.scale.set(1, 1, 1);\r\n      mesh.updateMatrixWorld(true);\r\n\r\n      if (this.world === null) {\r\n        this.world = this._createWorld();\r\n        this.setGravity(this.gravity);\r\n      }\r\n\r\n      this._initRigidBodies(rigidBodyParams);\r\n\r\n      this._initConstraints(constraintParams);\r\n\r\n      if (parent !== null) mesh.parent = parent;\r\n      mesh.position.copy(currentPosition);\r\n      mesh.quaternion.copy(currentQuaternion);\r\n      mesh.scale.copy(currentScale);\r\n      mesh.updateMatrixWorld(true);\r\n      this.reset();\r\n      manager.freeThreeVector3(currentPosition);\r\n      manager.freeThreeQuaternion(currentQuaternion);\r\n      manager.freeThreeVector3(currentScale);\r\n    },\r\n    _createWorld: function () {\r\n      const config = new Ammo.btDefaultCollisionConfiguration();\r\n      const dispatcher = new Ammo.btCollisionDispatcher(config);\r\n      const cache = new Ammo.btDbvtBroadphase();\r\n      const solver = new Ammo.btSequentialImpulseConstraintSolver();\r\n      const world = new Ammo.btDiscreteDynamicsWorld(dispatcher, cache, solver, config);\r\n      return world;\r\n    },\r\n    _initRigidBodies: function (rigidBodies) {\r\n      for (let i = 0, il = rigidBodies.length; i < il; i++) {\r\n        this.bodies.push(new RigidBody(this.mesh, this.world, rigidBodies[i], this.manager));\r\n      }\r\n    },\r\n    _initConstraints: function (constraints) {\r\n      for (let i = 0, il = constraints.length; i < il; i++) {\r\n        const params = constraints[i];\r\n        const bodyA = this.bodies[params.rigidBodyIndex1];\r\n        const bodyB = this.bodies[params.rigidBodyIndex2];\r\n        this.constraints.push(new Constraint(this.mesh, this.world, bodyA, bodyB, params, this.manager));\r\n      }\r\n    },\r\n    _stepSimulation: function (delta) {\r\n      const unitStep = this.unitStep;\r\n      let stepTime = delta;\r\n      let maxStepNum = (delta / unitStep | 0) + 1;\r\n\r\n      if (stepTime < unitStep) {\r\n        stepTime = unitStep;\r\n        maxStepNum = 1;\r\n      }\r\n\r\n      if (maxStepNum > this.maxStepNum) {\r\n        maxStepNum = this.maxStepNum;\r\n      }\r\n\r\n      this.world.stepSimulation(stepTime, maxStepNum, unitStep);\r\n    },\r\n    _updateRigidBodies: function () {\r\n      for (let i = 0, il = this.bodies.length; i < il; i++) {\r\n        this.bodies[i].updateFromBone();\r\n      }\r\n    },\r\n    _updateBones: function () {\r\n      for (let i = 0, il = this.bodies.length; i < il; i++) {\r\n        this.bodies[i].updateBone();\r\n      }\r\n    }\r\n  };\r\n  /**\r\n   * This manager's responsibilies are\r\n   *\r\n   * 1. manage Ammo.js and Three.js object resources and\r\n   *    improve the performance and the memory consumption by\r\n   *    reusing objects.\r\n   *\r\n   * 2. provide simple Ammo object operations.\r\n   */\r\n\r\n  function ResourceManager() {\r\n    // for Three.js\r\n    this.threeVector3s = [];\r\n    this.threeMatrix4s = [];\r\n    this.threeQuaternions = [];\r\n    this.threeEulers = []; // for Ammo.js\r\n\r\n    this.transforms = [];\r\n    this.quaternions = [];\r\n    this.vector3s = [];\r\n  }\r\n\r\n  ResourceManager.prototype = {\r\n    constructor: ResourceManager,\r\n    allocThreeVector3: function () {\r\n      return this.threeVector3s.length > 0 ? this.threeVector3s.pop() : new Vector3();\r\n    },\r\n    freeThreeVector3: function (v) {\r\n      this.threeVector3s.push(v);\r\n    },\r\n    allocThreeMatrix4: function () {\r\n      return this.threeMatrix4s.length > 0 ? this.threeMatrix4s.pop() : new Matrix4();\r\n    },\r\n    freeThreeMatrix4: function (m) {\r\n      this.threeMatrix4s.push(m);\r\n    },\r\n    allocThreeQuaternion: function () {\r\n      return this.threeQuaternions.length > 0 ? this.threeQuaternions.pop() : new Quaternion();\r\n    },\r\n    freeThreeQuaternion: function (q) {\r\n      this.threeQuaternions.push(q);\r\n    },\r\n    allocThreeEuler: function () {\r\n      return this.threeEulers.length > 0 ? this.threeEulers.pop() : new Euler();\r\n    },\r\n    freeThreeEuler: function (e) {\r\n      this.threeEulers.push(e);\r\n    },\r\n    allocTransform: function () {\r\n      return this.transforms.length > 0 ? this.transforms.pop() : new Ammo.btTransform();\r\n    },\r\n    freeTransform: function (t) {\r\n      this.transforms.push(t);\r\n    },\r\n    allocQuaternion: function () {\r\n      return this.quaternions.length > 0 ? this.quaternions.pop() : new Ammo.btQuaternion();\r\n    },\r\n    freeQuaternion: function (q) {\r\n      this.quaternions.push(q);\r\n    },\r\n    allocVector3: function () {\r\n      return this.vector3s.length > 0 ? this.vector3s.pop() : new Ammo.btVector3();\r\n    },\r\n    freeVector3: function (v) {\r\n      this.vector3s.push(v);\r\n    },\r\n    setIdentity: function (t) {\r\n      t.setIdentity();\r\n    },\r\n    getBasis: function (t) {\r\n      const q = this.allocQuaternion();\r\n      t.getBasis().getRotation(q);\r\n      return q;\r\n    },\r\n    getBasisAsMatrix3: function (t) {\r\n      const q = this.getBasis(t);\r\n      const m = this.quaternionToMatrix3(q);\r\n      this.freeQuaternion(q);\r\n      return m;\r\n    },\r\n    getOrigin: function (t) {\r\n      return t.getOrigin();\r\n    },\r\n    setOrigin: function (t, v) {\r\n      t.getOrigin().setValue(v.x(), v.y(), v.z());\r\n    },\r\n    copyOrigin: function (t1, t2) {\r\n      const o = t2.getOrigin();\r\n      this.setOrigin(t1, o);\r\n    },\r\n    setBasis: function (t, q) {\r\n      t.setRotation(q);\r\n    },\r\n    setBasisFromMatrix3: function (t, m) {\r\n      const q = this.matrix3ToQuaternion(m);\r\n      this.setBasis(t, q);\r\n      this.freeQuaternion(q);\r\n    },\r\n    setOriginFromArray3: function (t, a) {\r\n      t.getOrigin().setValue(a[0], a[1], a[2]);\r\n    },\r\n    setOriginFromThreeVector3: function (t, v) {\r\n      t.getOrigin().setValue(v.x, v.y, v.z);\r\n    },\r\n    setBasisFromArray3: function (t, a) {\r\n      const thQ = this.allocThreeQuaternion();\r\n      const thE = this.allocThreeEuler();\r\n      thE.set(a[0], a[1], a[2]);\r\n      this.setBasisFromThreeQuaternion(t, thQ.setFromEuler(thE));\r\n      this.freeThreeEuler(thE);\r\n      this.freeThreeQuaternion(thQ);\r\n    },\r\n    setBasisFromThreeQuaternion: function (t, a) {\r\n      const q = this.allocQuaternion();\r\n      q.setX(a.x);\r\n      q.setY(a.y);\r\n      q.setZ(a.z);\r\n      q.setW(a.w);\r\n      this.setBasis(t, q);\r\n      this.freeQuaternion(q);\r\n    },\r\n    multiplyTransforms: function (t1, t2) {\r\n      const t = this.allocTransform();\r\n      this.setIdentity(t);\r\n      const m1 = this.getBasisAsMatrix3(t1);\r\n      const m2 = this.getBasisAsMatrix3(t2);\r\n      const o1 = this.getOrigin(t1);\r\n      const o2 = this.getOrigin(t2);\r\n      const v1 = this.multiplyMatrix3ByVector3(m1, o2);\r\n      const v2 = this.addVector3(v1, o1);\r\n      this.setOrigin(t, v2);\r\n      const m3 = this.multiplyMatrices3(m1, m2);\r\n      this.setBasisFromMatrix3(t, m3);\r\n      this.freeVector3(v1);\r\n      this.freeVector3(v2);\r\n      return t;\r\n    },\r\n    inverseTransform: function (t) {\r\n      const t2 = this.allocTransform();\r\n      const m1 = this.getBasisAsMatrix3(t);\r\n      const o = this.getOrigin(t);\r\n      const m2 = this.transposeMatrix3(m1);\r\n      const v1 = this.negativeVector3(o);\r\n      const v2 = this.multiplyMatrix3ByVector3(m2, v1);\r\n      this.setOrigin(t2, v2);\r\n      this.setBasisFromMatrix3(t2, m2);\r\n      this.freeVector3(v1);\r\n      this.freeVector3(v2);\r\n      return t2;\r\n    },\r\n    multiplyMatrices3: function (m1, m2) {\r\n      const m3 = [];\r\n      const v10 = this.rowOfMatrix3(m1, 0);\r\n      const v11 = this.rowOfMatrix3(m1, 1);\r\n      const v12 = this.rowOfMatrix3(m1, 2);\r\n      const v20 = this.columnOfMatrix3(m2, 0);\r\n      const v21 = this.columnOfMatrix3(m2, 1);\r\n      const v22 = this.columnOfMatrix3(m2, 2);\r\n      m3[0] = this.dotVectors3(v10, v20);\r\n      m3[1] = this.dotVectors3(v10, v21);\r\n      m3[2] = this.dotVectors3(v10, v22);\r\n      m3[3] = this.dotVectors3(v11, v20);\r\n      m3[4] = this.dotVectors3(v11, v21);\r\n      m3[5] = this.dotVectors3(v11, v22);\r\n      m3[6] = this.dotVectors3(v12, v20);\r\n      m3[7] = this.dotVectors3(v12, v21);\r\n      m3[8] = this.dotVectors3(v12, v22);\r\n      this.freeVector3(v10);\r\n      this.freeVector3(v11);\r\n      this.freeVector3(v12);\r\n      this.freeVector3(v20);\r\n      this.freeVector3(v21);\r\n      this.freeVector3(v22);\r\n      return m3;\r\n    },\r\n    addVector3: function (v1, v2) {\r\n      const v = this.allocVector3();\r\n      v.setValue(v1.x() + v2.x(), v1.y() + v2.y(), v1.z() + v2.z());\r\n      return v;\r\n    },\r\n    dotVectors3: function (v1, v2) {\r\n      return v1.x() * v2.x() + v1.y() * v2.y() + v1.z() * v2.z();\r\n    },\r\n    rowOfMatrix3: function (m, i) {\r\n      const v = this.allocVector3();\r\n      v.setValue(m[i * 3 + 0], m[i * 3 + 1], m[i * 3 + 2]);\r\n      return v;\r\n    },\r\n    columnOfMatrix3: function (m, i) {\r\n      const v = this.allocVector3();\r\n      v.setValue(m[i + 0], m[i + 3], m[i + 6]);\r\n      return v;\r\n    },\r\n    negativeVector3: function (v) {\r\n      const v2 = this.allocVector3();\r\n      v2.setValue(-v.x(), -v.y(), -v.z());\r\n      return v2;\r\n    },\r\n    multiplyMatrix3ByVector3: function (m, v) {\r\n      const v4 = this.allocVector3();\r\n      const v0 = this.rowOfMatrix3(m, 0);\r\n      const v1 = this.rowOfMatrix3(m, 1);\r\n      const v2 = this.rowOfMatrix3(m, 2);\r\n      const x = this.dotVectors3(v0, v);\r\n      const y = this.dotVectors3(v1, v);\r\n      const z = this.dotVectors3(v2, v);\r\n      v4.setValue(x, y, z);\r\n      this.freeVector3(v0);\r\n      this.freeVector3(v1);\r\n      this.freeVector3(v2);\r\n      return v4;\r\n    },\r\n    transposeMatrix3: function (m) {\r\n      const m2 = [];\r\n      m2[0] = m[0];\r\n      m2[1] = m[3];\r\n      m2[2] = m[6];\r\n      m2[3] = m[1];\r\n      m2[4] = m[4];\r\n      m2[5] = m[7];\r\n      m2[6] = m[2];\r\n      m2[7] = m[5];\r\n      m2[8] = m[8];\r\n      return m2;\r\n    },\r\n    quaternionToMatrix3: function (q) {\r\n      const m = [];\r\n      const x = q.x();\r\n      const y = q.y();\r\n      const z = q.z();\r\n      const w = q.w();\r\n      const xx = x * x;\r\n      const yy = y * y;\r\n      const zz = z * z;\r\n      const xy = x * y;\r\n      const yz = y * z;\r\n      const zx = z * x;\r\n      const xw = x * w;\r\n      const yw = y * w;\r\n      const zw = z * w;\r\n      m[0] = 1 - 2 * (yy + zz);\r\n      m[1] = 2 * (xy - zw);\r\n      m[2] = 2 * (zx + yw);\r\n      m[3] = 2 * (xy + zw);\r\n      m[4] = 1 - 2 * (zz + xx);\r\n      m[5] = 2 * (yz - xw);\r\n      m[6] = 2 * (zx - yw);\r\n      m[7] = 2 * (yz + xw);\r\n      m[8] = 1 - 2 * (xx + yy);\r\n      return m;\r\n    },\r\n    matrix3ToQuaternion: function (m) {\r\n      const t = m[0] + m[4] + m[8];\r\n      let s, x, y, z, w;\r\n\r\n      if (t > 0) {\r\n        s = Math.sqrt(t + 1.0) * 2;\r\n        w = 0.25 * s;\r\n        x = (m[7] - m[5]) / s;\r\n        y = (m[2] - m[6]) / s;\r\n        z = (m[3] - m[1]) / s;\r\n      } else if (m[0] > m[4] && m[0] > m[8]) {\r\n        s = Math.sqrt(1.0 + m[0] - m[4] - m[8]) * 2;\r\n        w = (m[7] - m[5]) / s;\r\n        x = 0.25 * s;\r\n        y = (m[1] + m[3]) / s;\r\n        z = (m[2] + m[6]) / s;\r\n      } else if (m[4] > m[8]) {\r\n        s = Math.sqrt(1.0 + m[4] - m[0] - m[8]) * 2;\r\n        w = (m[2] - m[6]) / s;\r\n        x = (m[1] + m[3]) / s;\r\n        y = 0.25 * s;\r\n        z = (m[5] + m[7]) / s;\r\n      } else {\r\n        s = Math.sqrt(1.0 + m[8] - m[0] - m[4]) * 2;\r\n        w = (m[3] - m[1]) / s;\r\n        x = (m[2] + m[6]) / s;\r\n        y = (m[5] + m[7]) / s;\r\n        z = 0.25 * s;\r\n      }\r\n\r\n      const q = this.allocQuaternion();\r\n      q.setX(x);\r\n      q.setY(y);\r\n      q.setZ(z);\r\n      q.setW(w);\r\n      return q;\r\n    }\r\n  };\r\n  /**\r\n   * @param {THREE.SkinnedMesh} mesh\r\n   * @param {Ammo.btDiscreteDynamicsWorld} world\r\n   * @param {Object} params\r\n   * @param {ResourceManager} manager\r\n   */\r\n\r\n  function RigidBody(mesh, world, params, manager) {\r\n    this.mesh = mesh;\r\n    this.world = world;\r\n    this.params = params;\r\n    this.manager = manager;\r\n    this.body = null;\r\n    this.bone = null;\r\n    this.boneOffsetForm = null;\r\n    this.boneOffsetFormInverse = null;\r\n\r\n    this._init();\r\n  }\r\n\r\n  RigidBody.prototype = {\r\n    constructor: MMDPhysics.RigidBody,\r\n\r\n    /**\r\n     * Resets rigid body transform to the current bone's.\r\n     *\r\n     * @return {RigidBody}\r\n     */\r\n    reset: function () {\r\n      this._setTransformFromBone();\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Updates rigid body's transform from the current bone.\r\n     *\r\n     * @return {RidigBody}\r\n     */\r\n    updateFromBone: function () {\r\n      if (this.params.boneIndex !== -1 && this.params.type === 0) {\r\n        this._setTransformFromBone();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Updates bone from the current ridid body's transform.\r\n     *\r\n     * @return {RidigBody}\r\n     */\r\n    updateBone: function () {\r\n      if (this.params.type === 0 || this.params.boneIndex === -1) {\r\n        return this;\r\n      }\r\n\r\n      this._updateBoneRotation();\r\n\r\n      if (this.params.type === 1) {\r\n        this._updateBonePosition();\r\n      }\r\n\r\n      this.bone.updateMatrixWorld(true);\r\n\r\n      if (this.params.type === 2) {\r\n        this._setPositionFromBone();\r\n      }\r\n\r\n      return this;\r\n    },\r\n    // private methods\r\n    _init: function () {\r\n      function generateShape(p) {\r\n        switch (p.shapeType) {\r\n          case 0:\r\n            return new Ammo.btSphereShape(p.width);\r\n\r\n          case 1:\r\n            return new Ammo.btBoxShape(new Ammo.btVector3(p.width, p.height, p.depth));\r\n\r\n          case 2:\r\n            return new Ammo.btCapsuleShape(p.width, p.height);\r\n\r\n          default:\r\n            throw `unknown shape type ${p.shapeType}`;\r\n        }\r\n      }\r\n\r\n      const manager = this.manager;\r\n      const params = this.params;\r\n      const bones = this.mesh.skeleton.bones;\r\n      const bone = params.boneIndex === -1 ? new Bone() : bones[params.boneIndex];\r\n      const shape = generateShape(params);\r\n      const weight = params.type === 0 ? 0 : params.weight;\r\n      const localInertia = manager.allocVector3();\r\n      localInertia.setValue(0, 0, 0);\r\n\r\n      if (weight !== 0) {\r\n        shape.calculateLocalInertia(weight, localInertia);\r\n      }\r\n\r\n      const boneOffsetForm = manager.allocTransform();\r\n      manager.setIdentity(boneOffsetForm);\r\n      manager.setOriginFromArray3(boneOffsetForm, params.position);\r\n      manager.setBasisFromArray3(boneOffsetForm, params.rotation);\r\n      const vector = manager.allocThreeVector3();\r\n      const boneForm = manager.allocTransform();\r\n      manager.setIdentity(boneForm);\r\n      manager.setOriginFromThreeVector3(boneForm, bone.getWorldPosition(vector));\r\n      const form = manager.multiplyTransforms(boneForm, boneOffsetForm);\r\n      const state = new Ammo.btDefaultMotionState(form);\r\n      const info = new Ammo.btRigidBodyConstructionInfo(weight, state, shape, localInertia);\r\n      info.set_m_friction(params.friction);\r\n      info.set_m_restitution(params.restitution);\r\n      const body = new Ammo.btRigidBody(info);\r\n\r\n      if (params.type === 0) {\r\n        body.setCollisionFlags(body.getCollisionFlags() | 2);\r\n        /*\r\n         * It'd be better to comment out this line though in general I should call this method\r\n         * because I'm not sure why but physics will be more like MMD's\r\n         * if I comment out.\r\n         */\r\n\r\n        body.setActivationState(4);\r\n      }\r\n\r\n      body.setDamping(params.positionDamping, params.rotationDamping);\r\n      body.setSleepingThresholds(0, 0);\r\n      this.world.addRigidBody(body, 1 << params.groupIndex, params.groupTarget);\r\n      this.body = body;\r\n      this.bone = bone;\r\n      this.boneOffsetForm = boneOffsetForm;\r\n      this.boneOffsetFormInverse = manager.inverseTransform(boneOffsetForm);\r\n      manager.freeVector3(localInertia);\r\n      manager.freeTransform(form);\r\n      manager.freeTransform(boneForm);\r\n      manager.freeThreeVector3(vector);\r\n    },\r\n    _getBoneTransform: function () {\r\n      const manager = this.manager;\r\n      const p = manager.allocThreeVector3();\r\n      const q = manager.allocThreeQuaternion();\r\n      const s = manager.allocThreeVector3();\r\n      this.bone.matrixWorld.decompose(p, q, s);\r\n      const tr = manager.allocTransform();\r\n      manager.setOriginFromThreeVector3(tr, p);\r\n      manager.setBasisFromThreeQuaternion(tr, q);\r\n      const form = manager.multiplyTransforms(tr, this.boneOffsetForm);\r\n      manager.freeTransform(tr);\r\n      manager.freeThreeVector3(s);\r\n      manager.freeThreeQuaternion(q);\r\n      manager.freeThreeVector3(p);\r\n      return form;\r\n    },\r\n    _getWorldTransformForBone: function () {\r\n      const manager = this.manager;\r\n      const tr = this.body.getCenterOfMassTransform();\r\n      return manager.multiplyTransforms(tr, this.boneOffsetFormInverse);\r\n    },\r\n    _setTransformFromBone: function () {\r\n      const manager = this.manager;\r\n\r\n      const form = this._getBoneTransform(); // TODO: check the most appropriate way to set\r\n      //this.body.setWorldTransform( form );\r\n\r\n\r\n      this.body.setCenterOfMassTransform(form);\r\n      this.body.getMotionState().setWorldTransform(form);\r\n      manager.freeTransform(form);\r\n    },\r\n    _setPositionFromBone: function () {\r\n      const manager = this.manager;\r\n\r\n      const form = this._getBoneTransform();\r\n\r\n      const tr = manager.allocTransform();\r\n      this.body.getMotionState().getWorldTransform(tr);\r\n      manager.copyOrigin(tr, form); // TODO: check the most appropriate way to set\r\n      //this.body.setWorldTransform( tr );\r\n\r\n      this.body.setCenterOfMassTransform(tr);\r\n      this.body.getMotionState().setWorldTransform(tr);\r\n      manager.freeTransform(tr);\r\n      manager.freeTransform(form);\r\n    },\r\n    _updateBoneRotation: function () {\r\n      const manager = this.manager;\r\n\r\n      const tr = this._getWorldTransformForBone();\r\n\r\n      const q = manager.getBasis(tr);\r\n      const thQ = manager.allocThreeQuaternion();\r\n      const thQ2 = manager.allocThreeQuaternion();\r\n      const thQ3 = manager.allocThreeQuaternion();\r\n      thQ.set(q.x(), q.y(), q.z(), q.w());\r\n      thQ2.setFromRotationMatrix(this.bone.matrixWorld);\r\n      thQ2.conjugate();\r\n      thQ2.multiply(thQ); //this.bone.quaternion.multiply( thQ2 );\r\n\r\n      thQ3.setFromRotationMatrix(this.bone.matrix); // Renormalizing quaternion here because repeatedly transforming\r\n      // quaternion continuously accumulates floating point error and\r\n      // can end up being overflow. See #15335\r\n\r\n      this.bone.quaternion.copy(thQ2.multiply(thQ3).normalize());\r\n      manager.freeThreeQuaternion(thQ);\r\n      manager.freeThreeQuaternion(thQ2);\r\n      manager.freeThreeQuaternion(thQ3);\r\n      manager.freeQuaternion(q);\r\n      manager.freeTransform(tr);\r\n    },\r\n    _updateBonePosition: function () {\r\n      const manager = this.manager;\r\n\r\n      const tr = this._getWorldTransformForBone();\r\n\r\n      const thV = manager.allocThreeVector3();\r\n      const o = manager.getOrigin(tr);\r\n      thV.set(o.x(), o.y(), o.z());\r\n\r\n      if (this.bone.parent) {\r\n        this.bone.parent.worldToLocal(thV);\r\n      }\r\n\r\n      this.bone.position.copy(thV);\r\n      manager.freeThreeVector3(thV);\r\n      manager.freeTransform(tr);\r\n    }\r\n  };\r\n  /**\r\n   * @param {THREE.SkinnedMesh} mesh\r\n   * @param {Ammo.btDiscreteDynamicsWorld} world\r\n   * @param {RigidBody} bodyA\r\n   * @param {RigidBody} bodyB\r\n   * @param {Object} params\r\n   * @param {ResourceManager} manager\r\n   */\r\n\r\n  function Constraint(mesh, world, bodyA, bodyB, params, manager) {\r\n    this.mesh = mesh;\r\n    this.world = world;\r\n    this.bodyA = bodyA;\r\n    this.bodyB = bodyB;\r\n    this.params = params;\r\n    this.manager = manager;\r\n    this.constraint = null;\r\n\r\n    this._init();\r\n  }\r\n\r\n  Constraint.prototype = {\r\n    constructor: Constraint,\r\n    // private method\r\n    _init: function () {\r\n      const manager = this.manager;\r\n      const params = this.params;\r\n      const bodyA = this.bodyA;\r\n      const bodyB = this.bodyB;\r\n      const form = manager.allocTransform();\r\n      manager.setIdentity(form);\r\n      manager.setOriginFromArray3(form, params.position);\r\n      manager.setBasisFromArray3(form, params.rotation);\r\n      const formA = manager.allocTransform();\r\n      const formB = manager.allocTransform();\r\n      bodyA.body.getMotionState().getWorldTransform(formA);\r\n      bodyB.body.getMotionState().getWorldTransform(formB);\r\n      const formInverseA = manager.inverseTransform(formA);\r\n      const formInverseB = manager.inverseTransform(formB);\r\n      const formA2 = manager.multiplyTransforms(formInverseA, form);\r\n      const formB2 = manager.multiplyTransforms(formInverseB, form);\r\n      const constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA.body, bodyB.body, formA2, formB2, true);\r\n      const lll = manager.allocVector3();\r\n      const lul = manager.allocVector3();\r\n      const all = manager.allocVector3();\r\n      const aul = manager.allocVector3();\r\n      lll.setValue(params.translationLimitation1[0], params.translationLimitation1[1], params.translationLimitation1[2]);\r\n      lul.setValue(params.translationLimitation2[0], params.translationLimitation2[1], params.translationLimitation2[2]);\r\n      all.setValue(params.rotationLimitation1[0], params.rotationLimitation1[1], params.rotationLimitation1[2]);\r\n      aul.setValue(params.rotationLimitation2[0], params.rotationLimitation2[1], params.rotationLimitation2[2]);\r\n      constraint.setLinearLowerLimit(lll);\r\n      constraint.setLinearUpperLimit(lul);\r\n      constraint.setAngularLowerLimit(all);\r\n      constraint.setAngularUpperLimit(aul);\r\n\r\n      for (let i = 0; i < 3; i++) {\r\n        if (params.springPosition[i] !== 0) {\r\n          constraint.enableSpring(i, true);\r\n          constraint.setStiffness(i, params.springPosition[i]);\r\n        }\r\n      }\r\n\r\n      for (let i = 0; i < 3; i++) {\r\n        if (params.springRotation[i] !== 0) {\r\n          constraint.enableSpring(i + 3, true);\r\n          constraint.setStiffness(i + 3, params.springRotation[i]);\r\n        }\r\n      }\r\n      /*\r\n       * Currently(10/31/2016) official ammo.js doesn't support\r\n       * btGeneric6DofSpringConstraint.setParam method.\r\n       * You need custom ammo.js (add the method into idl) if you wanna use.\r\n       * By setting this parameter, physics will be more like MMD's\r\n       */\r\n\r\n\r\n      if (constraint.setParam !== undefined) {\r\n        for (let i = 0; i < 6; i++) {\r\n          // this parameter is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\r\n          constraint.setParam(2, 0.475, i);\r\n        }\r\n      }\r\n\r\n      this.world.addConstraint(constraint, true);\r\n      this.constraint = constraint;\r\n      manager.freeTransform(form);\r\n      manager.freeTransform(formA);\r\n      manager.freeTransform(formB);\r\n      manager.freeTransform(formInverseA);\r\n      manager.freeTransform(formInverseB);\r\n      manager.freeTransform(formA2);\r\n      manager.freeTransform(formB2);\r\n      manager.freeVector3(lll);\r\n      manager.freeVector3(lul);\r\n      manager.freeVector3(all);\r\n      manager.freeVector3(aul);\r\n    }\r\n  };\r\n  /**\r\n   * Visualize Rigid bodies\r\n   *\r\n   * @param {THREE.SkinnedMesh} mesh\r\n   * @param {Physics} physics\r\n   */\r\n\r\n  function MMDPhysicsHelper(mesh, physics) {\r\n    Object3D.call(this);\r\n    this.root = mesh;\r\n    this.physics = physics;\r\n    this.matrix.copy(mesh.matrixWorld);\r\n    this.matrixAutoUpdate = false;\r\n    this.materials = [];\r\n    this.materials.push(new MeshBasicMaterial({\r\n      color: new Color(0xff8888),\r\n      wireframe: true,\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      opacity: 0.25,\r\n      transparent: true\r\n    }));\r\n    this.materials.push(new MeshBasicMaterial({\r\n      color: new Color(0x88ff88),\r\n      wireframe: true,\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      opacity: 0.25,\r\n      transparent: true\r\n    }));\r\n    this.materials.push(new MeshBasicMaterial({\r\n      color: new Color(0x8888ff),\r\n      wireframe: true,\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      opacity: 0.25,\r\n      transparent: true\r\n    }));\r\n\r\n    this._init();\r\n  }\r\n\r\n  MMDPhysicsHelper.prototype = Object.assign(Object.create(Object3D.prototype), {\r\n    constructor: MMDPhysicsHelper,\r\n\r\n    /**\r\n     * Updates Rigid Bodies visualization.\r\n     */\r\n    updateMatrixWorld: (() => {\r\n      const position = new Vector3();\r\n      const quaternion = new Quaternion();\r\n      const scale = new Vector3();\r\n      const matrixWorldInv = new Matrix4();\r\n      return function updateMatrixWorld(force) {\r\n        const mesh = this.root;\r\n\r\n        if (this.visible) {\r\n          const bodies = this.physics.bodies;\r\n          matrixWorldInv.copy(mesh.matrixWorld).decompose(position, quaternion, scale).compose(position, quaternion, scale.set(1, 1, 1)).invert();\r\n\r\n          for (let i = 0, il = bodies.length; i < il; i++) {\r\n            const body = bodies[i].body;\r\n            const child = this.children[i];\r\n            const tr = body.getCenterOfMassTransform();\r\n            const origin = tr.getOrigin();\r\n            const rotation = tr.getRotation();\r\n            child.position.set(origin.x(), origin.y(), origin.z()).applyMatrix4(matrixWorldInv);\r\n            child.quaternion.setFromRotationMatrix(matrixWorldInv).multiply(quaternion.set(rotation.x(), rotation.y(), rotation.z(), rotation.w()));\r\n          }\r\n        }\r\n\r\n        this.matrix.copy(mesh.matrixWorld).decompose(position, quaternion, scale).compose(position, quaternion, scale.set(1, 1, 1));\r\n        Object3D.prototype.updateMatrixWorld.call(this, force);\r\n      };\r\n    })(),\r\n    // private method\r\n    _init: function () {\r\n      const bodies = this.physics.bodies;\r\n\r\n      function createGeometry(param) {\r\n        switch (param.shapeType) {\r\n          case 0:\r\n            return new SphereGeometry(param.width, 16, 8);\r\n\r\n          case 1:\r\n            return new BoxGeometry(param.width * 2, param.height * 2, param.depth * 2, 8, 8, 8);\r\n\r\n          case 2:\r\n            return new createCapsuleGeometry(param.width, param.height, 16, 8);\r\n\r\n          default:\r\n            return null;\r\n        }\r\n      } // copy from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mytest37.js?ver=20160815\r\n\r\n\r\n      function createCapsuleGeometry(radius, cylinderHeight, segmentsRadius, segmentsHeight) {\r\n        const geometry = new CylinderGeometry(radius, radius, cylinderHeight, segmentsRadius, segmentsHeight, true);\r\n        const upperSphere = new Mesh(new SphereGeometry(radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, 0, Math.PI / 2));\r\n        const lowerSphere = new Mesh(new SphereGeometry(radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2));\r\n        upperSphere.position.set(0, cylinderHeight / 2, 0);\r\n        lowerSphere.position.set(0, -cylinderHeight / 2, 0);\r\n        upperSphere.updateMatrix();\r\n        lowerSphere.updateMatrix();\r\n        geometry.merge(upperSphere.geometry, upperSphere.matrix);\r\n        geometry.merge(lowerSphere.geometry, lowerSphere.matrix);\r\n        return geometry;\r\n      }\r\n\r\n      for (let i = 0, il = bodies.length; i < il; i++) {\r\n        const param = bodies[i].params;\r\n        this.add(new Mesh(createGeometry(param), this.materials[param.type]));\r\n      }\r\n    }\r\n  });\r\n  return MMDPhysics;\r\n})();\r\n\r\nexport { MMDPhysics };\r\n", "import { Quaternion, Object3D, Vector3, AnimationMixer } from 'three';\r\nimport { CCDIKSolver } from './CCDIKSolver.js';\r\nimport { MMDPhysics } from './MMDPhysics.js';\r\n\r\n/**\r\n * MMDAnimationHelper handles animation of MMD assets loaded by MMDLoader\r\n * with MMD special features as IK, Grant, and Physics.\r\n *\r\n * Dependencies\r\n *  - ammo.js https://github.com/kripken/ammo.js\r\n *  - MMDPhysics\r\n *  - CCDIKSolver\r\n *\r\n * TODO\r\n *  - more precise grant skinning support.\r\n */\r\n\r\nconst MMDAnimationHelper = (() => {\r\n  /**\r\n   * @param {Object} params - (optional)\r\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\r\n   * @param {Number} params.afterglow - Default is 0.0.\r\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\r\n   */\r\n  function MMDAnimationHelper(params) {\r\n    params = params || {};\r\n    this.meshes = [];\r\n    this.camera = null;\r\n    this.cameraTarget = new Object3D();\r\n    this.cameraTarget.name = 'target';\r\n    this.audio = null;\r\n    this.audioManager = null;\r\n    this.objects = new WeakMap();\r\n    this.configuration = {\r\n      sync: params.sync !== undefined ? params.sync : true,\r\n      afterglow: params.afterglow !== undefined ? params.afterglow : 0.0,\r\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== undefined ? params.resetPhysicsOnLoop : true\r\n    };\r\n    this.enabled = {\r\n      animation: true,\r\n      ik: true,\r\n      grant: true,\r\n      physics: true,\r\n      cameraAnimation: true\r\n    };\r\n\r\n    this.onBeforePhysics = () =>\r\n    /* mesh */\r\n    {}; // experimental\r\n\r\n\r\n    this.sharedPhysics = false;\r\n    this.masterPhysics = null;\r\n  }\r\n\r\n  MMDAnimationHelper.prototype = {\r\n    constructor: MMDAnimationHelper,\r\n\r\n    /**\r\n     * Adds an Three.js Object to helper and setups animation.\r\n     * The anmation durations of added objects are synched\r\n     * if this.configuration.sync is true.\r\n     *\r\n     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\r\n     * @param {Object} params - (optional)\r\n     * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\r\n     * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\r\n     * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\r\n     * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\r\n     * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\r\n     * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\r\n     * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\r\n     * @return {MMDAnimationHelper}\r\n     */\r\n    add: function (object, params) {\r\n      params = params || {};\r\n\r\n      if (object.isSkinnedMesh) {\r\n        this._addMesh(object, params);\r\n      } else if (object.isCamera) {\r\n        this._setupCamera(object, params);\r\n      } else if (object.type === 'Audio') {\r\n        this._setupAudio(object, params);\r\n      } else {\r\n        throw new Error('THREE.MMDAnimationHelper.add: ' + 'accepts only ' + 'THREE.SkinnedMesh or ' + 'THREE.Camera or ' + 'THREE.Audio instance.');\r\n      }\r\n\r\n      if (this.configuration.sync) this._syncDuration();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Removes an Three.js Object from helper.\r\n     *\r\n     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\r\n     * @return {MMDAnimationHelper}\r\n     */\r\n    remove: function (object) {\r\n      if (object.isSkinnedMesh) {\r\n        this._removeMesh(object);\r\n      } else if (object.isCamera) {\r\n        this._clearCamera(object);\r\n      } else if (object.type === 'Audio') {\r\n        this._clearAudio(object);\r\n      } else {\r\n        throw new Error('THREE.MMDAnimationHelper.remove: ' + 'accepts only ' + 'THREE.SkinnedMesh or ' + 'THREE.Camera or ' + 'THREE.Audio instance.');\r\n      }\r\n\r\n      if (this.configuration.sync) this._syncDuration();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Updates the animation.\r\n     *\r\n     * @param {Number} delta\r\n     * @return {MMDAnimationHelper}\r\n     */\r\n    update: function (delta) {\r\n      if (this.audioManager !== null) this.audioManager.control(delta);\r\n\r\n      for (let i = 0; i < this.meshes.length; i++) {\r\n        this._animateMesh(this.meshes[i], delta);\r\n      }\r\n\r\n      if (this.sharedPhysics) this._updateSharedPhysics(delta);\r\n      if (this.camera !== null) this._animateCamera(this.camera, delta);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Changes the pose of SkinnedMesh as VPD specifies.\r\n     *\r\n     * @param {THREE.SkinnedMesh} mesh\r\n     * @param {Object} vpd - VPD content parsed MMDParser\r\n     * @param {Object} params - (optional)\r\n     * @param {boolean} params.resetPose - Default is true.\r\n     * @param {boolean} params.ik - Default is true.\r\n     * @param {boolean} params.grant - Default is true.\r\n     * @return {MMDAnimationHelper}\r\n     */\r\n    pose: function (mesh, vpd, params) {\r\n      params = params || {};\r\n      if (params.resetPose !== false) mesh.pose();\r\n      const bones = mesh.skeleton.bones;\r\n      const boneParams = vpd.bones;\r\n      const boneNameDictionary = {};\r\n\r\n      for (let i = 0, il = bones.length; i < il; i++) {\r\n        boneNameDictionary[bones[i].name] = i;\r\n      }\r\n\r\n      const vector = new Vector3();\r\n      const quaternion = new Quaternion();\r\n\r\n      for (let i = 0, il = boneParams.length; i < il; i++) {\r\n        const boneParam = boneParams[i];\r\n        const boneIndex = boneNameDictionary[boneParam.name];\r\n        if (boneIndex === undefined) continue;\r\n        const bone = bones[boneIndex];\r\n        bone.position.add(vector.fromArray(boneParam.translation));\r\n        bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));\r\n      }\r\n\r\n      mesh.updateMatrixWorld(true);\r\n\r\n      if (params.ik !== false) {\r\n        this._createCCDIKSolver(mesh).update(params.saveOriginalBonesBeforeIK); // this param is experimental\r\n\r\n      }\r\n\r\n      if (params.grant !== false) {\r\n        this.createGrantSolver(mesh).update();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Enabes/Disables an animation feature.\r\n     *\r\n     * @param {string} key\r\n     * @param {boolean} enabled\r\n     * @return {MMDAnimationHelper}\r\n     */\r\n    enable: function (key, enabled) {\r\n      if (this.enabled[key] === undefined) {\r\n        throw new Error(`THREE.MMDAnimationHelper.enable: unknown key ${key}`);\r\n      }\r\n\r\n      this.enabled[key] = enabled;\r\n\r\n      if (key === 'physics') {\r\n        for (let i = 0, il = this.meshes.length; i < il; i++) {\r\n          this._optimizeIK(this.meshes[i], enabled);\r\n        }\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Creates an GrantSolver instance.\r\n     *\r\n     * @param {THREE.SkinnedMesh} mesh\r\n     * @return {GrantSolver}\r\n     */\r\n    createGrantSolver: function (mesh) {\r\n      return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);\r\n    },\r\n    // private methods\r\n    _addMesh: function (mesh, params) {\r\n      if (this.meshes.indexOf(mesh) >= 0) {\r\n        throw new Error(`THREE.MMDAnimationHelper._addMesh: SkinnedMesh '${mesh.name}' has already been added.`);\r\n      }\r\n\r\n      this.meshes.push(mesh);\r\n      this.objects.set(mesh, {\r\n        looped: false\r\n      });\r\n\r\n      this._setupMeshAnimation(mesh, params.animation);\r\n\r\n      if (params.physics !== false) {\r\n        this._setupMeshPhysics(mesh, params);\r\n      }\r\n\r\n      return this;\r\n    },\r\n    _setupCamera: function (camera, params) {\r\n      if (this.camera === camera) {\r\n        throw new Error(`THREE.MMDAnimationHelper._setupCamera: Camera '${camera.name}' has already been set.`);\r\n      }\r\n\r\n      if (this.camera) this.clearCamera(this.camera);\r\n      this.camera = camera;\r\n      camera.add(this.cameraTarget);\r\n      this.objects.set(camera, {});\r\n\r\n      if (params.animation !== undefined) {\r\n        this._setupCameraAnimation(camera, params.animation);\r\n      }\r\n\r\n      return this;\r\n    },\r\n    _setupAudio: function (audio, params) {\r\n      if (this.audio === audio) {\r\n        throw new Error(`THREE.MMDAnimationHelper._setupAudio: Audio '${audio.name}' has already been set.`);\r\n      }\r\n\r\n      if (this.audio) this.clearAudio(this.audio);\r\n      this.audio = audio;\r\n      this.audioManager = new AudioManager(audio, params);\r\n      this.objects.set(this.audioManager, {\r\n        duration: this.audioManager.duration\r\n      });\r\n      return this;\r\n    },\r\n    _removeMesh: function (mesh) {\r\n      let found = false;\r\n      let writeIndex = 0;\r\n\r\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\r\n        if (this.meshes[i] === mesh) {\r\n          this.objects.delete(mesh);\r\n          found = true;\r\n          continue;\r\n        }\r\n\r\n        this.meshes[writeIndex++] = this.meshes[i];\r\n      }\r\n\r\n      if (!found) {\r\n        throw new Error(`THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '${mesh.name}' has not been added yet.`);\r\n      }\r\n\r\n      this.meshes.length = writeIndex;\r\n      return this;\r\n    },\r\n    _clearCamera: function (camera) {\r\n      if (camera !== this.camera) {\r\n        throw new Error(`THREE.MMDAnimationHelper._clearCamera: Camera '${camera.name}' has not been set yet.`);\r\n      }\r\n\r\n      this.camera.remove(this.cameraTarget);\r\n      this.objects.delete(this.camera);\r\n      this.camera = null;\r\n      return this;\r\n    },\r\n    _clearAudio: function (audio) {\r\n      if (audio !== this.audio) {\r\n        throw new Error(`THREE.MMDAnimationHelper._clearAudio: Audio '${audio.name}' has not been set yet.`);\r\n      }\r\n\r\n      this.objects.delete(this.audioManager);\r\n      this.audio = null;\r\n      this.audioManager = null;\r\n      return this;\r\n    },\r\n    _setupMeshAnimation: function (mesh, animation) {\r\n      const objects = this.objects.get(mesh);\r\n\r\n      if (animation !== undefined) {\r\n        const animations = Array.isArray(animation) ? animation : [animation];\r\n        objects.mixer = new AnimationMixer(mesh);\r\n\r\n        for (let i = 0, il = animations.length; i < il; i++) {\r\n          objects.mixer.clipAction(animations[i]).play();\r\n        } // TODO: find a workaround not to access ._clip looking like a private property\r\n\r\n\r\n        objects.mixer.addEventListener('loop', event => {\r\n          const tracks = event.action._clip.tracks;\r\n          if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== '.bones') return;\r\n          objects.looped = true;\r\n        });\r\n      }\r\n\r\n      objects.ikSolver = this._createCCDIKSolver(mesh);\r\n      objects.grantSolver = this.createGrantSolver(mesh);\r\n      return this;\r\n    },\r\n    _setupCameraAnimation: function (camera, animation) {\r\n      const animations = Array.isArray(animation) ? animation : [animation];\r\n      const objects = this.objects.get(camera);\r\n      objects.mixer = new AnimationMixer(camera);\r\n\r\n      for (let i = 0, il = animations.length; i < il; i++) {\r\n        objects.mixer.clipAction(animations[i]).play();\r\n      }\r\n    },\r\n    _setupMeshPhysics: function (mesh, params) {\r\n      const objects = this.objects.get(mesh); // shared physics is experimental\r\n\r\n      if (params.world === undefined && this.sharedPhysics) {\r\n        const masterPhysics = this._getMasterPhysics();\r\n\r\n        if (masterPhysics !== null) world = masterPhysics.world; // eslint-disable-line no-undef\r\n      }\r\n\r\n      objects.physics = this._createMMDPhysics(mesh, params);\r\n\r\n      if (objects.mixer && params.animationWarmup !== false) {\r\n        this._animateMesh(mesh, 0);\r\n\r\n        objects.physics.reset();\r\n      }\r\n\r\n      objects.physics.warmup(params.warmup !== undefined ? params.warmup : 60);\r\n\r\n      this._optimizeIK(mesh, true);\r\n    },\r\n    _animateMesh: function (mesh, delta) {\r\n      const objects = this.objects.get(mesh);\r\n      const mixer = objects.mixer;\r\n      const ikSolver = objects.ikSolver;\r\n      const grantSolver = objects.grantSolver;\r\n      const physics = objects.physics;\r\n      const looped = objects.looped; // alternate solution to save/restore bones but less performant?\r\n      //mesh.pose();\r\n      //this._updatePropertyMixersBuffer( mesh );\r\n\r\n      if (mixer && this.enabled.animation) {\r\n        this._restoreBones(mesh);\r\n\r\n        mixer.update(delta);\r\n\r\n        this._saveBones(mesh);\r\n\r\n        if (ikSolver && this.enabled.ik) {\r\n          mesh.updateMatrixWorld(true);\r\n          ikSolver.update();\r\n        }\r\n\r\n        if (grantSolver && this.enabled.grant) {\r\n          grantSolver.update();\r\n        }\r\n      }\r\n\r\n      if (looped === true && this.enabled.physics) {\r\n        if (physics && this.configuration.resetPhysicsOnLoop) physics.reset();\r\n        objects.looped = false;\r\n      }\r\n\r\n      if (physics && this.enabled.physics && !this.sharedPhysics) {\r\n        this.onBeforePhysics(mesh);\r\n        physics.update(delta);\r\n      }\r\n    },\r\n    _animateCamera: function (camera, delta) {\r\n      const mixer = this.objects.get(camera).mixer;\r\n\r\n      if (mixer && this.enabled.cameraAnimation) {\r\n        mixer.update(delta);\r\n        camera.updateProjectionMatrix();\r\n        camera.up.set(0, 1, 0);\r\n        camera.up.applyQuaternion(camera.quaternion);\r\n        camera.lookAt(this.cameraTarget.position);\r\n      }\r\n    },\r\n    _optimizeIK: function (mesh, physicsEnabled) {\r\n      const iks = mesh.geometry.userData.MMD.iks;\r\n      const bones = mesh.geometry.userData.MMD.bones;\r\n\r\n      for (let i = 0, il = iks.length; i < il; i++) {\r\n        const ik = iks[i];\r\n        const links = ik.links;\r\n\r\n        for (let j = 0, jl = links.length; j < jl; j++) {\r\n          const link = links[j];\r\n\r\n          if (physicsEnabled === true) {\r\n            // disable IK of the bone the corresponding rigidBody type of which is 1 or 2\r\n            // because its rotation will be overriden by physics\r\n            link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\r\n          } else {\r\n            link.enabled = true;\r\n          }\r\n        }\r\n      }\r\n    },\r\n    _createCCDIKSolver: function (mesh) {\r\n      if (CCDIKSolver === undefined) {\r\n        throw new Error('THREE.MMDAnimationHelper: Import CCDIKSolver.');\r\n      }\r\n\r\n      return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);\r\n    },\r\n    _createMMDPhysics: function (mesh, params) {\r\n      if (MMDPhysics === undefined) {\r\n        throw new Error('THREE.MMDPhysics: Import MMDPhysics.');\r\n      }\r\n\r\n      return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);\r\n    },\r\n\r\n    /*\r\n     * Detects the longest duration and then sets it to them to sync.\r\n     * TODO: Not to access private properties ( ._actions and ._clip )\r\n     */\r\n    _syncDuration: function () {\r\n      let max = 0.0;\r\n      const objects = this.objects;\r\n      const meshes = this.meshes;\r\n      const camera = this.camera;\r\n      const audioManager = this.audioManager; // get the longest duration\r\n\r\n      for (let i = 0, il = meshes.length; i < il; i++) {\r\n        var mixer = this.objects.get(meshes[i]).mixer;\r\n        if (mixer === undefined) continue;\r\n\r\n        for (let j = 0; j < mixer._actions.length; j++) {\r\n          var clip = mixer._actions[j]._clip;\r\n\r\n          if (!objects.has(clip)) {\r\n            objects.set(clip, {\r\n              duration: clip.duration\r\n            });\r\n          }\r\n\r\n          max = Math.max(max, objects.get(clip).duration);\r\n        }\r\n      }\r\n\r\n      if (camera !== null) {\r\n        var mixer = this.objects.get(camera).mixer;\r\n\r\n        if (mixer !== undefined) {\r\n          for (let i = 0, il = mixer._actions.length; i < il; i++) {\r\n            var clip = mixer._actions[i]._clip;\r\n\r\n            if (!objects.has(clip)) {\r\n              objects.set(clip, {\r\n                duration: clip.duration\r\n              });\r\n            }\r\n\r\n            max = Math.max(max, objects.get(clip).duration);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (audioManager !== null) {\r\n        max = Math.max(max, objects.get(audioManager).duration);\r\n      }\r\n\r\n      max += this.configuration.afterglow; // update the duration\r\n\r\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\r\n        var mixer = this.objects.get(this.meshes[i]).mixer;\r\n        if (mixer === undefined) continue;\r\n\r\n        for (let j = 0, jl = mixer._actions.length; j < jl; j++) {\r\n          mixer._actions[j]._clip.duration = max;\r\n        }\r\n      }\r\n\r\n      if (camera !== null) {\r\n        var mixer = this.objects.get(camera).mixer;\r\n\r\n        if (mixer !== undefined) {\r\n          for (let i = 0, il = mixer._actions.length; i < il; i++) {\r\n            mixer._actions[i]._clip.duration = max;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (audioManager !== null) {\r\n        audioManager.duration = max;\r\n      }\r\n    },\r\n    // workaround\r\n    _updatePropertyMixersBuffer: function (mesh) {\r\n      const mixer = this.objects.get(mesh).mixer;\r\n      const propertyMixers = mixer._bindings;\r\n      const accuIndex = mixer._accuIndex;\r\n\r\n      for (let i = 0, il = propertyMixers.length; i < il; i++) {\r\n        const propertyMixer = propertyMixers[i];\r\n        const buffer = propertyMixer.buffer;\r\n        const stride = propertyMixer.valueSize;\r\n        const offset = (accuIndex + 1) * stride;\r\n        propertyMixer.binding.getValue(buffer, offset);\r\n      }\r\n    },\r\n\r\n    /*\r\n     * Avoiding these two issues by restore/save bones before/after mixer animation.\r\n     *\r\n     * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\r\n     *    Calculating IK, Grant, and Physics after mixer animation can break\r\n     *    the cache coherency.\r\n     *\r\n     * 2. Applying Grant two or more times without reset the posing breaks model.\r\n     */\r\n    _saveBones: function (mesh) {\r\n      const objects = this.objects.get(mesh);\r\n      const bones = mesh.skeleton.bones;\r\n      let backupBones = objects.backupBones;\r\n\r\n      if (backupBones === undefined) {\r\n        backupBones = new Float32Array(bones.length * 7);\r\n        objects.backupBones = backupBones;\r\n      }\r\n\r\n      for (let i = 0, il = bones.length; i < il; i++) {\r\n        const bone = bones[i];\r\n        bone.position.toArray(backupBones, i * 7);\r\n        bone.quaternion.toArray(backupBones, i * 7 + 3);\r\n      }\r\n    },\r\n    _restoreBones: function (mesh) {\r\n      const objects = this.objects.get(mesh);\r\n      const backupBones = objects.backupBones;\r\n      if (backupBones === undefined) return;\r\n      const bones = mesh.skeleton.bones;\r\n\r\n      for (let i = 0, il = bones.length; i < il; i++) {\r\n        const bone = bones[i];\r\n        bone.position.fromArray(backupBones, i * 7);\r\n        bone.quaternion.fromArray(backupBones, i * 7 + 3);\r\n      }\r\n    },\r\n    // experimental\r\n    _getMasterPhysics: function () {\r\n      if (this.masterPhysics !== null) return this.masterPhysics;\r\n\r\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\r\n        const physics = this.meshes[i].physics;\r\n\r\n        if (physics !== undefined && physics !== null) {\r\n          this.masterPhysics = physics;\r\n          return this.masterPhysics;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    },\r\n    _updateSharedPhysics: function (delta) {\r\n      if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return;\r\n\r\n      const physics = this._getMasterPhysics();\r\n\r\n      if (physics === null) return;\r\n\r\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\r\n        var p = this.meshes[i].physics;\r\n\r\n        if (p !== null && p !== undefined) {\r\n          p.updateRigidBodies();\r\n        }\r\n      }\r\n\r\n      physics.stepSimulation(delta);\r\n\r\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\r\n        var p = this.meshes[i].physics;\r\n\r\n        if (p !== null && p !== undefined) {\r\n          p.updateBones();\r\n        }\r\n      }\r\n    }\r\n  }; //\r\n\r\n  /**\r\n   * @param {THREE.Audio} audio\r\n   * @param {Object} params - (optional)\r\n   * @param {Nuumber} params.delayTime\r\n   */\r\n\r\n  function AudioManager(audio, params) {\r\n    params = params || {};\r\n    this.audio = audio;\r\n    this.elapsedTime = 0.0;\r\n    this.currentTime = 0.0;\r\n    this.delayTime = params.delayTime !== undefined ? params.delayTime : 0.0;\r\n    this.audioDuration = this.audio.buffer.duration;\r\n    this.duration = this.audioDuration + this.delayTime;\r\n  }\r\n\r\n  AudioManager.prototype = {\r\n    constructor: AudioManager,\r\n\r\n    /**\r\n     * @param {Number} delta\r\n     * @return {AudioManager}\r\n     */\r\n    control: function (delta) {\r\n      this.elapsed += delta;\r\n      this.currentTime += delta;\r\n      if (this._shouldStopAudio()) this.audio.stop();\r\n      if (this._shouldStartAudio()) this.audio.play();\r\n      return this;\r\n    },\r\n    // private methods\r\n    _shouldStartAudio: function () {\r\n      if (this.audio.isPlaying) return false;\r\n\r\n      while (this.currentTime >= this.duration) {\r\n        this.currentTime -= this.duration;\r\n      }\r\n\r\n      if (this.currentTime < this.delayTime) return false; // 'duration' can be bigger than 'audioDuration + delayTime' because of sync configuration\r\n\r\n      if (this.currentTime - this.delayTime > this.audioDuration) return false;\r\n      return true;\r\n    },\r\n    _shouldStopAudio: function () {\r\n      return this.audio.isPlaying && this.currentTime >= this.duration;\r\n    }\r\n  };\r\n  /**\r\n   * @param {THREE.SkinnedMesh} mesh\r\n   * @param {Array<Object>} grants\r\n   */\r\n\r\n  function GrantSolver(mesh, grants) {\r\n    this.mesh = mesh;\r\n    this.grants = grants || [];\r\n  }\r\n\r\n  GrantSolver.prototype = {\r\n    constructor: GrantSolver,\r\n\r\n    /**\r\n     * @return {GrantSolver}\r\n     */\r\n    update: (() => {\r\n      const quaternion = new Quaternion();\r\n      return function () {\r\n        const bones = this.mesh.skeleton.bones;\r\n        const grants = this.grants;\r\n\r\n        for (let i = 0, il = grants.length; i < il; i++) {\r\n          const grant = grants[i];\r\n          const bone = bones[grant.index];\r\n          const parentBone = bones[grant.parentIndex];\r\n\r\n          if (grant.isLocal) {\r\n            // TODO: implement\r\n            if (grant.affectPosition) ; // TODO: implement\r\n\r\n\r\n            if (grant.affectRotation) ;\r\n          } else {\r\n            // TODO: implement\r\n            if (grant.affectPosition) ;\r\n\r\n            if (grant.affectRotation) {\r\n              quaternion.set(0, 0, 0, 1);\r\n              quaternion.slerp(parentBone.quaternion, grant.ratio);\r\n              bone.quaternion.multiply(quaternion);\r\n            }\r\n          }\r\n        }\r\n\r\n        return this;\r\n      };\r\n    })()\r\n  };\r\n  return MMDAnimationHelper;\r\n})();\r\n\r\nexport { MMDAnimationHelper };\r\n", "import { Mesh, Color, Plane, Vector3, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, ShaderMaterial, UniformsUtils } from 'three';\r\n\r\nclass Reflector extends Mesh {\r\n  constructor(geometry, options = {}) {\r\n    super(geometry);\r\n    this.type = 'Reflector';\r\n    const scope = this;\r\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\r\n    const textureWidth = options.textureWidth || 512;\r\n    const textureHeight = options.textureHeight || 512;\r\n    const clipBias = options.clipBias || 0;\r\n    const shader = options.shader || Reflector.ReflectorShader; //\r\n\r\n    const reflectorPlane = new Plane();\r\n    const normal = new Vector3();\r\n    const reflectorWorldPosition = new Vector3();\r\n    const cameraWorldPosition = new Vector3();\r\n    const rotationMatrix = new Matrix4();\r\n    const lookAtPosition = new Vector3(0, 0, -1);\r\n    const clipPlane = new Vector4();\r\n    const view = new Vector3();\r\n    const target = new Vector3();\r\n    const q = new Vector4();\r\n    const textureMatrix = new Matrix4();\r\n    const virtualCamera = new PerspectiveCamera();\r\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\r\n    const material = new ShaderMaterial({\r\n      uniforms: UniformsUtils.clone(shader.uniforms),\r\n      fragmentShader: shader.fragmentShader,\r\n      vertexShader: shader.vertexShader\r\n    });\r\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\r\n    material.uniforms['color'].value = color;\r\n    material.uniforms['textureMatrix'].value = textureMatrix;\r\n    this.material = material;\r\n\r\n    this.onBeforeRender = function (renderer, scene, camera) {\r\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\r\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\r\n      rotationMatrix.extractRotation(scope.matrixWorld);\r\n      normal.set(0, 0, 1);\r\n      normal.applyMatrix4(rotationMatrix);\r\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\r\n\r\n      if (view.dot(normal) > 0) return;\r\n      view.reflect(normal).negate();\r\n      view.add(reflectorWorldPosition);\r\n      rotationMatrix.extractRotation(camera.matrixWorld);\r\n      lookAtPosition.set(0, 0, -1);\r\n      lookAtPosition.applyMatrix4(rotationMatrix);\r\n      lookAtPosition.add(cameraWorldPosition);\r\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\r\n      target.reflect(normal).negate();\r\n      target.add(reflectorWorldPosition);\r\n      virtualCamera.position.copy(view);\r\n      virtualCamera.up.set(0, 1, 0);\r\n      virtualCamera.up.applyMatrix4(rotationMatrix);\r\n      virtualCamera.up.reflect(normal);\r\n      virtualCamera.lookAt(target);\r\n      virtualCamera.far = camera.far; // Used in WebGLBackground\r\n\r\n      virtualCamera.updateMatrixWorld();\r\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\r\n\r\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\r\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\r\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\r\n      textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\r\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\r\n\r\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\r\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\r\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\r\n      const projectionMatrix = virtualCamera.projectionMatrix;\r\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\r\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\r\n      q.z = -1.0;\r\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\r\n\r\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\r\n\r\n      projectionMatrix.elements[2] = clipPlane.x;\r\n      projectionMatrix.elements[6] = clipPlane.y;\r\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\r\n      projectionMatrix.elements[14] = clipPlane.w; // Render\r\n\r\n      renderTarget.texture.encoding = renderer.outputEncoding;\r\n      scope.visible = false;\r\n      const currentRenderTarget = renderer.getRenderTarget();\r\n      const currentXrEnabled = renderer.xr.enabled;\r\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n      renderer.xr.enabled = false; // Avoid camera modification\r\n\r\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\r\n\r\n      renderer.setRenderTarget(renderTarget);\r\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\r\n\r\n      if (renderer.autoClear === false) renderer.clear();\r\n      renderer.render(scene, virtualCamera);\r\n      renderer.xr.enabled = currentXrEnabled;\r\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\r\n\r\n      const viewport = camera.viewport;\r\n\r\n      if (viewport !== undefined) {\r\n        renderer.state.viewport(viewport);\r\n      }\r\n\r\n      scope.visible = true;\r\n    };\r\n\r\n    this.getRenderTarget = function () {\r\n      return renderTarget;\r\n    };\r\n\r\n    this.dispose = function () {\r\n      renderTarget.dispose();\r\n      scope.material.dispose();\r\n    };\r\n  }\r\n\r\n}\r\n\r\nReflector.prototype.isReflector = true;\r\nReflector.ReflectorShader = {\r\n  uniforms: {\r\n    color: {\r\n      value: null\r\n    },\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    textureMatrix: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader:\r\n  /* glsl */\r\n  `\r\n\t\tuniform mat4 textureMatrix;\r\n\t\tvarying vec4 vUv;\r\n\r\n\t\t#include <common>\r\n\t\t#include <logdepthbuf_pars_vertex>\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t#include <logdepthbuf_vertex>\r\n\r\n\t\t}`,\r\n  fragmentShader:\r\n  /* glsl */\r\n  `\r\n\t\tuniform vec3 color;\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tvarying vec4 vUv;\r\n\r\n\t\t#include <logdepthbuf_pars_fragment>\r\n\r\n\t\tfloat blendOverlay( float base, float blend ) {\r\n\r\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\r\n\r\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <logdepthbuf_fragment>\r\n\r\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\r\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\r\n\r\n\t\t}`\r\n};\r\n\r\nexport { Reflector };\r\n", "import { Mesh, Color, PerspectiveCamera, Plane, Matrix4, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4 } from 'three';\r\n\r\nclass Refractor extends Mesh {\r\n  constructor(geometry, options = {}) {\r\n    super(geometry);\r\n    this.type = 'Refractor';\r\n    const scope = this;\r\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\r\n    const textureWidth = options.textureWidth || 512;\r\n    const textureHeight = options.textureHeight || 512;\r\n    const clipBias = options.clipBias || 0;\r\n    const shader = options.shader || Refractor.RefractorShader; //\r\n\r\n    const virtualCamera = new PerspectiveCamera();\r\n    virtualCamera.matrixAutoUpdate = false;\r\n    virtualCamera.userData.refractor = true; //\r\n\r\n    const refractorPlane = new Plane();\r\n    const textureMatrix = new Matrix4(); // render target\r\n\r\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight); // material\r\n\r\n    this.material = new ShaderMaterial({\r\n      uniforms: UniformsUtils.clone(shader.uniforms),\r\n      vertexShader: shader.vertexShader,\r\n      fragmentShader: shader.fragmentShader,\r\n      transparent: true // ensures, refractors are drawn from farthest to closest\r\n\r\n    });\r\n    this.material.uniforms['color'].value = color;\r\n    this.material.uniforms['tDiffuse'].value = renderTarget.texture;\r\n    this.material.uniforms['textureMatrix'].value = textureMatrix; // functions\r\n\r\n    const visible = function () {\r\n      const refractorWorldPosition = new Vector3();\r\n      const cameraWorldPosition = new Vector3();\r\n      const rotationMatrix = new Matrix4();\r\n      const view = new Vector3();\r\n      const normal = new Vector3();\r\n      return function visible(camera) {\r\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\r\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\r\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\r\n        rotationMatrix.extractRotation(scope.matrixWorld);\r\n        normal.set(0, 0, 1);\r\n        normal.applyMatrix4(rotationMatrix);\r\n        return view.dot(normal) < 0;\r\n      };\r\n    }();\r\n\r\n    const updateRefractorPlane = function () {\r\n      const normal = new Vector3();\r\n      const position = new Vector3();\r\n      const quaternion = new Quaternion();\r\n      const scale = new Vector3();\r\n      return function updateRefractorPlane() {\r\n        scope.matrixWorld.decompose(position, quaternion, scale);\r\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize(); // flip the normal because we want to cull everything above the plane\r\n\r\n        normal.negate();\r\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\r\n      };\r\n    }();\r\n\r\n    const updateVirtualCamera = function () {\r\n      const clipPlane = new Plane();\r\n      const clipVector = new Vector4();\r\n      const q = new Vector4();\r\n      return function updateVirtualCamera(camera) {\r\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\r\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\r\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\r\n        virtualCamera.far = camera.far; // used in WebGLBackground\r\n        // The following code creates an oblique view frustum for clipping.\r\n        // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\r\n        // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\r\n\r\n        clipPlane.copy(refractorPlane);\r\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\r\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant); // calculate the clip-space corner point opposite the clipping plane and\r\n        // transform it into camera space by multiplying it by the inverse of the projection matrix\r\n\r\n        const projectionMatrix = virtualCamera.projectionMatrix;\r\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\r\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\r\n        q.z = -1.0;\r\n        q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // calculate the scaled plane vector\r\n\r\n        clipVector.multiplyScalar(2.0 / clipVector.dot(q)); // replacing the third row of the projection matrix\r\n\r\n        projectionMatrix.elements[2] = clipVector.x;\r\n        projectionMatrix.elements[6] = clipVector.y;\r\n        projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\r\n        projectionMatrix.elements[14] = clipVector.w;\r\n      };\r\n    }(); // This will update the texture matrix that is used for projective texture mapping in the shader.\r\n    // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\r\n\r\n\r\n    function updateTextureMatrix(camera) {\r\n      // this matrix does range mapping to [ 0, 1 ]\r\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0); // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\r\n      // (matrix above) with the projection and view matrix of the virtual camera\r\n      // and the model matrix of the refractor\r\n\r\n      textureMatrix.multiply(camera.projectionMatrix);\r\n      textureMatrix.multiply(camera.matrixWorldInverse);\r\n      textureMatrix.multiply(scope.matrixWorld);\r\n    } //\r\n\r\n\r\n    function render(renderer, scene, camera) {\r\n      scope.visible = false;\r\n      const currentRenderTarget = renderer.getRenderTarget();\r\n      const currentXrEnabled = renderer.xr.enabled;\r\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n      renderer.xr.enabled = false; // avoid camera modification\r\n\r\n      renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\r\n\r\n      renderer.setRenderTarget(renderTarget);\r\n      if (renderer.autoClear === false) renderer.clear();\r\n      renderer.render(scene, virtualCamera);\r\n      renderer.xr.enabled = currentXrEnabled;\r\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n      renderer.setRenderTarget(currentRenderTarget); // restore viewport\r\n\r\n      const viewport = camera.viewport;\r\n\r\n      if (viewport !== undefined) {\r\n        renderer.state.viewport(viewport);\r\n      }\r\n\r\n      scope.visible = true;\r\n    } //\r\n\r\n\r\n    this.onBeforeRender = function (renderer, scene, camera) {\r\n      // Render\r\n      renderTarget.texture.encoding = renderer.outputEncoding; // ensure refractors are rendered only once per frame\r\n\r\n      if (camera.userData.refractor === true) return; // avoid rendering when the refractor is viewed from behind\r\n\r\n      if (!visible(camera) === true) return; // update\r\n\r\n      updateRefractorPlane();\r\n      updateTextureMatrix(camera);\r\n      updateVirtualCamera(camera);\r\n      render(renderer, scene, camera);\r\n    };\r\n\r\n    this.getRenderTarget = function () {\r\n      return renderTarget;\r\n    };\r\n\r\n    this.dispose = function () {\r\n      renderTarget.dispose();\r\n      scope.material.dispose();\r\n    };\r\n  }\r\n\r\n}\r\n\r\nRefractor.prototype.isRefractor = true;\r\nRefractor.RefractorShader = {\r\n  uniforms: {\r\n    color: {\r\n      value: null\r\n    },\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    textureMatrix: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader:\r\n  /* glsl */\r\n  `\r\n\r\n\t\tuniform mat4 textureMatrix;\r\n\r\n\t\tvarying vec4 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n  fragmentShader:\r\n  /* glsl */\r\n  `\r\n\r\n\t\tuniform vec3 color;\r\n\t\tuniform sampler2D tDiffuse;\r\n\r\n\t\tvarying vec4 vUv;\r\n\r\n\t\tfloat blendOverlay( float base, float blend ) {\r\n\r\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\r\n\r\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\r\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\r\n\r\n\t\t}`\r\n};\r\n\r\nexport { Refractor };\r\n", "import { Matrix4, Mesh, MeshBasicMaterial } from 'three';\r\n\r\n/**\r\n * A shadow Mesh that follows a shadow-casting Mesh in the scene, but is confined to a single plane.\r\n */\r\n\r\nconst _shadowMatrix = new Matrix4();\r\n\r\nclass ShadowMesh extends Mesh {\r\n  constructor(mesh) {\r\n    const shadowMaterial = new MeshBasicMaterial({\r\n      color: 0x000000,\r\n      transparent: true,\r\n      opacity: 0.6,\r\n      depthWrite: false\r\n    });\r\n    super(mesh.geometry, shadowMaterial);\r\n    this.meshMatrix = mesh.matrixWorld;\r\n    this.frustumCulled = false;\r\n    this.matrixAutoUpdate = false;\r\n  }\r\n\r\n  update(plane, lightPosition4D) {\r\n    // based on https://www.opengl.org/archives/resources/features/StencilTalk/tsld021.htm\r\n    const dot = plane.normal.x * lightPosition4D.x + plane.normal.y * lightPosition4D.y + plane.normal.z * lightPosition4D.z + -plane.constant * lightPosition4D.w;\r\n    const sme = _shadowMatrix.elements;\r\n    sme[0] = dot - lightPosition4D.x * plane.normal.x;\r\n    sme[4] = -lightPosition4D.x * plane.normal.y;\r\n    sme[8] = -lightPosition4D.x * plane.normal.z;\r\n    sme[12] = -lightPosition4D.x * -plane.constant;\r\n    sme[1] = -lightPosition4D.y * plane.normal.x;\r\n    sme[5] = dot - lightPosition4D.y * plane.normal.y;\r\n    sme[9] = -lightPosition4D.y * plane.normal.z;\r\n    sme[13] = -lightPosition4D.y * -plane.constant;\r\n    sme[2] = -lightPosition4D.z * plane.normal.x;\r\n    sme[6] = -lightPosition4D.z * plane.normal.y;\r\n    sme[10] = dot - lightPosition4D.z * plane.normal.z;\r\n    sme[14] = -lightPosition4D.z * -plane.constant;\r\n    sme[3] = -lightPosition4D.w * plane.normal.x;\r\n    sme[7] = -lightPosition4D.w * plane.normal.y;\r\n    sme[11] = -lightPosition4D.w * plane.normal.z;\r\n    sme[15] = dot - lightPosition4D.w * -plane.constant;\r\n    this.matrix.multiplyMatrices(_shadowMatrix, this.meshMatrix);\r\n  }\r\n\r\n}\r\n\r\nShadowMesh.prototype.isShadowMesh = true;\r\n\r\nexport { ShadowMesh };\r\n", "import { Mesh, MeshBasicMaterial, Vector3, DataTexture, RGBAFormat, NearestFilter, ClampToEdgeWrapping, RawShaderMaterial, Color, Vector2, AdditiveBlending, Box2, Vector4, BufferGeometry, InterleavedBuffer, InterleavedBufferAttribute } from 'three';\r\n\r\nclass Lensflare extends Mesh {\r\n  constructor() {\r\n    super(Lensflare.Geometry, new MeshBasicMaterial({\r\n      opacity: 0,\r\n      transparent: true\r\n    }));\r\n    this.type = 'Lensflare';\r\n    this.frustumCulled = false;\r\n    this.renderOrder = Infinity; //\r\n\r\n    const positionScreen = new Vector3();\r\n    const positionView = new Vector3(); // textures\r\n\r\n    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);\r\n    tempMap.minFilter = NearestFilter;\r\n    tempMap.magFilter = NearestFilter;\r\n    tempMap.wrapS = ClampToEdgeWrapping;\r\n    tempMap.wrapT = ClampToEdgeWrapping;\r\n    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);\r\n    occlusionMap.minFilter = NearestFilter;\r\n    occlusionMap.magFilter = NearestFilter;\r\n    occlusionMap.wrapS = ClampToEdgeWrapping;\r\n    occlusionMap.wrapT = ClampToEdgeWrapping; // material\r\n\r\n    const geometry = Lensflare.Geometry;\r\n    const material1a = new RawShaderMaterial({\r\n      uniforms: {\r\n        scale: {\r\n          value: null\r\n        },\r\n        screenPosition: {\r\n          value: null\r\n        }\r\n      },\r\n      vertexShader:\r\n      /* glsl */\r\n      `\r\n\r\n\t\t\t\tprecision highp float;\r\n\r\n\t\t\t\tuniform vec3 screenPosition;\r\n\t\t\t\tuniform vec2 scale;\r\n\r\n\t\t\t\tattribute vec3 position;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\r\n\r\n\t\t\t\t}`,\r\n      fragmentShader:\r\n      /* glsl */\r\n      `\r\n\r\n\t\t\t\tprecision highp float;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\r\n\r\n\t\t\t\t}`,\r\n      depthTest: true,\r\n      depthWrite: false,\r\n      transparent: false\r\n    });\r\n    const material1b = new RawShaderMaterial({\r\n      uniforms: {\r\n        map: {\r\n          value: tempMap\r\n        },\r\n        scale: {\r\n          value: null\r\n        },\r\n        screenPosition: {\r\n          value: null\r\n        }\r\n      },\r\n      vertexShader:\r\n      /* glsl */\r\n      `\r\n\r\n\t\t\t\tprecision highp float;\r\n\r\n\t\t\t\tuniform vec3 screenPosition;\r\n\t\t\t\tuniform vec2 scale;\r\n\r\n\t\t\t\tattribute vec3 position;\r\n\t\t\t\tattribute vec2 uv;\r\n\r\n\t\t\t\tvarying vec2 vUV;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUV = uv;\r\n\r\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\r\n\r\n\t\t\t\t}`,\r\n      fragmentShader:\r\n      /* glsl */\r\n      `\r\n\r\n\t\t\t\tprecision highp float;\r\n\r\n\t\t\t\tuniform sampler2D map;\r\n\r\n\t\t\t\tvarying vec2 vUV;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\r\n\r\n\t\t\t\t}`,\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      transparent: false\r\n    }); // the following object is used for occlusionMap generation\r\n\r\n    const mesh1 = new Mesh(geometry, material1a); //\r\n\r\n    const elements = [];\r\n    const shader = LensflareElement.Shader;\r\n    const material2 = new RawShaderMaterial({\r\n      uniforms: {\r\n        map: {\r\n          value: null\r\n        },\r\n        occlusionMap: {\r\n          value: occlusionMap\r\n        },\r\n        color: {\r\n          value: new Color(0xffffff)\r\n        },\r\n        scale: {\r\n          value: new Vector2()\r\n        },\r\n        screenPosition: {\r\n          value: new Vector3()\r\n        }\r\n      },\r\n      vertexShader: shader.vertexShader,\r\n      fragmentShader: shader.fragmentShader,\r\n      blending: AdditiveBlending,\r\n      transparent: true,\r\n      depthWrite: false\r\n    });\r\n    const mesh2 = new Mesh(geometry, material2);\r\n\r\n    this.addElement = function (element) {\r\n      elements.push(element);\r\n    }; //\r\n\r\n\r\n    const scale = new Vector2();\r\n    const screenPositionPixels = new Vector2();\r\n    const validArea = new Box2();\r\n    const viewport = new Vector4();\r\n\r\n    this.onBeforeRender = function (renderer, scene, camera) {\r\n      renderer.getCurrentViewport(viewport);\r\n      const invAspect = viewport.w / viewport.z;\r\n      const halfViewportWidth = viewport.z / 2.0;\r\n      const halfViewportHeight = viewport.w / 2.0;\r\n      let size = 16 / viewport.w;\r\n      scale.set(size * invAspect, size);\r\n      validArea.min.set(viewport.x, viewport.y);\r\n      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16)); // calculate position in screen space\r\n\r\n      positionView.setFromMatrixPosition(this.matrixWorld);\r\n      positionView.applyMatrix4(camera.matrixWorldInverse);\r\n      if (positionView.z > 0) return; // lensflare is behind the camera\r\n\r\n      positionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix); // horizontal and vertical coordinate of the lower left corner of the pixels to copy\r\n\r\n      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;\r\n      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8; // screen cull\r\n\r\n      if (validArea.containsPoint(screenPositionPixels)) {\r\n        // save current RGB to temp texture\r\n        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap); // render pink quad\r\n\r\n        let uniforms = material1a.uniforms;\r\n        uniforms['scale'].value = scale;\r\n        uniforms['screenPosition'].value = positionScreen;\r\n        renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null); // copy result to occlusionMap\r\n\r\n        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap); // restore graphics\r\n\r\n        uniforms = material1b.uniforms;\r\n        uniforms['scale'].value = scale;\r\n        uniforms['screenPosition'].value = positionScreen;\r\n        renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null); // render elements\r\n\r\n        const vecX = -positionScreen.x * 2;\r\n        const vecY = -positionScreen.y * 2;\r\n\r\n        for (let i = 0, l = elements.length; i < l; i++) {\r\n          const element = elements[i];\r\n          const uniforms = material2.uniforms;\r\n          uniforms['color'].value.copy(element.color);\r\n          uniforms['map'].value = element.texture;\r\n          uniforms['screenPosition'].value.x = positionScreen.x + vecX * element.distance;\r\n          uniforms['screenPosition'].value.y = positionScreen.y + vecY * element.distance;\r\n          size = element.size / viewport.w;\r\n          const invAspect = viewport.w / viewport.z;\r\n          uniforms['scale'].value.set(size * invAspect, size);\r\n          material2.uniformsNeedUpdate = true;\r\n          renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);\r\n        }\r\n      }\r\n    };\r\n\r\n    this.dispose = function () {\r\n      material1a.dispose();\r\n      material1b.dispose();\r\n      material2.dispose();\r\n      tempMap.dispose();\r\n      occlusionMap.dispose();\r\n\r\n      for (let i = 0, l = elements.length; i < l; i++) {\r\n        elements[i].texture.dispose();\r\n      }\r\n    };\r\n  }\r\n\r\n}\r\n\r\nLensflare.prototype.isLensflare = true; //\r\n\r\nclass LensflareElement {\r\n  constructor(texture, size = 1, distance = 0, color = new Color(0xffffff)) {\r\n    this.texture = texture;\r\n    this.size = size;\r\n    this.distance = distance;\r\n    this.color = color;\r\n  }\r\n\r\n}\r\n\r\nLensflareElement.Shader = {\r\n  uniforms: {\r\n    map: {\r\n      value: null\r\n    },\r\n    occlusionMap: {\r\n      value: null\r\n    },\r\n    color: {\r\n      value: null\r\n    },\r\n    scale: {\r\n      value: null\r\n    },\r\n    screenPosition: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader:\r\n  /* glsl */\r\n  `\r\n\r\n\t\tprecision highp float;\r\n\r\n\t\tuniform vec3 screenPosition;\r\n\t\tuniform vec2 scale;\r\n\r\n\t\tuniform sampler2D occlusionMap;\r\n\r\n\t\tattribute vec3 position;\r\n\t\tattribute vec2 uv;\r\n\r\n\t\tvarying vec2 vUV;\r\n\t\tvarying float vVisibility;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUV = uv;\r\n\r\n\t\t\tvec2 pos = position.xy;\r\n\r\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\r\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\r\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\r\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\r\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\r\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\r\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\r\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\r\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\r\n\r\n\t\t\tvVisibility =        visibility.r / 9.0;\r\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\r\n\t\t\tvVisibility *=       visibility.b / 9.0;\r\n\r\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\r\n\r\n\t\t}`,\r\n  fragmentShader:\r\n  /* glsl */\r\n  `\r\n\r\n\t\tprecision highp float;\r\n\r\n\t\tuniform sampler2D map;\r\n\t\tuniform vec3 color;\r\n\r\n\t\tvarying vec2 vUV;\r\n\t\tvarying float vVisibility;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvec4 texture = texture2D( map, vUV );\r\n\t\t\ttexture.a *= vVisibility;\r\n\t\t\tgl_FragColor = texture;\r\n\t\t\tgl_FragColor.rgb *= color;\r\n\r\n\t\t}`\r\n};\r\n\r\nLensflare.Geometry = function () {\r\n  const geometry = new BufferGeometry();\r\n  const float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);\r\n  const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\r\n  geometry.setIndex([0, 1, 2, 0, 2, 3]);\r\n  geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\r\n  geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\r\n  return geometry;\r\n}();\r\n\r\nexport { Lensflare, LensflareElement };\r\n", "import { Mesh, Vector3, Color, FrontSide, Plane, Matrix4, Vector4, PerspectiveCamera, WebGLRenderTarget, UniformsUtils, UniformsLib, ShaderMaterial } from 'three';\r\n\r\n/**\r\n * Work based on :\r\n * https://github.com/Slayvin: Flat mirror for three.js\r\n * https://home.adelphi.edu/~stemkoski/ : An implementation of water shader based on the flat mirror\r\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\r\n */\r\n\r\nclass Water extends Mesh {\r\n  constructor(geometry, options = {}) {\r\n    super(geometry);\r\n    const scope = this;\r\n    const textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\r\n    const textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\r\n    const clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\r\n    const alpha = options.alpha !== undefined ? options.alpha : 1.0;\r\n    const time = options.time !== undefined ? options.time : 0.0;\r\n    const normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\r\n    const sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3(0.70707, 0.70707, 0.0);\r\n    const sunColor = new Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\r\n    const waterColor = new Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f);\r\n    const eye = options.eye !== undefined ? options.eye : new Vector3(0, 0, 0);\r\n    const distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\r\n    const side = options.side !== undefined ? options.side : FrontSide;\r\n    const fog = options.fog !== undefined ? options.fog : false; //\r\n\r\n    const mirrorPlane = new Plane();\r\n    const normal = new Vector3();\r\n    const mirrorWorldPosition = new Vector3();\r\n    const cameraWorldPosition = new Vector3();\r\n    const rotationMatrix = new Matrix4();\r\n    const lookAtPosition = new Vector3(0, 0, -1);\r\n    const clipPlane = new Vector4();\r\n    const view = new Vector3();\r\n    const target = new Vector3();\r\n    const q = new Vector4();\r\n    const textureMatrix = new Matrix4();\r\n    const mirrorCamera = new PerspectiveCamera();\r\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);\r\n    const mirrorShader = {\r\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {\r\n        normalSampler: {\r\n          value: null\r\n        },\r\n        mirrorSampler: {\r\n          value: null\r\n        },\r\n        alpha: {\r\n          value: 1.0\r\n        },\r\n        time: {\r\n          value: 0.0\r\n        },\r\n        size: {\r\n          value: 1.0\r\n        },\r\n        distortionScale: {\r\n          value: 20.0\r\n        },\r\n        textureMatrix: {\r\n          value: new Matrix4()\r\n        },\r\n        sunColor: {\r\n          value: new Color(0x7f7f7f)\r\n        },\r\n        sunDirection: {\r\n          value: new Vector3(0.70707, 0.70707, 0)\r\n        },\r\n        eye: {\r\n          value: new Vector3()\r\n        },\r\n        waterColor: {\r\n          value: new Color(0x555555)\r\n        }\r\n      }]),\r\n      vertexShader:\r\n      /* glsl */\r\n      `\r\n\t\t\t\tuniform mat4 textureMatrix;\r\n\t\t\t\tuniform float time;\r\n\r\n\t\t\t\tvarying vec4 mirrorCoord;\r\n\t\t\t\tvarying vec4 worldPosition;\r\n\r\n\t\t\t\t#include <common>\r\n\t\t\t\t#include <fog_pars_vertex>\r\n\t\t\t\t#include <shadowmap_pars_vertex>\r\n\t\t\t\t#include <logdepthbuf_pars_vertex>\r\n\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\r\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\r\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\r\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t\t\t\t#include <beginnormal_vertex>\r\n\t\t\t\t#include <defaultnormal_vertex>\r\n\t\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t\t#include <fog_vertex>\r\n\t\t\t\t#include <shadowmap_vertex>\r\n\t\t\t}`,\r\n      fragmentShader:\r\n      /* glsl */\r\n      `\r\n\t\t\t\tuniform sampler2D mirrorSampler;\r\n\t\t\t\tuniform float alpha;\r\n\t\t\t\tuniform float time;\r\n\t\t\t\tuniform float size;\r\n\t\t\t\tuniform float distortionScale;\r\n\t\t\t\tuniform sampler2D normalSampler;\r\n\t\t\t\tuniform vec3 sunColor;\r\n\t\t\t\tuniform vec3 sunDirection;\r\n\t\t\t\tuniform vec3 eye;\r\n\t\t\t\tuniform vec3 waterColor;\r\n\r\n\t\t\t\tvarying vec4 mirrorCoord;\r\n\t\t\t\tvarying vec4 worldPosition;\r\n\r\n\t\t\t\tvec4 getNoise( vec2 uv ) {\r\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\r\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\r\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\r\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\r\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\r\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\r\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\r\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\r\n\t\t\t\t\treturn noise * 0.5 - 1.0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\r\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\r\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\r\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\r\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t#include <common>\r\n\t\t\t\t#include <packing>\r\n\t\t\t\t#include <bsdfs>\r\n\t\t\t\t#include <fog_pars_fragment>\r\n\t\t\t\t#include <logdepthbuf_pars_fragment>\r\n\t\t\t\t#include <lights_pars_begin>\r\n\t\t\t\t#include <shadowmap_pars_fragment>\r\n\t\t\t\t#include <shadowmask_pars_fragment>\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\t#include <logdepthbuf_fragment>\r\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\r\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\r\n\r\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\r\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\r\n\r\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\r\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\r\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\r\n\r\n\t\t\t\t\tfloat distance = length(worldToEye);\r\n\r\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\r\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\r\n\r\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\r\n\t\t\t\t\tfloat rf0 = 0.3;\r\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\r\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\r\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\r\n\t\t\t\t\tvec3 outgoingLight = albedo;\r\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\r\n\r\n\t\t\t\t\t#include <tonemapping_fragment>\r\n\t\t\t\t\t#include <fog_fragment>\r\n\t\t\t\t}`\r\n    };\r\n    const material = new ShaderMaterial({\r\n      fragmentShader: mirrorShader.fragmentShader,\r\n      vertexShader: mirrorShader.vertexShader,\r\n      uniforms: UniformsUtils.clone(mirrorShader.uniforms),\r\n      lights: true,\r\n      side: side,\r\n      fog: fog\r\n    });\r\n    material.uniforms['mirrorSampler'].value = renderTarget.texture;\r\n    material.uniforms['textureMatrix'].value = textureMatrix;\r\n    material.uniforms['alpha'].value = alpha;\r\n    material.uniforms['time'].value = time;\r\n    material.uniforms['normalSampler'].value = normalSampler;\r\n    material.uniforms['sunColor'].value = sunColor;\r\n    material.uniforms['waterColor'].value = waterColor;\r\n    material.uniforms['sunDirection'].value = sunDirection;\r\n    material.uniforms['distortionScale'].value = distortionScale;\r\n    material.uniforms['eye'].value = eye;\r\n    scope.material = material;\r\n\r\n    scope.onBeforeRender = function (renderer, scene, camera) {\r\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\r\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\r\n      rotationMatrix.extractRotation(scope.matrixWorld);\r\n      normal.set(0, 0, 1);\r\n      normal.applyMatrix4(rotationMatrix);\r\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\r\n\r\n      if (view.dot(normal) > 0) return;\r\n      view.reflect(normal).negate();\r\n      view.add(mirrorWorldPosition);\r\n      rotationMatrix.extractRotation(camera.matrixWorld);\r\n      lookAtPosition.set(0, 0, -1);\r\n      lookAtPosition.applyMatrix4(rotationMatrix);\r\n      lookAtPosition.add(cameraWorldPosition);\r\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\r\n      target.reflect(normal).negate();\r\n      target.add(mirrorWorldPosition);\r\n      mirrorCamera.position.copy(view);\r\n      mirrorCamera.up.set(0, 1, 0);\r\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\r\n      mirrorCamera.up.reflect(normal);\r\n      mirrorCamera.lookAt(target);\r\n      mirrorCamera.far = camera.far; // Used in WebGLBackground\r\n\r\n      mirrorCamera.updateMatrixWorld();\r\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\r\n\r\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\r\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\r\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\r\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\r\n\r\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\r\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\r\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\r\n      const projectionMatrix = mirrorCamera.projectionMatrix;\r\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\r\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\r\n      q.z = -1.0;\r\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\r\n\r\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\r\n\r\n      projectionMatrix.elements[2] = clipPlane.x;\r\n      projectionMatrix.elements[6] = clipPlane.y;\r\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\r\n      projectionMatrix.elements[14] = clipPlane.w;\r\n      eye.setFromMatrixPosition(camera.matrixWorld); // Render\r\n\r\n      const currentRenderTarget = renderer.getRenderTarget();\r\n      const currentXrEnabled = renderer.xr.enabled;\r\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n      scope.visible = false;\r\n      renderer.xr.enabled = false; // Avoid camera modification and recursion\r\n\r\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\r\n\r\n      renderer.setRenderTarget(renderTarget);\r\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\r\n\r\n      if (renderer.autoClear === false) renderer.clear();\r\n      renderer.render(scene, mirrorCamera);\r\n      scope.visible = true;\r\n      renderer.xr.enabled = currentXrEnabled;\r\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\r\n\r\n      const viewport = camera.viewport;\r\n\r\n      if (viewport !== undefined) {\r\n        renderer.state.viewport(viewport);\r\n      }\r\n    };\r\n  }\r\n\r\n}\r\n\r\nWater.prototype.isWater = true;\r\n\r\nexport { Water };\r\n", "import { Mesh, BufferGeometry, BufferAttribute, DynamicDrawUsage, Color } from 'three';\r\n\r\n/**\r\n * Port of http://webglsamples.org/blob/blob.html\r\n */\r\n\r\nclass MarchingCubes extends Mesh {\r\n  constructor(resolution, material, enableUvs = false, enableColors = false, maxPolyCount = 10000) {\r\n    const geometry = new BufferGeometry();\r\n    super(geometry, material);\r\n    const scope = this; // temp buffers used in polygonize\r\n\r\n    const vlist = new Float32Array(12 * 3);\r\n    const nlist = new Float32Array(12 * 3);\r\n    const clist = new Float32Array(12 * 3);\r\n    this.enableUvs = enableUvs;\r\n    this.enableColors = enableColors; // functions have to be object properties\r\n    // prototype functions kill performance\r\n    // (tested and it was 4x slower !!!)\r\n\r\n    this.init = function (resolution) {\r\n      this.resolution = resolution; // parameters\r\n\r\n      this.isolation = 80.0; // size of field, 32 is pushing it in Javascript :)\r\n\r\n      this.size = resolution;\r\n      this.size2 = this.size * this.size;\r\n      this.size3 = this.size2 * this.size;\r\n      this.halfsize = this.size / 2.0; // deltas\r\n\r\n      this.delta = 2.0 / this.size;\r\n      this.yd = this.size;\r\n      this.zd = this.size2;\r\n      this.field = new Float32Array(this.size3);\r\n      this.normal_cache = new Float32Array(this.size3 * 3);\r\n      this.palette = new Float32Array(this.size3 * 3); //\r\n\r\n      this.count = 0;\r\n      const maxVertexCount = maxPolyCount * 3;\r\n      this.positionArray = new Float32Array(maxVertexCount * 3);\r\n      const positionAttribute = new BufferAttribute(this.positionArray, 3);\r\n      positionAttribute.setUsage(DynamicDrawUsage);\r\n      geometry.setAttribute('position', positionAttribute);\r\n      this.normalArray = new Float32Array(maxVertexCount * 3);\r\n      const normalAttribute = new BufferAttribute(this.normalArray, 3);\r\n      normalAttribute.setUsage(DynamicDrawUsage);\r\n      geometry.setAttribute('normal', normalAttribute);\r\n\r\n      if (this.enableUvs) {\r\n        this.uvArray = new Float32Array(maxVertexCount * 2);\r\n        const uvAttribute = new BufferAttribute(this.uvArray, 2);\r\n        uvAttribute.setUsage(DynamicDrawUsage);\r\n        geometry.setAttribute('uv', uvAttribute);\r\n      }\r\n\r\n      if (this.enableColors) {\r\n        this.colorArray = new Float32Array(maxVertexCount * 3);\r\n        const colorAttribute = new BufferAttribute(this.colorArray, 3);\r\n        colorAttribute.setUsage(DynamicDrawUsage);\r\n        geometry.setAttribute('color', colorAttribute);\r\n      }\r\n    }; ///////////////////////\r\n    // Polygonization\r\n    ///////////////////////\r\n\r\n\r\n    function lerp(a, b, t) {\r\n      return a + (b - a) * t;\r\n    }\r\n\r\n    function VIntX(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {\r\n      const mu = (isol - valp1) / (valp2 - valp1),\r\n            nc = scope.normal_cache;\r\n      vlist[offset + 0] = x + mu * scope.delta;\r\n      vlist[offset + 1] = y;\r\n      vlist[offset + 2] = z;\r\n      nlist[offset + 0] = lerp(nc[q + 0], nc[q + 3], mu);\r\n      nlist[offset + 1] = lerp(nc[q + 1], nc[q + 4], mu);\r\n      nlist[offset + 2] = lerp(nc[q + 2], nc[q + 5], mu);\r\n      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);\r\n      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);\r\n      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);\r\n    }\r\n\r\n    function VIntY(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {\r\n      const mu = (isol - valp1) / (valp2 - valp1),\r\n            nc = scope.normal_cache;\r\n      vlist[offset + 0] = x;\r\n      vlist[offset + 1] = y + mu * scope.delta;\r\n      vlist[offset + 2] = z;\r\n      const q2 = q + scope.yd * 3;\r\n      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);\r\n      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);\r\n      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);\r\n      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);\r\n      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);\r\n      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);\r\n    }\r\n\r\n    function VIntZ(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {\r\n      const mu = (isol - valp1) / (valp2 - valp1),\r\n            nc = scope.normal_cache;\r\n      vlist[offset + 0] = x;\r\n      vlist[offset + 1] = y;\r\n      vlist[offset + 2] = z + mu * scope.delta;\r\n      const q2 = q + scope.zd * 3;\r\n      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);\r\n      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);\r\n      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);\r\n      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);\r\n      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);\r\n      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);\r\n    }\r\n\r\n    function compNorm(q) {\r\n      const q3 = q * 3;\r\n\r\n      if (scope.normal_cache[q3] === 0.0) {\r\n        scope.normal_cache[q3 + 0] = scope.field[q - 1] - scope.field[q + 1];\r\n        scope.normal_cache[q3 + 1] = scope.field[q - scope.yd] - scope.field[q + scope.yd];\r\n        scope.normal_cache[q3 + 2] = scope.field[q - scope.zd] - scope.field[q + scope.zd];\r\n      }\r\n    } // Returns total number of triangles. Fills triangles.\r\n    // (this is where most of time is spent - it's inner work of O(n3) loop )\r\n\r\n\r\n    function polygonize(fx, fy, fz, q, isol) {\r\n      // cache indices\r\n      const q1 = q + 1,\r\n            qy = q + scope.yd,\r\n            qz = q + scope.zd,\r\n            q1y = q1 + scope.yd,\r\n            q1z = q1 + scope.zd,\r\n            qyz = q + scope.yd + scope.zd,\r\n            q1yz = q1 + scope.yd + scope.zd;\r\n      let cubeindex = 0;\r\n      const field0 = scope.field[q],\r\n            field1 = scope.field[q1],\r\n            field2 = scope.field[qy],\r\n            field3 = scope.field[q1y],\r\n            field4 = scope.field[qz],\r\n            field5 = scope.field[q1z],\r\n            field6 = scope.field[qyz],\r\n            field7 = scope.field[q1yz];\r\n      if (field0 < isol) cubeindex |= 1;\r\n      if (field1 < isol) cubeindex |= 2;\r\n      if (field2 < isol) cubeindex |= 8;\r\n      if (field3 < isol) cubeindex |= 4;\r\n      if (field4 < isol) cubeindex |= 16;\r\n      if (field5 < isol) cubeindex |= 32;\r\n      if (field6 < isol) cubeindex |= 128;\r\n      if (field7 < isol) cubeindex |= 64; // if cube is entirely in/out of the surface - bail, nothing to draw\r\n\r\n      const bits = edgeTable[cubeindex];\r\n      if (bits === 0) return 0;\r\n      const d = scope.delta,\r\n            fx2 = fx + d,\r\n            fy2 = fy + d,\r\n            fz2 = fz + d; // top of the cube\r\n\r\n      if (bits & 1) {\r\n        compNorm(q);\r\n        compNorm(q1);\r\n        VIntX(q * 3, 0, isol, fx, fy, fz, field0, field1, q, q1);\r\n      }\r\n\r\n      if (bits & 2) {\r\n        compNorm(q1);\r\n        compNorm(q1y);\r\n        VIntY(q1 * 3, 3, isol, fx2, fy, fz, field1, field3, q1, q1y);\r\n      }\r\n\r\n      if (bits & 4) {\r\n        compNorm(qy);\r\n        compNorm(q1y);\r\n        VIntX(qy * 3, 6, isol, fx, fy2, fz, field2, field3, qy, q1y);\r\n      }\r\n\r\n      if (bits & 8) {\r\n        compNorm(q);\r\n        compNorm(qy);\r\n        VIntY(q * 3, 9, isol, fx, fy, fz, field0, field2, q, qy);\r\n      } // bottom of the cube\r\n\r\n\r\n      if (bits & 16) {\r\n        compNorm(qz);\r\n        compNorm(q1z);\r\n        VIntX(qz * 3, 12, isol, fx, fy, fz2, field4, field5, qz, q1z);\r\n      }\r\n\r\n      if (bits & 32) {\r\n        compNorm(q1z);\r\n        compNorm(q1yz);\r\n        VIntY(q1z * 3, 15, isol, fx2, fy, fz2, field5, field7, q1z, q1yz);\r\n      }\r\n\r\n      if (bits & 64) {\r\n        compNorm(qyz);\r\n        compNorm(q1yz);\r\n        VIntX(qyz * 3, 18, isol, fx, fy2, fz2, field6, field7, qyz, q1yz);\r\n      }\r\n\r\n      if (bits & 128) {\r\n        compNorm(qz);\r\n        compNorm(qyz);\r\n        VIntY(qz * 3, 21, isol, fx, fy, fz2, field4, field6, qz, qyz);\r\n      } // vertical lines of the cube\r\n\r\n\r\n      if (bits & 256) {\r\n        compNorm(q);\r\n        compNorm(qz);\r\n        VIntZ(q * 3, 24, isol, fx, fy, fz, field0, field4, q, qz);\r\n      }\r\n\r\n      if (bits & 512) {\r\n        compNorm(q1);\r\n        compNorm(q1z);\r\n        VIntZ(q1 * 3, 27, isol, fx2, fy, fz, field1, field5, q1, q1z);\r\n      }\r\n\r\n      if (bits & 1024) {\r\n        compNorm(q1y);\r\n        compNorm(q1yz);\r\n        VIntZ(q1y * 3, 30, isol, fx2, fy2, fz, field3, field7, q1y, q1yz);\r\n      }\r\n\r\n      if (bits & 2048) {\r\n        compNorm(qy);\r\n        compNorm(qyz);\r\n        VIntZ(qy * 3, 33, isol, fx, fy2, fz, field2, field6, qy, qyz);\r\n      }\r\n\r\n      cubeindex <<= 4; // re-purpose cubeindex into an offset into triTable\r\n\r\n      let o1,\r\n          o2,\r\n          o3,\r\n          numtris = 0,\r\n          i = 0; // here is where triangles are created\r\n\r\n      while (triTable[cubeindex + i] != -1) {\r\n        o1 = cubeindex + i;\r\n        o2 = o1 + 1;\r\n        o3 = o1 + 2;\r\n        posnormtriv(vlist, nlist, clist, 3 * triTable[o1], 3 * triTable[o2], 3 * triTable[o3]);\r\n        i += 3;\r\n        numtris++;\r\n      }\r\n\r\n      return numtris;\r\n    }\r\n\r\n    function posnormtriv(pos, norm, colors, o1, o2, o3) {\r\n      const c = scope.count * 3; // positions\r\n\r\n      scope.positionArray[c + 0] = pos[o1];\r\n      scope.positionArray[c + 1] = pos[o1 + 1];\r\n      scope.positionArray[c + 2] = pos[o1 + 2];\r\n      scope.positionArray[c + 3] = pos[o2];\r\n      scope.positionArray[c + 4] = pos[o2 + 1];\r\n      scope.positionArray[c + 5] = pos[o2 + 2];\r\n      scope.positionArray[c + 6] = pos[o3];\r\n      scope.positionArray[c + 7] = pos[o3 + 1];\r\n      scope.positionArray[c + 8] = pos[o3 + 2]; // normals\r\n\r\n      if (scope.material.flatShading === true) {\r\n        const nx = (norm[o1 + 0] + norm[o2 + 0] + norm[o3 + 0]) / 3;\r\n        const ny = (norm[o1 + 1] + norm[o2 + 1] + norm[o3 + 1]) / 3;\r\n        const nz = (norm[o1 + 2] + norm[o2 + 2] + norm[o3 + 2]) / 3;\r\n        scope.normalArray[c + 0] = nx;\r\n        scope.normalArray[c + 1] = ny;\r\n        scope.normalArray[c + 2] = nz;\r\n        scope.normalArray[c + 3] = nx;\r\n        scope.normalArray[c + 4] = ny;\r\n        scope.normalArray[c + 5] = nz;\r\n        scope.normalArray[c + 6] = nx;\r\n        scope.normalArray[c + 7] = ny;\r\n        scope.normalArray[c + 8] = nz;\r\n      } else {\r\n        scope.normalArray[c + 0] = norm[o1 + 0];\r\n        scope.normalArray[c + 1] = norm[o1 + 1];\r\n        scope.normalArray[c + 2] = norm[o1 + 2];\r\n        scope.normalArray[c + 3] = norm[o2 + 0];\r\n        scope.normalArray[c + 4] = norm[o2 + 1];\r\n        scope.normalArray[c + 5] = norm[o2 + 2];\r\n        scope.normalArray[c + 6] = norm[o3 + 0];\r\n        scope.normalArray[c + 7] = norm[o3 + 1];\r\n        scope.normalArray[c + 8] = norm[o3 + 2];\r\n      } // uvs\r\n\r\n\r\n      if (scope.enableUvs) {\r\n        const d = scope.count * 2;\r\n        scope.uvArray[d + 0] = pos[o1 + 0];\r\n        scope.uvArray[d + 1] = pos[o1 + 2];\r\n        scope.uvArray[d + 2] = pos[o2 + 0];\r\n        scope.uvArray[d + 3] = pos[o2 + 2];\r\n        scope.uvArray[d + 4] = pos[o3 + 0];\r\n        scope.uvArray[d + 5] = pos[o3 + 2];\r\n      } // colors\r\n\r\n\r\n      if (scope.enableColors) {\r\n        scope.colorArray[c + 0] = colors[o1 + 0];\r\n        scope.colorArray[c + 1] = colors[o1 + 1];\r\n        scope.colorArray[c + 2] = colors[o1 + 2];\r\n        scope.colorArray[c + 3] = colors[o2 + 0];\r\n        scope.colorArray[c + 4] = colors[o2 + 1];\r\n        scope.colorArray[c + 5] = colors[o2 + 2];\r\n        scope.colorArray[c + 6] = colors[o3 + 0];\r\n        scope.colorArray[c + 7] = colors[o3 + 1];\r\n        scope.colorArray[c + 8] = colors[o3 + 2];\r\n      }\r\n\r\n      scope.count += 3;\r\n    } /////////////////////////////////////\r\n    // Metaballs\r\n    /////////////////////////////////////\r\n    // Adds a reciprocal ball (nice and blobby) that, to be fast, fades to zero after\r\n    // a fixed distance, determined by strength and subtract.\r\n\r\n\r\n    this.addBall = function (ballx, bally, ballz, strength, subtract, colors) {\r\n      const sign = Math.sign(strength);\r\n      strength = Math.abs(strength);\r\n      const userDefineColor = !(colors === undefined || colors === null);\r\n      let ballColor = new Color(ballx, bally, ballz);\r\n\r\n      if (userDefineColor) {\r\n        try {\r\n          ballColor = colors instanceof Color ? colors : Array.isArray(colors) ? new Color(Math.min(Math.abs(colors[0]), 1), Math.min(Math.abs(colors[1]), 1), Math.min(Math.abs(colors[2]), 1)) : new Color(colors);\r\n        } catch (err) {\r\n          ballColor = new Color(ballx, bally, ballz);\r\n        }\r\n      } // Let's solve the equation to find the radius:\r\n      // 1.0 / (0.000001 + radius^2) * strength - subtract = 0\r\n      // strength / (radius^2) = subtract\r\n      // strength = subtract * radius^2\r\n      // radius^2 = strength / subtract\r\n      // radius = sqrt(strength / subtract)\r\n\r\n\r\n      const radius = this.size * Math.sqrt(strength / subtract),\r\n            zs = ballz * this.size,\r\n            ys = bally * this.size,\r\n            xs = ballx * this.size;\r\n      let min_z = Math.floor(zs - radius);\r\n      if (min_z < 1) min_z = 1;\r\n      let max_z = Math.floor(zs + radius);\r\n      if (max_z > this.size - 1) max_z = this.size - 1;\r\n      let min_y = Math.floor(ys - radius);\r\n      if (min_y < 1) min_y = 1;\r\n      let max_y = Math.floor(ys + radius);\r\n      if (max_y > this.size - 1) max_y = this.size - 1;\r\n      let min_x = Math.floor(xs - radius);\r\n      if (min_x < 1) min_x = 1;\r\n      let max_x = Math.floor(xs + radius);\r\n      if (max_x > this.size - 1) max_x = this.size - 1; // Don't polygonize in the outer layer because normals aren't\r\n      // well-defined there.\r\n\r\n      let x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;\r\n\r\n      for (z = min_z; z < max_z; z++) {\r\n        z_offset = this.size2 * z;\r\n        fz = z / this.size - ballz;\r\n        fz2 = fz * fz;\r\n\r\n        for (y = min_y; y < max_y; y++) {\r\n          y_offset = z_offset + this.size * y;\r\n          fy = y / this.size - bally;\r\n          fy2 = fy * fy;\r\n\r\n          for (x = min_x; x < max_x; x++) {\r\n            fx = x / this.size - ballx;\r\n            val = strength / (0.000001 + fx * fx + fy2 + fz2) - subtract;\r\n\r\n            if (val > 0.0) {\r\n              this.field[y_offset + x] += val * sign; // optimization\r\n              // http://www.geisswerks.com/ryan/BLOBS/blobs.html\r\n\r\n              const ratio = Math.sqrt((x - xs) * (x - xs) + (y - ys) * (y - ys) + (z - zs) * (z - zs)) / radius;\r\n              const contrib = 1 - ratio * ratio * ratio * (ratio * (ratio * 6 - 15) + 10);\r\n              this.palette[(y_offset + x) * 3 + 0] += ballColor.r * contrib;\r\n              this.palette[(y_offset + x) * 3 + 1] += ballColor.g * contrib;\r\n              this.palette[(y_offset + x) * 3 + 2] += ballColor.b * contrib;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this.addPlaneX = function (strength, subtract) {\r\n      // cache attribute lookups\r\n      const size = this.size,\r\n            yd = this.yd,\r\n            zd = this.zd,\r\n            field = this.field;\r\n      let x,\r\n          y,\r\n          z,\r\n          xx,\r\n          val,\r\n          xdiv,\r\n          cxy,\r\n          dist = size * Math.sqrt(strength / subtract);\r\n      if (dist > size) dist = size;\r\n\r\n      for (x = 0; x < dist; x++) {\r\n        xdiv = x / size;\r\n        xx = xdiv * xdiv;\r\n        val = strength / (0.0001 + xx) - subtract;\r\n\r\n        if (val > 0.0) {\r\n          for (y = 0; y < size; y++) {\r\n            cxy = x + y * yd;\r\n\r\n            for (z = 0; z < size; z++) {\r\n              field[zd * z + cxy] += val;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this.addPlaneY = function (strength, subtract) {\r\n      // cache attribute lookups\r\n      const size = this.size,\r\n            yd = this.yd,\r\n            zd = this.zd,\r\n            field = this.field;\r\n      let x,\r\n          y,\r\n          z,\r\n          yy,\r\n          val,\r\n          ydiv,\r\n          cy,\r\n          cxy,\r\n          dist = size * Math.sqrt(strength / subtract);\r\n      if (dist > size) dist = size;\r\n\r\n      for (y = 0; y < dist; y++) {\r\n        ydiv = y / size;\r\n        yy = ydiv * ydiv;\r\n        val = strength / (0.0001 + yy) - subtract;\r\n\r\n        if (val > 0.0) {\r\n          cy = y * yd;\r\n\r\n          for (x = 0; x < size; x++) {\r\n            cxy = cy + x;\r\n\r\n            for (z = 0; z < size; z++) field[zd * z + cxy] += val;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this.addPlaneZ = function (strength, subtract) {\r\n      // cache attribute lookups\r\n      const size = this.size,\r\n            yd = this.yd,\r\n            zd = this.zd,\r\n            field = this.field;\r\n      let x,\r\n          y,\r\n          z,\r\n          zz,\r\n          val,\r\n          zdiv,\r\n          cz,\r\n          cyz,\r\n          dist = size * Math.sqrt(strength / subtract);\r\n      if (dist > size) dist = size;\r\n\r\n      for (z = 0; z < dist; z++) {\r\n        zdiv = z / size;\r\n        zz = zdiv * zdiv;\r\n        val = strength / (0.0001 + zz) - subtract;\r\n\r\n        if (val > 0.0) {\r\n          cz = zd * z;\r\n\r\n          for (y = 0; y < size; y++) {\r\n            cyz = cz + y * yd;\r\n\r\n            for (x = 0; x < size; x++) field[cyz + x] += val;\r\n          }\r\n        }\r\n      }\r\n    }; /////////////////////////////////////\r\n    // Updates\r\n    /////////////////////////////////////\r\n\r\n\r\n    this.setCell = function (x, y, z, value) {\r\n      const index = this.size2 * z + this.size * y + x;\r\n      this.field[index] = value;\r\n    };\r\n\r\n    this.getCell = function (x, y, z) {\r\n      const index = this.size2 * z + this.size * y + x;\r\n      return this.field[index];\r\n    };\r\n\r\n    this.blur = function (intensity = 1) {\r\n      const field = this.field;\r\n      const fieldCopy = field.slice();\r\n      const size = this.size;\r\n      const size2 = this.size2;\r\n\r\n      for (let x = 0; x < size; x++) {\r\n        for (let y = 0; y < size; y++) {\r\n          for (let z = 0; z < size; z++) {\r\n            const index = size2 * z + size * y + x;\r\n            let val = fieldCopy[index];\r\n            let count = 1;\r\n\r\n            for (let x2 = -1; x2 <= 1; x2 += 2) {\r\n              const x3 = x2 + x;\r\n              if (x3 < 0 || x3 >= size) continue;\r\n\r\n              for (let y2 = -1; y2 <= 1; y2 += 2) {\r\n                const y3 = y2 + y;\r\n                if (y3 < 0 || y3 >= size) continue;\r\n\r\n                for (let z2 = -1; z2 <= 1; z2 += 2) {\r\n                  const z3 = z2 + z;\r\n                  if (z3 < 0 || z3 >= size) continue;\r\n                  const index2 = size2 * z3 + size * y3 + x3;\r\n                  const val2 = fieldCopy[index2];\r\n                  count++;\r\n                  val += intensity * (val2 - val) / count;\r\n                }\r\n              }\r\n            }\r\n\r\n            field[index] = val;\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this.reset = function () {\r\n      // wipe the normal cache\r\n      for (let i = 0; i < this.size3; i++) {\r\n        this.normal_cache[i * 3] = 0.0;\r\n        this.field[i] = 0.0;\r\n        this.palette[i * 3] = this.palette[i * 3 + 1] = this.palette[i * 3 + 2] = 0.0;\r\n      }\r\n    };\r\n\r\n    this.onBeforeRender = function () {\r\n      this.count = 0; // Triangulate. Yeah, this is slow.\r\n\r\n      const smin2 = this.size - 2;\r\n\r\n      for (let z = 1; z < smin2; z++) {\r\n        const z_offset = this.size2 * z;\r\n        const fz = (z - this.halfsize) / this.halfsize; //+ 1\r\n\r\n        for (let y = 1; y < smin2; y++) {\r\n          const y_offset = z_offset + this.size * y;\r\n          const fy = (y - this.halfsize) / this.halfsize; //+ 1\r\n\r\n          for (let x = 1; x < smin2; x++) {\r\n            const fx = (x - this.halfsize) / this.halfsize; //+ 1\r\n\r\n            const q = y_offset + x;\r\n            polygonize(fx, fy, fz, q, this.isolation);\r\n          }\r\n        }\r\n      } // reset unneeded data\r\n\r\n\r\n      for (let i = this.count * 3; i < this.positionArray.length; i++) {\r\n        this.positionArray[i] = 0.0;\r\n      } // update geometry data\r\n\r\n\r\n      geometry.getAttribute('position').needsUpdate = true;\r\n      geometry.getAttribute('normal').needsUpdate = true;\r\n      if (this.enableUvs) geometry.getAttribute('uv').needsUpdate = true;\r\n      if (this.enableColors) geometry.getAttribute('color').needsUpdate = true; // safety check\r\n\r\n      if (this.count / 3 > maxPolyCount) {\r\n        console.warn('MarchingCubes: Geometry buffers too small for rendering. Please create an instance with a higher poly count.');\r\n      }\r\n    };\r\n\r\n    this.init(resolution);\r\n  }\r\n\r\n}\r\n\r\nMarchingCubes.prototype.isMarchingCubes = true; /////////////////////////////////////\r\n// Marching cubes lookup tables\r\n/////////////////////////////////////\r\n// These tables are straight from Paul Bourke's page:\r\n// http://paulbourke.net/geometry/polygonise/\r\n// who in turn got them from Cory Gene Bloyd.\r\n// prettier-ignore\r\n\r\nconst edgeTable = new Int32Array([0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0]); // prettier-ignore\r\n\r\nconst triTable = new Int32Array([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1, 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1, 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);\r\n\r\nexport { MarchingCubes, edgeTable, triTable };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\n\r\n// Ported from Stefan Gustavson's java implementation\r\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\r\n// Read Stefan's excellent paper for details on how this code works.\r\n//\r\n// Sean McCullough banksean@gmail.com\r\n//\r\n// Added 4D noise\r\nclass SimplexNoise {\r\n  // To remove the need for index wrapping, double the permutation table length\r\n  // A lookup table to traverse the simplex around a given point in 4D.\r\n  // Details can be found where this table is used, in the 4D noise method.\r\n\r\n  /**\r\n   * You can pass in a random number generator object if you like.\r\n   * It is assumed to have a random() method.\r\n   */\r\n  constructor(r = Math) {\r\n    _defineProperty(this, \"grad3\", [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]]);\r\n\r\n    _defineProperty(this, \"grad4\", [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]]);\r\n\r\n    _defineProperty(this, \"p\", []);\r\n\r\n    _defineProperty(this, \"perm\", []);\r\n\r\n    _defineProperty(this, \"simplex\", [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]]);\r\n\r\n    _defineProperty(this, \"dot\", (g, x, y) => {\r\n      return g[0] * x + g[1] * y;\r\n    });\r\n\r\n    _defineProperty(this, \"dot3\", (g, x, y, z) => {\r\n      return g[0] * x + g[1] * y + g[2] * z;\r\n    });\r\n\r\n    _defineProperty(this, \"dot4\", (g, x, y, z, w) => {\r\n      return g[0] * x + g[1] * y + g[2] * z + g[3] * w;\r\n    });\r\n\r\n    _defineProperty(this, \"noise\", (xin, yin) => {\r\n      let n0;\r\n      let n1;\r\n      let n2; // Noise contributions from the three corners\r\n      // Skew the input space to determine which simplex cell we're in\r\n\r\n      const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);\r\n      const s = (xin + yin) * F2; // Hairy factor for 2D\r\n\r\n      const i = Math.floor(xin + s);\r\n      const j = Math.floor(yin + s);\r\n      const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;\r\n      const t = (i + j) * G2;\r\n      const X0 = i - t; // Unskew the cell origin back to (x,y) space\r\n\r\n      const Y0 = j - t;\r\n      const x0 = xin - X0; // The x,y distances from the cell origin\r\n\r\n      const y0 = yin - Y0; // For the 2D case, the simplex shape is an equilateral triangle.\r\n      // Determine which simplex we are in.\r\n      // upper triangle, YX order: (0,0)->(0,1)->(1,1)\r\n\r\n      let i1 = 0; // Offsets for second (middle) corner of simplex in (i,j) coords\r\n\r\n      let j1 = 1;\r\n\r\n      if (x0 > y0) {\r\n        i1 = 1;\r\n        j1 = 0;\r\n      } // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\r\n      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\r\n      // c = (3-sqrt(3))/6\r\n\r\n\r\n      const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\r\n\r\n      const y1 = y0 - j1 + G2;\r\n      const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\r\n\r\n      const y2 = y0 - 1.0 + 2.0 * G2; // Work out the hashed gradient indices of the three simplex corners\r\n\r\n      const ii = i & 255;\r\n      const jj = j & 255;\r\n      const gi0 = this.perm[ii + this.perm[jj]] % 12;\r\n      const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;\r\n      const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12; // Calculate the contribution from the three corners\r\n\r\n      let t0 = 0.5 - x0 * x0 - y0 * y0;\r\n\r\n      if (t0 < 0) {\r\n        n0 = 0.0;\r\n      } else {\r\n        t0 *= t0;\r\n        n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient\r\n      }\r\n\r\n      let t1 = 0.5 - x1 * x1 - y1 * y1;\r\n\r\n      if (t1 < 0) {\r\n        n1 = 0.0;\r\n      } else {\r\n        t1 *= t1;\r\n        n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);\r\n      }\r\n\r\n      let t2 = 0.5 - x2 * x2 - y2 * y2;\r\n\r\n      if (t2 < 0) {\r\n        n2 = 0.0;\r\n      } else {\r\n        t2 *= t2;\r\n        n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);\r\n      } // Add contributions from each corner to get the final noise value.\r\n      // The result is scaled to return values in the interval [-1,1].\r\n\r\n\r\n      return 70.0 * (n0 + n1 + n2);\r\n    });\r\n\r\n    _defineProperty(this, \"noise3d\", (xin, yin, zin) => {\r\n      // Noise contributions from the four corners\r\n      let n0;\r\n      let n1;\r\n      let n2;\r\n      let n3; // Skew the input space to determine which simplex cell we're in\r\n\r\n      const F3 = 1.0 / 3.0;\r\n      const s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D\r\n\r\n      const i = Math.floor(xin + s);\r\n      const j = Math.floor(yin + s);\r\n      const k = Math.floor(zin + s);\r\n      const G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too\r\n\r\n      const t = (i + j + k) * G3;\r\n      const X0 = i - t; // Unskew the cell origin back to (x,y,z) space\r\n\r\n      const Y0 = j - t;\r\n      const Z0 = k - t;\r\n      const x0 = xin - X0; // The x,y,z distances from the cell origin\r\n\r\n      const y0 = yin - Y0;\r\n      const z0 = zin - Z0; // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\r\n      // Determine which simplex we are in.\r\n\r\n      let i1;\r\n      let j1;\r\n      let k1; // Offsets for second corner of simplex in (i,j,k) coords\r\n\r\n      let i2;\r\n      let j2;\r\n      let k2; // Offsets for third corner of simplex in (i,j,k) coords\r\n\r\n      if (x0 >= y0) {\r\n        if (y0 >= z0) {\r\n          i1 = 1;\r\n          j1 = 0;\r\n          k1 = 0;\r\n          i2 = 1;\r\n          j2 = 1;\r\n          k2 = 0; // X Y Z order\r\n        } else if (x0 >= z0) {\r\n          i1 = 1;\r\n          j1 = 0;\r\n          k1 = 0;\r\n          i2 = 1;\r\n          j2 = 0;\r\n          k2 = 1; // X Z Y order\r\n        } else {\r\n          i1 = 0;\r\n          j1 = 0;\r\n          k1 = 1;\r\n          i2 = 1;\r\n          j2 = 0;\r\n          k2 = 1;\r\n        } // Z X Y order\r\n\r\n      } else {\r\n        // x0<y0\r\n        if (y0 < z0) {\r\n          i1 = 0;\r\n          j1 = 0;\r\n          k1 = 1;\r\n          i2 = 0;\r\n          j2 = 1;\r\n          k2 = 1; // Z Y X order\r\n        } else if (x0 < z0) {\r\n          i1 = 0;\r\n          j1 = 1;\r\n          k1 = 0;\r\n          i2 = 0;\r\n          j2 = 1;\r\n          k2 = 1; // Y Z X order\r\n        } else {\r\n          i1 = 0;\r\n          j1 = 1;\r\n          k1 = 0;\r\n          i2 = 1;\r\n          j2 = 1;\r\n          k2 = 0;\r\n        } // Y X Z order\r\n\r\n      } // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\r\n      // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\r\n      // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\r\n      // c = 1/6.\r\n\r\n\r\n      const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\r\n\r\n      const y1 = y0 - j1 + G3;\r\n      const z1 = z0 - k1 + G3;\r\n      const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\r\n\r\n      const y2 = y0 - j2 + 2.0 * G3;\r\n      const z2 = z0 - k2 + 2.0 * G3;\r\n      const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\r\n\r\n      const y3 = y0 - 1.0 + 3.0 * G3;\r\n      const z3 = z0 - 1.0 + 3.0 * G3; // Work out the hashed gradient indices of the four simplex corners\r\n\r\n      const ii = i & 255;\r\n      const jj = j & 255;\r\n      const kk = k & 255;\r\n      const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;\r\n      const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;\r\n      const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;\r\n      const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12; // Calculate the contribution from the four corners\r\n\r\n      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\r\n\r\n      if (t0 < 0) {\r\n        n0 = 0.0;\r\n      } else {\r\n        t0 *= t0;\r\n        n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);\r\n      }\r\n\r\n      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\r\n\r\n      if (t1 < 0) {\r\n        n1 = 0.0;\r\n      } else {\r\n        t1 *= t1;\r\n        n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);\r\n      }\r\n\r\n      let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\r\n\r\n      if (t2 < 0) {\r\n        n2 = 0.0;\r\n      } else {\r\n        t2 *= t2;\r\n        n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);\r\n      }\r\n\r\n      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\r\n\r\n      if (t3 < 0) {\r\n        n3 = 0.0;\r\n      } else {\r\n        t3 *= t3;\r\n        n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);\r\n      } // Add contributions from each corner to get the final noise value.\r\n      // The result is scaled to stay just inside [-1,1]\r\n\r\n\r\n      return 32.0 * (n0 + n1 + n2 + n3);\r\n    });\r\n\r\n    _defineProperty(this, \"noise4d\", (x, y, z, w) => {\r\n      // For faster and easier lookups\r\n      const grad4 = this.grad4;\r\n      const simplex = this.simplex;\r\n      const perm = this.perm; // The skewing and unskewing factors are hairy again for the 4D case\r\n\r\n      const F4 = (Math.sqrt(5.0) - 1.0) / 4.0;\r\n      const G4 = (5.0 - Math.sqrt(5.0)) / 20.0;\r\n      let n0;\r\n      let n1;\r\n      let n2;\r\n      let n3;\r\n      let n4; // Noise contributions from the five corners\r\n      // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\r\n\r\n      const s = (x + y + z + w) * F4; // Factor for 4D skewing\r\n\r\n      const i = Math.floor(x + s);\r\n      const j = Math.floor(y + s);\r\n      const k = Math.floor(z + s);\r\n      const l = Math.floor(w + s);\r\n      const t = (i + j + k + l) * G4; // Factor for 4D unskewing\r\n\r\n      const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\r\n\r\n      const Y0 = j - t;\r\n      const Z0 = k - t;\r\n      const W0 = l - t;\r\n      const x0 = x - X0; // The x,y,z,w distances from the cell origin\r\n\r\n      const y0 = y - Y0;\r\n      const z0 = z - Z0;\r\n      const w0 = w - W0; // For the 4D case, the simplex is a 4D shape I won't even try to describe.\r\n      // To find out which of the 24 possible simplices we're in, we need to\r\n      // determine the magnitude ordering of x0, y0, z0 and w0.\r\n      // The method below is a good way of finding the ordering of x,y,z,w and\r\n      // then find the correct traversal order for the simplex we’re in.\r\n      // First, six pair-wise comparisons are performed between each possible pair\r\n      // of the four coordinates, and the results are used to add up binary bits\r\n      // for an integer index.\r\n\r\n      const c1 = x0 > y0 ? 32 : 0;\r\n      const c2 = x0 > z0 ? 16 : 0;\r\n      const c3 = y0 > z0 ? 8 : 0;\r\n      const c4 = x0 > w0 ? 4 : 0;\r\n      const c5 = y0 > w0 ? 2 : 0;\r\n      const c6 = z0 > w0 ? 1 : 0;\r\n      const c = c1 + c2 + c3 + c4 + c5 + c6; // The integer offsets for the second simplex corner\r\n\r\n      let i1;\r\n      let j1;\r\n      let k1;\r\n      let l1; // The integer offsets for the third simplex corner\r\n\r\n      let i2;\r\n      let j2;\r\n      let k2;\r\n      let l2; // The integer offsets for the fourth simplex corner\r\n\r\n      let i3;\r\n      let j3;\r\n      let k3;\r\n      let l3; // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\r\n      // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\r\n      // impossible. Only the 24 indices which have non-zero entries make any sense.\r\n      // We use a thresholding to set the coordinates in turn from the largest magnitude.\r\n      // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\r\n\r\n      i1 = simplex[c][0] >= 3 ? 1 : 0;\r\n      j1 = simplex[c][1] >= 3 ? 1 : 0;\r\n      k1 = simplex[c][2] >= 3 ? 1 : 0;\r\n      l1 = simplex[c][3] >= 3 ? 1 : 0; // The number 2 in the \"simplex\" array is at the second largest coordinate.\r\n\r\n      i2 = simplex[c][0] >= 2 ? 1 : 0;\r\n      j2 = simplex[c][1] >= 2 ? 1 : 0;\r\n      k2 = simplex[c][2] >= 2 ? 1 : 0;\r\n      l2 = simplex[c][3] >= 2 ? 1 : 0; // The number 1 in the \"simplex\" array is at the second smallest coordinate.\r\n\r\n      i3 = simplex[c][0] >= 1 ? 1 : 0;\r\n      j3 = simplex[c][1] >= 1 ? 1 : 0;\r\n      k3 = simplex[c][2] >= 1 ? 1 : 0;\r\n      l3 = simplex[c][3] >= 1 ? 1 : 0; // The fifth corner has all coordinate offsets = 1, so no need to look that up.\r\n\r\n      const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\r\n\r\n      const y1 = y0 - j1 + G4;\r\n      const z1 = z0 - k1 + G4;\r\n      const w1 = w0 - l1 + G4;\r\n      const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\r\n\r\n      const y2 = y0 - j2 + 2.0 * G4;\r\n      const z2 = z0 - k2 + 2.0 * G4;\r\n      const w2 = w0 - l2 + 2.0 * G4;\r\n      const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\r\n\r\n      const y3 = y0 - j3 + 3.0 * G4;\r\n      const z3 = z0 - k3 + 3.0 * G4;\r\n      const w3 = w0 - l3 + 3.0 * G4;\r\n      const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\r\n\r\n      const y4 = y0 - 1.0 + 4.0 * G4;\r\n      const z4 = z0 - 1.0 + 4.0 * G4;\r\n      const w4 = w0 - 1.0 + 4.0 * G4; // Work out the hashed gradient indices of the five simplex corners\r\n\r\n      const ii = i & 255;\r\n      const jj = j & 255;\r\n      const kk = k & 255;\r\n      const ll = l & 255;\r\n      const gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;\r\n      const gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;\r\n      const gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;\r\n      const gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;\r\n      const gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32; // Calculate the contribution from the five corners\r\n\r\n      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\r\n\r\n      if (t0 < 0) {\r\n        n0 = 0.0;\r\n      } else {\r\n        t0 *= t0;\r\n        n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);\r\n      }\r\n\r\n      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\r\n\r\n      if (t1 < 0) {\r\n        n1 = 0.0;\r\n      } else {\r\n        t1 *= t1;\r\n        n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);\r\n      }\r\n\r\n      let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\r\n\r\n      if (t2 < 0) {\r\n        n2 = 0.0;\r\n      } else {\r\n        t2 *= t2;\r\n        n2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);\r\n      }\r\n\r\n      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\r\n\r\n      if (t3 < 0) {\r\n        n3 = 0.0;\r\n      } else {\r\n        t3 *= t3;\r\n        n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);\r\n      }\r\n\r\n      let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\r\n\r\n      if (t4 < 0) {\r\n        n4 = 0.0;\r\n      } else {\r\n        t4 *= t4;\r\n        n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);\r\n      } // Sum up and scale the result to cover the range [-1,1]\r\n\r\n\r\n      return 27.0 * (n0 + n1 + n2 + n3 + n4);\r\n    });\r\n\r\n    for (let i = 0; i < 256; i++) {\r\n      this.p[i] = Math.floor(r.random() * 256);\r\n    }\r\n\r\n    for (let i = 0; i < 512; i++) {\r\n      this.perm[i] = this.p[i & 255];\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport { SimplexNoise };\r\n", "import { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from 'three';\r\nimport { SimplexNoise } from '../math/SimplexNoise.js';\r\n\r\n/**\r\n * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\r\n *\r\n *\r\n * Usage\r\n *\r\n * var myRay = new LightningStrike( paramsObject );\r\n * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\r\n * scene.add( myRayMesh );\r\n * ...\r\n * myRay.update( currentTime );\r\n *\r\n * The \"currentTime\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\r\n *\r\n * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\r\n *\r\n *\r\n * LightningStrike parameters\r\n *\r\n * The paramsObject can contain any of the following parameters.\r\n *\r\n * Legend:\r\n * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\r\n * 'Subray': A ramification of the ray. It is not a LightningStrike object.\r\n * 'Segment': A linear segment piece of a subray.\r\n * 'Leaf segment': A ray segment which cannot be smaller.\r\n *\r\n *\r\n * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\r\n *\r\n * @param {Vector3} sourceOffset The point where the ray starts.\r\n *\r\n * @param {Vector3} destOffset The point where the ray ends.\r\n *\r\n * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\r\n *\r\n * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\r\n *\r\n * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\r\n *\r\n * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\r\n *\r\n * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\r\n *\r\n * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\r\n *\r\n * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\r\n *\r\n * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\r\n *\r\n * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\r\n *\r\n * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\r\n *\r\n *\r\n * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\r\n *\r\n * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\r\n *\r\n * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\r\n *\r\n * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\r\n *\r\n * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\r\n *\r\n * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\r\n *\r\n * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\r\n *\r\n * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\r\n *\r\n *\r\n * These parameters cannot change after lightning creation:\r\n *\r\n * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\r\n *\r\n * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\r\n *\r\n * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\r\n *\r\n * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\r\n *\r\n * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\r\n *\r\n * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\r\n *\r\n * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\r\n * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\r\n * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\r\n * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\r\n * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\r\n *\r\n * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\r\n *\r\n * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\r\n *\r\n * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\r\n *\r\n *\r\n */\r\n\r\nclass LightningStrike extends BufferGeometry {\r\n  constructor(rayParameters) {\r\n    super();\r\n    this.type = 'LightningStrike'; // Set parameters, and set undefined parameters to default values\r\n\r\n    rayParameters = rayParameters || {};\r\n    this.init(LightningStrike.copyParameters(rayParameters, rayParameters)); // Creates and populates the mesh\r\n\r\n    this.createMesh();\r\n  }\r\n\r\n  update(time) {\r\n    if (this.isStatic) return;\r\n\r\n    if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\r\n      this.updateMesh(time);\r\n\r\n      if (time < this.subrays[0].endPropagationTime) {\r\n        this.state = LightningStrike.RAY_PROPAGATING;\r\n      } else if (time > this.subrays[0].beginVanishingTime) {\r\n        this.state = LightningStrike.RAY_VANISHING;\r\n      } else {\r\n        this.state = LightningStrike.RAY_STEADY;\r\n      }\r\n\r\n      this.visible = true;\r\n    } else {\r\n      this.visible = false;\r\n\r\n      if (time < this.rayParameters.birthTime) {\r\n        this.state = LightningStrike.RAY_UNBORN;\r\n      } else {\r\n        this.state = LightningStrike.RAY_EXTINGUISHED;\r\n      }\r\n    }\r\n  }\r\n\r\n  init(rayParameters) {\r\n    // Init all the state from the parameters\r\n    this.rayParameters = rayParameters; // These parameters cannot change after lightning creation:\r\n\r\n    this.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor(rayParameters.maxIterations) : 9;\r\n    rayParameters.maxIterations = this.maxIterations;\r\n    this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false;\r\n    rayParameters.isStatic = this.isStatic;\r\n    this.ramification = rayParameters.ramification !== undefined ? Math.floor(rayParameters.ramification) : 5;\r\n    rayParameters.ramification = this.ramification;\r\n    this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== undefined ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\r\n    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\r\n    this.recursionProbability = rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6;\r\n    rayParameters.recursionProbability = this.recursionProbability;\r\n    this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false;\r\n    rayParameters.generateUVs = this.generateUVs; // Random generator\r\n\r\n    if (rayParameters.randomGenerator !== undefined) {\r\n      this.randomGenerator = rayParameters.randomGenerator;\r\n      this.seedGenerator = rayParameters.randomGenerator;\r\n\r\n      if (rayParameters.noiseSeed !== undefined) {\r\n        this.seedGenerator.setSeed(rayParameters.noiseSeed);\r\n      }\r\n    } else {\r\n      this.randomGenerator = LightningStrike.createRandomGenerator();\r\n      this.seedGenerator = Math;\r\n    } // Ray creation callbacks\r\n\r\n\r\n    if (rayParameters.onDecideSubrayCreation !== undefined) {\r\n      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\r\n    } else {\r\n      this.createDefaultSubrayCreationCallbacks();\r\n\r\n      if (rayParameters.onSubrayCreation !== undefined) {\r\n        this.onSubrayCreation = rayParameters.onSubrayCreation;\r\n      }\r\n    } // Internal state\r\n\r\n\r\n    this.state = LightningStrike.RAY_INITIALIZED;\r\n    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\r\n    rayParameters.maxSubrays = this.maxSubrays;\r\n    this.maxRaySegments = 2 * (1 << this.maxIterations);\r\n    this.subrays = [];\r\n\r\n    for (let i = 0; i < this.maxSubrays; i++) {\r\n      this.subrays.push(this.createSubray());\r\n    }\r\n\r\n    this.raySegments = [];\r\n\r\n    for (let i = 0; i < this.maxRaySegments; i++) {\r\n      this.raySegments.push(this.createSegment());\r\n    }\r\n\r\n    this.time = 0;\r\n    this.timeFraction = 0;\r\n    this.currentSegmentCallback = null;\r\n    this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\r\n    this.numSubrays = 0;\r\n    this.currentSubray = null;\r\n    this.currentSegmentIndex = 0;\r\n    this.isInitialSegment = false;\r\n    this.subrayProbability = 0;\r\n    this.currentVertex = 0;\r\n    this.currentIndex = 0;\r\n    this.currentCoordinate = 0;\r\n    this.currentUVCoordinate = 0;\r\n    this.vertices = null;\r\n    this.uvs = null;\r\n    this.indices = null;\r\n    this.positionAttribute = null;\r\n    this.uvsAttribute = null;\r\n    this.simplexX = new SimplexNoise(this.seedGenerator);\r\n    this.simplexY = new SimplexNoise(this.seedGenerator);\r\n    this.simplexZ = new SimplexNoise(this.seedGenerator); // Temp vectors\r\n\r\n    this.forwards = new Vector3();\r\n    this.forwardsFill = new Vector3();\r\n    this.side = new Vector3();\r\n    this.down = new Vector3();\r\n    this.middlePos = new Vector3();\r\n    this.middleLinPos = new Vector3();\r\n    this.newPos = new Vector3();\r\n    this.vPos = new Vector3();\r\n    this.cross1 = new Vector3();\r\n  }\r\n\r\n  createMesh() {\r\n    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\r\n    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\r\n    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\r\n    this.vertices = new Float32Array(maxVerts * 3);\r\n    this.indices = new Uint32Array(maxIndices);\r\n\r\n    if (this.generateUVs) {\r\n      this.uvs = new Float32Array(maxVerts * 2);\r\n    } // Populate the mesh\r\n\r\n\r\n    this.fillMesh(0);\r\n    this.setIndex(new Uint32BufferAttribute(this.indices, 1));\r\n    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\r\n    this.setAttribute('position', this.positionAttribute);\r\n\r\n    if (this.generateUVs) {\r\n      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\r\n      this.setAttribute('uv', this.uvsAttribute);\r\n    }\r\n\r\n    if (!this.isStatic) {\r\n      this.index.usage = DynamicDrawUsage;\r\n      this.positionAttribute.usage = DynamicDrawUsage;\r\n\r\n      if (this.generateUVs) {\r\n        this.uvsAttribute.usage = DynamicDrawUsage;\r\n      }\r\n    } // Store buffers for later modification\r\n\r\n\r\n    this.vertices = this.positionAttribute.array;\r\n    this.indices = this.index.array;\r\n\r\n    if (this.generateUVs) {\r\n      this.uvs = this.uvsAttribute.array;\r\n    }\r\n  }\r\n\r\n  updateMesh(time) {\r\n    this.fillMesh(time);\r\n    this.drawRange.count = this.currentIndex;\r\n    this.index.needsUpdate = true;\r\n    this.positionAttribute.needsUpdate = true;\r\n\r\n    if (this.generateUVs) {\r\n      this.uvsAttribute.needsUpdate = true;\r\n    }\r\n  }\r\n\r\n  fillMesh(time) {\r\n    const scope = this;\r\n    this.currentVertex = 0;\r\n    this.currentIndex = 0;\r\n    this.currentCoordinate = 0;\r\n    this.currentUVCoordinate = 0;\r\n    this.fractalRay(time, function fillVertices(segment) {\r\n      const subray = scope.currentSubray;\r\n\r\n      if (time < subray.birthTime) {\r\n        //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\r\n        return;\r\n      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\r\n        // Eternal rays don't propagate nor vanish, but its subrays do\r\n        scope.createPrism(segment);\r\n        scope.onDecideSubrayCreation(segment, scope);\r\n      } else if (time < subray.endPropagationTime) {\r\n        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\r\n          // Ray propagation has arrived to this segment\r\n          scope.createPrism(segment);\r\n          scope.onDecideSubrayCreation(segment, scope);\r\n        }\r\n      } else if (time < subray.beginVanishingTime) {\r\n        // Ray is steady (nor propagating nor vanishing)\r\n        scope.createPrism(segment);\r\n        scope.onDecideSubrayCreation(segment, scope);\r\n      } else {\r\n        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\r\n          // Segment has not yet vanished\r\n          scope.createPrism(segment);\r\n        }\r\n\r\n        scope.onDecideSubrayCreation(segment, scope);\r\n      }\r\n    });\r\n  }\r\n\r\n  addNewSubray()\r\n  /*rayParameters*/\r\n  {\r\n    return this.subrays[this.numSubrays++];\r\n  }\r\n\r\n  initSubray(subray, rayParameters) {\r\n    subray.pos0.copy(rayParameters.sourceOffset);\r\n    subray.pos1.copy(rayParameters.destOffset);\r\n    subray.up0.copy(rayParameters.up0);\r\n    subray.up1.copy(rayParameters.up1);\r\n    subray.radius0 = rayParameters.radius0;\r\n    subray.radius1 = rayParameters.radius1;\r\n    subray.birthTime = rayParameters.birthTime;\r\n    subray.deathTime = rayParameters.deathTime;\r\n    subray.timeScale = rayParameters.timeScale;\r\n    subray.roughness = rayParameters.roughness;\r\n    subray.straightness = rayParameters.straightness;\r\n    subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\r\n    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\r\n    subray.maxIterations = this.maxIterations;\r\n    subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0;\r\n    subray.recursion = 0;\r\n  }\r\n\r\n  fractalRay(time, segmentCallback) {\r\n    this.time = time;\r\n    this.currentSegmentCallback = segmentCallback;\r\n    this.numSubrays = 0; // Add the top level subray\r\n\r\n    this.initSubray(this.addNewSubray(), this.rayParameters); // Process all subrays that are being generated until consuming all of them\r\n\r\n    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\r\n      const subray = this.subrays[subrayIndex];\r\n      this.currentSubray = subray;\r\n      this.randomGenerator.setSeed(subray.seed);\r\n      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\r\n      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\r\n      const random1 = this.randomGenerator.random;\r\n      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\r\n      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\r\n      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\r\n      this.currentSegmentIndex = 0;\r\n      this.isInitialSegment = true;\r\n      const segment = this.getNewSegment();\r\n      segment.iteration = 0;\r\n      segment.pos0.copy(subray.pos0);\r\n      segment.pos1.copy(subray.pos1);\r\n      segment.linPos0.copy(subray.linPos0);\r\n      segment.linPos1.copy(subray.linPos1);\r\n      segment.up0.copy(subray.up0);\r\n      segment.up1.copy(subray.up1);\r\n      segment.radius0 = subray.radius0;\r\n      segment.radius1 = subray.radius1;\r\n      segment.fraction0 = 0;\r\n      segment.fraction1 = 1;\r\n      segment.positionVariationFactor = 1 - subray.straightness;\r\n      this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\r\n      this.fractalRayRecursive(segment);\r\n    }\r\n\r\n    this.currentSegmentCallback = null;\r\n    this.currentSubray = null;\r\n  }\r\n\r\n  fractalRayRecursive(segment) {\r\n    // Leave recursion condition\r\n    if (segment.iteration >= this.currentSubray.maxIterations) {\r\n      this.currentSegmentCallback(segment);\r\n      return;\r\n    } // Interpolation\r\n\r\n\r\n    this.forwards.subVectors(segment.pos1, segment.pos0);\r\n    let lForwards = this.forwards.length();\r\n\r\n    if (lForwards < 0.000001) {\r\n      this.forwards.set(0, 0, 0.01);\r\n      lForwards = this.forwards.length();\r\n    }\r\n\r\n    const middleRadius = (segment.radius0 + segment.radius1) * 0.5;\r\n    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\r\n    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\r\n    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\r\n    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\r\n    const p = this.middleLinPos; // Noise\r\n\r\n    this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\r\n    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\r\n    this.newPos.add(this.middlePos); // Recursion\r\n\r\n    const newSegment1 = this.getNewSegment();\r\n    newSegment1.pos0.copy(segment.pos0);\r\n    newSegment1.pos1.copy(this.newPos);\r\n    newSegment1.linPos0.copy(segment.linPos0);\r\n    newSegment1.linPos1.copy(this.middleLinPos);\r\n    newSegment1.up0.copy(segment.up0);\r\n    newSegment1.up1.copy(segment.up1);\r\n    newSegment1.radius0 = segment.radius0;\r\n    newSegment1.radius1 = middleRadius;\r\n    newSegment1.fraction0 = segment.fraction0;\r\n    newSegment1.fraction1 = middleFraction;\r\n    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\r\n    newSegment1.iteration = segment.iteration + 1;\r\n    const newSegment2 = this.getNewSegment();\r\n    newSegment2.pos0.copy(this.newPos);\r\n    newSegment2.pos1.copy(segment.pos1);\r\n    newSegment2.linPos0.copy(this.middleLinPos);\r\n    newSegment2.linPos1.copy(segment.linPos1);\r\n    this.cross1.crossVectors(segment.up0, this.forwards.normalize());\r\n    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\r\n    newSegment2.up1.copy(segment.up1);\r\n    newSegment2.radius0 = middleRadius;\r\n    newSegment2.radius1 = segment.radius1;\r\n    newSegment2.fraction0 = middleFraction;\r\n    newSegment2.fraction1 = segment.fraction1;\r\n    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\r\n    newSegment2.iteration = segment.iteration + 1;\r\n    this.fractalRayRecursive(newSegment1);\r\n    this.fractalRayRecursive(newSegment2);\r\n  }\r\n\r\n  createPrism(segment) {\r\n    // Creates one triangular prism and its vertices at the segment\r\n    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\r\n\r\n    if (this.isInitialSegment) {\r\n      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\r\n      this.isInitialSegment = false;\r\n    }\r\n\r\n    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\r\n    this.createPrismFaces();\r\n  }\r\n\r\n  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\r\n    // Create an equilateral triangle (only vertices)\r\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\r\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\r\n    const p = this.vPos;\r\n    const v = this.vertices;\r\n    p.copy(pos).sub(this.side).add(this.down);\r\n    v[this.currentCoordinate++] = p.x;\r\n    v[this.currentCoordinate++] = p.y;\r\n    v[this.currentCoordinate++] = p.z;\r\n    p.copy(pos).add(this.side).add(this.down);\r\n    v[this.currentCoordinate++] = p.x;\r\n    v[this.currentCoordinate++] = p.y;\r\n    v[this.currentCoordinate++] = p.z;\r\n    p.copy(up).multiplyScalar(radius).add(pos);\r\n    v[this.currentCoordinate++] = p.x;\r\n    v[this.currentCoordinate++] = p.y;\r\n    v[this.currentCoordinate++] = p.z;\r\n    this.currentVertex += 3;\r\n  }\r\n\r\n  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\r\n    // Create an equilateral triangle (only vertices)\r\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\r\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\r\n    const p = this.vPos;\r\n    const v = this.vertices;\r\n    const uv = this.uvs;\r\n    p.copy(pos).sub(this.side).add(this.down);\r\n    v[this.currentCoordinate++] = p.x;\r\n    v[this.currentCoordinate++] = p.y;\r\n    v[this.currentCoordinate++] = p.z;\r\n    uv[this.currentUVCoordinate++] = u;\r\n    uv[this.currentUVCoordinate++] = 0;\r\n    p.copy(pos).add(this.side).add(this.down);\r\n    v[this.currentCoordinate++] = p.x;\r\n    v[this.currentCoordinate++] = p.y;\r\n    v[this.currentCoordinate++] = p.z;\r\n    uv[this.currentUVCoordinate++] = u;\r\n    uv[this.currentUVCoordinate++] = 0.5;\r\n    p.copy(up).multiplyScalar(radius).add(pos);\r\n    v[this.currentCoordinate++] = p.x;\r\n    v[this.currentCoordinate++] = p.y;\r\n    v[this.currentCoordinate++] = p.z;\r\n    uv[this.currentUVCoordinate++] = u;\r\n    uv[this.currentUVCoordinate++] = 1;\r\n    this.currentVertex += 3;\r\n  }\r\n\r\n  createPrismFaces(vertex\r\n  /*, index*/\r\n  ) {\r\n    const indices = this.indices;\r\n    var vertex = this.currentVertex - 6;\r\n    indices[this.currentIndex++] = vertex + 1;\r\n    indices[this.currentIndex++] = vertex + 2;\r\n    indices[this.currentIndex++] = vertex + 5;\r\n    indices[this.currentIndex++] = vertex + 1;\r\n    indices[this.currentIndex++] = vertex + 5;\r\n    indices[this.currentIndex++] = vertex + 4;\r\n    indices[this.currentIndex++] = vertex + 0;\r\n    indices[this.currentIndex++] = vertex + 1;\r\n    indices[this.currentIndex++] = vertex + 4;\r\n    indices[this.currentIndex++] = vertex + 0;\r\n    indices[this.currentIndex++] = vertex + 4;\r\n    indices[this.currentIndex++] = vertex + 3;\r\n    indices[this.currentIndex++] = vertex + 2;\r\n    indices[this.currentIndex++] = vertex + 0;\r\n    indices[this.currentIndex++] = vertex + 3;\r\n    indices[this.currentIndex++] = vertex + 2;\r\n    indices[this.currentIndex++] = vertex + 3;\r\n    indices[this.currentIndex++] = vertex + 5;\r\n  }\r\n\r\n  createDefaultSubrayCreationCallbacks() {\r\n    const random1 = this.randomGenerator.random;\r\n\r\n    this.onDecideSubrayCreation = (segment, lightningStrike) => {\r\n      // Decide subrays creation at parent (sub)ray segment\r\n      const subray = lightningStrike.currentSubray;\r\n      const period = lightningStrike.rayParameters.subrayPeriod;\r\n      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\r\n      const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\r\n      const phase = lightningStrike.time - phase0;\r\n      const currentCycle = Math.floor(phase / period);\r\n      const childSubraySeed = random1() * (currentCycle + 1);\r\n      const isActive = phase % period <= dutyCycle * period;\r\n      let probability = 0;\r\n\r\n      if (isActive) {\r\n        probability = lightningStrike.subrayProbability; // Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\r\n      }\r\n\r\n      if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\r\n        const childSubray = lightningStrike.addNewSubray();\r\n        const parentSeed = lightningStrike.randomGenerator.getSeed();\r\n        childSubray.seed = childSubraySeed;\r\n        lightningStrike.randomGenerator.setSeed(childSubraySeed);\r\n        childSubray.recursion = subray.recursion + 1;\r\n        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\r\n        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\r\n        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\r\n        childSubray.up0.copy(subray.up0);\r\n        childSubray.up1.copy(subray.up1);\r\n        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\r\n        childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\r\n        childSubray.birthTime = phase0 + currentCycle * period;\r\n        childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\r\n\r\n        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\r\n          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\r\n          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\r\n        }\r\n\r\n        childSubray.timeScale = subray.timeScale * 2;\r\n        childSubray.roughness = subray.roughness;\r\n        childSubray.straightness = subray.straightness;\r\n        childSubray.propagationTimeFactor = subray.propagationTimeFactor;\r\n        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\r\n        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\r\n        lightningStrike.randomGenerator.setSeed(parentSeed);\r\n      }\r\n    };\r\n\r\n    const vec1Pos = new Vector3();\r\n    const vec2Forward = new Vector3();\r\n    const vec3Side = new Vector3();\r\n    const vec4Up = new Vector3();\r\n\r\n    this.onSubrayCreation = (segment, parentSubray, childSubray, lightningStrike) => {\r\n      // Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\r\n      // Just use the default cone position generator\r\n      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\r\n    };\r\n\r\n    this.subrayConePosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {\r\n      // Sets childSubray pos0 and pos1 in a cone\r\n      childSubray.pos0.copy(segment.pos0);\r\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\r\n      vec2Forward.copy(vec1Pos).normalize();\r\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\r\n      const length = vec1Pos.length();\r\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\r\n      const angle = 2 * Math.PI * random1();\r\n      vec3Side.multiplyScalar(Math.cos(angle));\r\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\r\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\r\n    };\r\n\r\n    this.subrayCylinderPosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {\r\n      // Sets childSubray pos0 and pos1 in a cylinder\r\n      childSubray.pos0.copy(segment.pos0);\r\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\r\n      vec2Forward.copy(vec1Pos).normalize();\r\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\r\n      const length = vec1Pos.length();\r\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\r\n      const angle = 2 * Math.PI * random1();\r\n      vec3Side.multiplyScalar(Math.cos(angle));\r\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\r\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\r\n    };\r\n  }\r\n\r\n  createSubray() {\r\n    return {\r\n      seed: 0,\r\n      maxIterations: 0,\r\n      recursion: 0,\r\n      pos0: new Vector3(),\r\n      pos1: new Vector3(),\r\n      linPos0: new Vector3(),\r\n      linPos1: new Vector3(),\r\n      up0: new Vector3(),\r\n      up1: new Vector3(),\r\n      radius0: 0,\r\n      radius1: 0,\r\n      birthTime: 0,\r\n      deathTime: 0,\r\n      timeScale: 0,\r\n      roughness: 0,\r\n      straightness: 0,\r\n      propagationTimeFactor: 0,\r\n      vanishingTimeFactor: 0,\r\n      endPropagationTime: 0,\r\n      beginVanishingTime: 0\r\n    };\r\n  }\r\n\r\n  createSegment() {\r\n    return {\r\n      iteration: 0,\r\n      pos0: new Vector3(),\r\n      pos1: new Vector3(),\r\n      linPos0: new Vector3(),\r\n      linPos1: new Vector3(),\r\n      up0: new Vector3(),\r\n      up1: new Vector3(),\r\n      radius0: 0,\r\n      radius1: 0,\r\n      fraction0: 0,\r\n      fraction1: 0,\r\n      positionVariationFactor: 0\r\n    };\r\n  }\r\n\r\n  getNewSegment() {\r\n    return this.raySegments[this.currentSegmentIndex++];\r\n  }\r\n\r\n  copy(source) {\r\n    super.copy(source);\r\n    this.init(LightningStrike.copyParameters({}, source.rayParameters));\r\n    return this;\r\n  }\r\n\r\n  clone() {\r\n    return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters));\r\n  }\r\n\r\n}\r\n\r\nLightningStrike.prototype.isLightningStrike = true; // Ray states\r\n\r\nLightningStrike.RAY_INITIALIZED = 0;\r\nLightningStrike.RAY_UNBORN = 1;\r\nLightningStrike.RAY_PROPAGATING = 2;\r\nLightningStrike.RAY_STEADY = 3;\r\nLightningStrike.RAY_VANISHING = 4;\r\nLightningStrike.RAY_EXTINGUISHED = 5;\r\nLightningStrike.COS30DEG = Math.cos(30 * Math.PI / 180);\r\nLightningStrike.SIN30DEG = Math.sin(30 * Math.PI / 180);\r\n\r\nLightningStrike.createRandomGenerator = () => {\r\n  const numSeeds = 2053;\r\n  const seeds = [];\r\n\r\n  for (let i = 0; i < numSeeds; i++) {\r\n    seeds.push(Math.random());\r\n  }\r\n\r\n  const generator = {\r\n    currentSeed: 0,\r\n    random: function () {\r\n      const value = seeds[generator.currentSeed];\r\n      generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\r\n      return value;\r\n    },\r\n    getSeed: function () {\r\n      return generator.currentSeed / numSeeds;\r\n    },\r\n    setSeed: function (seed) {\r\n      generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\r\n    }\r\n  };\r\n  return generator;\r\n};\r\n\r\nLightningStrike.copyParameters = (dest, source) => {\r\n  source = source || {};\r\n  dest = dest || {};\r\n\r\n  const vecCopy = v => {\r\n    if (source === dest) {\r\n      return v;\r\n    } else {\r\n      return v.clone();\r\n    }\r\n  };\r\n\r\n  dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== undefined ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1, dest.roughness = source.roughness !== undefined ? source.roughness : 0.9, dest.straightness = source.straightness !== undefined ? source.straightness : 0.7, dest.up0 = source.up0 !== undefined ? vecCopy(source.up0) : new Vector3(0, 0, 1);\r\n  dest.up1 = source.up1 !== undefined ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1, dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2, // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\r\n  dest.isEternal = source.isEternal !== undefined ? source.isEternal : source.birthTime === undefined || source.deathTime === undefined, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6; // These parameters cannot change after lightning creation:\r\n\r\n  dest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9;\r\n  dest.isStatic = source.isStatic !== undefined ? source.isStatic : false;\r\n  dest.ramification = source.ramification !== undefined ? source.ramification : 5;\r\n  dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3;\r\n  dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6;\r\n  dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false;\r\n  dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\r\n  return dest;\r\n};\r\n\r\nexport { LightningStrike };\r\n", "import { Object3D, MeshBasicMaterial, MathUtils, Mesh } from 'three';\r\nimport { LightningStrike } from '../geometries/LightningStrike.js';\r\n\r\n/**\r\n * @fileoverview Lightning strike object generator\r\n *\r\n *\r\n * Usage\r\n *\r\n * const myStorm = new LightningStorm( paramsObject );\r\n * myStorm.position.set( ... );\r\n * scene.add( myStorm );\r\n * ...\r\n * myStorm.update( currentTime );\r\n *\r\n * The \"currentTime\" can only go forwards or be stopped.\r\n *\r\n *\r\n * LightningStorm parameters:\r\n *\r\n * @param {double} size Size of the storm. If no 'onRayPosition' parameter is defined, it means the side of the rectangle the storm covers.\r\n *\r\n * @param {double} minHeight Minimum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\r\n *\r\n * @param {double} maxHeight Maximum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\r\n *\r\n * @param {double} maxSlope The maximum inclination slope of a ray. If no 'onRayPosition' parameter is defined, it means the slope relative to plane y = 0.\r\n *\r\n * @param {integer} maxLightnings Greater than 0. The maximum number of simultaneous rays.\r\n *\r\n * @param {double} lightningMinPeriod minimum time between two consecutive rays.\r\n *\r\n * @param {double} lightningMaxPeriod maximum time between two consecutive rays.\r\n *\r\n * @param {double} lightningMinDuration The minimum time a ray can last.\r\n *\r\n * @param {double} lightningMaxDuration The maximum time a ray can last.\r\n *\r\n * @param {Object} lightningParameters The parameters for created rays. See LightningStrike (geometry)\r\n *\r\n * @param {Material} lightningMaterial The THREE.Material used for the created rays.\r\n *\r\n * @param {function} onRayPosition Optional callback with two Vector3 parameters (source, dest). You can set here the start and end points for each created ray, using the standard size, minHeight, etc parameters and other values in your algorithm.\r\n *\r\n * @param {function} onLightningDown This optional callback is called with one parameter (lightningStrike) when a ray ends propagating, so it has hit the ground.\r\n *\r\n *\r\n */\r\n\r\nclass LightningStorm extends Object3D {\r\n  constructor(stormParams = {}) {\r\n    super(); // Parameters\r\n\r\n    this.stormParams = stormParams;\r\n    stormParams.size = stormParams.size !== undefined ? stormParams.size : 1000.0;\r\n    stormParams.minHeight = stormParams.minHeight !== undefined ? stormParams.minHeight : 80.0;\r\n    stormParams.maxHeight = stormParams.maxHeight !== undefined ? stormParams.maxHeight : 100.0;\r\n    stormParams.maxSlope = stormParams.maxSlope !== undefined ? stormParams.maxSlope : 1.1;\r\n    stormParams.maxLightnings = stormParams.maxLightnings !== undefined ? stormParams.maxLightnings : 3;\r\n    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== undefined ? stormParams.lightningMinPeriod : 3.0;\r\n    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== undefined ? stormParams.lightningMaxPeriod : 7.0;\r\n    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== undefined ? stormParams.lightningMinDuration : 1.0;\r\n    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== undefined ? stormParams.lightningMaxDuration : 2.5;\r\n    this.lightningParameters = LightningStrike.copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);\r\n    this.lightningParameters.isEternal = false;\r\n    this.lightningMaterial = stormParams.lightningMaterial !== undefined ? stormParams.lightningMaterial : new MeshBasicMaterial({\r\n      color: 0xb0ffff\r\n    });\r\n\r\n    if (stormParams.onRayPosition !== undefined) {\r\n      this.onRayPosition = stormParams.onRayPosition;\r\n    } else {\r\n      this.onRayPosition = function (source, dest) {\r\n        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);\r\n        const height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());\r\n        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);\r\n      };\r\n    }\r\n\r\n    this.onLightningDown = stormParams.onLightningDown; // Internal state\r\n\r\n    this.inited = false;\r\n    this.nextLightningTime = 0;\r\n    this.lightningsMeshes = [];\r\n    this.deadLightningsMeshes = [];\r\n\r\n    for (let i = 0; i < this.stormParams.maxLightnings; i++) {\r\n      const lightning = new LightningStrike(LightningStrike.copyParameters({}, this.lightningParameters));\r\n      const mesh = new Mesh(lightning, this.lightningMaterial);\r\n      this.deadLightningsMeshes.push(mesh);\r\n    }\r\n  }\r\n\r\n  update(time) {\r\n    if (!this.inited) {\r\n      this.nextLightningTime = this.getNextLightningTime(time) * Math.random();\r\n      this.inited = true;\r\n    }\r\n\r\n    if (time >= this.nextLightningTime) {\r\n      // Lightning creation\r\n      const lightningMesh = this.deadLightningsMeshes.pop();\r\n\r\n      if (lightningMesh) {\r\n        const lightningParams1 = LightningStrike.copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);\r\n        lightningParams1.birthTime = time;\r\n        lightningParams1.deathTime = time + MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());\r\n        this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);\r\n        lightningParams1.noiseSeed = Math.random();\r\n        this.add(lightningMesh);\r\n        this.lightningsMeshes.push(lightningMesh);\r\n      } // Schedule next lightning\r\n\r\n\r\n      this.nextLightningTime = this.getNextLightningTime(time);\r\n    }\r\n\r\n    let i = 0,\r\n        il = this.lightningsMeshes.length;\r\n\r\n    while (i < il) {\r\n      const mesh = this.lightningsMeshes[i];\r\n      const lightning = mesh.geometry;\r\n      const prevState = lightning.state;\r\n      lightning.update(time);\r\n\r\n      if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {\r\n        if (this.onLightningDown) {\r\n          this.onLightningDown(lightning);\r\n        }\r\n      }\r\n\r\n      if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {\r\n        // Lightning is to be destroyed\r\n        this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);\r\n        this.deadLightningsMeshes.push(mesh);\r\n        this.remove(mesh);\r\n        il--;\r\n      } else {\r\n        i++;\r\n      }\r\n    }\r\n  }\r\n\r\n  getNextLightningTime(currentTime) {\r\n    return currentTime + MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);\r\n  }\r\n\r\n  copy(source) {\r\n    super.copy(source);\r\n    this.stormParams.size = source.stormParams.size;\r\n    this.stormParams.minHeight = source.stormParams.minHeight;\r\n    this.stormParams.maxHeight = source.stormParams.maxHeight;\r\n    this.stormParams.maxSlope = source.stormParams.maxSlope;\r\n    this.stormParams.maxLightnings = source.stormParams.maxLightnings;\r\n    this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;\r\n    this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;\r\n    this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;\r\n    this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;\r\n    this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters);\r\n    this.lightningMaterial = source.stormParams.lightningMaterial;\r\n    this.onLightningDown = source.onLightningDown;\r\n    return this;\r\n  }\r\n\r\n  clone() {\r\n    return new this.constructor(this.stormParams).copy(this);\r\n  }\r\n\r\n}\r\n\r\nLightningStorm.prototype.isLightningStorm = true;\r\n\r\nexport { LightningStorm };\r\n", "import { Mesh, Color, Vector3, Vector2, Matrix4, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Plane } from 'three';\r\n\r\nclass ReflectorForSSRPass extends Mesh {\r\n  constructor(geometry, options = {}) {\r\n    super(geometry);\r\n    this.type = 'ReflectorForSSRPass';\r\n    const scope = this;\r\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f);\r\n    const textureWidth = options.textureWidth || 512;\r\n    const textureHeight = options.textureHeight || 512;\r\n    const clipBias = options.clipBias || 0;\r\n    const shader = options.shader || ReflectorForSSRPass.ReflectorShader;\r\n    const useDepthTexture = options.useDepthTexture === true;\r\n    const yAxis = new Vector3(0, 1, 0);\r\n    const vecTemp0 = new Vector3();\r\n    const vecTemp1 = new Vector3(); //\r\n\r\n    scope.needsUpdate = false;\r\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\r\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\r\n    scope.color = color;\r\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\r\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\r\n    Object.defineProperty(scope, 'distanceAttenuation', {\r\n      get() {\r\n        return scope._distanceAttenuation;\r\n      },\r\n\r\n      set(val) {\r\n        if (scope._distanceAttenuation === val) return;\r\n        scope._distanceAttenuation = val;\r\n        scope.material.defines.DISTANCE_ATTENUATION = val;\r\n        scope.material.needsUpdate = true;\r\n      }\r\n\r\n    });\r\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\r\n    Object.defineProperty(scope, 'fresnel', {\r\n      get() {\r\n        return scope._fresnel;\r\n      },\r\n\r\n      set(val) {\r\n        if (scope._fresnel === val) return;\r\n        scope._fresnel = val;\r\n        scope.material.defines.FRESNEL = val;\r\n        scope.material.needsUpdate = true;\r\n      }\r\n\r\n    });\r\n    const normal = new Vector3();\r\n    const reflectorWorldPosition = new Vector3();\r\n    const cameraWorldPosition = new Vector3();\r\n    const rotationMatrix = new Matrix4();\r\n    const lookAtPosition = new Vector3(0, 0, -1);\r\n    const view = new Vector3();\r\n    const target = new Vector3();\r\n    const textureMatrix = new Matrix4();\r\n    const virtualCamera = new PerspectiveCamera();\r\n    let depthTexture;\r\n\r\n    if (useDepthTexture) {\r\n      depthTexture = new DepthTexture();\r\n      depthTexture.type = UnsignedShortType;\r\n      depthTexture.minFilter = NearestFilter;\r\n      depthTexture.magFilter = NearestFilter;\r\n    }\r\n\r\n    const parameters = {\r\n      depthTexture: useDepthTexture ? depthTexture : null\r\n    };\r\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\r\n    const material = new ShaderMaterial({\r\n      transparent: useDepthTexture,\r\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\r\n        useDepthTexture\r\n      }),\r\n      uniforms: UniformsUtils.clone(shader.uniforms),\r\n      fragmentShader: shader.fragmentShader,\r\n      vertexShader: shader.vertexShader\r\n    });\r\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\r\n    material.uniforms['color'].value = scope.color;\r\n    material.uniforms['textureMatrix'].value = textureMatrix;\r\n\r\n    if (useDepthTexture) {\r\n      material.uniforms['tDepth'].value = renderTarget.depthTexture;\r\n    }\r\n\r\n    this.material = material;\r\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\r\n    const globalPlanes = [globalPlane];\r\n\r\n    this.doRender = function (renderer, scene, camera) {\r\n      material.uniforms['maxDistance'].value = scope.maxDistance;\r\n      material.uniforms['color'].value = scope.color;\r\n      material.uniforms['opacity'].value = scope.opacity;\r\n      vecTemp0.copy(camera.position).normalize();\r\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\r\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\r\n\r\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\r\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\r\n      rotationMatrix.extractRotation(scope.matrixWorld);\r\n      normal.set(0, 0, 1);\r\n      normal.applyMatrix4(rotationMatrix);\r\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\r\n\r\n      if (view.dot(normal) > 0) return;\r\n      view.reflect(normal).negate();\r\n      view.add(reflectorWorldPosition);\r\n      rotationMatrix.extractRotation(camera.matrixWorld);\r\n      lookAtPosition.set(0, 0, -1);\r\n      lookAtPosition.applyMatrix4(rotationMatrix);\r\n      lookAtPosition.add(cameraWorldPosition);\r\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\r\n      target.reflect(normal).negate();\r\n      target.add(reflectorWorldPosition);\r\n      virtualCamera.position.copy(view);\r\n      virtualCamera.up.set(0, 1, 0);\r\n      virtualCamera.up.applyMatrix4(rotationMatrix);\r\n      virtualCamera.up.reflect(normal);\r\n      virtualCamera.lookAt(target);\r\n      virtualCamera.far = camera.far; // Used in WebGLBackground\r\n\r\n      virtualCamera.updateMatrixWorld();\r\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\r\n      material.uniforms['virtualCameraNear'].value = camera.near;\r\n      material.uniforms['virtualCameraFar'].value = camera.far;\r\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld;\r\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix;\r\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse;\r\n      material.uniforms['resolution'].value = scope.resolution; // Update the texture matrix\r\n\r\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\r\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\r\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\r\n      textureMatrix.multiply(scope.matrixWorld); // Render\r\n\r\n      renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\r\n\r\n      const currentRenderTarget = renderer.getRenderTarget();\r\n      const currentXrEnabled = renderer.xr.enabled;\r\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n      const currentClippingPlanes = renderer.clippingPlanes;\r\n      renderer.xr.enabled = false; // Avoid camera modification\r\n\r\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\r\n\r\n      renderer.clippingPlanes = globalPlanes;\r\n      renderer.setRenderTarget(renderTarget);\r\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\r\n\r\n      if (renderer.autoClear === false) renderer.clear();\r\n      renderer.render(scene, virtualCamera);\r\n      renderer.xr.enabled = currentXrEnabled;\r\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n      renderer.clippingPlanes = currentClippingPlanes;\r\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\r\n\r\n      const viewport = camera.viewport;\r\n\r\n      if (viewport !== undefined) {\r\n        renderer.state.viewport(viewport);\r\n      } // scope.visible = true;\r\n\r\n    };\r\n\r\n    this.getRenderTarget = function () {\r\n      return renderTarget;\r\n    };\r\n  }\r\n\r\n}\r\n\r\nReflectorForSSRPass.prototype.isReflectorForSSRPass = true;\r\nReflectorForSSRPass.ReflectorShader = {\r\n  defines: {\r\n    DISTANCE_ATTENUATION: true,\r\n    FRESNEL: true\r\n  },\r\n  uniforms: {\r\n    color: {\r\n      value: null\r\n    },\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    tDepth: {\r\n      value: null\r\n    },\r\n    textureMatrix: {\r\n      value: new Matrix4()\r\n    },\r\n    maxDistance: {\r\n      value: 180\r\n    },\r\n    opacity: {\r\n      value: 0.5\r\n    },\r\n    fresnelCoe: {\r\n      value: null\r\n    },\r\n    virtualCameraNear: {\r\n      value: null\r\n    },\r\n    virtualCameraFar: {\r\n      value: null\r\n    },\r\n    virtualCameraProjectionMatrix: {\r\n      value: new Matrix4()\r\n    },\r\n    virtualCameraMatrixWorld: {\r\n      value: new Matrix4()\r\n    },\r\n    virtualCameraProjectionMatrixInverse: {\r\n      value: new Matrix4()\r\n    },\r\n    resolution: {\r\n      value: new Vector2()\r\n    }\r\n  },\r\n  vertexShader:\r\n  /* glsl */\r\n  `\r\n\t\tuniform mat4 textureMatrix;\r\n\t\tvarying vec4 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n  fragmentShader:\r\n  /* glsl */\r\n  `\r\n\t\tuniform vec3 color;\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tuniform sampler2D tDepth;\r\n\t\tuniform float maxDistance;\r\n\t\tuniform float opacity;\r\n\t\tuniform float fresnelCoe;\r\n\t\tuniform float virtualCameraNear;\r\n\t\tuniform float virtualCameraFar;\r\n\t\tuniform mat4 virtualCameraProjectionMatrix;\r\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\r\n\t\tuniform mat4 virtualCameraMatrixWorld;\r\n\t\tuniform vec2 resolution;\r\n\t\tvarying vec4 vUv;\r\n\t\t#include <packing>\r\n\t\tfloat blendOverlay( float base, float blend ) {\r\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\r\n\t\t}\r\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\r\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\r\n\t\t}\r\n\t\tfloat getDepth( const in vec2 uv ) {\r\n\t\t\treturn texture2D( tDepth, uv ).x;\r\n\t\t}\r\n\t\tfloat getViewZ( const in float depth ) {\r\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\r\n\t\t}\r\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\r\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\r\n\t\t\tclipPosition *= clipW; //clip\r\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\r\n\t\t}\r\n\t\tvoid main() {\r\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\r\n\t\t\t#ifdef useDepthTexture\r\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\r\n\t\t\t\tuv.x=1.-uv.x;\r\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\r\n\t\t\t\tfloat viewZ = getViewZ( depth );\r\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\r\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\r\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\r\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\r\n\t\t\t\tfloat op=opacity;\r\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\r\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\r\n\t\t\t\t\tfloat attenuation=ratio*ratio;\r\n\t\t\t\t\top=opacity*attenuation;\r\n\t\t\t\t#endif\r\n\t\t\t\t#ifdef FRESNEL\r\n\t\t\t\t\top*=fresnelCoe;\r\n\t\t\t\t#endif\r\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\r\n\t\t\t#else\r\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\r\n\t\t\t#endif\r\n\t\t}\r\n\t`\r\n};\r\n\r\nexport { ReflectorForSSRPass };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { Mesh, BoxGeometry, Vector3, ShaderMaterial, UniformsUtils, BackSide } from 'three';\r\n\r\n/**\r\n * Based on \"A Practical Analytic Model for Daylight\"\r\n * aka The Preetham Model, the de facto standard analytic skydome model\r\n * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight\r\n *\r\n * First implemented by Simon Wallner\r\n * http://www.simonwallner.at/projects/atmospheric-scattering\r\n *\r\n * Improved by Martin Upitis\r\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\r\n *\r\n * Three.js integration by zz85 http://twitter.com/blurspline\r\n */\r\n\r\nclass Sky extends Mesh {\r\n  constructor() {\r\n    super(new BoxGeometry(1, 1, 1), Sky.material);\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(Sky, \"SkyShader\", {\r\n  uniforms: {\r\n    turbidity: {\r\n      value: 2\r\n    },\r\n    rayleigh: {\r\n      value: 1\r\n    },\r\n    mieCoefficient: {\r\n      value: 0.005\r\n    },\r\n    mieDirectionalG: {\r\n      value: 0.8\r\n    },\r\n    sunPosition: {\r\n      value: new Vector3()\r\n    },\r\n    up: {\r\n      value: new Vector3(0, 1, 0)\r\n    }\r\n  },\r\n  vertexShader: ['uniform vec3 sunPosition;', 'uniform float rayleigh;', 'uniform float turbidity;', 'uniform float mieCoefficient;', 'uniform vec3 up;', 'varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', // constants for atmospheric scattering\r\n  'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;', // wavelength of used primaries, according to preetham\r\n  'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );', // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\r\n  // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\r\n  'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );', // mie stuff\r\n  // K coefficient for the primaries\r\n  'const float v = 4.0;', 'const vec3 K = vec3( 0.686, 0.678, 0.666 );', // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\r\n  'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );', // earth shadow hack\r\n  // cutoffAngle = pi / 1.95;\r\n  'const float cutoffAngle = 1.6110731556870734;', 'const float steepness = 1.5;', 'const float EE = 1000.0;', 'float sunIntensity( float zenithAngleCos ) {', '\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );', '\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );', '}', 'vec3 totalMie( float T ) {', '\tfloat c = ( 0.2 * T ) * 10E-18;', '\treturn 0.434 * c * MieConst;', '}', 'void main() {', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvWorldPosition = worldPosition.xyz;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tgl_Position.z = gl_Position.w;', // set z to camera.far\r\n  '\tvSunDirection = normalize( sunPosition );', '\tvSunE = sunIntensity( dot( vSunDirection, up ) );', '\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );', '\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );', // extinction (absorbtion + out scattering)\r\n  // rayleigh coefficients\r\n  '\tvBetaR = totalRayleigh * rayleighCoefficient;', // mie coefficients\r\n  '\tvBetaM = totalMie( turbidity ) * mieCoefficient;', '}'].join('\\n'),\r\n  fragmentShader: ['varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'uniform float mieDirectionalG;', 'uniform vec3 up;', 'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );', // constants for atmospheric scattering\r\n  'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003;', // refractive index of air\r\n  'const float N = 2.545E25;', // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\r\n  // optical length at zenith for molecules\r\n  'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;', // 66 arc seconds -> degrees, and the cosine of that\r\n  'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;', // 3.0 / ( 16.0 * pi )\r\n  'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;', // 1.0 / ( 4.0 * pi )\r\n  'const float ONE_OVER_FOURPI = 0.07957747154594767;', 'float rayleighPhase( float cosTheta ) {', '\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );', '}', 'float hgPhase( float cosTheta, float g ) {', '\tfloat g2 = pow( g, 2.0 );', '\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );', '\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );', '}', 'void main() {', '\tvec3 direction = normalize( vWorldPosition - cameraPos );', // optical length\r\n  // cutoff angle at 90 to avoid singularity in next formula.\r\n  '\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );', '\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );', '\tfloat sR = rayleighZenithLength * inverse;', '\tfloat sM = mieZenithLength * inverse;', // combined extinction factor\r\n  '\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );', // in scattering\r\n  '\tfloat cosTheta = dot( direction, vSunDirection );', '\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );', '\tvec3 betaRTheta = vBetaR * rPhase;', '\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );', '\tvec3 betaMTheta = vBetaM * mPhase;', '\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );', '\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );', // nightsky\r\n  '\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]', '\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]', '\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );', '\tvec3 L0 = vec3( 0.1 ) * Fex;', // composition + solar disc\r\n  '\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );', '\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;', '\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );', '\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );', '\tgl_FragColor = vec4( retColor, 1.0 );', '#include <tonemapping_fragment>', '#include <encodings_fragment>', '}'].join('\\n')\r\n});\r\n\r\n_defineProperty(Sky, \"material\", new ShaderMaterial({\r\n  name: 'SkyShader',\r\n  fragmentShader: Sky.SkyShader.fragmentShader,\r\n  vertexShader: Sky.SkyShader.vertexShader,\r\n  uniforms: UniformsUtils.clone(Sky.SkyShader.uniforms),\r\n  side: BackSide,\r\n  depthWrite: false\r\n}));\r\n\r\nexport { Sky };\r\n", "import { Mesh, Color, Vector2, LinearEncoding, TextureLoader, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping, Vector4 } from 'three';\r\nimport { Reflector } from './Reflector.js';\r\nimport { Refractor } from './Refractor.js';\r\n\r\n/**\r\n * References:\r\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\r\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\r\n *\r\n */\r\n\r\nclass Water2 extends Mesh {\r\n  constructor(geometry, options = {}) {\r\n    super(geometry);\r\n    this.type = 'Water';\r\n    const scope = this;\r\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0xffffff);\r\n    const textureWidth = options.textureWidth || 512;\r\n    const textureHeight = options.textureHeight || 512;\r\n    const clipBias = options.clipBias || 0;\r\n    const flowDirection = options.flowDirection || new Vector2(1, 0);\r\n    const flowSpeed = options.flowSpeed || 0.03;\r\n    const reflectivity = options.reflectivity || 0.02;\r\n    const scale = options.scale || 1;\r\n    const shader = options.shader || Water2.WaterShader;\r\n    const encoding = options.encoding !== undefined ? options.encoding : LinearEncoding;\r\n    const textureLoader = new TextureLoader();\r\n    const flowMap = options.flowMap || undefined;\r\n    const normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\r\n    const normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\r\n    const cycle = 0.15; // a cycle of a flow map phase\r\n\r\n    const halfCycle = cycle * 0.5;\r\n    const textureMatrix = new Matrix4();\r\n    const clock = new Clock(); // internal components\r\n\r\n    if (Reflector === undefined) {\r\n      console.error('THREE.Water: Required component Reflector not found.');\r\n      return;\r\n    }\r\n\r\n    if (Refractor === undefined) {\r\n      console.error('THREE.Water: Required component Refractor not found.');\r\n      return;\r\n    }\r\n\r\n    const reflector = new Reflector(geometry, {\r\n      textureWidth: textureWidth,\r\n      textureHeight: textureHeight,\r\n      clipBias: clipBias,\r\n      encoding: encoding\r\n    });\r\n    const refractor = new Refractor(geometry, {\r\n      textureWidth: textureWidth,\r\n      textureHeight: textureHeight,\r\n      clipBias: clipBias,\r\n      encoding: encoding\r\n    });\r\n    reflector.matrixAutoUpdate = false;\r\n    refractor.matrixAutoUpdate = false; // material\r\n\r\n    this.material = new ShaderMaterial({\r\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], shader.uniforms]),\r\n      vertexShader: shader.vertexShader,\r\n      fragmentShader: shader.fragmentShader,\r\n      transparent: true,\r\n      fog: true\r\n    });\r\n\r\n    if (flowMap !== undefined) {\r\n      this.material.defines.USE_FLOWMAP = '';\r\n      this.material.uniforms['tFlowMap'] = {\r\n        type: 't',\r\n        value: flowMap\r\n      };\r\n    } else {\r\n      this.material.uniforms['flowDirection'] = {\r\n        type: 'v2',\r\n        value: flowDirection\r\n      };\r\n    } // maps\r\n\r\n\r\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\r\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\r\n    this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\r\n    this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\r\n    this.material.uniforms['tNormalMap0'].value = normalMap0;\r\n    this.material.uniforms['tNormalMap1'].value = normalMap1; // water\r\n\r\n    this.material.uniforms['color'].value = color;\r\n    this.material.uniforms['reflectivity'].value = reflectivity;\r\n    this.material.uniforms['textureMatrix'].value = textureMatrix; // inital values\r\n\r\n    this.material.uniforms['config'].value.x = 0; // flowMapOffset0\r\n\r\n    this.material.uniforms['config'].value.y = halfCycle; // flowMapOffset1\r\n\r\n    this.material.uniforms['config'].value.z = halfCycle; // halfCycle\r\n\r\n    this.material.uniforms['config'].value.w = scale; // scale\r\n    // functions\r\n\r\n    function updateTextureMatrix(camera) {\r\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\r\n      textureMatrix.multiply(camera.projectionMatrix);\r\n      textureMatrix.multiply(camera.matrixWorldInverse);\r\n      textureMatrix.multiply(scope.matrixWorld);\r\n    }\r\n\r\n    function updateFlow() {\r\n      const delta = clock.getDelta();\r\n      const config = scope.material.uniforms['config'];\r\n      config.value.x += flowSpeed * delta; // flowMapOffset0\r\n\r\n      config.value.y = config.value.x + halfCycle; // flowMapOffset1\r\n      // Important: The distance between offsets should be always the value of \"halfCycle\".\r\n      // Moreover, both offsets should be in the range of [ 0, cycle ].\r\n      // This approach ensures a smooth water flow and avoids \"reset\" effects.\r\n\r\n      if (config.value.x >= cycle) {\r\n        config.value.x = 0;\r\n        config.value.y = halfCycle;\r\n      } else if (config.value.y >= cycle) {\r\n        config.value.y = config.value.y - cycle;\r\n      }\r\n    } //\r\n\r\n\r\n    this.onBeforeRender = function (renderer, scene, camera) {\r\n      updateTextureMatrix(camera);\r\n      updateFlow();\r\n      scope.visible = false;\r\n      reflector.matrixWorld.copy(scope.matrixWorld);\r\n      refractor.matrixWorld.copy(scope.matrixWorld);\r\n      reflector.onBeforeRender(renderer, scene, camera);\r\n      refractor.onBeforeRender(renderer, scene, camera);\r\n      scope.visible = true;\r\n    };\r\n  }\r\n\r\n}\r\n\r\nWater2.prototype.isWater = true;\r\nWater2.WaterShader = {\r\n  uniforms: {\r\n    color: {\r\n      type: 'c',\r\n      value: null\r\n    },\r\n    reflectivity: {\r\n      type: 'f',\r\n      value: 0\r\n    },\r\n    tReflectionMap: {\r\n      type: 't',\r\n      value: null\r\n    },\r\n    tRefractionMap: {\r\n      type: 't',\r\n      value: null\r\n    },\r\n    tNormalMap0: {\r\n      type: 't',\r\n      value: null\r\n    },\r\n    tNormalMap1: {\r\n      type: 't',\r\n      value: null\r\n    },\r\n    textureMatrix: {\r\n      type: 'm4',\r\n      value: null\r\n    },\r\n    config: {\r\n      type: 'v4',\r\n      value: new Vector4()\r\n    }\r\n  },\r\n  vertexShader:\r\n  /* glsl */\r\n  `\r\n\r\n\t\t#include <common>\r\n\t\t#include <fog_pars_vertex>\r\n\t\t#include <logdepthbuf_pars_vertex>\r\n\r\n\t\tuniform mat4 textureMatrix;\r\n\r\n\t\tvarying vec4 vCoord;\r\n\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 vToEye;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\r\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\r\n\r\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t#include <fog_vertex>\r\n\r\n\t\t}`,\r\n  fragmentShader:\r\n  /* glsl */\r\n  `\r\n\r\n\t\t#include <common>\r\n\t\t#include <fog_pars_fragment>\r\n\t\t#include <logdepthbuf_pars_fragment>\r\n\r\n\t\tuniform sampler2D tReflectionMap;\r\n\t\tuniform sampler2D tRefractionMap;\r\n\t\tuniform sampler2D tNormalMap0;\r\n\t\tuniform sampler2D tNormalMap1;\r\n\r\n\t\t#ifdef USE_FLOWMAP\r\n\t\t\tuniform sampler2D tFlowMap;\r\n\t\t#else\r\n\t\t\tuniform vec2 flowDirection;\r\n\t\t#endif\r\n\r\n\t\tuniform vec3 color;\r\n\t\tuniform float reflectivity;\r\n\t\tuniform vec4 config;\r\n\r\n\t\tvarying vec4 vCoord;\r\n\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 vToEye;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <logdepthbuf_fragment>\r\n\r\n\t\t\tfloat flowMapOffset0 = config.x;\r\n\t\t\tfloat flowMapOffset1 = config.y;\r\n\t\t\tfloat halfCycle = config.z;\r\n\t\t\tfloat scale = config.w;\r\n\r\n\t\t\tvec3 toEye = normalize( vToEye );\r\n\r\n\t\t\t// determine flow direction\r\n\t\t\tvec2 flow;\r\n\t\t\t#ifdef USE_FLOWMAP\r\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\r\n\t\t\t#else\r\n\t\t\t\tflow = flowDirection;\r\n\t\t\t#endif\r\n\t\t\tflow.x *= - 1.0;\r\n\r\n\t\t\t// sample normal maps (distort uvs with flowdata)\r\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\r\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\r\n\r\n\t\t\t// linear interpolate to get the final normal color\r\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\r\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\r\n\r\n\t\t\t// calculate normal vector\r\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\r\n\r\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\r\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\r\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\r\n\r\n\t\t\t// calculate final uv coords\r\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\r\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\r\n\r\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\r\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\r\n\r\n\t\t\t// multiply water color with the mix of both textures\r\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <encodings_fragment>\r\n\t\t\t#include <fog_fragment>\r\n\r\n\t\t}`\r\n};\r\n\r\nexport { Water2 };\r\n", "import { Mesh, PlaneGeometry, OrthographicCamera, MathUtils, WebGLRenderTarget, Vector2, RawShaderMaterial, NoBlending } from 'three';\r\n\r\n/**\r\n * This class generates custom mipmaps for a roughness map by encoding the lost variation in the\r\n * normal map mip levels as increased roughness in the corresponding roughness mip levels. This\r\n * helps with rendering accuracy for MeshStandardMaterial, and also helps with anti-aliasing when\r\n * using PMREM. If the normal map is larger than the roughness map, the roughness map will be\r\n * enlarged to match the dimensions of the normal map.\r\n */\r\n\r\nvar _mipmapMaterial = _getMipmapMaterial();\r\n\r\nvar _mesh = new Mesh(new PlaneGeometry(2, 2), _mipmapMaterial);\r\n\r\nvar _flatCamera = new OrthographicCamera(0, 1, 0, 1, 0, 1);\r\n\r\nvar _tempTarget = null;\r\nvar _renderer = null;\r\n\r\nfunction RoughnessMipmapper(renderer) {\r\n  _renderer = renderer;\r\n\r\n  _renderer.compile(_mesh, _flatCamera);\r\n}\r\n\r\nRoughnessMipmapper.prototype = {\r\n  constructor: RoughnessMipmapper,\r\n  generateMipmaps: function (material) {\r\n    if ('roughnessMap' in material === false) return;\r\n    var {\r\n      roughnessMap,\r\n      normalMap\r\n    } = material;\r\n\r\n    if (roughnessMap === null || normalMap === null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated) {\r\n      return;\r\n    }\r\n\r\n    material.userData.roughnessUpdated = true;\r\n    var width = Math.max(roughnessMap.image.width, normalMap.image.width);\r\n    var height = Math.max(roughnessMap.image.height, normalMap.image.height);\r\n    if (!MathUtils.isPowerOfTwo(width) || !MathUtils.isPowerOfTwo(height)) return;\r\n\r\n    var oldTarget = _renderer.getRenderTarget();\r\n\r\n    var autoClear = _renderer.autoClear;\r\n    _renderer.autoClear = false;\r\n\r\n    if (_tempTarget === null || _tempTarget.width !== width || _tempTarget.height !== height) {\r\n      if (_tempTarget !== null) _tempTarget.dispose();\r\n      _tempTarget = new WebGLRenderTarget(width, height, {\r\n        depthBuffer: false\r\n      });\r\n      _tempTarget.scissorTest = true;\r\n    }\r\n\r\n    if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {\r\n      var params = {\r\n        wrapS: roughnessMap.wrapS,\r\n        wrapT: roughnessMap.wrapT,\r\n        magFilter: roughnessMap.magFilter,\r\n        minFilter: roughnessMap.minFilter,\r\n        depthBuffer: false\r\n      };\r\n      var newRoughnessTarget = new WebGLRenderTarget(width, height, params);\r\n      newRoughnessTarget.texture.generateMipmaps = true; // Setting the render target causes the memory to be allocated.\r\n\r\n      _renderer.setRenderTarget(newRoughnessTarget);\r\n\r\n      material.roughnessMap = newRoughnessTarget.texture;\r\n      if (material.metalnessMap == roughnessMap) material.metalnessMap = material.roughnessMap;\r\n      if (material.aoMap == roughnessMap) material.aoMap = material.roughnessMap;\r\n    }\r\n\r\n    _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;\r\n    _mipmapMaterial.uniforms.normalMap.value = normalMap;\r\n    var position = new Vector2(0, 0);\r\n    var texelSize = _mipmapMaterial.uniforms.texelSize.value;\r\n\r\n    for (let mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {\r\n      // Rendering to a mip level is not allowed in webGL1. Instead we must set\r\n      // up a secondary texture to write the result to, then copy it back to the\r\n      // proper mipmap level.\r\n      texelSize.set(1.0 / width, 1.0 / height);\r\n      if (mip == 0) texelSize.set(0.0, 0.0);\r\n\r\n      _tempTarget.viewport.set(position.x, position.y, width, height);\r\n\r\n      _tempTarget.scissor.set(position.x, position.y, width, height);\r\n\r\n      _renderer.setRenderTarget(_tempTarget);\r\n\r\n      _renderer.render(_mesh, _flatCamera);\r\n\r\n      _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);\r\n\r\n      _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;\r\n    }\r\n\r\n    if (roughnessMap !== material.roughnessMap) roughnessMap.dispose();\r\n\r\n    _renderer.setRenderTarget(oldTarget);\r\n\r\n    _renderer.autoClear = autoClear;\r\n  },\r\n  dispose: function () {\r\n    _mipmapMaterial.dispose();\r\n\r\n    _mesh.geometry.dispose();\r\n\r\n    if (_tempTarget != null) _tempTarget.dispose();\r\n  }\r\n};\r\n\r\nfunction _getMipmapMaterial() {\r\n  var shaderMaterial = new RawShaderMaterial({\r\n    uniforms: {\r\n      roughnessMap: {\r\n        value: null\r\n      },\r\n      normalMap: {\r\n        value: null\r\n      },\r\n      texelSize: {\r\n        value: new Vector2(1, 1)\r\n      }\r\n    },\r\n    vertexShader:\r\n    /* glsl */\r\n    `\r\n\t\t\tprecision mediump float;\r\n\t\t\tprecision mediump int;\r\n\r\n\t\t\tattribute vec3 position;\r\n\t\t\tattribute vec2 uv;\r\n\r\n\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\tvoid main() {\r\n\r\n\t\t\t\tvUv = uv;\r\n\r\n\t\t\t\tgl_Position = vec4( position, 1.0 );\r\n\r\n\t\t\t}\r\n\t\t`,\r\n    fragmentShader:\r\n    /* glsl */\r\n    `\r\n\t\t\tprecision mediump float;\r\n\t\t\tprecision mediump int;\r\n\r\n\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\tuniform sampler2D roughnessMap;\r\n\t\t\tuniform sampler2D normalMap;\r\n\t\t\tuniform vec2 texelSize;\r\n\r\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\r\n\r\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\r\n\r\n\t\t\t#include <cube_uv_reflection_fragment>\r\n\r\n\t\t\tfloat roughnessToVariance( float roughness ) {\r\n\r\n\t\t\t\tfloat variance = 0.0;\r\n\r\n\t\t\t\tif ( roughness >= r1 ) {\r\n\r\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\r\n\r\n\t\t\t\t} else if ( roughness >= r4 ) {\r\n\r\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\r\n\r\n\t\t\t\t} else if ( roughness >= r5 ) {\r\n\r\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\r\n\r\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn variance;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloat varianceToRoughness( float variance ) {\r\n\r\n\t\t\t\tfloat roughness = 0.0;\r\n\r\n\t\t\t\tif ( variance >= v1 ) {\r\n\r\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\r\n\r\n\t\t\t\t} else if ( variance >= v4 ) {\r\n\r\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\r\n\r\n\t\t\t\t} else if ( variance >= v5 ) {\r\n\r\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn roughness;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvoid main() {\r\n\r\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\r\n\r\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\r\n\r\n\t\t\t\tfloat roughness = gl_FragColor.g;\r\n\r\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\r\n\r\n\t\t\t\tvec3 avgNormal;\r\n\r\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\r\n\r\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\r\n\r\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\r\n\r\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\r\n\r\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\r\n\r\n\t\t\t}\r\n\t\t`,\r\n    blending: NoBlending,\r\n    depthTest: false,\r\n    depthWrite: false\r\n  });\r\n  shaderMaterial.type = 'RoughnessMipmapper';\r\n  return shaderMaterial;\r\n}\r\n\r\nexport { RoughnessMipmapper };\r\n", "import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper, Vector2, Euler } from 'three';\r\n\r\nvar SkeletonUtils = {\r\n  retarget: function () {\r\n    var pos = new Vector3(),\r\n        quat = new Quaternion(),\r\n        scale = new Vector3(),\r\n        bindBoneMatrix = new Matrix4(),\r\n        relativeMatrix = new Matrix4(),\r\n        globalMatrix = new Matrix4();\r\n    return function (target, source, options) {\r\n      options = options || {};\r\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\r\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\r\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\r\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\r\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\r\n      options.names = options.names || {};\r\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\r\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\r\n          bindBones,\r\n          bone,\r\n          name,\r\n          boneTo,\r\n          bonesPosition,\r\n          i; // reset bones\r\n\r\n      if (target.isObject3D) {\r\n        target.skeleton.pose();\r\n      } else {\r\n        options.useTargetMatrix = true;\r\n        options.preserveMatrix = false;\r\n      }\r\n\r\n      if (options.preservePosition) {\r\n        bonesPosition = [];\r\n\r\n        for (i = 0; i < bones.length; i++) {\r\n          bonesPosition.push(bones[i].position.clone());\r\n        }\r\n      }\r\n\r\n      if (options.preserveMatrix) {\r\n        // reset matrix\r\n        target.updateMatrixWorld();\r\n        target.matrixWorld.identity(); // reset children matrix\r\n\r\n        for (i = 0; i < target.children.length; ++i) {\r\n          target.children[i].updateMatrixWorld(true);\r\n        }\r\n      }\r\n\r\n      if (options.offsets) {\r\n        bindBones = [];\r\n\r\n        for (i = 0; i < bones.length; ++i) {\r\n          bone = bones[i];\r\n          name = options.names[bone.name] || bone.name;\r\n\r\n          if (options.offsets && options.offsets[name]) {\r\n            bone.matrix.multiply(options.offsets[name]);\r\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\r\n            bone.updateMatrixWorld();\r\n          }\r\n\r\n          bindBones.push(bone.matrixWorld.clone());\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < bones.length; ++i) {\r\n        bone = bones[i];\r\n        name = options.names[bone.name] || bone.name;\r\n        boneTo = this.getBoneByName(name, sourceBones);\r\n        globalMatrix.copy(bone.matrixWorld);\r\n\r\n        if (boneTo) {\r\n          boneTo.updateMatrixWorld();\r\n\r\n          if (options.useTargetMatrix) {\r\n            relativeMatrix.copy(boneTo.matrixWorld);\r\n          } else {\r\n            relativeMatrix.copy(target.matrixWorld).invert();\r\n            relativeMatrix.multiply(boneTo.matrixWorld);\r\n          } // ignore scale to extract rotation\r\n\r\n\r\n          scale.setFromMatrixScale(relativeMatrix);\r\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\r\n\r\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\r\n\r\n          if (target.isObject3D) {\r\n            var boneIndex = bones.indexOf(bone),\r\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\r\n            globalMatrix.multiply(wBindMatrix);\r\n          }\r\n\r\n          globalMatrix.copyPosition(relativeMatrix);\r\n        }\r\n\r\n        if (bone.parent && bone.parent.isBone) {\r\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\r\n          bone.matrix.multiply(globalMatrix);\r\n        } else {\r\n          bone.matrix.copy(globalMatrix);\r\n        }\r\n\r\n        if (options.preserveHipPosition && name === options.hip) {\r\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\r\n        }\r\n\r\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\r\n        bone.updateMatrixWorld();\r\n      }\r\n\r\n      if (options.preservePosition) {\r\n        for (i = 0; i < bones.length; ++i) {\r\n          bone = bones[i];\r\n          name = options.names[bone.name] || bone.name;\r\n\r\n          if (name !== options.hip) {\r\n            bone.position.copy(bonesPosition[i]);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (options.preserveMatrix) {\r\n        // restore matrix\r\n        target.updateMatrixWorld(true);\r\n      }\r\n    };\r\n  }(),\r\n  retargetClip: function (target, source, clip, options) {\r\n    options = options || {};\r\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\r\n    options.fps = options.fps !== undefined ? options.fps : 30;\r\n    options.names = options.names || [];\r\n\r\n    if (!source.isObject3D) {\r\n      source = this.getHelperFromSkeleton(source);\r\n    }\r\n\r\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\r\n        delta = 1 / options.fps,\r\n        convertedTracks = [],\r\n        mixer = new AnimationMixer(source),\r\n        bones = this.getBones(target.skeleton),\r\n        boneDatas = [],\r\n        positionOffset,\r\n        bone,\r\n        boneTo,\r\n        boneData,\r\n        name,\r\n        i,\r\n        j;\r\n    mixer.clipAction(clip).play();\r\n    mixer.update(0);\r\n    source.updateMatrixWorld();\r\n\r\n    for (i = 0; i < numFrames; ++i) {\r\n      var time = i * delta;\r\n      this.retarget(target, source, options);\r\n\r\n      for (j = 0; j < bones.length; ++j) {\r\n        name = options.names[bones[j].name] || bones[j].name;\r\n        boneTo = this.getBoneByName(name, source.skeleton);\r\n\r\n        if (boneTo) {\r\n          bone = bones[j];\r\n          boneData = boneDatas[j] = boneDatas[j] || {\r\n            bone: bone\r\n          };\r\n\r\n          if (options.hip === name) {\r\n            if (!boneData.pos) {\r\n              boneData.pos = {\r\n                times: new Float32Array(numFrames),\r\n                values: new Float32Array(numFrames * 3)\r\n              };\r\n            }\r\n\r\n            if (options.useFirstFramePosition) {\r\n              if (i === 0) {\r\n                positionOffset = bone.position.clone();\r\n              }\r\n\r\n              bone.position.sub(positionOffset);\r\n            }\r\n\r\n            boneData.pos.times[i] = time;\r\n            bone.position.toArray(boneData.pos.values, i * 3);\r\n          }\r\n\r\n          if (!boneData.quat) {\r\n            boneData.quat = {\r\n              times: new Float32Array(numFrames),\r\n              values: new Float32Array(numFrames * 4)\r\n            };\r\n          }\r\n\r\n          boneData.quat.times[i] = time;\r\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\r\n        }\r\n      }\r\n\r\n      mixer.update(delta);\r\n      source.updateMatrixWorld();\r\n    }\r\n\r\n    for (i = 0; i < boneDatas.length; ++i) {\r\n      boneData = boneDatas[i];\r\n\r\n      if (boneData) {\r\n        if (boneData.pos) {\r\n          convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\r\n        }\r\n\r\n        convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\r\n      }\r\n    }\r\n\r\n    mixer.uncacheAction(clip);\r\n    return new AnimationClip(clip.name, -1, convertedTracks);\r\n  },\r\n  getHelperFromSkeleton: function (skeleton) {\r\n    var source = new SkeletonHelper(skeleton.bones[0]);\r\n    source.skeleton = skeleton;\r\n    return source;\r\n  },\r\n  getSkeletonOffsets: function () {\r\n    var targetParentPos = new Vector3(),\r\n        targetPos = new Vector3(),\r\n        sourceParentPos = new Vector3(),\r\n        sourcePos = new Vector3(),\r\n        targetDir = new Vector2(),\r\n        sourceDir = new Vector2();\r\n    return function (target, source, options) {\r\n      options = options || {};\r\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\r\n      options.names = options.names || {};\r\n\r\n      if (!source.isObject3D) {\r\n        source = this.getHelperFromSkeleton(source);\r\n      }\r\n\r\n      var nameKeys = Object.keys(options.names),\r\n          nameValues = Object.values(options.names),\r\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\r\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\r\n          offsets = [],\r\n          bone,\r\n          boneTo,\r\n          name,\r\n          i;\r\n      target.skeleton.pose();\r\n\r\n      for (i = 0; i < bones.length; ++i) {\r\n        bone = bones[i];\r\n        name = options.names[bone.name] || bone.name;\r\n        boneTo = this.getBoneByName(name, sourceBones);\r\n\r\n        if (boneTo && name !== options.hip) {\r\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\r\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\r\n          boneParent.updateMatrixWorld();\r\n          boneToParent.updateMatrixWorld();\r\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\r\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\r\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\r\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\r\n          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\r\n          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\r\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\r\n          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\r\n          bone.matrix.multiply(offset);\r\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\r\n          bone.updateMatrixWorld();\r\n          offsets[name] = offset;\r\n        }\r\n      }\r\n\r\n      return offsets;\r\n    };\r\n  }(),\r\n  renameBones: function (skeleton, names) {\r\n    var bones = this.getBones(skeleton);\r\n\r\n    for (let i = 0; i < bones.length; ++i) {\r\n      var bone = bones[i];\r\n\r\n      if (names[bone.name]) {\r\n        bone.name = names[bone.name];\r\n      }\r\n    }\r\n\r\n    return this;\r\n  },\r\n  getBones: function (skeleton) {\r\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\r\n  },\r\n  getBoneByName: function (name, skeleton) {\r\n    for (let i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\r\n      if (name === bones[i].name) return bones[i];\r\n    }\r\n  },\r\n  getNearestBone: function (bone, names) {\r\n    while (bone.isBone) {\r\n      if (names.indexOf(bone.name) !== -1) {\r\n        return bone;\r\n      }\r\n\r\n      bone = bone.parent;\r\n    }\r\n  },\r\n  findBoneTrackData: function (name, tracks) {\r\n    var regexp = /\\[(.*)\\]\\.(.*)/,\r\n        result = {\r\n      name: name\r\n    };\r\n\r\n    for (let i = 0; i < tracks.length; ++i) {\r\n      // 1 is track name\r\n      // 2 is track type\r\n      var trackData = regexp.exec(tracks[i].name);\r\n\r\n      if (trackData && name === trackData[1]) {\r\n        result[trackData[2]] = i;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  },\r\n  getEqualsBonesNames: function (skeleton, targetSkeleton) {\r\n    var sourceBones = this.getBones(skeleton),\r\n        targetBones = this.getBones(targetSkeleton),\r\n        bones = [];\r\n\r\n    search: for (let i = 0; i < sourceBones.length; i++) {\r\n      var boneName = sourceBones[i].name;\r\n\r\n      for (let j = 0; j < targetBones.length; j++) {\r\n        if (boneName === targetBones[j].name) {\r\n          bones.push(boneName);\r\n          continue search;\r\n        }\r\n      }\r\n    }\r\n\r\n    return bones;\r\n  },\r\n  clone: function (source) {\r\n    var sourceLookup = new Map();\r\n    var cloneLookup = new Map();\r\n    var clone = source.clone();\r\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\r\n      sourceLookup.set(clonedNode, sourceNode);\r\n      cloneLookup.set(sourceNode, clonedNode);\r\n    });\r\n    clone.traverse(function (node) {\r\n      if (!node.isSkinnedMesh) return;\r\n      var clonedMesh = node;\r\n      var sourceMesh = sourceLookup.get(node);\r\n      var sourceBones = sourceMesh.skeleton.bones;\r\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\r\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\r\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\r\n        return cloneLookup.get(bone);\r\n      });\r\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\r\n    });\r\n    return clone;\r\n  }\r\n};\r\n\r\nfunction parallelTraverse(a, b, callback) {\r\n  callback(a, b);\r\n\r\n  for (let i = 0; i < a.children.length; i++) {\r\n    parallelTraverse(a.children[i], b.children[i], callback);\r\n  }\r\n}\r\n\r\nexport { SkeletonUtils };\r\n", "/**\r\n * Unpack RGBA depth shader\r\n * - show RGBA encoded depth as monochrome color\r\n */\r\nconst UnpackDepthRGBAShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    opacity: {\r\n      value: 1.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform float opacity;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', '#include <packing>', 'void main() {', '\tfloat depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );', '\tgl_FragColor = vec4( vec3( depth ), opacity );', '}'].join('\\n')\r\n};\r\n\r\nexport { UnpackDepthRGBAShader };\r\n", "import { OrthographicCamera, Scene, UniformsUtils, ShaderMaterial, PlaneGeometry, Mesh, Texture, LinearFilter, MeshBasicMaterial, DoubleSide } from 'three';\r\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';\r\n\r\n/**\r\n * This is a helper for visualising a given light's shadow map.\r\n * It works for shadow casting lights: DirectionalLight and SpotLight.\r\n * It renders out the shadow map and displays it on a HUD.\r\n *\r\n * Example usage:\r\n *\t1) Import ShadowMapViewer into your app.\r\n *\r\n *\t2) Create a shadow casting light and name it optionally:\r\n *\t\tvar light = new DirectionalLight( 0xffffff, 1 );\r\n *\t\tlight.castShadow = true;\r\n *\t\tlight.name = 'Sun';\r\n *\r\n *\t3) Create a shadow map viewer for that light and set its size and position optionally:\r\n *\t\tvar shadowMapViewer = new ShadowMapViewer( light );\r\n *\t\tshadowMapViewer.size.set( 128, 128 );\t//width, height  default: 256, 256\r\n *\t\tshadowMapViewer.position.set( 10, 10 );\t//x, y in pixel\t default: 0, 0 (top left corner)\r\n *\r\n *\t4) Render the shadow map viewer in your render loop:\r\n *\t\tshadowMapViewer.render( renderer );\r\n *\r\n *\t5) Optionally: Update the shadow map viewer on window resize:\r\n *\t\tshadowMapViewer.updateForWindowResize();\r\n *\r\n *\t6) If you set the position or size members directly, you need to call shadowMapViewer.update();\r\n */\r\n\r\nvar ShadowMapViewer = function (light) {\r\n  //- Internals\r\n  var scope = this;\r\n  var doRenderLabel = light.name !== undefined && light.name !== '';\r\n  var userAutoClearSetting; //Holds the initial position and dimension of the HUD\r\n\r\n  var frame = {\r\n    x: 10,\r\n    y: 10,\r\n    width: 256,\r\n    height: 256\r\n  };\r\n  var camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);\r\n  camera.position.set(0, 0, 2);\r\n  var scene = new Scene(); //HUD for shadow map\r\n\r\n  var shader = UnpackDepthRGBAShader;\r\n  var uniforms = UniformsUtils.clone(shader.uniforms);\r\n  var material = new ShaderMaterial({\r\n    uniforms: uniforms,\r\n    vertexShader: shader.vertexShader,\r\n    fragmentShader: shader.fragmentShader\r\n  });\r\n  var plane = new PlaneGeometry(frame.width, frame.height);\r\n  var mesh = new Mesh(plane, material);\r\n  scene.add(mesh); //Label for light's name\r\n\r\n  var labelCanvas, labelMesh;\r\n\r\n  if (doRenderLabel) {\r\n    labelCanvas = document.createElement('canvas');\r\n    var context = labelCanvas.getContext('2d');\r\n    context.font = 'Bold 20px Arial';\r\n    var labelWidth = context.measureText(light.name).width;\r\n    labelCanvas.width = labelWidth;\r\n    labelCanvas.height = 25; //25 to account for g, p, etc.\r\n\r\n    context.font = 'Bold 20px Arial';\r\n    context.fillStyle = 'rgba( 255, 0, 0, 1 )';\r\n    context.fillText(light.name, 0, 20);\r\n    var labelTexture = new Texture(labelCanvas);\r\n    labelTexture.magFilter = LinearFilter;\r\n    labelTexture.minFilter = LinearFilter;\r\n    labelTexture.needsUpdate = true;\r\n    var labelMaterial = new MeshBasicMaterial({\r\n      map: labelTexture,\r\n      side: DoubleSide\r\n    });\r\n    labelMaterial.transparent = true;\r\n    var labelPlane = new PlaneGeometry(labelCanvas.width, labelCanvas.height);\r\n    labelMesh = new Mesh(labelPlane, labelMaterial);\r\n    scene.add(labelMesh);\r\n  }\r\n\r\n  function resetPosition() {\r\n    scope.position.set(scope.position.x, scope.position.y);\r\n  } //- API\r\n  // Set to false to disable displaying this shadow map\r\n\r\n\r\n  this.enabled = true; // Set the size of the displayed shadow map on the HUD\r\n\r\n  this.size = {\r\n    width: frame.width,\r\n    height: frame.height,\r\n    set: function (width, height) {\r\n      this.width = width;\r\n      this.height = height;\r\n      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1); //Reset the position as it is off when we scale stuff\r\n\r\n      resetPosition();\r\n    }\r\n  }; // Set the position of the displayed shadow map on the HUD\r\n\r\n  this.position = {\r\n    x: frame.x,\r\n    y: frame.y,\r\n    set: function (x, y) {\r\n      this.x = x;\r\n      this.y = y;\r\n      var width = scope.size.width;\r\n      var height = scope.size.height;\r\n      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);\r\n\r\n      if (doRenderLabel) {\r\n        labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);\r\n      }\r\n    }\r\n  };\r\n\r\n  this.render = function (renderer) {\r\n    if (this.enabled) {\r\n      //Because a light's .shadowMap is only initialised after the first render pass\r\n      //we have to make sure the correct map is sent into the shader, otherwise we\r\n      //always end up with the scene's first added shadow casting light's shadowMap\r\n      //in the shader\r\n      //See: https://github.com/mrdoob/three.js/issues/5932\r\n      uniforms.tDiffuse.value = light.shadow.map.texture;\r\n      userAutoClearSetting = renderer.autoClear;\r\n      renderer.autoClear = false; // To allow render overlay\r\n\r\n      renderer.clearDepth();\r\n      renderer.render(scene, camera);\r\n      renderer.autoClear = userAutoClearSetting; //Restore user's setting\r\n    }\r\n  };\r\n\r\n  this.updateForWindowResize = function () {\r\n    if (this.enabled) {\r\n      camera.left = window.innerWidth / -2;\r\n      camera.right = window.innerWidth / 2;\r\n      camera.top = window.innerHeight / 2;\r\n      camera.bottom = window.innerHeight / -2;\r\n      camera.updateProjectionMatrix();\r\n      this.update();\r\n    }\r\n  };\r\n\r\n  this.update = function () {\r\n    this.position.set(this.position.x, this.position.y);\r\n    this.size.set(this.size.width, this.size.height);\r\n  }; //Force an update to set position/size\r\n\r\n\r\n  this.update();\r\n};\r\n\r\nShadowMapViewer.prototype.constructor = ShadowMapViewer;\r\n\r\nexport { ShadowMapViewer };\r\n", "import { Vector2 } from 'three';\r\n\r\n/**\r\n * Depth-of-field shader with bokeh\r\n * ported from GLSL shader by Martins Upitis\r\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\r\n *\r\n * Requires #define RINGS and SAMPLES integers\r\n */\r\nconst BokehShader2 = {\r\n  uniforms: {\r\n    textureWidth: {\r\n      value: 1.0\r\n    },\r\n    textureHeight: {\r\n      value: 1.0\r\n    },\r\n    focalDepth: {\r\n      value: 1.0\r\n    },\r\n    focalLength: {\r\n      value: 24.0\r\n    },\r\n    fstop: {\r\n      value: 0.9\r\n    },\r\n    tColor: {\r\n      value: null\r\n    },\r\n    tDepth: {\r\n      value: null\r\n    },\r\n    maxblur: {\r\n      value: 1.0\r\n    },\r\n    showFocus: {\r\n      value: 0\r\n    },\r\n    manualdof: {\r\n      value: 0\r\n    },\r\n    vignetting: {\r\n      value: 0\r\n    },\r\n    depthblur: {\r\n      value: 0\r\n    },\r\n    threshold: {\r\n      value: 0.5\r\n    },\r\n    gain: {\r\n      value: 2.0\r\n    },\r\n    bias: {\r\n      value: 0.5\r\n    },\r\n    fringe: {\r\n      value: 0.7\r\n    },\r\n    znear: {\r\n      value: 0.1\r\n    },\r\n    zfar: {\r\n      value: 100\r\n    },\r\n    noise: {\r\n      value: 1\r\n    },\r\n    dithering: {\r\n      value: 0.0001\r\n    },\r\n    pentagon: {\r\n      value: 0\r\n    },\r\n    shaderFocus: {\r\n      value: 1\r\n    },\r\n    focusCoords: {\r\n      value: new Vector2()\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', 'uniform sampler2D tColor;', 'uniform sampler2D tDepth;', 'uniform float textureWidth;', 'uniform float textureHeight;', 'uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below', 'uniform float focalLength; //focal length in mm', 'uniform float fstop; //f-stop value', 'uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)', '/*', 'make sure that these two values are the same for your camera, otherwise distances will be wrong.', '*/', 'uniform float znear; // camera clipping start', 'uniform float zfar; // camera clipping end', '//------------------------------------------', '//user variables', 'const int samples = SAMPLES; //samples on the first ring', 'const int rings = RINGS; //ring count', 'const int maxringsamples = rings * samples;', 'uniform bool manualdof; // manual dof calculation', 'float ndofstart = 1.0; // near dof blur start', 'float ndofdist = 2.0; // near dof blur falloff distance', 'float fdofstart = 1.0; // far dof blur start', 'float fdofdist = 3.0; // far dof blur falloff distance', 'float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)', 'uniform bool vignetting; // use optical lens vignetting', 'float vignout = 1.3; // vignetting outer border', 'float vignin = 0.0; // vignetting inner border', 'float vignfade = 22.0; // f-stops till vignete fades', 'uniform bool shaderFocus;', '// disable if you use external focalDepth value', 'uniform vec2 focusCoords;', '// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)', '// if center of screen use vec2(0.5, 0.5);', 'uniform float maxblur;', '//clamp value of max blur (0.0 = no blur, 1.0 default)', 'uniform float threshold; // highlight threshold;', 'uniform float gain; // highlight gain;', 'uniform float bias; // bokeh edge bias', 'uniform float fringe; // bokeh chromatic aberration / fringing', 'uniform bool noise; //use noise instead of pattern for sample dithering', 'uniform float dithering;', 'uniform bool depthblur; // blur the depth buffer', 'float dbsize = 1.25; // depth blur size', '/*', 'next part is experimental', 'not looking good with small sample and ring count', 'looks okay starting from samples = 4, rings = 4', '*/', 'uniform bool pentagon; //use pentagon as bokeh shape?', 'float feather = 0.4; //pentagon shape feather', '//------------------------------------------', 'float penta(vec2 coords) {', '\t//pentagonal shape', '\tfloat scale = float(rings) - 1.3;', '\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);', '\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);', '\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);', '\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);', '\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);', '\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);', '\tvec4  one = vec4( 1.0 );', '\tvec4 P = vec4((coords),vec2(scale, scale));', '\tvec4 dist = vec4(0.0);', '\tfloat inorout = -4.0;', '\tdist.x = dot( P, HS0 );', '\tdist.y = dot( P, HS1 );', '\tdist.z = dot( P, HS2 );', '\tdist.w = dot( P, HS3 );', '\tdist = smoothstep( -feather, feather, dist );', '\tinorout += dot( dist, one );', '\tdist.x = dot( P, HS4 );', '\tdist.y = HS5.w - abs( P.z );', '\tdist = smoothstep( -feather, feather, dist );', '\tinorout += dist.x;', '\treturn clamp( inorout, 0.0, 1.0 );', '}', 'float bdepth(vec2 coords) {', '\t// Depth buffer blur', '\tfloat d = 0.0;', '\tfloat kernel[9];', '\tvec2 offset[9];', '\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;', '\toffset[0] = vec2(-wh.x,-wh.y);', '\toffset[1] = vec2( 0.0, -wh.y);', '\toffset[2] = vec2( wh.x -wh.y);', '\toffset[3] = vec2(-wh.x,  0.0);', '\toffset[4] = vec2( 0.0,   0.0);', '\toffset[5] = vec2( wh.x,  0.0);', '\toffset[6] = vec2(-wh.x, wh.y);', '\toffset[7] = vec2( 0.0,  wh.y);', '\toffset[8] = vec2( wh.x, wh.y);', '\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;', '\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;', '\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;', '\tfor( int i=0; i<9; i++ ) {', '\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;', '\t\td += tmp * kernel[i];', '\t}', '\treturn d;', '}', 'vec3 color(vec2 coords,float blur) {', '\t//processing the sample', '\tvec3 col = vec3(0.0);', '\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);', '\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;', '\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;', '\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;', '\tvec3 lumcoeff = vec3(0.299,0.587,0.114);', '\tfloat lum = dot(col.rgb, lumcoeff);', '\tfloat thresh = max((lum-threshold)*gain, 0.0);', '\treturn col+mix(vec3(0.0),col,thresh*blur);', '}', 'vec3 debugFocus(vec3 col, float blur, float depth) {', '\tfloat edge = 0.002*depth; //distance based edge smoothing', '\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);', '\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);', '\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);', '\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);', '\treturn col;', '}', 'float linearize(float depth) {', '\treturn -zfar * znear / (depth * (zfar - znear) - zfar);', '}', 'float vignette() {', '\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));', '\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);', '\treturn clamp(dist,0.0,1.0);', '}', 'float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {', '\tfloat rings2 = float(rings);', '\tfloat step = PI*2.0 / float(ringsamples);', '\tfloat pw = cos(j*step)*i;', '\tfloat ph = sin(j*step)*i;', '\tfloat p = 1.0;', '\tif (pentagon) {', '\t\tp = penta(vec2(pw,ph));', '\t}', '\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;', '\treturn 1.0 * mix(1.0, i /rings2, bias) * p;', '}', 'void main() {', '\t//scene depth calculation', '\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);', '\t// Blur depth?', '\tif ( depthblur ) {', '\t\tdepth = linearize(bdepth(vUv.xy));', '\t}', '\t//focal plane calculation', '\tfloat fDepth = focalDepth;', '\tif (shaderFocus) {', '\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);', '\t}', '\t// dof blur factor calculation', '\tfloat blur = 0.0;', '\tif (manualdof) {', '\t\tfloat a = depth-fDepth; // Focal plane', '\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF', '\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof', '\t\tblur = (a>0.0) ? b : c;', '\t} else {', '\t\tfloat f = focalLength; // focal length in mm', '\t\tfloat d = fDepth*1000.0; // focal plane in mm', '\t\tfloat o = depth*1000.0; // depth in mm', '\t\tfloat a = (o*f)/(o-f);', '\t\tfloat b = (d*f)/(d-f);', '\t\tfloat c = (d-f)/(d*fstop*CoC);', '\t\tblur = abs(a-b)*c;', '\t}', '\tblur = clamp(blur,0.0,1.0);', '\t// calculation of pattern for dithering', '\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;', '\t// getting blur x and y step factor', '\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;', '\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;', '\t// calculation of final color', '\tvec3 col = vec3(0.0);', '\tif(blur < 0.05) {', '\t\t//some optimization thingy', '\t\tcol = texture2D(tColor, vUv.xy).rgb;', '\t} else {', '\t\tcol = texture2D(tColor, vUv.xy).rgb;', '\t\tfloat s = 1.0;', '\t\tint ringsamples;', '\t\tfor (int i = 1; i <= rings; i++) {', '\t\t\t/*unboxstart*/', '\t\t\tringsamples = i * samples;', '\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {', '\t\t\t\tif (j >= ringsamples) break;', '\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);', '\t\t\t}', '\t\t\t/*unboxend*/', '\t\t}', '\t\tcol /= s; //divide by sample count', '\t}', '\tif (showFocus) {', '\t\tcol = debugFocus(col, blur, depth);', '\t}', '\tif (vignetting) {', '\t\tcol *= vignette();', '\t}', '\tgl_FragColor.rgb = col;', '\tgl_FragColor.a = 1.0;', '} '].join('\\n')\r\n};\r\nconst BokehDepthShader = {\r\n  uniforms: {\r\n    mNear: {\r\n      value: 1.0\r\n    },\r\n    mFar: {\r\n      value: 1000.0\r\n    }\r\n  },\r\n  vertexShader: ['varying float vViewZDepth;', 'void main() {', '\t#include <begin_vertex>', '\t#include <project_vertex>', '\tvViewZDepth = - mvPosition.z;', '}'].join('\\n'),\r\n  fragmentShader: ['uniform float mNear;', 'uniform float mFar;', 'varying float vViewZDepth;', 'void main() {', '\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );', '\tgl_FragColor = vec4( vec3( color ), 1.0 );', '} '].join('\\n')\r\n};\r\n\r\nexport { BokehDepthShader, BokehShader2 };\r\n", "import { Triangle, Vector3 } from 'three';\r\n\r\n/**\r\n * Utility class for sampling weighted random points on the surface of a mesh.\r\n *\r\n * Building the sampler is a one-time O(n) operation. Once built, any number of\r\n * random samples may be selected in O(logn) time. Memory usage is O(n).\r\n *\r\n * References:\r\n * - http://www.joesfer.com/?p=84\r\n * - https://stackoverflow.com/a/4322940/1314762\r\n */\r\n\r\nvar MeshSurfaceSampler = function () {\r\n  var _face = new Triangle();\r\n\r\n  var _color = new Vector3();\r\n\r\n  function MeshSurfaceSampler(mesh) {\r\n    var geometry = mesh.geometry;\r\n\r\n    if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {\r\n      throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');\r\n    }\r\n\r\n    if (geometry.index) {\r\n      console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');\r\n      geometry = geometry.toNonIndexed();\r\n    }\r\n\r\n    this.geometry = geometry;\r\n    this.randomFunction = Math.random;\r\n    this.positionAttribute = this.geometry.getAttribute('position');\r\n    this.colorAttribute = this.geometry.getAttribute('color');\r\n    this.weightAttribute = null;\r\n    this.distribution = null;\r\n  }\r\n\r\n  MeshSurfaceSampler.prototype = {\r\n    constructor: MeshSurfaceSampler,\r\n    setWeightAttribute: function (name) {\r\n      this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\r\n      return this;\r\n    },\r\n    build: function () {\r\n      var positionAttribute = this.positionAttribute;\r\n      var weightAttribute = this.weightAttribute;\r\n      var faceWeights = new Float32Array(positionAttribute.count / 3); // Accumulate weights for each mesh face.\r\n\r\n      for (let i = 0; i < positionAttribute.count; i += 3) {\r\n        var faceWeight = 1;\r\n\r\n        if (weightAttribute) {\r\n          faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\r\n        }\r\n\r\n        _face.a.fromBufferAttribute(positionAttribute, i);\r\n\r\n        _face.b.fromBufferAttribute(positionAttribute, i + 1);\r\n\r\n        _face.c.fromBufferAttribute(positionAttribute, i + 2);\r\n\r\n        faceWeight *= _face.getArea();\r\n        faceWeights[i / 3] = faceWeight;\r\n      } // Store cumulative total face weights in an array, where weight index\r\n      // corresponds to face index.\r\n\r\n\r\n      this.distribution = new Float32Array(positionAttribute.count / 3);\r\n      var cumulativeTotal = 0;\r\n\r\n      for (let i = 0; i < faceWeights.length; i++) {\r\n        cumulativeTotal += faceWeights[i];\r\n        this.distribution[i] = cumulativeTotal;\r\n      }\r\n\r\n      return this;\r\n    },\r\n    setRandomGenerator: function (randomFunction) {\r\n      this.randomFunction = randomFunction;\r\n      return this;\r\n    },\r\n    sample: function (targetPosition, targetNormal, targetColor) {\r\n      var cumulativeTotal = this.distribution[this.distribution.length - 1];\r\n      var faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);\r\n      return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\r\n    },\r\n    binarySearch: function (x) {\r\n      var dist = this.distribution;\r\n      var start = 0;\r\n      var end = dist.length - 1;\r\n      var index = -1;\r\n\r\n      while (start <= end) {\r\n        var mid = Math.ceil((start + end) / 2);\r\n\r\n        if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\r\n          index = mid;\r\n          break;\r\n        } else if (x < dist[mid]) {\r\n          end = mid - 1;\r\n        } else {\r\n          start = mid + 1;\r\n        }\r\n      }\r\n\r\n      return index;\r\n    },\r\n    sampleFace: function (faceIndex, targetPosition, targetNormal, targetColor) {\r\n      var u = this.randomFunction();\r\n      var v = this.randomFunction();\r\n\r\n      if (u + v > 1) {\r\n        u = 1 - u;\r\n        v = 1 - v;\r\n      }\r\n\r\n      _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\r\n\r\n      _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\r\n\r\n      _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\r\n\r\n      targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\r\n\r\n      if (targetNormal !== undefined) {\r\n        _face.getNormal(targetNormal);\r\n      }\r\n\r\n      if (targetColor !== undefined && this.colorAttribute !== undefined) {\r\n        _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\r\n\r\n        _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\r\n\r\n        _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\r\n\r\n        _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\r\n\r\n        targetColor.r = _color.x;\r\n        targetColor.g = _color.y;\r\n        targetColor.b = _color.z;\r\n      }\r\n\r\n      return this;\r\n    }\r\n  };\r\n  return MeshSurfaceSampler;\r\n}();\r\n\r\nexport { MeshSurfaceSampler };\r\n", "import { Vector3, Matrix3, Box3, Matrix4, Ray, MathUtils } from 'three';\r\n\r\nvar a = {\r\n  c: null,\r\n  // center\r\n  u: [new Vector3(), new Vector3(), new Vector3()],\r\n  // basis vectors\r\n  e: [] // half width\r\n\r\n};\r\nvar b = {\r\n  c: null,\r\n  // center\r\n  u: [new Vector3(), new Vector3(), new Vector3()],\r\n  // basis vectors\r\n  e: [] // half width\r\n\r\n};\r\nvar R = [[], [], []];\r\nvar AbsR = [[], [], []];\r\nvar t = [];\r\nvar xAxis = new Vector3();\r\nvar yAxis = new Vector3();\r\nvar zAxis = new Vector3();\r\nvar v1 = new Vector3();\r\nvar size = new Vector3();\r\nvar closestPoint = new Vector3();\r\nvar rotationMatrix = new Matrix3();\r\nvar aabb = new Box3();\r\nvar matrix = new Matrix4();\r\nvar inverse = new Matrix4();\r\nvar localRay = new Ray(); // OBB\r\n\r\nfunction OBB(center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3()) {\r\n  this.center = center;\r\n  this.halfSize = halfSize;\r\n  this.rotation = rotation;\r\n}\r\n\r\nObject.assign(OBB.prototype, {\r\n  set: function (center, halfSize, rotation) {\r\n    this.center = center;\r\n    this.halfSize = halfSize;\r\n    this.rotation = rotation;\r\n    return this;\r\n  },\r\n  copy: function (obb) {\r\n    this.center.copy(obb.center);\r\n    this.halfSize.copy(obb.halfSize);\r\n    this.rotation.copy(obb.rotation);\r\n    return this;\r\n  },\r\n  clone: function () {\r\n    return new this.constructor().copy(this);\r\n  },\r\n  getSize: function (result) {\r\n    return result.copy(this.halfSize).multiplyScalar(2);\r\n  },\r\n\r\n  /**\r\n   * Reference: Closest Point on OBB to Point in Real-Time Collision Detection\r\n   * by Christer Ericson (chapter 5.1.4)\r\n   */\r\n  clampPoint: function (point, result) {\r\n    var halfSize = this.halfSize;\r\n    v1.subVectors(point, this.center);\r\n    this.rotation.extractBasis(xAxis, yAxis, zAxis); // start at the center position of the OBB\r\n\r\n    result.copy(this.center); // project the target onto the OBB axes and walk towards that point\r\n\r\n    var x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);\r\n    result.add(xAxis.multiplyScalar(x));\r\n    var y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);\r\n    result.add(yAxis.multiplyScalar(y));\r\n    var z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);\r\n    result.add(zAxis.multiplyScalar(z));\r\n    return result;\r\n  },\r\n  containsPoint: function (point) {\r\n    v1.subVectors(point, this.center);\r\n    this.rotation.extractBasis(xAxis, yAxis, zAxis); // project v1 onto each axis and check if these points lie inside the OBB\r\n\r\n    return Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;\r\n  },\r\n  intersectsBox3: function (box3) {\r\n    return this.intersectsOBB(obb.fromBox3(box3));\r\n  },\r\n  intersectsSphere: function (sphere) {\r\n    // find the point on the OBB closest to the sphere center\r\n    this.clampPoint(sphere.center, closestPoint); // if that point is inside the sphere, the OBB and sphere intersect\r\n\r\n    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\r\n  },\r\n\r\n  /**\r\n   * Reference: OBB-OBB Intersection in Real-Time Collision Detection\r\n   * by Christer Ericson (chapter 4.4.1)\r\n   *\r\n   */\r\n  intersectsOBB: function (obb, epsilon = Number.EPSILON) {\r\n    // prepare data structures (the code uses the same nomenclature like the reference)\r\n    a.c = this.center;\r\n    a.e[0] = this.halfSize.x;\r\n    a.e[1] = this.halfSize.y;\r\n    a.e[2] = this.halfSize.z;\r\n    this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]);\r\n    b.c = obb.center;\r\n    b.e[0] = obb.halfSize.x;\r\n    b.e[1] = obb.halfSize.y;\r\n    b.e[2] = obb.halfSize.z;\r\n    obb.rotation.extractBasis(b.u[0], b.u[1], b.u[2]); // compute rotation matrix expressing b in a's coordinate frame\r\n\r\n    for (let i = 0; i < 3; i++) {\r\n      for (let j = 0; j < 3; j++) {\r\n        R[i][j] = a.u[i].dot(b.u[j]);\r\n      }\r\n    } // compute translation vector\r\n\r\n\r\n    v1.subVectors(b.c, a.c); // bring translation into a's coordinate frame\r\n\r\n    t[0] = v1.dot(a.u[0]);\r\n    t[1] = v1.dot(a.u[1]);\r\n    t[2] = v1.dot(a.u[2]); // compute common subexpressions. Add in an epsilon term to\r\n    // counteract arithmetic errors when two edges are parallel and\r\n    // their cross product is (near) null\r\n\r\n    for (let i = 0; i < 3; i++) {\r\n      for (let j = 0; j < 3; j++) {\r\n        AbsR[i][j] = Math.abs(R[i][j]) + epsilon;\r\n      }\r\n    }\r\n\r\n    var ra, rb; // test axes L = A0, L = A1, L = A2\r\n\r\n    for (let i = 0; i < 3; i++) {\r\n      ra = a.e[i];\r\n      rb = b.e[0] * AbsR[i][0] + b.e[1] * AbsR[i][1] + b.e[2] * AbsR[i][2];\r\n      if (Math.abs(t[i]) > ra + rb) return false;\r\n    } // test axes L = B0, L = B1, L = B2\r\n\r\n\r\n    for (let i = 0; i < 3; i++) {\r\n      ra = a.e[0] * AbsR[0][i] + a.e[1] * AbsR[1][i] + a.e[2] * AbsR[2][i];\r\n      rb = b.e[i];\r\n      if (Math.abs(t[0] * R[0][i] + t[1] * R[1][i] + t[2] * R[2][i]) > ra + rb) return false;\r\n    } // test axis L = A0 x B0\r\n\r\n\r\n    ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];\r\n    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];\r\n    if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb) return false; // test axis L = A0 x B1\r\n\r\n    ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];\r\n    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];\r\n    if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb) return false; // test axis L = A0 x B2\r\n\r\n    ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];\r\n    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];\r\n    if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb) return false; // test axis L = A1 x B0\r\n\r\n    ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];\r\n    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];\r\n    if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb) return false; // test axis L = A1 x B1\r\n\r\n    ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];\r\n    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];\r\n    if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb) return false; // test axis L = A1 x B2\r\n\r\n    ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];\r\n    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];\r\n    if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb) return false; // test axis L = A2 x B0\r\n\r\n    ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];\r\n    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];\r\n    if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb) return false; // test axis L = A2 x B1\r\n\r\n    ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];\r\n    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];\r\n    if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb) return false; // test axis L = A2 x B2\r\n\r\n    ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];\r\n    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];\r\n    if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb) return false; // since no separating axis is found, the OBBs must be intersecting\r\n\r\n    return true;\r\n  },\r\n\r\n  /**\r\n   * Reference: Testing Box Against Plane in Real-Time Collision Detection\r\n   * by Christer Ericson (chapter 5.2.3)\r\n   */\r\n  intersectsPlane: function (plane) {\r\n    this.rotation.extractBasis(xAxis, yAxis, zAxis); // compute the projection interval radius of this OBB onto L(t) = this->center + t * p.normal;\r\n\r\n    const r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis)); // compute distance of the OBB's center from the plane\r\n\r\n    const d = plane.normal.dot(this.center) - plane.constant; // Intersection occurs when distance d falls within [-r,+r] interval\r\n\r\n    return Math.abs(d) <= r;\r\n  },\r\n\r\n  /**\r\n   * Performs a ray/OBB intersection test and stores the intersection point\r\n   * to the given 3D vector. If no intersection is detected, *null* is returned.\r\n   */\r\n  intersectRay: function (ray, result) {\r\n    // the idea is to perform the intersection test in the local space\r\n    // of the OBB.\r\n    this.getSize(size);\r\n    aabb.setFromCenterAndSize(v1.set(0, 0, 0), size); // create a 4x4 transformation matrix\r\n\r\n    matrix4FromRotationMatrix(matrix, this.rotation);\r\n    matrix.setPosition(this.center); // transform ray to the local space of the OBB\r\n\r\n    inverse.copy(matrix).invert();\r\n    localRay.copy(ray).applyMatrix4(inverse); // perform ray <-> AABB intersection test\r\n\r\n    if (localRay.intersectBox(aabb, result)) {\r\n      // transform the intersection point back to world space\r\n      return result.applyMatrix4(matrix);\r\n    } else {\r\n      return null;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Performs a ray/OBB intersection test. Returns either true or false if\r\n   * there is a intersection or not.\r\n   */\r\n  intersectsRay: function (ray) {\r\n    return this.intersectRay(ray, v1) !== null;\r\n  },\r\n  fromBox3: function (box3) {\r\n    box3.getCenter(this.center);\r\n    box3.getSize(this.halfSize).multiplyScalar(0.5);\r\n    this.rotation.identity();\r\n    return this;\r\n  },\r\n  equals: function (obb) {\r\n    return obb.center.equals(this.center) && obb.halfSize.equals(this.halfSize) && obb.rotation.equals(this.rotation);\r\n  },\r\n  applyMatrix4: function (matrix) {\r\n    var e = matrix.elements;\r\n    var sx = v1.set(e[0], e[1], e[2]).length();\r\n    var sy = v1.set(e[4], e[5], e[6]).length();\r\n    var sz = v1.set(e[8], e[9], e[10]).length();\r\n    var det = matrix.determinant();\r\n    if (det < 0) sx = -sx;\r\n    rotationMatrix.setFromMatrix4(matrix);\r\n    var invSX = 1 / sx;\r\n    var invSY = 1 / sy;\r\n    var invSZ = 1 / sz;\r\n    rotationMatrix.elements[0] *= invSX;\r\n    rotationMatrix.elements[1] *= invSX;\r\n    rotationMatrix.elements[2] *= invSX;\r\n    rotationMatrix.elements[3] *= invSY;\r\n    rotationMatrix.elements[4] *= invSY;\r\n    rotationMatrix.elements[5] *= invSY;\r\n    rotationMatrix.elements[6] *= invSZ;\r\n    rotationMatrix.elements[7] *= invSZ;\r\n    rotationMatrix.elements[8] *= invSZ;\r\n    this.rotation.multiply(rotationMatrix);\r\n    this.halfSize.x *= sx;\r\n    this.halfSize.y *= sy;\r\n    this.halfSize.z *= sz;\r\n    v1.setFromMatrixPosition(matrix);\r\n    this.center.add(v1);\r\n    return this;\r\n  }\r\n});\r\n\r\nfunction matrix4FromRotationMatrix(matrix4, matrix3) {\r\n  var e = matrix4.elements;\r\n  var me = matrix3.elements;\r\n  e[0] = me[0];\r\n  e[1] = me[1];\r\n  e[2] = me[2];\r\n  e[3] = 0;\r\n  e[4] = me[3];\r\n  e[5] = me[4];\r\n  e[6] = me[5];\r\n  e[7] = 0;\r\n  e[8] = me[6];\r\n  e[9] = me[7];\r\n  e[10] = me[8];\r\n  e[11] = 0;\r\n  e[12] = 0;\r\n  e[13] = 0;\r\n  e[14] = 0;\r\n  e[15] = 1;\r\n}\r\n\r\nvar obb = new OBB();\r\n\r\nexport { OBB };\r\n", "import { Vector3 } from 'three';\r\n\r\nvar Capsule = function () {\r\n  var _v1 = new Vector3();\r\n\r\n  var _v2 = new Vector3();\r\n\r\n  var _v3 = new Vector3();\r\n\r\n  var EPS = 1e-10;\r\n\r\n  function Capsule(start, end, radius) {\r\n    this.start = start == undefined ? new Vector3(0, 0, 0) : start;\r\n    this.end = end == undefined ? new Vector3(0, 1, 0) : end;\r\n    this.radius = radius == undefined ? 1 : radius;\r\n  }\r\n\r\n  Object.assign(Capsule.prototype, {\r\n    clone: function () {\r\n      return new Capsule(this.start.clone(), this.end.clone(), this.radius);\r\n    },\r\n    set: function (start, end, radius) {\r\n      this.start.copy(start);\r\n      this.end.copy(end);\r\n      this.radius = radius;\r\n    },\r\n    copy: function (capsule) {\r\n      this.start.copy(capsule.start);\r\n      this.end.copy(capsule.end);\r\n      this.radius = capsule.radius;\r\n    },\r\n    getCenter: function (target) {\r\n      return target.copy(this.end).add(this.start).multiplyScalar(0.5);\r\n    },\r\n    translate: function (v) {\r\n      this.start.add(v);\r\n      this.end.add(v);\r\n    },\r\n    checkAABBAxis: function (p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius) {\r\n      return (minx - p1x < radius || minx - p2x < radius) && (p1x - maxx < radius || p2x - maxx < radius) && (miny - p1y < radius || miny - p2y < radius) && (p1y - maxy < radius || p2y - maxy < radius);\r\n    },\r\n    intersectsBox: function (box) {\r\n      return this.checkAABBAxis(this.start.x, this.start.y, this.end.x, this.end.y, box.min.x, box.max.x, box.min.y, box.max.y, this.radius) && this.checkAABBAxis(this.start.x, this.start.z, this.end.x, this.end.z, box.min.x, box.max.x, box.min.z, box.max.z, this.radius) && this.checkAABBAxis(this.start.y, this.start.z, this.end.y, this.end.z, box.min.y, box.max.y, box.min.z, box.max.z, this.radius);\r\n    },\r\n    lineLineMinimumPoints: function (line1, line2) {\r\n      var r = _v1.copy(line1.end).sub(line1.start);\r\n\r\n      var s = _v2.copy(line2.end).sub(line2.start);\r\n\r\n      var w = _v3.copy(line2.start).sub(line1.start);\r\n\r\n      var a = r.dot(s),\r\n          b = r.dot(r),\r\n          c = s.dot(s),\r\n          d = s.dot(w),\r\n          e = r.dot(w);\r\n      var t1,\r\n          t2,\r\n          divisor = b * c - a * a;\r\n\r\n      if (Math.abs(divisor) < EPS) {\r\n        var d1 = -d / c;\r\n        var d2 = (a - d) / c;\r\n\r\n        if (Math.abs(d1 - 0.5) < Math.abs(d2 - 0.5)) {\r\n          t1 = 0;\r\n          t2 = d1;\r\n        } else {\r\n          t1 = 1;\r\n          t2 = d2;\r\n        }\r\n      } else {\r\n        t1 = (d * a + e * c) / divisor;\r\n        t2 = (t1 * a - d) / c;\r\n      }\r\n\r\n      t2 = Math.max(0, Math.min(1, t2));\r\n      t1 = Math.max(0, Math.min(1, t1));\r\n      var point1 = r.multiplyScalar(t1).add(line1.start);\r\n      var point2 = s.multiplyScalar(t2).add(line2.start);\r\n      return [point1, point2];\r\n    }\r\n  });\r\n  return Capsule;\r\n}();\r\n\r\nexport { Capsule };\r\n", "import { MathUtils } from 'three';\r\n\r\nvar ColorConverter = {\r\n  setHSV: function (color, h, s, v) {\r\n    // https://gist.github.com/xpansive/1337890#file-index-js\r\n    h = MathUtils.euclideanModulo(h, 1);\r\n    s = MathUtils.clamp(s, 0, 1);\r\n    v = MathUtils.clamp(v, 0, 1);\r\n    return color.setHSL(h, s * v / ((h = (2 - s) * v) < 1 ? h : 2 - h), h * 0.5);\r\n  },\r\n  getHSV: function () {\r\n    var hsl = {};\r\n    return function getHSV(color, target) {\r\n      if (target === undefined) {\r\n        console.warn('THREE.ColorConverter: .getHSV() target is now required');\r\n        target = {\r\n          h: 0,\r\n          s: 0,\r\n          l: 0\r\n        };\r\n      }\r\n\r\n      color.getHSL(hsl); // based on https://gist.github.com/xpansive/1337890#file-index-js\r\n\r\n      hsl.s *= hsl.l < 0.5 ? hsl.l : 1 - hsl.l;\r\n      target.h = hsl.h;\r\n      target.s = 2 * hsl.s / (hsl.l + hsl.s);\r\n      target.v = hsl.l + hsl.s;\r\n      return target;\r\n    };\r\n  }(),\r\n  // where c, m, y, k is between 0 and 1\r\n  setCMYK: function (color, c, m, y, k) {\r\n    var r = (1 - c) * (1 - k);\r\n    var g = (1 - m) * (1 - k);\r\n    var b = (1 - y) * (1 - k);\r\n    return color.setRGB(r, g, b);\r\n  },\r\n  getCMYK: function (color, target) {\r\n    if (target === undefined) {\r\n      console.warn('THREE.ColorConverter: .getCMYK() target is now required');\r\n      target = {\r\n        c: 0,\r\n        m: 0,\r\n        y: 0,\r\n        k: 0\r\n      };\r\n    }\r\n\r\n    var r = color.r;\r\n    var g = color.g;\r\n    var b = color.b;\r\n    var k = 1 - Math.max(r, g, b);\r\n    var c = (1 - r - k) / (1 - k);\r\n    var m = (1 - g - k) / (1 - k);\r\n    var y = (1 - b - k) / (1 - k);\r\n    target.c = c;\r\n    target.m = m;\r\n    target.y = y;\r\n    target.k = k;\r\n    return target;\r\n  }\r\n};\r\n\r\nexport { ColorConverter };\r\n", "import { Vector3, Plane, Line3, Sphere, Box3, Triangle } from 'three';\r\nimport { Capsule } from './Capsule.js';\r\n\r\nvar Octree = function () {\r\n  var _v1 = new Vector3();\r\n\r\n  var _v2 = new Vector3();\r\n\r\n  var _plane = new Plane();\r\n\r\n  var _line1 = new Line3();\r\n\r\n  var _line2 = new Line3();\r\n\r\n  var _sphere = new Sphere();\r\n\r\n  var _capsule = new Capsule();\r\n\r\n  function Octree(box) {\r\n    this.triangles = [];\r\n    this.box = box;\r\n    this.subTrees = [];\r\n  }\r\n\r\n  Object.assign(Octree.prototype, {\r\n    addTriangle: function (triangle) {\r\n      if (!this.bounds) this.bounds = new Box3();\r\n      this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x);\r\n      this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y);\r\n      this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z);\r\n      this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x);\r\n      this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y);\r\n      this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z);\r\n      this.triangles.push(triangle);\r\n      return this;\r\n    },\r\n    calcBox: function () {\r\n      this.box = this.bounds.clone(); // offset small ammount to account for regular grid\r\n\r\n      this.box.min.x -= 0.01;\r\n      this.box.min.y -= 0.01;\r\n      this.box.min.z -= 0.01;\r\n      return this;\r\n    },\r\n    split: function (level) {\r\n      if (!this.box) return;\r\n\r\n      var subTrees = [],\r\n          halfsize = _v2.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5),\r\n          box,\r\n          v,\r\n          triangle;\r\n\r\n      for (let x = 0; x < 2; x++) {\r\n        for (let y = 0; y < 2; y++) {\r\n          for (let z = 0; z < 2; z++) {\r\n            box = new Box3();\r\n            v = _v1.set(x, y, z);\r\n            box.min.copy(this.box.min).add(v.multiply(halfsize));\r\n            box.max.copy(box.min).add(halfsize);\r\n            subTrees.push(new Octree(box));\r\n          }\r\n        }\r\n      }\r\n\r\n      while (triangle = this.triangles.pop()) {\r\n        for (let i = 0; i < subTrees.length; i++) {\r\n          if (subTrees[i].box.intersectsTriangle(triangle)) {\r\n            subTrees[i].triangles.push(triangle);\r\n          }\r\n        }\r\n      }\r\n\r\n      for (let i = 0; i < subTrees.length; i++) {\r\n        var len = subTrees[i].triangles.length;\r\n\r\n        if (len > 8 && level < 16) {\r\n          subTrees[i].split(level + 1);\r\n        }\r\n\r\n        if (len != 0) {\r\n          this.subTrees.push(subTrees[i]);\r\n        }\r\n      }\r\n\r\n      return this;\r\n    },\r\n    build: function () {\r\n      this.calcBox();\r\n      this.split(0);\r\n      return this;\r\n    },\r\n    getRayTriangles: function (ray, triangles) {\r\n      for (let i = 0; i < this.subTrees.length; i++) {\r\n        var subTree = this.subTrees[i];\r\n        if (!ray.intersectsBox(subTree.box)) continue;\r\n\r\n        if (subTree.triangles.length > 0) {\r\n          for (let j = 0; j < subTree.triangles.length; j++) {\r\n            if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\r\n          }\r\n        } else {\r\n          subTree.getRayTriangles(ray, triangles);\r\n        }\r\n      }\r\n\r\n      return triangles;\r\n    },\r\n    triangleCapsuleIntersect: function (capsule, triangle) {\r\n      var point1, point2, line1, line2;\r\n      triangle.getPlane(_plane);\r\n      var d1 = _plane.distanceToPoint(capsule.start) - capsule.radius;\r\n      var d2 = _plane.distanceToPoint(capsule.end) - capsule.radius;\r\n\r\n      if (d1 > 0 && d2 > 0 || d1 < -capsule.radius && d2 < -capsule.radius) {\r\n        return false;\r\n      }\r\n\r\n      var delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)));\r\n\r\n      var intersectPoint = _v1.copy(capsule.start).lerp(capsule.end, delta);\r\n\r\n      if (triangle.containsPoint(intersectPoint)) {\r\n        return {\r\n          normal: _plane.normal.clone(),\r\n          point: intersectPoint.clone(),\r\n          depth: Math.abs(Math.min(d1, d2))\r\n        };\r\n      }\r\n\r\n      var r2 = capsule.radius * capsule.radius;\r\n      line1 = _line1.set(capsule.start, capsule.end);\r\n      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\r\n\r\n      for (let i = 0; i < lines.length; i++) {\r\n        line2 = _line2.set(lines[i][0], lines[i][1]);\r\n        [point1, point2] = capsule.lineLineMinimumPoints(line1, line2);\r\n\r\n        if (point1.distanceToSquared(point2) < r2) {\r\n          return {\r\n            normal: point1.clone().sub(point2).normalize(),\r\n            point: point2.clone(),\r\n            depth: capsule.radius - point1.distanceTo(point2)\r\n          };\r\n        }\r\n      }\r\n\r\n      return false;\r\n    },\r\n    triangleSphereIntersect: function (sphere, triangle) {\r\n      triangle.getPlane(_plane);\r\n      if (!sphere.intersectsPlane(_plane)) return false;\r\n      var depth = Math.abs(_plane.distanceToSphere(sphere));\r\n      var r2 = sphere.radius * sphere.radius - depth * depth;\r\n\r\n      var plainPoint = _plane.projectPoint(sphere.center, _v1);\r\n\r\n      if (triangle.containsPoint(sphere.center)) {\r\n        return {\r\n          normal: _plane.normal.clone(),\r\n          point: plainPoint.clone(),\r\n          depth: Math.abs(_plane.distanceToSphere(sphere))\r\n        };\r\n      }\r\n\r\n      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\r\n\r\n      for (let i = 0; i < lines.length; i++) {\r\n        _line1.set(lines[i][0], lines[i][1]);\r\n\r\n        _line1.closestPointToPoint(plainPoint, true, _v2);\r\n\r\n        var d = _v2.distanceToSquared(sphere.center);\r\n\r\n        if (d < r2) {\r\n          return {\r\n            normal: sphere.center.clone().sub(_v2).normalize(),\r\n            point: _v2.clone(),\r\n            depth: sphere.radius - Math.sqrt(d)\r\n          };\r\n        }\r\n      }\r\n\r\n      return false;\r\n    },\r\n    getSphereTriangles: function (sphere, triangles) {\r\n      for (let i = 0; i < this.subTrees.length; i++) {\r\n        var subTree = this.subTrees[i];\r\n        if (!sphere.intersectsBox(subTree.box)) continue;\r\n\r\n        if (subTree.triangles.length > 0) {\r\n          for (let j = 0; j < subTree.triangles.length; j++) {\r\n            if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\r\n          }\r\n        } else {\r\n          subTree.getSphereTriangles(sphere, triangles);\r\n        }\r\n      }\r\n    },\r\n    getCapsuleTriangles: function (capsule, triangles) {\r\n      for (let i = 0; i < this.subTrees.length; i++) {\r\n        var subTree = this.subTrees[i];\r\n        if (!capsule.intersectsBox(subTree.box)) continue;\r\n\r\n        if (subTree.triangles.length > 0) {\r\n          for (let j = 0; j < subTree.triangles.length; j++) {\r\n            if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\r\n          }\r\n        } else {\r\n          subTree.getCapsuleTriangles(capsule, triangles);\r\n        }\r\n      }\r\n    },\r\n\r\n    sphereIntersect(sphere) {\r\n      _sphere.copy(sphere);\r\n\r\n      var triangles = [],\r\n          result,\r\n          hit = false;\r\n      this.getSphereTriangles(sphere, triangles);\r\n\r\n      for (let i = 0; i < triangles.length; i++) {\r\n        if (result = this.triangleSphereIntersect(_sphere, triangles[i])) {\r\n          hit = true;\r\n\r\n          _sphere.center.add(result.normal.multiplyScalar(result.depth));\r\n        }\r\n      }\r\n\r\n      if (hit) {\r\n        var collisionVector = _sphere.center.clone().sub(sphere.center);\r\n\r\n        var depth = collisionVector.length();\r\n        return {\r\n          normal: collisionVector.normalize(),\r\n          depth: depth\r\n        };\r\n      }\r\n\r\n      return false;\r\n    },\r\n\r\n    capsuleIntersect: function (capsule) {\r\n      _capsule.copy(capsule);\r\n\r\n      var triangles = [],\r\n          result,\r\n          hit = false;\r\n      this.getCapsuleTriangles(_capsule, triangles);\r\n\r\n      for (let i = 0; i < triangles.length; i++) {\r\n        if (result = this.triangleCapsuleIntersect(_capsule, triangles[i])) {\r\n          hit = true;\r\n\r\n          _capsule.translate(result.normal.multiplyScalar(result.depth));\r\n        }\r\n      }\r\n\r\n      if (hit) {\r\n        var collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v1));\r\n\r\n        var depth = collisionVector.length();\r\n        return {\r\n          normal: collisionVector.normalize(),\r\n          depth: depth\r\n        };\r\n      }\r\n\r\n      return false;\r\n    },\r\n    rayIntersect: function (ray) {\r\n      if (ray.direction.length() === 0) return;\r\n      var triangles = [],\r\n          triangle,\r\n          position,\r\n          distance = 1e100,\r\n          result;\r\n      this.getRayTriangles(ray, triangles);\r\n\r\n      for (let i = 0; i < triangles.length; i++) {\r\n        result = ray.intersectTriangle(triangles[i].a, triangles[i].b, triangles[i].c, true, _v1);\r\n\r\n        if (result) {\r\n          var newdistance = result.sub(ray.origin).length();\r\n\r\n          if (distance > newdistance) {\r\n            position = result.clone().add(ray.origin);\r\n            distance = newdistance;\r\n            triangle = triangles[i];\r\n          }\r\n        }\r\n      }\r\n\r\n      return distance < 1e100 ? {\r\n        distance: distance,\r\n        triangle: triangle,\r\n        position: position\r\n      } : false;\r\n    },\r\n    fromGraphNode: function (group) {\r\n      group.traverse(obj => {\r\n        if (obj.type === 'Mesh') {\r\n          obj.updateMatrix();\r\n          obj.updateWorldMatrix();\r\n          var geometry,\r\n              isTemp = false;\r\n\r\n          if (obj.geometry.index) {\r\n            isTemp = true;\r\n            geometry = obj.geometry.clone().toNonIndexed();\r\n          } else {\r\n            geometry = obj.geometry;\r\n          }\r\n\r\n          var positions = geometry.attributes.position.array;\r\n          var transform = obj.matrixWorld;\r\n\r\n          for (let i = 0; i < positions.length; i += 9) {\r\n            var v1 = new Vector3(positions[i], positions[i + 1], positions[i + 2]);\r\n            var v2 = new Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);\r\n            var v3 = new Vector3(positions[i + 6], positions[i + 7], positions[i + 8]);\r\n            v1.applyMatrix4(transform);\r\n            v2.applyMatrix4(transform);\r\n            v3.applyMatrix4(transform);\r\n            this.addTriangle(new Triangle(v1, v2, v3));\r\n          }\r\n\r\n          if (isTemp) {\r\n            geometry.dispose();\r\n          }\r\n        }\r\n      });\r\n      this.build();\r\n      return this;\r\n    }\r\n  });\r\n  return Octree;\r\n}();\r\n\r\nexport { Octree };\r\n", "import { Color } from 'three';\r\n\r\nvar Lut = function (colormap, numberofcolors) {\r\n  this.lut = [];\r\n  this.setColorMap(colormap, numberofcolors);\r\n  return this;\r\n};\r\n\r\nLut.prototype = {\r\n  constructor: Lut,\r\n  lut: [],\r\n  map: [],\r\n  n: 256,\r\n  minV: 0,\r\n  maxV: 1,\r\n  set: function (value) {\r\n    if (value instanceof Lut) {\r\n      this.copy(value);\r\n    }\r\n\r\n    return this;\r\n  },\r\n  setMin: function (min) {\r\n    this.minV = min;\r\n    return this;\r\n  },\r\n  setMax: function (max) {\r\n    this.maxV = max;\r\n    return this;\r\n  },\r\n  setColorMap: function (colormap, numberofcolors) {\r\n    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;\r\n    this.n = numberofcolors || 32;\r\n    var step = 1.0 / this.n;\r\n    this.lut.length = 0;\r\n\r\n    for (let i = 0; i <= 1; i += step) {\r\n      for (let j = 0; j < this.map.length - 1; j++) {\r\n        if (i >= this.map[j][0] && i < this.map[j + 1][0]) {\r\n          var min = this.map[j][0];\r\n          var max = this.map[j + 1][0];\r\n          var minColor = new Color(this.map[j][1]);\r\n          var maxColor = new Color(this.map[j + 1][1]);\r\n          var color = minColor.lerp(maxColor, (i - min) / (max - min));\r\n          this.lut.push(color);\r\n        }\r\n      }\r\n    }\r\n\r\n    return this;\r\n  },\r\n  copy: function (lut) {\r\n    this.lut = lut.lut;\r\n    this.map = lut.map;\r\n    this.n = lut.n;\r\n    this.minV = lut.minV;\r\n    this.maxV = lut.maxV;\r\n    return this;\r\n  },\r\n  getColor: function (alpha) {\r\n    if (alpha <= this.minV) {\r\n      alpha = this.minV;\r\n    } else if (alpha >= this.maxV) {\r\n      alpha = this.maxV;\r\n    }\r\n\r\n    alpha = (alpha - this.minV) / (this.maxV - this.minV);\r\n    var colorPosition = Math.round(alpha * this.n);\r\n    colorPosition == this.n ? colorPosition -= 1 : colorPosition;\r\n    return this.lut[colorPosition];\r\n  },\r\n  addColorMap: function (colormapName, arrayOfColors) {\r\n    ColorMapKeywords[colormapName] = arrayOfColors;\r\n  },\r\n  createCanvas: function () {\r\n    var canvas = document.createElement('canvas');\r\n    canvas.width = 1;\r\n    canvas.height = this.n;\r\n    this.updateCanvas(canvas);\r\n    return canvas;\r\n  },\r\n  updateCanvas: function (canvas) {\r\n    var ctx = canvas.getContext('2d', {\r\n      alpha: false\r\n    });\r\n    var imageData = ctx.getImageData(0, 0, 1, this.n);\r\n    var data = imageData.data;\r\n    var k = 0;\r\n    var step = 1.0 / this.n;\r\n\r\n    for (let i = 1; i >= 0; i -= step) {\r\n      for (let j = this.map.length - 1; j >= 0; j--) {\r\n        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\r\n          var min = this.map[j - 1][0];\r\n          var max = this.map[j][0];\r\n          var minColor = new Color(this.map[j - 1][1]);\r\n          var maxColor = new Color(this.map[j][1]);\r\n          var color = minColor.lerp(maxColor, (i - min) / (max - min));\r\n          data[k * 4] = Math.round(color.r * 255);\r\n          data[k * 4 + 1] = Math.round(color.g * 255);\r\n          data[k * 4 + 2] = Math.round(color.b * 255);\r\n          data[k * 4 + 3] = 255;\r\n          k += 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    ctx.putImageData(imageData, 0, 0);\r\n    return canvas;\r\n  }\r\n};\r\nvar ColorMapKeywords = {\r\n  rainbow: [[0.0, 0x0000ff], [0.2, 0x00ffff], [0.5, 0x00ff00], [0.8, 0xffff00], [1.0, 0xff0000]],\r\n  cooltowarm: [[0.0, 0x3c4ec2], [0.2, 0x9bbcff], [0.5, 0xdcdcdc], [0.8, 0xf6a385], [1.0, 0xb40426]],\r\n  blackbody: [[0.0, 0x000000], [0.2, 0x780000], [0.5, 0xe63200], [0.8, 0xffff00], [1.0, 0xffffff]],\r\n  grayscale: [[0.0, 0x000000], [0.2, 0x404040], [0.5, 0x7f7f80], [0.8, 0xbfbfbf], [1.0, 0xffffff]]\r\n};\r\n\r\nexport { ColorMapKeywords, Lut };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { EventDispatcher, Vector3, TOUCH, Spherical, Vector2, Quaternion, PerspectiveCamera, OrthographicCamera, MOUSE } from 'three';\r\n\r\nlet STATE;\r\n\r\n(function (STATE) {\r\n  STATE[STATE[\"NONE\"] = -1] = \"NONE\";\r\n  STATE[STATE[\"ROTATE\"] = 0] = \"ROTATE\";\r\n  STATE[STATE[\"DOLLY\"] = 1] = \"DOLLY\";\r\n  STATE[STATE[\"PAN\"] = 2] = \"PAN\";\r\n  STATE[STATE[\"TOUCH_ROTATE\"] = 3] = \"TOUCH_ROTATE\";\r\n  STATE[STATE[\"TOUCH_PAN\"] = 4] = \"TOUCH_PAN\";\r\n  STATE[STATE[\"TOUCH_DOLLY_PAN\"] = 5] = \"TOUCH_DOLLY_PAN\";\r\n  STATE[STATE[\"TOUCH_DOLLY_ROTATE\"] = 6] = \"TOUCH_DOLLY_ROTATE\";\r\n})(STATE || (STATE = {}));\r\n\r\nclass CameraControls extends EventDispatcher {\r\n  /** Set to false to disable this control */\r\n\r\n  /** \"target\" sets the location of focus, where the object orbits around */\r\n\r\n  /** Set to true to enable trackball behavior */\r\n\r\n  /** How far you can dolly in ( PerspectiveCamera only ) */\r\n\r\n  /** How far you can dolly out ( PerspectiveCamera only ) */\r\n  // How far you can zoom in and out ( OrthographicCamera only )\r\n  // How far you can orbit vertically, upper and lower limits.\r\n  // Range is 0 to Math.PI radians.\r\n  // How far you can orbit horizontally, upper and lower limits.\r\n  // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\r\n  // radians\r\n  // radians\r\n  // Set to true to enable damping (inertia)\r\n  // If damping is enabled, you must call controls.update() in your animation loop\r\n\r\n  /**\r\n   * This option enables dollying in and out; property named as \"zoom\" for backwards compatibility\r\n   * Set to false to disable zooming\r\n   */\r\n\r\n  /** Set to false to disable rotating */\r\n\r\n  /** Set to false to disable panning */\r\n\r\n  /** if true, pan in screen-space */\r\n\r\n  /** pixels moved per arrow key push */\r\n\r\n  /**\r\n   * Set to true to automatically rotate around the target\r\n   * If auto-rotate is enabled, you must call controls.update() in your animation loop\r\n   * auto-rotate is not supported for trackball behavior\r\n   */\r\n  // 30 seconds per round when fps is 60\r\n\r\n  /** Set to false to disable use of the keys */\r\n\r\n  /** The four arrow keys */\r\n\r\n  /** Touch fingers */\r\n  // for reset\r\n  // current position in spherical coordinates\r\n  constructor(object, domElement) {\r\n    super();\r\n\r\n    _defineProperty(this, \"object\", void 0);\r\n\r\n    _defineProperty(this, \"domElement\", void 0);\r\n\r\n    _defineProperty(this, \"enabled\", true);\r\n\r\n    _defineProperty(this, \"target\", new Vector3());\r\n\r\n    _defineProperty(this, \"trackball\", false);\r\n\r\n    _defineProperty(this, \"minDistance\", 0);\r\n\r\n    _defineProperty(this, \"maxDistance\", Infinity);\r\n\r\n    _defineProperty(this, \"minZoom\", 0);\r\n\r\n    _defineProperty(this, \"maxZoom\", Infinity);\r\n\r\n    _defineProperty(this, \"minPolarAngle\", 0);\r\n\r\n    _defineProperty(this, \"maxPolarAngle\", Math.PI);\r\n\r\n    _defineProperty(this, \"minAzimuthAngle\", -Infinity);\r\n\r\n    _defineProperty(this, \"maxAzimuthAngle\", Infinity);\r\n\r\n    _defineProperty(this, \"enableDamping\", false);\r\n\r\n    _defineProperty(this, \"dampingFactor\", 0.05);\r\n\r\n    _defineProperty(this, \"enableZoom\", true);\r\n\r\n    _defineProperty(this, \"zoomSpeed\", 1.0);\r\n\r\n    _defineProperty(this, \"enableRotate\", true);\r\n\r\n    _defineProperty(this, \"rotateSpeed\", 1.0);\r\n\r\n    _defineProperty(this, \"enablePan\", true);\r\n\r\n    _defineProperty(this, \"panSpeed\", 1.0);\r\n\r\n    _defineProperty(this, \"screenSpacePanning\", false);\r\n\r\n    _defineProperty(this, \"keyPanSpeed\", 7.0);\r\n\r\n    _defineProperty(this, \"autoRotate\", false);\r\n\r\n    _defineProperty(this, \"autoRotateSpeed\", 2.0);\r\n\r\n    _defineProperty(this, \"enableKeys\", true);\r\n\r\n    _defineProperty(this, \"keys\", {\r\n      LEFT: 'ArrowLeft',\r\n      UP: 'ArrowUp',\r\n      RIGHT: 'ArrowRight',\r\n      BOTTOM: 'ArrowDown'\r\n    });\r\n\r\n    _defineProperty(this, \"mouseButtons\", void 0);\r\n\r\n    _defineProperty(this, \"touches\", {\r\n      ONE: TOUCH.ROTATE,\r\n      TWO: TOUCH.DOLLY_PAN\r\n    });\r\n\r\n    _defineProperty(this, \"target0\", void 0);\r\n\r\n    _defineProperty(this, \"position0\", void 0);\r\n\r\n    _defineProperty(this, \"quaternion0\", void 0);\r\n\r\n    _defineProperty(this, \"zoom0\", void 0);\r\n\r\n    _defineProperty(this, \"spherical\", new Spherical());\r\n\r\n    _defineProperty(this, \"sphericalDelta\", new Spherical());\r\n\r\n    _defineProperty(this, \"changeEvent\", {\r\n      type: 'change'\r\n    });\r\n\r\n    _defineProperty(this, \"startEvent\", {\r\n      type: 'start'\r\n    });\r\n\r\n    _defineProperty(this, \"endEvent\", {\r\n      type: 'end'\r\n    });\r\n\r\n    _defineProperty(this, \"state\", STATE.NONE);\r\n\r\n    _defineProperty(this, \"EPS\", 0.000001);\r\n\r\n    _defineProperty(this, \"scale\", 1);\r\n\r\n    _defineProperty(this, \"panOffset\", new Vector3());\r\n\r\n    _defineProperty(this, \"zoomChanged\", false);\r\n\r\n    _defineProperty(this, \"rotateStart\", new Vector2());\r\n\r\n    _defineProperty(this, \"rotateEnd\", new Vector2());\r\n\r\n    _defineProperty(this, \"rotateDelta\", new Vector2());\r\n\r\n    _defineProperty(this, \"panStart\", new Vector2());\r\n\r\n    _defineProperty(this, \"panEnd\", new Vector2());\r\n\r\n    _defineProperty(this, \"panDelta\", new Vector2());\r\n\r\n    _defineProperty(this, \"dollyStart\", new Vector2());\r\n\r\n    _defineProperty(this, \"dollyEnd\", new Vector2());\r\n\r\n    _defineProperty(this, \"dollyDelta\", new Vector2());\r\n\r\n    _defineProperty(this, \"offset\", new Vector3());\r\n\r\n    _defineProperty(this, \"lastPosition\", new Vector3());\r\n\r\n    _defineProperty(this, \"lastQuaternion\", new Quaternion());\r\n\r\n    _defineProperty(this, \"q\", new Quaternion());\r\n\r\n    _defineProperty(this, \"v\", new Vector3());\r\n\r\n    _defineProperty(this, \"vec\", new Vector3());\r\n\r\n    _defineProperty(this, \"quat\", void 0);\r\n\r\n    _defineProperty(this, \"quatInverse\", void 0);\r\n\r\n    _defineProperty(this, \"getPolarAngle\", () => this.spherical.phi);\r\n\r\n    _defineProperty(this, \"getAzimuthalAngle\", () => this.spherical.theta);\r\n\r\n    _defineProperty(this, \"saveState\", () => {\r\n      this.target0.copy(this.target);\r\n      this.position0.copy(this.object.position);\r\n      this.quaternion0.copy(this.object.quaternion);\r\n      this.zoom0 = this.object.zoom;\r\n    });\r\n\r\n    _defineProperty(this, \"reset\", () => {\r\n      this.target.copy(this.target0);\r\n      this.object.position.copy(this.position0);\r\n      this.object.quaternion.copy(this.quaternion0);\r\n      this.object.zoom = this.zoom0;\r\n      this.object.updateProjectionMatrix();\r\n      this.dispatchEvent(this.changeEvent);\r\n      this.update();\r\n      this.state = STATE.NONE;\r\n    });\r\n\r\n    _defineProperty(this, \"dispose\", () => {\r\n      this.domElement.removeEventListener('contextmenu', this.onContextMenu, false);\r\n      this.domElement.removeEventListener('mousedown', this.onMouseDown, false);\r\n      this.domElement.removeEventListener('wheel', this.onMouseWheel, false);\r\n      this.domElement.removeEventListener('touchstart', this.onTouchStart, false);\r\n      this.domElement.removeEventListener('touchend', this.onTouchEnd, false);\r\n      this.domElement.removeEventListener('touchmove', this.onTouchMove, false);\r\n      document.removeEventListener('mousemove', this.onMouseMove, false);\r\n      document.removeEventListener('mouseup', this.onMouseUp, false);\r\n      this.domElement.removeEventListener('keydown', this.onKeyDown, false); //this.dispatchEvent( { type: 'dispose' } ); // should this be added here?\r\n    });\r\n\r\n    _defineProperty(this, \"update\", () => {\r\n      const position = this.object.position;\r\n      this.offset.copy(position).sub(this.target);\r\n\r\n      if (this.trackball) {\r\n        // rotate around screen-space y-axis\r\n        if (this.sphericalDelta.theta) {\r\n          this.vec.set(0, 1, 0).applyQuaternion(this.object.quaternion);\r\n          const factor = this.enableDamping ? this.dampingFactor : 1;\r\n          this.q.setFromAxisAngle(this.vec, this.sphericalDelta.theta * factor);\r\n          this.object.quaternion.premultiply(this.q);\r\n          this.offset.applyQuaternion(this.q);\r\n        } // rotate around screen-space x-axis\r\n\r\n\r\n        if (this.sphericalDelta.phi) {\r\n          this.vec.set(1, 0, 0).applyQuaternion(this.object.quaternion);\r\n          const factor = this.enableDamping ? this.dampingFactor : 1;\r\n          this.q.setFromAxisAngle(this.vec, this.sphericalDelta.phi * factor);\r\n          this.object.quaternion.premultiply(this.q);\r\n          this.offset.applyQuaternion(this.q);\r\n        }\r\n\r\n        this.offset.multiplyScalar(this.scale);\r\n        this.offset.clampLength(this.minDistance, this.maxDistance);\r\n      } else {\r\n        // rotate offset to \"y-axis-is-up\" space\r\n        this.offset.applyQuaternion(this.quat);\r\n\r\n        if (this.autoRotate && this.state === STATE.NONE) {\r\n          this.rotateLeft(this.getAutoRotationAngle());\r\n        }\r\n\r\n        this.spherical.setFromVector3(this.offset);\r\n\r\n        if (this.enableDamping) {\r\n          this.spherical.theta += this.sphericalDelta.theta * this.dampingFactor;\r\n          this.spherical.phi += this.sphericalDelta.phi * this.dampingFactor;\r\n        } else {\r\n          this.spherical.theta += this.sphericalDelta.theta;\r\n          this.spherical.phi += this.sphericalDelta.phi;\r\n        } // restrict theta to be between desired limits\r\n\r\n\r\n        this.spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, this.spherical.theta)); // restrict phi to be between desired limits\r\n\r\n        this.spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this.spherical.phi));\r\n        this.spherical.makeSafe();\r\n        this.spherical.radius *= this.scale; // restrict radius to be between desired limits\r\n\r\n        this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));\r\n        this.offset.setFromSpherical(this.spherical); // rotate offset back to \"camera-up-vector-is-up\" space\r\n\r\n        this.offset.applyQuaternion(this.quatInverse);\r\n      } // move target to panned location\r\n\r\n\r\n      if (this.enableDamping === true) {\r\n        this.target.addScaledVector(this.panOffset, this.dampingFactor);\r\n      } else {\r\n        this.target.add(this.panOffset);\r\n      }\r\n\r\n      position.copy(this.target).add(this.offset);\r\n\r\n      if (this.trackball === false) {\r\n        this.object.lookAt(this.target);\r\n      }\r\n\r\n      if (this.enableDamping === true) {\r\n        this.sphericalDelta.theta *= 1 - this.dampingFactor;\r\n        this.sphericalDelta.phi *= 1 - this.dampingFactor;\r\n        this.panOffset.multiplyScalar(1 - this.dampingFactor);\r\n      } else {\r\n        this.sphericalDelta.set(0, 0, 0);\r\n        this.panOffset.set(0, 0, 0);\r\n      }\r\n\r\n      this.scale = 1; // update condition is:\r\n      // min(camera displacement, camera rotation in radians)^2 > EPS\r\n      // using small-angle approximation cos(x/2) = 1 - x^2 / 8\r\n\r\n      if (this.zoomChanged || this.lastPosition.distanceToSquared(this.object.position) > this.EPS || 8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > this.EPS) {\r\n        this.dispatchEvent(this.changeEvent);\r\n        this.lastPosition.copy(this.object.position);\r\n        this.lastQuaternion.copy(this.object.quaternion);\r\n        this.zoomChanged = false;\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    });\r\n\r\n    _defineProperty(this, \"getAutoRotationAngle\", () => 2 * Math.PI / 60 / 60 * this.autoRotateSpeed);\r\n\r\n    _defineProperty(this, \"getZoomScale\", () => Math.pow(0.95, this.zoomSpeed));\r\n\r\n    _defineProperty(this, \"rotateLeft\", angle => {\r\n      this.sphericalDelta.theta -= angle;\r\n    });\r\n\r\n    _defineProperty(this, \"rotateUp\", angle => {\r\n      this.sphericalDelta.phi -= angle;\r\n    });\r\n\r\n    _defineProperty(this, \"panLeft\", (distance, objectMatrix) => {\r\n      this.v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\r\n\r\n      this.v.multiplyScalar(-distance);\r\n      this.panOffset.add(this.v);\r\n    });\r\n\r\n    _defineProperty(this, \"panUp\", (distance, objectMatrix) => {\r\n      if (this.screenSpacePanning === true) {\r\n        this.v.setFromMatrixColumn(objectMatrix, 1);\r\n      } else {\r\n        this.v.setFromMatrixColumn(objectMatrix, 0);\r\n        this.v.crossVectors(this.object.up, this.v);\r\n      }\r\n\r\n      this.v.multiplyScalar(distance);\r\n      this.panOffset.add(this.v);\r\n    });\r\n\r\n    _defineProperty(this, \"pan\", (deltaX, deltaY) => {\r\n      const element = this.domElement;\r\n\r\n      if (this.object instanceof PerspectiveCamera) {\r\n        // perspective\r\n        const position = this.object.position;\r\n        this.offset.copy(position).sub(this.target);\r\n        let targetDistance = this.offset.length(); // half of the fov is center to top of screen\r\n\r\n        targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180.0); // we use only clientHeight here so aspect ratio does not distort speed\r\n\r\n        this.panLeft(2 * deltaX * targetDistance / element.clientHeight, this.object.matrix);\r\n        this.panUp(2 * deltaY * targetDistance / element.clientHeight, this.object.matrix);\r\n      } else if (this.object.isOrthographicCamera) {\r\n        // orthographic\r\n        this.panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element.clientWidth, this.object.matrix);\r\n        this.panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element.clientHeight, this.object.matrix);\r\n      } else {\r\n        // camera neither orthographic nor perspective\r\n        console.warn('WARNING: CameraControls.js encountered an unknown camera type - pan disabled.');\r\n        this.enablePan = false;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"dollyIn\", dollyScale => {\r\n      // TODO: replace w/.isPerspectiveCamera ?\r\n      if (this.object instanceof PerspectiveCamera) {\r\n        this.scale /= dollyScale; // TODO: replace w/.isOrthographicCamera ?\r\n      } else if (this.object instanceof OrthographicCamera) {\r\n        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));\r\n        this.object.updateProjectionMatrix();\r\n        this.zoomChanged = true;\r\n      } else {\r\n        console.warn('WARNING: CameraControls.js encountered an unknown camera type - dolly/zoom disabled.');\r\n        this.enableZoom = false;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"dollyOut\", dollyScale => {\r\n      // TODO: replace w/.isPerspectiveCamera ?\r\n      if (this.object instanceof PerspectiveCamera) {\r\n        this.scale *= dollyScale; // TODO: replace w/.isOrthographicCamera ?\r\n      } else if (this.object instanceof OrthographicCamera) {\r\n        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));\r\n        this.object.updateProjectionMatrix();\r\n        this.zoomChanged = true;\r\n      } else {\r\n        console.warn('WARNING: CameraControls.js encountered an unknown camera type - dolly/zoom disabled.');\r\n        this.enableZoom = false;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"handleMouseDownRotate\", event => {\r\n      this.rotateStart.set(event.clientX, event.clientY);\r\n    });\r\n\r\n    _defineProperty(this, \"handleMouseDownDolly\", event => {\r\n      this.dollyStart.set(event.clientX, event.clientY);\r\n    });\r\n\r\n    _defineProperty(this, \"handleMouseDownPan\", event => {\r\n      this.panStart.set(event.clientX, event.clientY);\r\n    });\r\n\r\n    _defineProperty(this, \"handleMouseMoveRotate\", event => {\r\n      this.rotateEnd.set(event.clientX, event.clientY);\r\n      this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);\r\n      const element = this.domElement;\r\n      this.rotateLeft(2 * Math.PI * this.rotateDelta.x / element.clientHeight); // yes, height\r\n\r\n      this.rotateUp(2 * Math.PI * this.rotateDelta.y / element.clientHeight);\r\n      this.rotateStart.copy(this.rotateEnd);\r\n      this.update();\r\n    });\r\n\r\n    _defineProperty(this, \"handleMouseMoveDolly\", event => {\r\n      this.dollyEnd.set(event.clientX, event.clientY);\r\n      this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart);\r\n\r\n      if (this.dollyDelta.y > 0) {\r\n        this.dollyIn(this.getZoomScale());\r\n      } else if (this.dollyDelta.y < 0) {\r\n        this.dollyOut(this.getZoomScale());\r\n      }\r\n\r\n      this.dollyStart.copy(this.dollyEnd);\r\n      this.update();\r\n    });\r\n\r\n    _defineProperty(this, \"handleMouseMovePan\", event => {\r\n      this.panEnd.set(event.clientX, event.clientY);\r\n      this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed);\r\n      this.pan(this.panDelta.x, this.panDelta.y);\r\n      this.panStart.copy(this.panEnd);\r\n      this.update();\r\n    });\r\n\r\n    _defineProperty(this, \"handleMouseWheel\", event => {\r\n      if (event.deltaY < 0) {\r\n        this.dollyOut(this.getZoomScale());\r\n      } else if (event.deltaY > 0) {\r\n        this.dollyIn(this.getZoomScale());\r\n      }\r\n\r\n      this.update();\r\n    });\r\n\r\n    _defineProperty(this, \"handleKeyDown\", event => {\r\n      let needsUpdate = false;\r\n\r\n      switch (event.code) {\r\n        case this.keys.UP:\r\n          this.pan(0, this.keyPanSpeed);\r\n          needsUpdate = true;\r\n          break;\r\n\r\n        case this.keys.BOTTOM:\r\n          this.pan(0, -this.keyPanSpeed);\r\n          needsUpdate = true;\r\n          break;\r\n\r\n        case this.keys.LEFT:\r\n          this.pan(this.keyPanSpeed, 0);\r\n          needsUpdate = true;\r\n          break;\r\n\r\n        case this.keys.RIGHT:\r\n          this.pan(-this.keyPanSpeed, 0);\r\n          needsUpdate = true;\r\n          break;\r\n      }\r\n\r\n      if (needsUpdate) {\r\n        // prevent the browser from scrolling on cursor keys\r\n        event.preventDefault();\r\n        this.update();\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"handleTouchStartRotate\", event => {\r\n      if (event.touches.length == 1) {\r\n        this.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\r\n      } else {\r\n        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\r\n        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\r\n        this.rotateStart.set(x, y);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"handleTouchStartPan\", event => {\r\n      if (event.touches.length == 1) {\r\n        this.panStart.set(event.touches[0].pageX, event.touches[0].pageY);\r\n      } else {\r\n        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\r\n        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\r\n        this.panStart.set(x, y);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"handleTouchStartDolly\", event => {\r\n      const dx = event.touches[0].pageX - event.touches[1].pageX;\r\n      const dy = event.touches[0].pageY - event.touches[1].pageY;\r\n      const distance = Math.sqrt(dx * dx + dy * dy);\r\n      this.dollyStart.set(0, distance);\r\n    });\r\n\r\n    _defineProperty(this, \"handleTouchStartDollyPan\", event => {\r\n      if (this.enableZoom) this.handleTouchStartDolly(event);\r\n      if (this.enablePan) this.handleTouchStartPan(event);\r\n    });\r\n\r\n    _defineProperty(this, \"handleTouchStartDollyRotate\", event => {\r\n      if (this.enableZoom) this.handleTouchStartDolly(event);\r\n      if (this.enableRotate) this.handleTouchStartRotate(event);\r\n    });\r\n\r\n    _defineProperty(this, \"handleTouchMoveRotate\", event => {\r\n      if (event.touches.length == 1) {\r\n        this.rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\r\n      } else {\r\n        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\r\n        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\r\n        this.rotateEnd.set(x, y);\r\n      }\r\n\r\n      this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);\r\n      const element = this.domElement;\r\n      this.rotateLeft(2 * Math.PI * this.rotateDelta.x / element.clientHeight); // yes, height\r\n\r\n      this.rotateUp(2 * Math.PI * this.rotateDelta.y / element.clientHeight);\r\n      this.rotateStart.copy(this.rotateEnd);\r\n    });\r\n\r\n    _defineProperty(this, \"handleTouchMovePan\", event => {\r\n      if (event.touches.length == 1) {\r\n        this.panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\r\n      } else {\r\n        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\r\n        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\r\n        this.panEnd.set(x, y);\r\n      }\r\n\r\n      this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed);\r\n      this.pan(this.panDelta.x, this.panDelta.y);\r\n      this.panStart.copy(this.panEnd);\r\n    });\r\n\r\n    _defineProperty(this, \"handleTouchMoveDolly\", event => {\r\n      const dx = event.touches[0].pageX - event.touches[1].pageX;\r\n      const dy = event.touches[0].pageY - event.touches[1].pageY;\r\n      const distance = Math.sqrt(dx * dx + dy * dy);\r\n      this.dollyEnd.set(0, distance);\r\n      this.dollyDelta.set(0, Math.pow(this.dollyEnd.y / this.dollyStart.y, this.zoomSpeed));\r\n      this.dollyIn(this.dollyDelta.y);\r\n      this.dollyStart.copy(this.dollyEnd);\r\n    });\r\n\r\n    _defineProperty(this, \"handleTouchMoveDollyPan\", event => {\r\n      if (this.enableZoom) this.handleTouchMoveDolly(event);\r\n      if (this.enablePan) this.handleTouchMovePan(event);\r\n    });\r\n\r\n    _defineProperty(this, \"handleTouchMoveDollyRotate\", event => {\r\n      if (this.enableZoom) this.handleTouchMoveDolly(event);\r\n      if (this.enableRotate) this.handleTouchMoveRotate(event);\r\n    });\r\n\r\n    _defineProperty(this, \"onMouseDown\", event => {\r\n      if (this.enabled === false) return; // Prevent the browser from scrolling.\r\n\r\n      event.preventDefault(); // Manually set the focus since calling preventDefault above\r\n      // prevents the browser from setting it automatically.\r\n\r\n      this.domElement.focus ? this.domElement.focus() : window.focus();\r\n      let mouseAction;\r\n\r\n      switch (event.button) {\r\n        case 0:\r\n          mouseAction = this.mouseButtons.LEFT;\r\n          break;\r\n\r\n        case 1:\r\n          mouseAction = this.mouseButtons.MIDDLE;\r\n          break;\r\n\r\n        case 2:\r\n          mouseAction = this.mouseButtons.RIGHT;\r\n          break;\r\n\r\n        default:\r\n          mouseAction = -1;\r\n      }\r\n\r\n      switch (mouseAction) {\r\n        case MOUSE.DOLLY:\r\n          if (this.enableZoom === false) return;\r\n          this.handleMouseDownDolly(event);\r\n          this.state = STATE.DOLLY;\r\n          break;\r\n\r\n        case MOUSE.ROTATE:\r\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\r\n            if (this.enablePan === false) return;\r\n            this.handleMouseDownPan(event);\r\n            this.state = STATE.PAN;\r\n          } else {\r\n            if (this.enableRotate === false) return;\r\n            this.handleMouseDownRotate(event);\r\n            this.state = STATE.ROTATE;\r\n          }\r\n\r\n          break;\r\n\r\n        case MOUSE.PAN:\r\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\r\n            if (this.enableRotate === false) return;\r\n            this.handleMouseDownRotate(event);\r\n            this.state = STATE.ROTATE;\r\n          } else {\r\n            if (this.enablePan === false) return;\r\n            this.handleMouseDownPan(event);\r\n            this.state = STATE.PAN;\r\n          }\r\n\r\n          break;\r\n\r\n        default:\r\n          this.state = STATE.NONE;\r\n      }\r\n\r\n      if (this.state !== STATE.NONE) {\r\n        document.addEventListener('mousemove', this.onMouseMove, false);\r\n        document.addEventListener('mouseup', this.onMouseUp, false);\r\n        this.dispatchEvent(this.startEvent);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onMouseMove\", event => {\r\n      if (this.enabled === false) return;\r\n      event.preventDefault();\r\n\r\n      switch (this.state) {\r\n        case STATE.ROTATE:\r\n          if (this.enableRotate === false) return;\r\n          this.handleMouseMoveRotate(event);\r\n          break;\r\n\r\n        case STATE.DOLLY:\r\n          if (this.enableZoom === false) return;\r\n          this.handleMouseMoveDolly(event);\r\n          break;\r\n\r\n        case STATE.PAN:\r\n          if (this.enablePan === false) return;\r\n          this.handleMouseMovePan(event);\r\n          break;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onMouseUp\", () => {\r\n      if (this.enabled === false) return; // this.handleMouseUp()\r\n\r\n      document.removeEventListener('mousemove', this.onMouseMove, false);\r\n      document.removeEventListener('mouseup', this.onMouseUp, false);\r\n      this.dispatchEvent(this.endEvent);\r\n      this.state = STATE.NONE;\r\n    });\r\n\r\n    _defineProperty(this, \"onMouseWheel\", event => {\r\n      if (this.enabled === false || this.enableZoom === false || this.state !== STATE.NONE && this.state !== STATE.ROTATE) {\r\n        return;\r\n      }\r\n\r\n      event.preventDefault();\r\n      this.dispatchEvent(this.startEvent);\r\n      this.handleMouseWheel(event);\r\n      this.dispatchEvent(this.endEvent);\r\n    });\r\n\r\n    _defineProperty(this, \"onKeyDown\", event => {\r\n      if (this.enabled === false || this.enableKeys === false || this.enablePan === false) return;\r\n      this.handleKeyDown(event);\r\n    });\r\n\r\n    _defineProperty(this, \"onTouchStart\", event => {\r\n      if (this.enabled === false) return;\r\n      event.preventDefault();\r\n\r\n      switch (event.touches.length) {\r\n        case 1:\r\n          switch (this.touches.ONE) {\r\n            case TOUCH.ROTATE:\r\n              if (this.enableRotate === false) return;\r\n              this.handleTouchStartRotate(event);\r\n              this.state = STATE.TOUCH_ROTATE;\r\n              break;\r\n\r\n            case TOUCH.PAN:\r\n              if (this.enablePan === false) return;\r\n              this.handleTouchStartPan(event);\r\n              this.state = STATE.TOUCH_PAN;\r\n              break;\r\n\r\n            default:\r\n              this.state = STATE.NONE;\r\n          }\r\n\r\n          break;\r\n\r\n        case 2:\r\n          switch (this.touches.TWO) {\r\n            case TOUCH.DOLLY_PAN:\r\n              if (this.enableZoom === false && this.enablePan === false) return;\r\n              this.handleTouchStartDollyPan(event);\r\n              this.state = STATE.TOUCH_DOLLY_PAN;\r\n              break;\r\n\r\n            case TOUCH.DOLLY_ROTATE:\r\n              if (this.enableZoom === false && this.enableRotate === false) return;\r\n              this.handleTouchStartDollyRotate(event);\r\n              this.state = STATE.TOUCH_DOLLY_ROTATE;\r\n              break;\r\n\r\n            default:\r\n              this.state = STATE.NONE;\r\n          }\r\n\r\n          break;\r\n\r\n        default:\r\n          this.state = STATE.NONE;\r\n      }\r\n\r\n      if (this.state !== STATE.NONE) {\r\n        this.dispatchEvent(this.startEvent);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onTouchMove\", event => {\r\n      if (this.enabled === false) return;\r\n      event.preventDefault();\r\n\r\n      switch (this.state) {\r\n        case STATE.TOUCH_ROTATE:\r\n          if (this.enableRotate === false) return;\r\n          this.handleTouchMoveRotate(event);\r\n          this.update();\r\n          break;\r\n\r\n        case STATE.TOUCH_PAN:\r\n          if (this.enablePan === false) return;\r\n          this.handleTouchMovePan(event);\r\n          this.update();\r\n          break;\r\n\r\n        case STATE.TOUCH_DOLLY_PAN:\r\n          if (this.enableZoom === false && this.enablePan === false) return;\r\n          this.handleTouchMoveDollyPan(event);\r\n          this.update();\r\n          break;\r\n\r\n        case STATE.TOUCH_DOLLY_ROTATE:\r\n          if (this.enableZoom === false && this.enableRotate === false) return;\r\n          this.handleTouchMoveDollyRotate(event);\r\n          this.update();\r\n          break;\r\n\r\n        default:\r\n          this.state = STATE.NONE;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onTouchEnd\", () => {\r\n      if (this.enabled === false) return; // this.handleTouchEnd()\r\n\r\n      this.dispatchEvent(this.endEvent);\r\n      this.state = STATE.NONE;\r\n    });\r\n\r\n    _defineProperty(this, \"onContextMenu\", event => {\r\n      if (this.enabled === false) return;\r\n      event.preventDefault();\r\n    });\r\n\r\n    if (domElement === undefined) {\r\n      console.warn('THREE.CameraControls: The second parameter \"domElement\" is now mandatory.');\r\n    }\r\n\r\n    if (domElement instanceof Document) {\r\n      console.error('THREE.CameraControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\r\n    }\r\n\r\n    this.object = object;\r\n    this.domElement = domElement;\r\n    this.mouseButtons = {\r\n      LEFT: MOUSE.ROTATE,\r\n      MIDDLE: MOUSE.DOLLY,\r\n      RIGHT: MOUSE.PAN\r\n    }; // for reset\r\n\r\n    this.target0 = this.target.clone();\r\n    this.position0 = this.object.position.clone();\r\n    this.quaternion0 = this.object.quaternion.clone();\r\n    this.zoom0 = this.object.zoom; //\r\n    // internals\r\n    //\r\n    // so camera.up is the orbit axis\r\n\r\n    this.quat = new Quaternion().setFromUnitVectors(this.object.up, new Vector3(0, 1, 0));\r\n    this.quatInverse = this.quat.clone().invert();\r\n    this.lastPosition = new Vector3();\r\n    this.lastQuaternion = new Quaternion();\r\n    this.domElement.addEventListener('contextmenu', this.onContextMenu, false);\r\n    this.domElement.addEventListener('mousedown', this.onMouseDown, false);\r\n    this.domElement.addEventListener('wheel', this.onMouseWheel, false);\r\n    this.domElement.addEventListener('touchstart', this.onTouchStart, false);\r\n    this.domElement.addEventListener('touchend', this.onTouchEnd, false);\r\n    this.domElement.addEventListener('touchmove', this.onTouchMove, false);\r\n    this.domElement.addEventListener('keydown', this.onKeyDown, false); // make sure element can receive keys.\r\n\r\n    if (this.domElement.tabIndex === -1) {\r\n      this.domElement.tabIndex = 0;\r\n    } // force an update at start\r\n\r\n\r\n    this.object.lookAt(this.target);\r\n    this.update();\r\n    this.saveState();\r\n  }\r\n\r\n  handleMouseUp() {// no-op\r\n  }\r\n\r\n  handleTouchEnd() {// no-op\r\n  } //\r\n  // event handlers - FSM: listen for events and reset state\r\n  //\r\n\r\n\r\n}\r\n/**\r\n * OrbitControls maintains the \"up\" direction, camera.up (+Y by default).\r\n *\r\n * @event Orbit - left mouse / touch: one-finger move\r\n * @event Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\r\n * @event Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\r\n */\r\n\r\n\r\nclass OrbitControlsExp extends CameraControls {\r\n  constructor(object, domElement) {\r\n    super(object, domElement);\r\n\r\n    _defineProperty(this, \"mouseButtons\", void 0);\r\n\r\n    _defineProperty(this, \"touches\", void 0);\r\n\r\n    this.mouseButtons = {\r\n      LEFT: MOUSE.ROTATE,\r\n      RIGHT: MOUSE.PAN\r\n    };\r\n    this.touches = {\r\n      ONE: TOUCH.ROTATE,\r\n      TWO: TOUCH.DOLLY_PAN\r\n    };\r\n  }\r\n\r\n}\r\n/**\r\n * MapControls maintains the \"up\" direction, camera.up (+Y by default)\r\n *\r\n * @event Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\r\n * @event Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\r\n * @event Pan - left mouse, or left right + ctrl/meta/shiftKey, or arrow keys / touch: one-finger move\r\n */\r\n\r\n\r\nclass MapControlsExp extends CameraControls {\r\n  constructor(object, domElement) {\r\n    super(object, domElement);\r\n\r\n    _defineProperty(this, \"mouseButtons\", void 0);\r\n\r\n    _defineProperty(this, \"touches\", void 0);\r\n\r\n    this.mouseButtons = {\r\n      LEFT: MOUSE.PAN,\r\n      RIGHT: MOUSE.ROTATE\r\n    };\r\n    this.touches = {\r\n      ONE: TOUCH.PAN,\r\n      TWO: TOUCH.DOLLY_ROTATE\r\n    };\r\n  }\r\n\r\n}\r\n/**\r\n * TrackballControls allows the camera to rotate over the polls and does not maintain camera.up\r\n *\r\n * @event Orbit - left mouse / touch: one-finger move\r\n * @event Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\r\n * @event Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\r\n */\r\n\r\n\r\nclass TrackballControlsExp extends CameraControls {\r\n  constructor(object, domElement) {\r\n    super(object, domElement);\r\n\r\n    _defineProperty(this, \"trackball\", void 0);\r\n\r\n    _defineProperty(this, \"screenSpacePanning\", void 0);\r\n\r\n    _defineProperty(this, \"autoRotate\", void 0);\r\n\r\n    _defineProperty(this, \"mouseButtons\", void 0);\r\n\r\n    _defineProperty(this, \"touches\", void 0);\r\n\r\n    this.trackball = true;\r\n    this.screenSpacePanning = true;\r\n    this.autoRotate = false;\r\n    this.mouseButtons = {\r\n      LEFT: MOUSE.ROTATE,\r\n      RIGHT: MOUSE.PAN\r\n    };\r\n    this.touches = {\r\n      ONE: TOUCH.ROTATE,\r\n      TWO: TOUCH.DOLLY_PAN\r\n    };\r\n  }\r\n\r\n}\r\n\r\nexport { CameraControls, MapControlsExp, OrbitControlsExp, STATE, TrackballControlsExp };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { Vector3, EventDispatcher, Spherical, MathUtils } from 'three';\r\n\r\nconst targetPosition = new Vector3();\r\nclass FirstPersonControls extends EventDispatcher {\r\n  // internals\r\n  constructor(object, _domElement) {\r\n    super();\r\n\r\n    _defineProperty(this, \"object\", void 0);\r\n\r\n    _defineProperty(this, \"domElement\", void 0);\r\n\r\n    _defineProperty(this, \"enabled\", true);\r\n\r\n    _defineProperty(this, \"movementSpeed\", 1.0);\r\n\r\n    _defineProperty(this, \"lookSpeed\", 0.005);\r\n\r\n    _defineProperty(this, \"lookVertical\", true);\r\n\r\n    _defineProperty(this, \"autoForward\", false);\r\n\r\n    _defineProperty(this, \"activeLook\", true);\r\n\r\n    _defineProperty(this, \"heightSpeed\", false);\r\n\r\n    _defineProperty(this, \"heightCoef\", 1.0);\r\n\r\n    _defineProperty(this, \"heightMin\", 0.0);\r\n\r\n    _defineProperty(this, \"heightMax\", 1.0);\r\n\r\n    _defineProperty(this, \"constrainVertical\", false);\r\n\r\n    _defineProperty(this, \"verticalMin\", 0);\r\n\r\n    _defineProperty(this, \"verticalMax\", Math.PI);\r\n\r\n    _defineProperty(this, \"mouseDragOn\", false);\r\n\r\n    _defineProperty(this, \"autoSpeedFactor\", 0.0);\r\n\r\n    _defineProperty(this, \"mouseX\", 0);\r\n\r\n    _defineProperty(this, \"mouseY\", 0);\r\n\r\n    _defineProperty(this, \"moveForward\", false);\r\n\r\n    _defineProperty(this, \"moveBackward\", false);\r\n\r\n    _defineProperty(this, \"moveLeft\", false);\r\n\r\n    _defineProperty(this, \"moveRight\", false);\r\n\r\n    _defineProperty(this, \"moveUp\", false);\r\n\r\n    _defineProperty(this, \"moveDown\", false);\r\n\r\n    _defineProperty(this, \"viewHalfX\", 0);\r\n\r\n    _defineProperty(this, \"viewHalfY\", 0);\r\n\r\n    _defineProperty(this, \"lat\", 0);\r\n\r\n    _defineProperty(this, \"lon\", 0);\r\n\r\n    _defineProperty(this, \"lookDirection\", new Vector3());\r\n\r\n    _defineProperty(this, \"spherical\", new Spherical());\r\n\r\n    _defineProperty(this, \"target\", new Vector3());\r\n\r\n    _defineProperty(this, \"connect\", domElement => {\r\n      domElement.setAttribute('tabindex', '-1');\r\n      domElement.style.touchAction = 'none';\r\n      domElement.addEventListener('contextmenu', this.contextmenu);\r\n      domElement.addEventListener('mousemove', this.onMouseMove);\r\n      domElement.addEventListener('mousedown', this.onMouseDown);\r\n      domElement.addEventListener('mouseup', this.onMouseUp);\r\n      this.domElement = domElement;\r\n      window.addEventListener('keydown', this.onKeyDown);\r\n      window.addEventListener('keyup', this.onKeyUp);\r\n      this.handleResize();\r\n    });\r\n\r\n    _defineProperty(this, \"dispose\", () => {\r\n      var _this$domElement, _this$domElement2, _this$domElement3, _this$domElement4;\r\n\r\n      (_this$domElement = this.domElement) === null || _this$domElement === void 0 ? void 0 : _this$domElement.removeEventListener('contextmenu', this.contextmenu);\r\n      (_this$domElement2 = this.domElement) === null || _this$domElement2 === void 0 ? void 0 : _this$domElement2.removeEventListener('mousedown', this.onMouseDown);\r\n      (_this$domElement3 = this.domElement) === null || _this$domElement3 === void 0 ? void 0 : _this$domElement3.removeEventListener('mousemove', this.onMouseMove);\r\n      (_this$domElement4 = this.domElement) === null || _this$domElement4 === void 0 ? void 0 : _this$domElement4.removeEventListener('mouseup', this.onMouseUp);\r\n      window.removeEventListener('keydown', this.onKeyDown);\r\n      window.removeEventListener('keyup', this.onKeyUp);\r\n    });\r\n\r\n    _defineProperty(this, \"handleResize\", () => {\r\n      if (this.domElement) {\r\n        this.viewHalfX = this.domElement.offsetWidth / 2;\r\n        this.viewHalfY = this.domElement.offsetHeight / 2;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onMouseDown\", event => {\r\n      var _this$domElement5;\r\n\r\n      (_this$domElement5 = this.domElement) === null || _this$domElement5 === void 0 ? void 0 : _this$domElement5.focus();\r\n\r\n      if (this.activeLook) {\r\n        switch (event.button) {\r\n          case 0:\r\n            this.moveForward = true;\r\n            break;\r\n\r\n          case 2:\r\n            this.moveBackward = true;\r\n            break;\r\n        }\r\n      }\r\n\r\n      this.mouseDragOn = true;\r\n    });\r\n\r\n    _defineProperty(this, \"onMouseUp\", event => {\r\n      if (this.activeLook) {\r\n        switch (event.button) {\r\n          case 0:\r\n            this.moveForward = false;\r\n            break;\r\n\r\n          case 2:\r\n            this.moveBackward = false;\r\n            break;\r\n        }\r\n      }\r\n\r\n      this.mouseDragOn = false;\r\n    });\r\n\r\n    _defineProperty(this, \"onMouseMove\", event => {\r\n      if (this.domElement) {\r\n        this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;\r\n        this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onKeyDown\", event => {\r\n      switch (event.code) {\r\n        case 'ArrowUp':\r\n        case 'KeyW':\r\n          this.moveForward = true;\r\n          break;\r\n\r\n        case 'ArrowLeft':\r\n        case 'KeyA':\r\n          this.moveLeft = true;\r\n          break;\r\n\r\n        case 'ArrowDown':\r\n        case 'KeyS':\r\n          this.moveBackward = true;\r\n          break;\r\n\r\n        case 'ArrowRight':\r\n        case 'KeyD':\r\n          this.moveRight = true;\r\n          break;\r\n\r\n        case 'KeyR':\r\n          this.moveUp = true;\r\n          break;\r\n\r\n        case 'KeyF':\r\n          this.moveDown = true;\r\n          break;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onKeyUp\", event => {\r\n      switch (event.code) {\r\n        case 'ArrowUp':\r\n        case 'KeyW':\r\n          this.moveForward = false;\r\n          break;\r\n\r\n        case 'ArrowLeft':\r\n        case 'KeyA':\r\n          this.moveLeft = false;\r\n          break;\r\n\r\n        case 'ArrowDown':\r\n        case 'KeyS':\r\n          this.moveBackward = false;\r\n          break;\r\n\r\n        case 'ArrowRight':\r\n        case 'KeyD':\r\n          this.moveRight = false;\r\n          break;\r\n\r\n        case 'KeyR':\r\n          this.moveUp = false;\r\n          break;\r\n\r\n        case 'KeyF':\r\n          this.moveDown = false;\r\n          break;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"lookAt\", (x, y, z) => {\r\n      if (x instanceof Vector3) {\r\n        this.target.copy(x);\r\n      } else if (y && z) {\r\n        this.target.set(x, y, z);\r\n      }\r\n\r\n      this.object.lookAt(this.target);\r\n      this.setOrientation();\r\n      return this;\r\n    });\r\n\r\n    _defineProperty(this, \"update\", delta => {\r\n      if (!this.enabled) return;\r\n\r\n      if (this.heightSpeed) {\r\n        const y = MathUtils.clamp(this.object.position.y, this.heightMin, this.heightMax);\r\n        const heightDelta = y - this.heightMin;\r\n        this.autoSpeedFactor = delta * (heightDelta * this.heightCoef);\r\n      } else {\r\n        this.autoSpeedFactor = 0.0;\r\n      }\r\n\r\n      const actualMoveSpeed = delta * this.movementSpeed;\r\n\r\n      if (this.moveForward || this.autoForward && !this.moveBackward) {\r\n        this.object.translateZ(-(actualMoveSpeed + this.autoSpeedFactor));\r\n      }\r\n\r\n      if (this.moveBackward) this.object.translateZ(actualMoveSpeed);\r\n      if (this.moveLeft) this.object.translateX(-actualMoveSpeed);\r\n      if (this.moveRight) this.object.translateX(actualMoveSpeed);\r\n      if (this.moveUp) this.object.translateY(actualMoveSpeed);\r\n      if (this.moveDown) this.object.translateY(-actualMoveSpeed);\r\n      let actualLookSpeed = delta * this.lookSpeed;\r\n\r\n      if (!this.activeLook) {\r\n        actualLookSpeed = 0;\r\n      }\r\n\r\n      let verticalLookRatio = 1;\r\n\r\n      if (this.constrainVertical) {\r\n        verticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin);\r\n      }\r\n\r\n      this.lon -= this.mouseX * actualLookSpeed;\r\n      if (this.lookVertical) this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;\r\n      this.lat = Math.max(-85, Math.min(85, this.lat));\r\n      let phi = MathUtils.degToRad(90 - this.lat);\r\n      const theta = MathUtils.degToRad(this.lon);\r\n\r\n      if (this.constrainVertical) {\r\n        phi = MathUtils.mapLinear(phi, 0, Math.PI, this.verticalMin, this.verticalMax);\r\n      }\r\n\r\n      const position = this.object.position;\r\n      targetPosition.setFromSphericalCoords(1, phi, theta).add(position);\r\n      this.object.lookAt(targetPosition);\r\n    });\r\n\r\n    _defineProperty(this, \"contextmenu\", event => event.preventDefault());\r\n\r\n    _defineProperty(this, \"setOrientation\", () => {\r\n      this.lookDirection.set(0, 0, -1).applyQuaternion(this.object.quaternion);\r\n      this.spherical.setFromVector3(this.lookDirection);\r\n      this.lat = 90 - MathUtils.radToDeg(this.spherical.phi);\r\n      this.lon = MathUtils.radToDeg(this.spherical.theta);\r\n    });\r\n\r\n    this.object = object;\r\n    this.domElement = _domElement;\r\n    this.setOrientation();\r\n    if (_domElement) this.connect(_domElement);\r\n  }\r\n\r\n}\r\n\r\nexport { FirstPersonControls };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { Euler, Vector3, EventDispatcher } from 'three';\r\n\r\nconst _euler = new Euler(0, 0, 0, 'YXZ');\r\n\r\nconst _vector = new Vector3();\r\n\r\nconst _changeEvent = {\r\n  type: 'change'\r\n};\r\nconst _lockEvent = {\r\n  type: 'lock'\r\n};\r\nconst _unlockEvent = {\r\n  type: 'unlock'\r\n};\r\n\r\nconst _PI_2 = Math.PI / 2;\r\n\r\nclass PointerLockControls extends EventDispatcher {\r\n  constructor(camera, _domElement) {\r\n    super();\r\n\r\n    _defineProperty(this, \"camera\", void 0);\r\n\r\n    _defineProperty(this, \"domElement\", void 0);\r\n\r\n    _defineProperty(this, \"isLocked\", void 0);\r\n\r\n    _defineProperty(this, \"minPolarAngle\", void 0);\r\n\r\n    _defineProperty(this, \"maxPolarAngle\", void 0);\r\n\r\n    _defineProperty(this, \"pointerSpeed\", void 0);\r\n\r\n    _defineProperty(this, \"onMouseMove\", event => {\r\n      if (!this.domElement || this.isLocked === false) return;\r\n      const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;\r\n      const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;\r\n\r\n      _euler.setFromQuaternion(this.camera.quaternion);\r\n\r\n      _euler.y -= movementX * 0.002 * this.pointerSpeed;\r\n      _euler.x -= movementY * 0.002 * this.pointerSpeed;\r\n      _euler.x = Math.max(_PI_2 - this.maxPolarAngle, Math.min(_PI_2 - this.minPolarAngle, _euler.x));\r\n      this.camera.quaternion.setFromEuler(_euler);\r\n      this.dispatchEvent(_changeEvent);\r\n    });\r\n\r\n    _defineProperty(this, \"onPointerlockChange\", () => {\r\n      if (!this.domElement) return;\r\n\r\n      if (this.domElement.ownerDocument.pointerLockElement === this.domElement) {\r\n        this.dispatchEvent(_lockEvent);\r\n        this.isLocked = true;\r\n      } else {\r\n        this.dispatchEvent(_unlockEvent);\r\n        this.isLocked = false;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onPointerlockError\", () => {\r\n      console.error('THREE.PointerLockControls: Unable to use Pointer Lock API');\r\n    });\r\n\r\n    _defineProperty(this, \"connect\", domElement => {\r\n      this.domElement = domElement || this.domElement;\r\n      if (!this.domElement) return;\r\n      this.domElement.ownerDocument.addEventListener('mousemove', this.onMouseMove);\r\n      this.domElement.ownerDocument.addEventListener('pointerlockchange', this.onPointerlockChange);\r\n      this.domElement.ownerDocument.addEventListener('pointerlockerror', this.onPointerlockError);\r\n    });\r\n\r\n    _defineProperty(this, \"disconnect\", () => {\r\n      if (!this.domElement) return;\r\n      this.domElement.ownerDocument.removeEventListener('mousemove', this.onMouseMove);\r\n      this.domElement.ownerDocument.removeEventListener('pointerlockchange', this.onPointerlockChange);\r\n      this.domElement.ownerDocument.removeEventListener('pointerlockerror', this.onPointerlockError);\r\n    });\r\n\r\n    _defineProperty(this, \"dispose\", () => {\r\n      this.disconnect();\r\n    });\r\n\r\n    _defineProperty(this, \"getObject\", () => {\r\n      // retaining this method for backward compatibility\r\n      return this.camera;\r\n    });\r\n\r\n    _defineProperty(this, \"direction\", new Vector3(0, 0, -1));\r\n\r\n    _defineProperty(this, \"getDirection\", v => {\r\n      return v.copy(this.direction).applyQuaternion(this.camera.quaternion);\r\n    });\r\n\r\n    _defineProperty(this, \"moveForward\", distance => {\r\n      // move forward parallel to the xz-plane\r\n      // assumes camera.up is y-up\r\n      _vector.setFromMatrixColumn(this.camera.matrix, 0);\r\n\r\n      _vector.crossVectors(this.camera.up, _vector);\r\n\r\n      this.camera.position.addScaledVector(_vector, distance);\r\n    });\r\n\r\n    _defineProperty(this, \"moveRight\", distance => {\r\n      _vector.setFromMatrixColumn(this.camera.matrix, 0);\r\n\r\n      this.camera.position.addScaledVector(_vector, distance);\r\n    });\r\n\r\n    _defineProperty(this, \"lock\", () => {\r\n      if (this.domElement) this.domElement.requestPointerLock();\r\n    });\r\n\r\n    _defineProperty(this, \"unlock\", () => {\r\n      if (this.domElement) this.domElement.ownerDocument.exitPointerLock();\r\n    });\r\n\r\n    this.camera = camera;\r\n    this.domElement = _domElement;\r\n    this.isLocked = false; // Set to constrain the pitch of the camera\r\n    // Range is 0 to Math.PI radians\r\n\r\n    this.minPolarAngle = 0; // radians\r\n\r\n    this.maxPolarAngle = Math.PI; // radians\r\n\r\n    this.pointerSpeed = 1.0;\r\n    if (_domElement) this.connect(_domElement);\r\n  }\r\n\r\n}\r\n\r\nexport { PointerLockControls };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { Matrix4, EventDispatcher, EllipseCurve, BufferGeometry, MathUtils, Vector3, GridHelper, LineBasicMaterial, Line, Raycaster, Vector2, Quaternion, Group, Box3, Sphere } from 'three';\r\n\r\n//trackball state\r\nconst STATE = {\r\n  IDLE: Symbol(),\r\n  ROTATE: Symbol(),\r\n  PAN: Symbol(),\r\n  SCALE: Symbol(),\r\n  FOV: Symbol(),\r\n  FOCUS: Symbol(),\r\n  ZROTATE: Symbol(),\r\n  TOUCH_MULTI: Symbol(),\r\n  ANIMATION_FOCUS: Symbol(),\r\n  ANIMATION_ROTATE: Symbol()\r\n};\r\nconst INPUT = {\r\n  NONE: Symbol(),\r\n  ONE_FINGER: Symbol(),\r\n  ONE_FINGER_SWITCHED: Symbol(),\r\n  TWO_FINGER: Symbol(),\r\n  MULT_FINGER: Symbol(),\r\n  CURSOR: Symbol()\r\n}; //cursor center coordinates\r\n\r\nconst _center = {\r\n  x: 0,\r\n  y: 0\r\n}; //transformation matrices for gizmos and camera\r\n\r\nconst _transformation = {\r\n  camera: new Matrix4(),\r\n  gizmos: new Matrix4()\r\n}; //events\r\n\r\nconst _changeEvent = {\r\n  type: 'change'\r\n};\r\nconst _startEvent = {\r\n  type: 'start'\r\n};\r\nconst _endEvent = {\r\n  type: 'end'\r\n};\r\n/**\r\n *\r\n * @param {CamOrthographicCamera | PerspectiveCameraera} camera Virtual camera used in the scene\r\n * @param {HTMLElement=null} domElement Renderer's dom element\r\n * @param {Scene=null} scene The scene to be rendered\r\n */\r\n\r\nclass ArcballControls extends EventDispatcher {\r\n  constructor(_camera, _domElement = null, scene = null) {\r\n    super();\r\n\r\n    _defineProperty(this, \"camera\", void 0);\r\n\r\n    _defineProperty(this, \"domElement\", void 0);\r\n\r\n    _defineProperty(this, \"scene\", void 0);\r\n\r\n    _defineProperty(this, \"mouseActions\", void 0);\r\n\r\n    _defineProperty(this, \"_mouseOp\", void 0);\r\n\r\n    _defineProperty(this, \"_v2_1\", void 0);\r\n\r\n    _defineProperty(this, \"_v3_1\", void 0);\r\n\r\n    _defineProperty(this, \"_v3_2\", void 0);\r\n\r\n    _defineProperty(this, \"_m4_1\", void 0);\r\n\r\n    _defineProperty(this, \"_m4_2\", void 0);\r\n\r\n    _defineProperty(this, \"_quat\", void 0);\r\n\r\n    _defineProperty(this, \"_translationMatrix\", void 0);\r\n\r\n    _defineProperty(this, \"_rotationMatrix\", void 0);\r\n\r\n    _defineProperty(this, \"_scaleMatrix\", void 0);\r\n\r\n    _defineProperty(this, \"_rotationAxis\", void 0);\r\n\r\n    _defineProperty(this, \"_cameraMatrixState\", void 0);\r\n\r\n    _defineProperty(this, \"_cameraProjectionState\", void 0);\r\n\r\n    _defineProperty(this, \"_fovState\", void 0);\r\n\r\n    _defineProperty(this, \"_upState\", void 0);\r\n\r\n    _defineProperty(this, \"_zoomState\", void 0);\r\n\r\n    _defineProperty(this, \"_nearPos\", void 0);\r\n\r\n    _defineProperty(this, \"_farPos\", void 0);\r\n\r\n    _defineProperty(this, \"_gizmoMatrixState\", void 0);\r\n\r\n    _defineProperty(this, \"_up0\", void 0);\r\n\r\n    _defineProperty(this, \"_zoom0\", void 0);\r\n\r\n    _defineProperty(this, \"_fov0\", void 0);\r\n\r\n    _defineProperty(this, \"_initialNear\", void 0);\r\n\r\n    _defineProperty(this, \"_nearPos0\", void 0);\r\n\r\n    _defineProperty(this, \"_initialFar\", void 0);\r\n\r\n    _defineProperty(this, \"_farPos0\", void 0);\r\n\r\n    _defineProperty(this, \"_cameraMatrixState0\", void 0);\r\n\r\n    _defineProperty(this, \"_gizmoMatrixState0\", void 0);\r\n\r\n    _defineProperty(this, \"_button\", void 0);\r\n\r\n    _defineProperty(this, \"_touchStart\", void 0);\r\n\r\n    _defineProperty(this, \"_touchCurrent\", void 0);\r\n\r\n    _defineProperty(this, \"_input\", void 0);\r\n\r\n    _defineProperty(this, \"_switchSensibility\", void 0);\r\n\r\n    _defineProperty(this, \"_startFingerDistance\", void 0);\r\n\r\n    _defineProperty(this, \"_currentFingerDistance\", void 0);\r\n\r\n    _defineProperty(this, \"_startFingerRotation\", void 0);\r\n\r\n    _defineProperty(this, \"_currentFingerRotation\", void 0);\r\n\r\n    _defineProperty(this, \"_devPxRatio\", void 0);\r\n\r\n    _defineProperty(this, \"_downValid\", void 0);\r\n\r\n    _defineProperty(this, \"_nclicks\", void 0);\r\n\r\n    _defineProperty(this, \"_downEvents\", void 0);\r\n\r\n    _defineProperty(this, \"_clickStart\", void 0);\r\n\r\n    _defineProperty(this, \"_maxDownTime\", void 0);\r\n\r\n    _defineProperty(this, \"_maxInterval\", void 0);\r\n\r\n    _defineProperty(this, \"_posThreshold\", void 0);\r\n\r\n    _defineProperty(this, \"_movementThreshold\", void 0);\r\n\r\n    _defineProperty(this, \"_currentCursorPosition\", void 0);\r\n\r\n    _defineProperty(this, \"_startCursorPosition\", void 0);\r\n\r\n    _defineProperty(this, \"_grid\", void 0);\r\n\r\n    _defineProperty(this, \"_gridPosition\", void 0);\r\n\r\n    _defineProperty(this, \"_gizmos\", void 0);\r\n\r\n    _defineProperty(this, \"_curvePts\", void 0);\r\n\r\n    _defineProperty(this, \"_timeStart\", void 0);\r\n\r\n    _defineProperty(this, \"_animationId\", void 0);\r\n\r\n    _defineProperty(this, \"focusAnimationTime\", void 0);\r\n\r\n    _defineProperty(this, \"_timePrev\", void 0);\r\n\r\n    _defineProperty(this, \"_timeCurrent\", void 0);\r\n\r\n    _defineProperty(this, \"_anglePrev\", void 0);\r\n\r\n    _defineProperty(this, \"_angleCurrent\", void 0);\r\n\r\n    _defineProperty(this, \"_cursorPosPrev\", void 0);\r\n\r\n    _defineProperty(this, \"_cursorPosCurr\", void 0);\r\n\r\n    _defineProperty(this, \"_wPrev\", void 0);\r\n\r\n    _defineProperty(this, \"_wCurr\", void 0);\r\n\r\n    _defineProperty(this, \"adjustNearFar\", void 0);\r\n\r\n    _defineProperty(this, \"scaleFactor\", void 0);\r\n\r\n    _defineProperty(this, \"dampingFactor\", void 0);\r\n\r\n    _defineProperty(this, \"wMax\", void 0);\r\n\r\n    _defineProperty(this, \"enableAnimations\", void 0);\r\n\r\n    _defineProperty(this, \"enableGrid\", void 0);\r\n\r\n    _defineProperty(this, \"cursorZoom\", void 0);\r\n\r\n    _defineProperty(this, \"minFov\", void 0);\r\n\r\n    _defineProperty(this, \"maxFov\", void 0);\r\n\r\n    _defineProperty(this, \"enabled\", void 0);\r\n\r\n    _defineProperty(this, \"enablePan\", void 0);\r\n\r\n    _defineProperty(this, \"enableRotate\", void 0);\r\n\r\n    _defineProperty(this, \"enableZoom\", void 0);\r\n\r\n    _defineProperty(this, \"minDistance\", void 0);\r\n\r\n    _defineProperty(this, \"maxDistance\", void 0);\r\n\r\n    _defineProperty(this, \"minZoom\", void 0);\r\n\r\n    _defineProperty(this, \"maxZoom\", void 0);\r\n\r\n    _defineProperty(this, \"target\", void 0);\r\n\r\n    _defineProperty(this, \"_currentTarget\", void 0);\r\n\r\n    _defineProperty(this, \"_tbRadius\", void 0);\r\n\r\n    _defineProperty(this, \"_state\", void 0);\r\n\r\n    _defineProperty(this, \"onWindowResize\", () => {\r\n      const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\r\n\r\n      if (this.camera) {\r\n        const tbRadius = this.calculateTbRadius(this.camera);\r\n\r\n        if (tbRadius !== undefined) {\r\n          this._tbRadius = tbRadius;\r\n        }\r\n      }\r\n\r\n      const newRadius = this._tbRadius / scale; // @ts-expect-error\r\n\r\n      const curve = new EllipseCurve(0, 0, newRadius, newRadius);\r\n      const points = curve.getPoints(this._curvePts);\r\n      const curveGeometry = new BufferGeometry().setFromPoints(points);\r\n\r\n      for (const gizmo in this._gizmos.children) {\r\n        const child = this._gizmos.children[gizmo];\r\n        child.geometry = curveGeometry;\r\n      }\r\n\r\n      this.dispatchEvent(_changeEvent);\r\n    });\r\n\r\n    _defineProperty(this, \"onContextMenu\", event => {\r\n      if (!this.enabled) {\r\n        return;\r\n      }\r\n\r\n      for (let i = 0; i < this.mouseActions.length; i++) {\r\n        if (this.mouseActions[i].mouse == 2) {\r\n          //prevent only if button 2 is actually used\r\n          event.preventDefault();\r\n          break;\r\n        }\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onPointerCancel\", () => {\r\n      this._touchStart.splice(0, this._touchStart.length);\r\n\r\n      this._touchCurrent.splice(0, this._touchCurrent.length);\r\n\r\n      this._input = INPUT.NONE;\r\n    });\r\n\r\n    _defineProperty(this, \"onPointerDown\", event => {\r\n      if (event.button == 0 && event.isPrimary) {\r\n        this._downValid = true;\r\n\r\n        this._downEvents.push(event);\r\n      } else {\r\n        this._downValid = false;\r\n      }\r\n\r\n      if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\r\n        this._touchStart.push(event);\r\n\r\n        this._touchCurrent.push(event);\r\n\r\n        switch (this._input) {\r\n          case INPUT.NONE:\r\n            //singleStart\r\n            this._input = INPUT.ONE_FINGER;\r\n            this.onSinglePanStart(event, 'ROTATE');\r\n            window.addEventListener('pointermove', this.onPointerMove);\r\n            window.addEventListener('pointerup', this.onPointerUp);\r\n            break;\r\n\r\n          case INPUT.ONE_FINGER:\r\n          case INPUT.ONE_FINGER_SWITCHED:\r\n            //doubleStart\r\n            this._input = INPUT.TWO_FINGER;\r\n            this.onRotateStart();\r\n            this.onPinchStart();\r\n            this.onDoublePanStart();\r\n            break;\r\n\r\n          case INPUT.TWO_FINGER:\r\n            //multipleStart\r\n            this._input = INPUT.MULT_FINGER;\r\n            this.onTriplePanStart();\r\n            break;\r\n        }\r\n      } else if (event.pointerType != 'touch' && this._input == INPUT.NONE) {\r\n        let modifier = null;\r\n\r\n        if (event.ctrlKey || event.metaKey) {\r\n          modifier = 'CTRL';\r\n        } else if (event.shiftKey) {\r\n          modifier = 'SHIFT';\r\n        }\r\n\r\n        this._mouseOp = this.getOpFromAction(event.button, modifier);\r\n\r\n        if (this._mouseOp) {\r\n          window.addEventListener('pointermove', this.onPointerMove);\r\n          window.addEventListener('pointerup', this.onPointerUp); //singleStart\r\n\r\n          this._input = INPUT.CURSOR;\r\n          this._button = event.button;\r\n          this.onSinglePanStart(event, this._mouseOp);\r\n        }\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onPointerMove\", event => {\r\n      if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\r\n        switch (this._input) {\r\n          case INPUT.ONE_FINGER:\r\n            //singleMove\r\n            this.updateTouchEvent(event);\r\n            this.onSinglePanMove(event, STATE.ROTATE);\r\n            break;\r\n\r\n          case INPUT.ONE_FINGER_SWITCHED:\r\n            const movement = this.calculatePointersDistance(this._touchCurrent[0], event) * this._devPxRatio;\r\n\r\n            if (movement >= this._switchSensibility) {\r\n              //singleMove\r\n              this._input = INPUT.ONE_FINGER;\r\n              this.updateTouchEvent(event);\r\n              this.onSinglePanStart(event, 'ROTATE');\r\n              break;\r\n            }\r\n\r\n            break;\r\n\r\n          case INPUT.TWO_FINGER:\r\n            //rotate/pan/pinchMove\r\n            this.updateTouchEvent(event);\r\n            this.onRotateMove();\r\n            this.onPinchMove();\r\n            this.onDoublePanMove();\r\n            break;\r\n\r\n          case INPUT.MULT_FINGER:\r\n            //multMove\r\n            this.updateTouchEvent(event);\r\n            this.onTriplePanMove();\r\n            break;\r\n        }\r\n      } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\r\n        let modifier = null;\r\n\r\n        if (event.ctrlKey || event.metaKey) {\r\n          modifier = 'CTRL';\r\n        } else if (event.shiftKey) {\r\n          modifier = 'SHIFT';\r\n        }\r\n\r\n        const mouseOpState = this.getOpStateFromAction(this._button, modifier);\r\n\r\n        if (mouseOpState) {\r\n          this.onSinglePanMove(event, mouseOpState);\r\n        }\r\n      } //checkDistance\r\n\r\n\r\n      if (this._downValid) {\r\n        const movement = this.calculatePointersDistance(this._downEvents[this._downEvents.length - 1], event) * this._devPxRatio;\r\n\r\n        if (movement > this._movementThreshold) {\r\n          this._downValid = false;\r\n        }\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onPointerUp\", event => {\r\n      if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\r\n        const nTouch = this._touchCurrent.length;\r\n\r\n        for (let i = 0; i < nTouch; i++) {\r\n          if (this._touchCurrent[i].pointerId == event.pointerId) {\r\n            this._touchCurrent.splice(i, 1);\r\n\r\n            this._touchStart.splice(i, 1);\r\n\r\n            break;\r\n          }\r\n        }\r\n\r\n        switch (this._input) {\r\n          case INPUT.ONE_FINGER:\r\n          case INPUT.ONE_FINGER_SWITCHED:\r\n            //singleEnd\r\n            window.removeEventListener('pointermove', this.onPointerMove);\r\n            window.removeEventListener('pointerup', this.onPointerUp);\r\n            this._input = INPUT.NONE;\r\n            this.onSinglePanEnd();\r\n            break;\r\n\r\n          case INPUT.TWO_FINGER:\r\n            //doubleEnd\r\n            this.onDoublePanEnd();\r\n            this.onPinchEnd();\r\n            this.onRotateEnd(); //switching to singleStart\r\n\r\n            this._input = INPUT.ONE_FINGER_SWITCHED;\r\n            break;\r\n\r\n          case INPUT.MULT_FINGER:\r\n            if (this._touchCurrent.length == 0) {\r\n              window.removeEventListener('pointermove', this.onPointerMove);\r\n              window.removeEventListener('pointerup', this.onPointerUp); //multCancel\r\n\r\n              this._input = INPUT.NONE;\r\n              this.onTriplePanEnd();\r\n            }\r\n\r\n            break;\r\n        }\r\n      } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\r\n        window.removeEventListener('pointermove', this.onPointerMove);\r\n        window.removeEventListener('pointerup', this.onPointerUp);\r\n        this._input = INPUT.NONE;\r\n        this.onSinglePanEnd();\r\n        this._button = -1;\r\n      }\r\n\r\n      if (event.isPrimary) {\r\n        if (this._downValid) {\r\n          const downTime = event.timeStamp - this._downEvents[this._downEvents.length - 1].timeStamp;\r\n\r\n          if (downTime <= this._maxDownTime) {\r\n            if (this._nclicks == 0) {\r\n              //first valid click detected\r\n              this._nclicks = 1;\r\n              this._clickStart = performance.now();\r\n            } else {\r\n              const clickInterval = event.timeStamp - this._clickStart;\r\n\r\n              const movement = this.calculatePointersDistance(this._downEvents[1], this._downEvents[0]) * this._devPxRatio;\r\n\r\n              if (clickInterval <= this._maxInterval && movement <= this._posThreshold) {\r\n                //second valid click detected\r\n                //fire double tap and reset values\r\n                this._nclicks = 0;\r\n\r\n                this._downEvents.splice(0, this._downEvents.length);\r\n\r\n                this.onDoubleTap(event);\r\n              } else {\r\n                //new 'first click'\r\n                this._nclicks = 1;\r\n\r\n                this._downEvents.shift();\r\n\r\n                this._clickStart = performance.now();\r\n              }\r\n            }\r\n          } else {\r\n            this._downValid = false;\r\n            this._nclicks = 0;\r\n\r\n            this._downEvents.splice(0, this._downEvents.length);\r\n          }\r\n        } else {\r\n          this._nclicks = 0;\r\n\r\n          this._downEvents.splice(0, this._downEvents.length);\r\n        }\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onWheel\", event => {\r\n      var _this$camera3;\r\n\r\n      if (this.enabled && this.enableZoom && this.domElement) {\r\n        let modifier = null;\r\n\r\n        if (event.ctrlKey || event.metaKey) {\r\n          modifier = 'CTRL';\r\n        } else if (event.shiftKey) {\r\n          modifier = 'SHIFT';\r\n        }\r\n\r\n        const mouseOp = this.getOpFromAction('WHEEL', modifier);\r\n\r\n        if (mouseOp) {\r\n          event.preventDefault();\r\n          this.dispatchEvent(_startEvent);\r\n          const notchDeltaY = 125; //distance of one notch of mouse wheel\r\n\r\n          let sgn = event.deltaY / notchDeltaY;\r\n          let size = 1;\r\n\r\n          if (sgn > 0) {\r\n            size = 1 / this.scaleFactor;\r\n          } else if (sgn < 0) {\r\n            size = this.scaleFactor;\r\n          }\r\n\r\n          switch (mouseOp) {\r\n            case 'ZOOM':\r\n              this.updateTbState(STATE.SCALE, true);\r\n\r\n              if (sgn > 0) {\r\n                size = 1 / Math.pow(this.scaleFactor, sgn);\r\n              } else if (sgn < 0) {\r\n                size = Math.pow(this.scaleFactor, -sgn);\r\n              }\r\n\r\n              if (this.cursorZoom && this.enablePan) {\r\n                var _this$camera, _this$camera2;\r\n\r\n                let scalePoint;\r\n\r\n                if (((_this$camera = this.camera) === null || _this$camera === void 0 ? void 0 : _this$camera.type) === 'OrthographicCamera') {\r\n                  var _this$unprojectOnTbPl;\r\n\r\n                  scalePoint = (_this$unprojectOnTbPl = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)) === null || _this$unprojectOnTbPl === void 0 ? void 0 : _this$unprojectOnTbPl.applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\r\n                }\r\n\r\n                if (((_this$camera2 = this.camera) === null || _this$camera2 === void 0 ? void 0 : _this$camera2.type) === 'PerspectiveCamera') {\r\n                  var _this$unprojectOnTbPl2;\r\n\r\n                  scalePoint = (_this$unprojectOnTbPl2 = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)) === null || _this$unprojectOnTbPl2 === void 0 ? void 0 : _this$unprojectOnTbPl2.applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\r\n                }\r\n\r\n                if (scalePoint !== undefined) this.applyTransformMatrix(this.applyScale(size, scalePoint));\r\n              } else {\r\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\r\n              }\r\n\r\n              if (this._grid) {\r\n                this.disposeGrid();\r\n                this.drawGrid();\r\n              }\r\n\r\n              this.updateTbState(STATE.IDLE, false);\r\n              this.dispatchEvent(_changeEvent);\r\n              this.dispatchEvent(_endEvent);\r\n              break;\r\n\r\n            case 'FOV':\r\n              if (((_this$camera3 = this.camera) === null || _this$camera3 === void 0 ? void 0 : _this$camera3.type) === 'PerspectiveCamera') {\r\n                this.updateTbState(STATE.FOV, true); //Vertigo effect\r\n                //\t  fov / 2\r\n                //\t\t|\\\r\n                //\t\t| \\\r\n                //\t\t|  \\\r\n                //\tx\t|\t\\\r\n                //\t\t| \t \\\r\n                //\t\t| \t  \\\r\n                //\t\t| _ _ _\\\r\n                //\t\t\ty\r\n                //check for iOs shift shortcut\r\n\r\n                if (event.deltaX != 0) {\r\n                  sgn = event.deltaX / notchDeltaY;\r\n                  size = 1;\r\n\r\n                  if (sgn > 0) {\r\n                    size = 1 / Math.pow(this.scaleFactor, sgn);\r\n                  } else if (sgn < 0) {\r\n                    size = Math.pow(this.scaleFactor, -sgn);\r\n                  }\r\n                }\r\n\r\n                this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\r\n\r\n                const x = this._v3_1.distanceTo(this._gizmos.position);\r\n\r\n                let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\r\n                //check min and max distance\r\n\r\n                xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\r\n                const y = x * Math.tan(MathUtils.DEG2RAD * this.camera.fov * 0.5); //calculate new fov\r\n\r\n                let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\r\n\r\n                if (newFov > this.maxFov) {\r\n                  newFov = this.maxFov;\r\n                } else if (newFov < this.minFov) {\r\n                  newFov = this.minFov;\r\n                }\r\n\r\n                const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\r\n                size = x / newDistance;\r\n                this.setFov(newFov);\r\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position, false));\r\n              }\r\n\r\n              if (this._grid) {\r\n                this.disposeGrid();\r\n                this.drawGrid();\r\n              }\r\n\r\n              this.updateTbState(STATE.IDLE, false);\r\n              this.dispatchEvent(_changeEvent);\r\n              this.dispatchEvent(_endEvent);\r\n              break;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onSinglePanStart\", (event, operation) => {\r\n      var _this$camera4;\r\n\r\n      if (this.enabled && this.domElement) {\r\n        this.dispatchEvent(_startEvent);\r\n        this.setCenter(event.clientX, event.clientY);\r\n\r\n        switch (operation) {\r\n          case 'PAN':\r\n            if (!this.enablePan) return;\r\n\r\n            if (this._animationId != -1) {\r\n              cancelAnimationFrame(this._animationId);\r\n              this._animationId = -1;\r\n              this._timeStart = -1;\r\n              this.activateGizmos(false);\r\n              this.dispatchEvent(_changeEvent);\r\n            }\r\n\r\n            if (this.camera) {\r\n              this.updateTbState(STATE.PAN, true);\r\n              const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement);\r\n\r\n              if (rayDir !== undefined) {\r\n                this._startCursorPosition.copy(rayDir);\r\n              }\r\n\r\n              if (this.enableGrid) {\r\n                this.drawGrid();\r\n                this.dispatchEvent(_changeEvent);\r\n              }\r\n            }\r\n\r\n            break;\r\n\r\n          case 'ROTATE':\r\n            if (!this.enableRotate) return;\r\n\r\n            if (this._animationId != -1) {\r\n              cancelAnimationFrame(this._animationId);\r\n              this._animationId = -1;\r\n              this._timeStart = -1;\r\n            }\r\n\r\n            if (this.camera) {\r\n              this.updateTbState(STATE.ROTATE, true);\r\n              const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius);\r\n\r\n              if (rayDir !== undefined) {\r\n                this._startCursorPosition.copy(rayDir);\r\n              }\r\n\r\n              this.activateGizmos(true);\r\n\r\n              if (this.enableAnimations) {\r\n                this._timePrev = this._timeCurrent = performance.now();\r\n                this._angleCurrent = this._anglePrev = 0;\r\n\r\n                this._cursorPosPrev.copy(this._startCursorPosition);\r\n\r\n                this._cursorPosCurr.copy(this._cursorPosPrev);\r\n\r\n                this._wCurr = 0;\r\n                this._wPrev = this._wCurr;\r\n              }\r\n            }\r\n\r\n            this.dispatchEvent(_changeEvent);\r\n            break;\r\n\r\n          case 'FOV':\r\n            if (!this.enableZoom) return;\r\n\r\n            if (((_this$camera4 = this.camera) === null || _this$camera4 === void 0 ? void 0 : _this$camera4.type) === 'PerspectiveCamera') {\r\n              if (this._animationId != -1) {\r\n                cancelAnimationFrame(this._animationId);\r\n                this._animationId = -1;\r\n                this._timeStart = -1;\r\n                this.activateGizmos(false);\r\n                this.dispatchEvent(_changeEvent);\r\n              }\r\n\r\n              this.updateTbState(STATE.FOV, true);\r\n\r\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\r\n\r\n              this._currentCursorPosition.copy(this._startCursorPosition);\r\n            }\r\n\r\n            break;\r\n\r\n          case 'ZOOM':\r\n            if (!this.enableZoom) return;\r\n\r\n            if (this._animationId != -1) {\r\n              cancelAnimationFrame(this._animationId);\r\n              this._animationId = -1;\r\n              this._timeStart = -1;\r\n              this.activateGizmos(false);\r\n              this.dispatchEvent(_changeEvent);\r\n            }\r\n\r\n            this.updateTbState(STATE.SCALE, true);\r\n\r\n            this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\r\n\r\n            this._currentCursorPosition.copy(this._startCursorPosition);\r\n\r\n            break;\r\n        }\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onSinglePanMove\", (event, opState) => {\r\n      var _this$camera5;\r\n\r\n      if (this.enabled && this.domElement) {\r\n        const restart = opState != this._state;\r\n        this.setCenter(event.clientX, event.clientY);\r\n\r\n        switch (opState) {\r\n          case STATE.PAN:\r\n            if (this.enablePan && this.camera) {\r\n              if (restart) {\r\n                //switch to pan operation\r\n                this.dispatchEvent(_endEvent);\r\n                this.dispatchEvent(_startEvent);\r\n                this.updateTbState(opState, true);\r\n                const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement);\r\n\r\n                if (rayDir !== undefined) {\r\n                  this._startCursorPosition.copy(rayDir);\r\n                }\r\n\r\n                if (this.enableGrid) {\r\n                  this.drawGrid();\r\n                }\r\n\r\n                this.activateGizmos(false);\r\n              } else {\r\n                //continue with pan operation\r\n                const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement);\r\n\r\n                if (rayDir !== undefined) {\r\n                  this._currentCursorPosition.copy(rayDir);\r\n                }\r\n\r\n                this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition));\r\n              }\r\n            }\r\n\r\n            break;\r\n\r\n          case STATE.ROTATE:\r\n            if (this.enableRotate && this.camera) {\r\n              if (restart) {\r\n                //switch to rotate operation\r\n                this.dispatchEvent(_endEvent);\r\n                this.dispatchEvent(_startEvent);\r\n                this.updateTbState(opState, true);\r\n                const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius);\r\n\r\n                if (rayDir !== undefined) {\r\n                  this._startCursorPosition.copy(rayDir);\r\n                }\r\n\r\n                if (this.enableGrid) {\r\n                  this.disposeGrid();\r\n                }\r\n\r\n                this.activateGizmos(true);\r\n              } else {\r\n                //continue with rotate operation\r\n                const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius);\r\n\r\n                if (rayDir !== undefined) {\r\n                  this._currentCursorPosition.copy(rayDir);\r\n                }\r\n\r\n                const distance = this._startCursorPosition.distanceTo(this._currentCursorPosition);\r\n\r\n                const angle = this._startCursorPosition.angleTo(this._currentCursorPosition);\r\n\r\n                const amount = Math.max(distance / this._tbRadius, angle); //effective rotation angle\r\n\r\n                this.applyTransformMatrix(this.rotate(this.calculateRotationAxis(this._startCursorPosition, this._currentCursorPosition), amount));\r\n\r\n                if (this.enableAnimations) {\r\n                  this._timePrev = this._timeCurrent;\r\n                  this._timeCurrent = performance.now();\r\n                  this._anglePrev = this._angleCurrent;\r\n                  this._angleCurrent = amount;\r\n\r\n                  this._cursorPosPrev.copy(this._cursorPosCurr);\r\n\r\n                  this._cursorPosCurr.copy(this._currentCursorPosition);\r\n\r\n                  this._wPrev = this._wCurr;\r\n                  this._wCurr = this.calculateAngularSpeed(this._anglePrev, this._angleCurrent, this._timePrev, this._timeCurrent);\r\n                }\r\n              }\r\n            }\r\n\r\n            break;\r\n\r\n          case STATE.SCALE:\r\n            if (this.enableZoom) {\r\n              if (restart) {\r\n                //switch to zoom operation\r\n                this.dispatchEvent(_endEvent);\r\n                this.dispatchEvent(_startEvent);\r\n                this.updateTbState(opState, true);\r\n\r\n                this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\r\n\r\n                this._currentCursorPosition.copy(this._startCursorPosition);\r\n\r\n                if (this.enableGrid) {\r\n                  this.disposeGrid();\r\n                }\r\n\r\n                this.activateGizmos(false);\r\n              } else {\r\n                //continue with zoom operation\r\n                const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\r\n\r\n                this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\r\n\r\n                const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\r\n                let size = 1;\r\n\r\n                if (movement < 0) {\r\n                  size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\r\n                } else if (movement > 0) {\r\n                  size = Math.pow(this.scaleFactor, movement * screenNotches);\r\n                }\r\n\r\n                this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\r\n              }\r\n            }\r\n\r\n            break;\r\n\r\n          case STATE.FOV:\r\n            if (this.enableZoom && ((_this$camera5 = this.camera) === null || _this$camera5 === void 0 ? void 0 : _this$camera5.type) === 'PerspectiveCamera') {\r\n              if (restart) {\r\n                //switch to fov operation\r\n                this.dispatchEvent(_endEvent);\r\n                this.dispatchEvent(_startEvent);\r\n                this.updateTbState(opState, true);\r\n\r\n                this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\r\n\r\n                this._currentCursorPosition.copy(this._startCursorPosition);\r\n\r\n                if (this.enableGrid) {\r\n                  this.disposeGrid();\r\n                }\r\n\r\n                this.activateGizmos(false);\r\n              } else {\r\n                //continue with fov operation\r\n                const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\r\n\r\n                this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\r\n\r\n                const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\r\n                let size = 1;\r\n\r\n                if (movement < 0) {\r\n                  size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\r\n                } else if (movement > 0) {\r\n                  size = Math.pow(this.scaleFactor, movement * screenNotches);\r\n                }\r\n\r\n                this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\r\n\r\n                const x = this._v3_1.distanceTo(this._gizmos.position);\r\n\r\n                let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\r\n                //check min and max distance\r\n\r\n                xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\r\n                const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5); //calculate new fov\r\n\r\n                let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\r\n\r\n                newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\r\n                const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\r\n                size = x / newDistance;\r\n\r\n                this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\r\n\r\n                this.setFov(newFov);\r\n                this.applyTransformMatrix(this.applyScale(size, this._v3_2, false)); //adjusting distance\r\n\r\n                const direction = this._gizmos.position.clone().sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\r\n\r\n                this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\r\n              }\r\n            }\r\n\r\n            break;\r\n        }\r\n\r\n        this.dispatchEvent(_changeEvent);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onSinglePanEnd\", () => {\r\n      if (this._state == STATE.ROTATE) {\r\n        if (!this.enableRotate) {\r\n          return;\r\n        }\r\n\r\n        if (this.enableAnimations) {\r\n          //perform rotation animation\r\n          const deltaTime = performance.now() - this._timeCurrent;\r\n\r\n          if (deltaTime < 120) {\r\n            const w = Math.abs((this._wPrev + this._wCurr) / 2);\r\n            const self = this;\r\n            this._animationId = window.requestAnimationFrame(function (t) {\r\n              self.updateTbState(STATE.ANIMATION_ROTATE, true);\r\n              const rotationAxis = self.calculateRotationAxis(self._cursorPosPrev, self._cursorPosCurr);\r\n              self.onRotationAnim(t, rotationAxis, Math.min(w, self.wMax));\r\n            });\r\n          } else {\r\n            //cursor has been standing still for over 120 ms since last movement\r\n            this.updateTbState(STATE.IDLE, false);\r\n            this.activateGizmos(false);\r\n            this.dispatchEvent(_changeEvent);\r\n          }\r\n        } else {\r\n          this.updateTbState(STATE.IDLE, false);\r\n          this.activateGizmos(false);\r\n          this.dispatchEvent(_changeEvent);\r\n        }\r\n      } else if (this._state == STATE.PAN || this._state == STATE.IDLE) {\r\n        this.updateTbState(STATE.IDLE, false);\r\n\r\n        if (this.enableGrid) {\r\n          this.disposeGrid();\r\n        }\r\n\r\n        this.activateGizmos(false);\r\n        this.dispatchEvent(_changeEvent);\r\n      }\r\n\r\n      this.dispatchEvent(_endEvent);\r\n    });\r\n\r\n    _defineProperty(this, \"onDoubleTap\", event => {\r\n      if (this.enabled && this.enablePan && this.scene && this.camera && this.domElement) {\r\n        this.dispatchEvent(_startEvent);\r\n        this.setCenter(event.clientX, event.clientY);\r\n        const hitP = this.unprojectOnObj(this.getCursorNDC(_center.x, _center.y, this.domElement), this.camera);\r\n\r\n        if (hitP && this.enableAnimations) {\r\n          const self = this;\r\n\r\n          if (this._animationId != -1) {\r\n            window.cancelAnimationFrame(this._animationId);\r\n          }\r\n\r\n          this._timeStart = -1;\r\n          this._animationId = window.requestAnimationFrame(function (t) {\r\n            self.updateTbState(STATE.ANIMATION_FOCUS, true);\r\n            self.onFocusAnim(t, hitP, self._cameraMatrixState, self._gizmoMatrixState);\r\n          });\r\n        } else if (hitP && !this.enableAnimations) {\r\n          this.updateTbState(STATE.FOCUS, true);\r\n          this.focus(hitP, this.scaleFactor);\r\n          this.updateTbState(STATE.IDLE, false);\r\n          this.dispatchEvent(_changeEvent);\r\n        }\r\n      }\r\n\r\n      this.dispatchEvent(_endEvent);\r\n    });\r\n\r\n    _defineProperty(this, \"onDoublePanStart\", () => {\r\n      if (this.enabled && this.enablePan && this.camera && this.domElement) {\r\n        this.dispatchEvent(_startEvent);\r\n        this.updateTbState(STATE.PAN, true);\r\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\r\n        const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true);\r\n\r\n        if (rayDir !== undefined) {\r\n          this._startCursorPosition.copy(rayDir);\r\n        }\r\n\r\n        this._currentCursorPosition.copy(this._startCursorPosition);\r\n\r\n        this.activateGizmos(false);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onDoublePanMove\", () => {\r\n      if (this.enabled && this.enablePan && this.camera && this.domElement) {\r\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\r\n\r\n        if (this._state != STATE.PAN) {\r\n          this.updateTbState(STATE.PAN, true);\r\n\r\n          this._startCursorPosition.copy(this._currentCursorPosition);\r\n        }\r\n\r\n        const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true);\r\n        if (rayDir !== undefined) this._currentCursorPosition.copy(rayDir);\r\n        this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition, true));\r\n        this.dispatchEvent(_changeEvent);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onDoublePanEnd\", () => {\r\n      this.updateTbState(STATE.IDLE, false);\r\n      this.dispatchEvent(_endEvent);\r\n    });\r\n\r\n    _defineProperty(this, \"onRotateStart\", () => {\r\n      if (this.enabled && this.enableRotate) {\r\n        var _this$camera6;\r\n\r\n        this.dispatchEvent(_startEvent);\r\n        this.updateTbState(STATE.ZROTATE, true); //this._startFingerRotation = event.rotation;\r\n\r\n        this._startFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\r\n        this._currentFingerRotation = this._startFingerRotation;\r\n        (_this$camera6 = this.camera) === null || _this$camera6 === void 0 ? void 0 : _this$camera6.getWorldDirection(this._rotationAxis); //rotation axis\r\n\r\n        if (!this.enablePan && !this.enableZoom) {\r\n          this.activateGizmos(true);\r\n        }\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onRotateMove\", () => {\r\n      if (this.enabled && this.enableRotate && this.camera && this.domElement) {\r\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\r\n        let rotationPoint;\r\n\r\n        if (this._state != STATE.ZROTATE) {\r\n          this.updateTbState(STATE.ZROTATE, true);\r\n          this._startFingerRotation = this._currentFingerRotation;\r\n        } //this._currentFingerRotation = event.rotation;\r\n\r\n\r\n        this._currentFingerRotation = this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) + this.getAngle(this._touchStart[1], this._touchStart[0]);\r\n\r\n        if (!this.enablePan) {\r\n          rotationPoint = new Vector3().setFromMatrixPosition(this._gizmoMatrixState);\r\n        } else if (this.camera) {\r\n          var _this$unprojectOnTbPl3;\r\n\r\n          this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\r\n\r\n          rotationPoint = (_this$unprojectOnTbPl3 = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)) === null || _this$unprojectOnTbPl3 === void 0 ? void 0 : _this$unprojectOnTbPl3.applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._v3_2);\r\n        }\r\n\r\n        const amount = MathUtils.DEG2RAD * (this._startFingerRotation - this._currentFingerRotation);\r\n\r\n        if (rotationPoint !== undefined) {\r\n          this.applyTransformMatrix(this.zRotate(rotationPoint, amount));\r\n        }\r\n\r\n        this.dispatchEvent(_changeEvent);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onRotateEnd\", () => {\r\n      this.updateTbState(STATE.IDLE, false);\r\n      this.activateGizmos(false);\r\n      this.dispatchEvent(_endEvent);\r\n    });\r\n\r\n    _defineProperty(this, \"onPinchStart\", () => {\r\n      if (this.enabled && this.enableZoom) {\r\n        this.dispatchEvent(_startEvent);\r\n        this.updateTbState(STATE.SCALE, true);\r\n        this._startFingerDistance = this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]);\r\n        this._currentFingerDistance = this._startFingerDistance;\r\n        this.activateGizmos(false);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onPinchMove\", () => {\r\n      if (this.enabled && this.enableZoom && this.domElement) {\r\n        this.setCenter((this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2, (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2);\r\n        const minDistance = 12; //minimum distance between fingers (in css pixels)\r\n\r\n        if (this._state != STATE.SCALE) {\r\n          this._startFingerDistance = this._currentFingerDistance;\r\n          this.updateTbState(STATE.SCALE, true);\r\n        }\r\n\r\n        this._currentFingerDistance = Math.max(this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]), minDistance * this._devPxRatio);\r\n        const amount = this._currentFingerDistance / this._startFingerDistance;\r\n        let scalePoint;\r\n\r\n        if (!this.enablePan) {\r\n          scalePoint = this._gizmos.position;\r\n        } else {\r\n          var _this$camera7, _this$camera8;\r\n\r\n          if (((_this$camera7 = this.camera) === null || _this$camera7 === void 0 ? void 0 : _this$camera7.type) === 'OrthographicCamera') {\r\n            var _this$unprojectOnTbPl4;\r\n\r\n            scalePoint = (_this$unprojectOnTbPl4 = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)) === null || _this$unprojectOnTbPl4 === void 0 ? void 0 : _this$unprojectOnTbPl4.applyQuaternion(this.camera.quaternion).multiplyScalar(1 / this.camera.zoom).add(this._gizmos.position);\r\n          } else if (((_this$camera8 = this.camera) === null || _this$camera8 === void 0 ? void 0 : _this$camera8.type) === 'PerspectiveCamera') {\r\n            var _this$unprojectOnTbPl5;\r\n\r\n            scalePoint = (_this$unprojectOnTbPl5 = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)) === null || _this$unprojectOnTbPl5 === void 0 ? void 0 : _this$unprojectOnTbPl5.applyQuaternion(this.camera.quaternion).add(this._gizmos.position);\r\n          }\r\n        }\r\n\r\n        if (scalePoint !== undefined) {\r\n          this.applyTransformMatrix(this.applyScale(amount, scalePoint));\r\n        }\r\n\r\n        this.dispatchEvent(_changeEvent);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onPinchEnd\", () => {\r\n      this.updateTbState(STATE.IDLE, false);\r\n      this.dispatchEvent(_endEvent);\r\n    });\r\n\r\n    _defineProperty(this, \"onTriplePanStart\", () => {\r\n      if (this.enabled && this.enableZoom && this.domElement) {\r\n        this.dispatchEvent(_startEvent);\r\n        this.updateTbState(STATE.SCALE, true); //const center = event.center;\r\n\r\n        let clientX = 0;\r\n        let clientY = 0;\r\n        const nFingers = this._touchCurrent.length;\r\n\r\n        for (let i = 0; i < nFingers; i++) {\r\n          clientX += this._touchCurrent[i].clientX;\r\n          clientY += this._touchCurrent[i].clientY;\r\n        }\r\n\r\n        this.setCenter(clientX / nFingers, clientY / nFingers);\r\n\r\n        this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\r\n\r\n        this._currentCursorPosition.copy(this._startCursorPosition);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onTriplePanMove\", () => {\r\n      if (this.enabled && this.enableZoom && this.camera && this.domElement) {\r\n        //\t  fov / 2\r\n        //\t\t|\\\r\n        //\t\t| \\\r\n        //\t\t|  \\\r\n        //\tx\t|\t\\\r\n        //\t\t| \t \\\r\n        //\t\t| \t  \\\r\n        //\t\t| _ _ _\\\r\n        //\t\t\ty\r\n        //const center = event.center;\r\n        let clientX = 0;\r\n        let clientY = 0;\r\n        const nFingers = this._touchCurrent.length;\r\n\r\n        for (let i = 0; i < nFingers; i++) {\r\n          clientX += this._touchCurrent[i].clientX;\r\n          clientY += this._touchCurrent[i].clientY;\r\n        }\r\n\r\n        this.setCenter(clientX / nFingers, clientY / nFingers);\r\n        const screenNotches = 8; //how many wheel notches corresponds to a full screen pan\r\n\r\n        this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5);\r\n\r\n        const movement = this._currentCursorPosition.y - this._startCursorPosition.y;\r\n        let size = 1;\r\n\r\n        if (movement < 0) {\r\n          size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches);\r\n        } else if (movement > 0) {\r\n          size = Math.pow(this.scaleFactor, movement * screenNotches);\r\n        }\r\n\r\n        this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\r\n\r\n        const x = this._v3_1.distanceTo(this._gizmos.position);\r\n\r\n        let xNew = x / size; //distance between camera and gizmos if scale(size, scalepoint) would be performed\r\n        //check min and max distance\r\n\r\n        xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance);\r\n        const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5); //calculate new fov\r\n\r\n        let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2); //check min and max fov\r\n\r\n        newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov);\r\n        const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\r\n        size = x / newDistance;\r\n\r\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState);\r\n\r\n        this.setFov(newFov);\r\n        this.applyTransformMatrix(this.applyScale(size, this._v3_2, false)); //adjusting distance\r\n\r\n        const direction = this._gizmos.position.clone().sub(this.camera.position).normalize().multiplyScalar(newDistance / x);\r\n\r\n        this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\r\n\r\n        this.dispatchEvent(_changeEvent);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onTriplePanEnd\", () => {\r\n      this.updateTbState(STATE.IDLE, false);\r\n      this.dispatchEvent(_endEvent); //this.dispatchEvent( _changeEvent );\r\n    });\r\n\r\n    _defineProperty(this, \"setCenter\", (clientX, clientY) => {\r\n      _center.x = clientX;\r\n      _center.y = clientY;\r\n    });\r\n\r\n    _defineProperty(this, \"initializeMouseActions\", () => {\r\n      this.setMouseAction('PAN', 0, 'CTRL');\r\n      this.setMouseAction('PAN', 2);\r\n      this.setMouseAction('ROTATE', 0);\r\n      this.setMouseAction('ZOOM', 'WHEEL');\r\n      this.setMouseAction('ZOOM', 1);\r\n      this.setMouseAction('FOV', 'WHEEL', 'SHIFT');\r\n      this.setMouseAction('FOV', 1, 'SHIFT');\r\n    });\r\n\r\n    _defineProperty(this, \"setMouseAction\", (operation, mouse, key = null) => {\r\n      const operationInput = ['PAN', 'ROTATE', 'ZOOM', 'FOV'];\r\n      const mouseInput = [0, 1, 2, 'WHEEL'];\r\n      const keyInput = ['CTRL', 'SHIFT', null];\r\n      let state;\r\n\r\n      if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {\r\n        //invalid parameters\r\n        return false;\r\n      }\r\n\r\n      if (mouse == 'WHEEL') {\r\n        if (operation != 'ZOOM' && operation != 'FOV') {\r\n          //cannot associate 2D operation to 1D input\r\n          return false;\r\n        }\r\n      }\r\n\r\n      switch (operation) {\r\n        case 'PAN':\r\n          state = STATE.PAN;\r\n          break;\r\n\r\n        case 'ROTATE':\r\n          state = STATE.ROTATE;\r\n          break;\r\n\r\n        case 'ZOOM':\r\n          state = STATE.SCALE;\r\n          break;\r\n\r\n        case 'FOV':\r\n          state = STATE.FOV;\r\n          break;\r\n      }\r\n\r\n      const action = {\r\n        operation: operation,\r\n        mouse: mouse,\r\n        key: key,\r\n        state: state\r\n      };\r\n\r\n      for (let i = 0; i < this.mouseActions.length; i++) {\r\n        if (this.mouseActions[i].mouse == action.mouse && this.mouseActions[i].key == action.key) {\r\n          this.mouseActions.splice(i, 1, action);\r\n          return true;\r\n        }\r\n      }\r\n\r\n      this.mouseActions.push(action);\r\n      return true;\r\n    });\r\n\r\n    _defineProperty(this, \"getOpFromAction\", (mouse, key) => {\r\n      let action;\r\n\r\n      for (let i = 0; i < this.mouseActions.length; i++) {\r\n        action = this.mouseActions[i];\r\n\r\n        if (action.mouse == mouse && action.key == key) {\r\n          return action.operation;\r\n        }\r\n      }\r\n\r\n      if (key) {\r\n        for (let i = 0; i < this.mouseActions.length; i++) {\r\n          action = this.mouseActions[i];\r\n\r\n          if (action.mouse == mouse && action.key == null) {\r\n            return action.operation;\r\n          }\r\n        }\r\n      }\r\n\r\n      return null;\r\n    });\r\n\r\n    _defineProperty(this, \"getOpStateFromAction\", (mouse, key) => {\r\n      let action;\r\n\r\n      for (let i = 0; i < this.mouseActions.length; i++) {\r\n        action = this.mouseActions[i];\r\n\r\n        if (action.mouse == mouse && action.key == key) {\r\n          return action.state;\r\n        }\r\n      }\r\n\r\n      if (key) {\r\n        for (let i = 0; i < this.mouseActions.length; i++) {\r\n          action = this.mouseActions[i];\r\n\r\n          if (action.mouse == mouse && action.key == null) {\r\n            return action.state;\r\n          }\r\n        }\r\n      }\r\n\r\n      return null;\r\n    });\r\n\r\n    _defineProperty(this, \"getAngle\", (p1, p2) => {\r\n      return Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180 / Math.PI;\r\n    });\r\n\r\n    _defineProperty(this, \"updateTouchEvent\", event => {\r\n      for (let i = 0; i < this._touchCurrent.length; i++) {\r\n        if (this._touchCurrent[i].pointerId == event.pointerId) {\r\n          this._touchCurrent.splice(i, 1, event);\r\n\r\n          break;\r\n        }\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"calculateAngularSpeed\", (p0, p1, t0, t1) => {\r\n      const s = p1 - p0;\r\n      const t = (t1 - t0) / 1000;\r\n\r\n      if (t == 0) {\r\n        return 0;\r\n      }\r\n\r\n      return s / t;\r\n    });\r\n\r\n    _defineProperty(this, \"calculatePointersDistance\", (p0, p1) => {\r\n      return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2));\r\n    });\r\n\r\n    _defineProperty(this, \"calculateRotationAxis\", (vec1, vec2) => {\r\n      this._rotationMatrix.extractRotation(this._cameraMatrixState);\r\n\r\n      this._quat.setFromRotationMatrix(this._rotationMatrix);\r\n\r\n      this._rotationAxis.crossVectors(vec1, vec2).applyQuaternion(this._quat);\r\n\r\n      return this._rotationAxis.normalize().clone();\r\n    });\r\n\r\n    _defineProperty(this, \"calculateTbRadius\", camera => {\r\n      const factor = 0.67;\r\n      const distance = camera.position.distanceTo(this._gizmos.position);\r\n\r\n      if (camera.type == 'PerspectiveCamera') {\r\n        const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5; //vertical fov/2 in radians\r\n\r\n        const halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV)); //horizontal fov/2 in radians\r\n\r\n        return Math.tan(Math.min(halfFovV, halfFovH)) * distance * factor;\r\n      } else if (camera.type == 'OrthographicCamera') {\r\n        return Math.min(camera.top, camera.right) * factor;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"focus\", (point, size, amount = 1) => {\r\n      if (this.camera) {\r\n        const focusPoint = point.clone(); //move center of camera (along with gizmos) towards point of interest\r\n\r\n        focusPoint.sub(this._gizmos.position).multiplyScalar(amount);\r\n\r\n        this._translationMatrix.makeTranslation(focusPoint.x, focusPoint.y, focusPoint.z);\r\n\r\n        const gizmoStateTemp = this._gizmoMatrixState.clone();\r\n\r\n        this._gizmoMatrixState.premultiply(this._translationMatrix);\r\n\r\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\r\n\r\n        const cameraStateTemp = this._cameraMatrixState.clone();\r\n\r\n        this._cameraMatrixState.premultiply(this._translationMatrix);\r\n\r\n        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale); //apply zoom\r\n\r\n\r\n        if (this.enableZoom) {\r\n          this.applyTransformMatrix(this.applyScale(size, this._gizmos.position));\r\n        }\r\n\r\n        this._gizmoMatrixState.copy(gizmoStateTemp);\r\n\r\n        this._cameraMatrixState.copy(cameraStateTemp);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"drawGrid\", () => {\r\n      if (this.scene) {\r\n        var _this$camera9, _this$camera10;\r\n\r\n        const color = 0x888888;\r\n        const multiplier = 3;\r\n        let size, divisions, maxLength, tick;\r\n\r\n        if (((_this$camera9 = this.camera) === null || _this$camera9 === void 0 ? void 0 : _this$camera9.type) === 'OrthographicCamera') {\r\n          const width = this.camera.right - this.camera.left;\r\n          const height = this.camera.bottom - this.camera.top;\r\n          maxLength = Math.max(width, height);\r\n          tick = maxLength / 20;\r\n          size = maxLength / this.camera.zoom * multiplier;\r\n          divisions = size / tick * this.camera.zoom;\r\n        } else if (((_this$camera10 = this.camera) === null || _this$camera10 === void 0 ? void 0 : _this$camera10.type) === 'PerspectiveCamera') {\r\n          const distance = this.camera.position.distanceTo(this._gizmos.position);\r\n          const halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5;\r\n          const halfFovH = Math.atan(this.camera.aspect * Math.tan(halfFovV));\r\n          maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance * 2;\r\n          tick = maxLength / 20;\r\n          size = maxLength * multiplier;\r\n          divisions = size / tick;\r\n        }\r\n\r\n        if (this._grid == null && this.camera) {\r\n          this._grid = new GridHelper(size, divisions, color, color);\r\n\r\n          this._grid.position.copy(this._gizmos.position);\r\n\r\n          this._gridPosition.copy(this._grid.position);\r\n\r\n          this._grid.quaternion.copy(this.camera.quaternion);\r\n\r\n          this._grid.rotateX(Math.PI * 0.5);\r\n\r\n          this.scene.add(this._grid);\r\n        }\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"connect\", domElement => {\r\n      // https://github.com/mrdoob/three.js/issues/20575\r\n      if (domElement === document) {\r\n        console.error('THREE.ArcballControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\r\n      }\r\n\r\n      this.domElement = domElement; // disables touch scroll\r\n      // touch-action needs to be defined for pointer events to work on mobile\r\n      // https://stackoverflow.com/a/48254578\r\n\r\n      this.domElement.style.touchAction = 'none';\r\n      this.domElement.addEventListener('contextmenu', this.onContextMenu);\r\n      this.domElement.addEventListener('pointerdown', this.onPointerDown);\r\n      this.domElement.addEventListener('pointercancel', this.onPointerCancel);\r\n      this.domElement.addEventListener('wheel', this.onWheel);\r\n    });\r\n\r\n    _defineProperty(this, \"dispose\", () => {\r\n      var _this$domElement, _this$domElement2, _this$domElement3, _this$domElement4, _this$scene;\r\n\r\n      if (this._animationId != -1) {\r\n        window.cancelAnimationFrame(this._animationId);\r\n      }\r\n\r\n      (_this$domElement = this.domElement) === null || _this$domElement === void 0 ? void 0 : _this$domElement.removeEventListener('pointerdown', this.onPointerDown);\r\n      (_this$domElement2 = this.domElement) === null || _this$domElement2 === void 0 ? void 0 : _this$domElement2.removeEventListener('pointercancel', this.onPointerCancel);\r\n      (_this$domElement3 = this.domElement) === null || _this$domElement3 === void 0 ? void 0 : _this$domElement3.removeEventListener('wheel', this.onWheel);\r\n      (_this$domElement4 = this.domElement) === null || _this$domElement4 === void 0 ? void 0 : _this$domElement4.removeEventListener('contextmenu', this.onContextMenu);\r\n      window.removeEventListener('pointermove', this.onPointerMove);\r\n      window.removeEventListener('pointerup', this.onPointerUp);\r\n      window.removeEventListener('resize', this.onWindowResize);\r\n      (_this$scene = this.scene) === null || _this$scene === void 0 ? void 0 : _this$scene.remove(this._gizmos);\r\n      this.disposeGrid();\r\n    });\r\n\r\n    _defineProperty(this, \"disposeGrid\", () => {\r\n      if (this._grid && this.scene) {\r\n        this.scene.remove(this._grid);\r\n        this._grid = null;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"easeOutCubic\", t => {\r\n      return 1 - Math.pow(1 - t, 3);\r\n    });\r\n\r\n    _defineProperty(this, \"activateGizmos\", isActive => {\r\n      for (const gizmo of this._gizmos.children) {\r\n        gizmo.material.setValues({\r\n          opacity: isActive ? 1 : 0.6\r\n        });\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"getCursorNDC\", (cursorX, cursorY, canvas) => {\r\n      const canvasRect = canvas.getBoundingClientRect();\r\n\r\n      this._v2_1.setX((cursorX - canvasRect.left) / canvasRect.width * 2 - 1);\r\n\r\n      this._v2_1.setY((canvasRect.bottom - cursorY) / canvasRect.height * 2 - 1);\r\n\r\n      return this._v2_1.clone();\r\n    });\r\n\r\n    _defineProperty(this, \"getCursorPosition\", (cursorX, cursorY, canvas) => {\r\n      var _this$camera11;\r\n\r\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\r\n\r\n      if (((_this$camera11 = this.camera) === null || _this$camera11 === void 0 ? void 0 : _this$camera11.type) === 'OrthographicCamera') {\r\n        this._v2_1.x *= (this.camera.right - this.camera.left) * 0.5;\r\n        this._v2_1.y *= (this.camera.top - this.camera.bottom) * 0.5;\r\n      }\r\n\r\n      return this._v2_1.clone();\r\n    });\r\n\r\n    _defineProperty(this, \"setCamera\", camera => {\r\n      if (camera) {\r\n        camera.lookAt(this.target);\r\n        camera.updateMatrix(); //setting state\r\n\r\n        if ((camera === null || camera === void 0 ? void 0 : camera.type) == 'PerspectiveCamera') {\r\n          this._fov0 = camera.fov;\r\n          this._fovState = camera.fov;\r\n        }\r\n\r\n        this._cameraMatrixState0.copy(camera.matrix);\r\n\r\n        this._cameraMatrixState.copy(this._cameraMatrixState0);\r\n\r\n        this._cameraProjectionState.copy(camera.projectionMatrix);\r\n\r\n        this._zoom0 = camera.zoom;\r\n        this._zoomState = this._zoom0;\r\n        this._initialNear = camera.near;\r\n        this._nearPos0 = camera.position.distanceTo(this.target) - camera.near;\r\n        this._nearPos = this._initialNear;\r\n        this._initialFar = camera.far;\r\n        this._farPos0 = camera.position.distanceTo(this.target) - camera.far;\r\n        this._farPos = this._initialFar;\r\n\r\n        this._up0.copy(camera.up);\r\n\r\n        this._upState.copy(camera.up);\r\n\r\n        this.camera = camera;\r\n        this.camera.updateProjectionMatrix(); //making gizmos\r\n\r\n        const tbRadius = this.calculateTbRadius(camera);\r\n\r\n        if (tbRadius !== undefined) {\r\n          this._tbRadius = tbRadius;\r\n        }\r\n\r\n        this.makeGizmos(this.target, this._tbRadius);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"makeGizmos\", (tbCenter, tbRadius) => {\r\n      // @ts-expect-error\r\n      const curve = new EllipseCurve(0, 0, tbRadius, tbRadius);\r\n      const points = curve.getPoints(this._curvePts); //geometry\r\n\r\n      const curveGeometry = new BufferGeometry().setFromPoints(points); //material\r\n\r\n      const curveMaterialX = new LineBasicMaterial({\r\n        color: 0xff8080,\r\n        fog: false,\r\n        transparent: true,\r\n        opacity: 0.6\r\n      });\r\n      const curveMaterialY = new LineBasicMaterial({\r\n        color: 0x80ff80,\r\n        fog: false,\r\n        transparent: true,\r\n        opacity: 0.6\r\n      });\r\n      const curveMaterialZ = new LineBasicMaterial({\r\n        color: 0x8080ff,\r\n        fog: false,\r\n        transparent: true,\r\n        opacity: 0.6\r\n      }); //line\r\n\r\n      const gizmoX = new Line(curveGeometry, curveMaterialX);\r\n      const gizmoY = new Line(curveGeometry, curveMaterialY);\r\n      const gizmoZ = new Line(curveGeometry, curveMaterialZ);\r\n      const rotation = Math.PI * 0.5;\r\n      gizmoX.rotation.x = rotation;\r\n      gizmoY.rotation.y = rotation; //setting state\r\n\r\n      this._gizmoMatrixState0.identity().setPosition(tbCenter);\r\n\r\n      this._gizmoMatrixState.copy(this._gizmoMatrixState0);\r\n\r\n      if (this.camera && this.camera.zoom != 1) {\r\n        //adapt gizmos size to camera zoom\r\n        const size = 1 / this.camera.zoom;\r\n\r\n        this._scaleMatrix.makeScale(size, size, size);\r\n\r\n        this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z);\r\n\r\n        this._gizmoMatrixState.premultiply(this._translationMatrix).premultiply(this._scaleMatrix);\r\n\r\n        this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z);\r\n\r\n        this._gizmoMatrixState.premultiply(this._translationMatrix);\r\n      }\r\n\r\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\r\n\r\n      this._gizmos.clear();\r\n\r\n      this._gizmos.add(gizmoX);\r\n\r\n      this._gizmos.add(gizmoY);\r\n\r\n      this._gizmos.add(gizmoZ);\r\n    });\r\n\r\n    _defineProperty(this, \"onFocusAnim\", (time, point, cameraMatrix, gizmoMatrix) => {\r\n      if (this._timeStart == -1) {\r\n        //animation start\r\n        this._timeStart = time;\r\n      }\r\n\r\n      if (this._state == STATE.ANIMATION_FOCUS) {\r\n        const deltaTime = time - this._timeStart;\r\n        const animTime = deltaTime / this.focusAnimationTime;\r\n\r\n        this._gizmoMatrixState.copy(gizmoMatrix);\r\n\r\n        if (animTime >= 1) {\r\n          //animation end\r\n          this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\r\n\r\n          this.focus(point, this.scaleFactor);\r\n          this._timeStart = -1;\r\n          this.updateTbState(STATE.IDLE, false);\r\n          this.activateGizmos(false);\r\n          this.dispatchEvent(_changeEvent);\r\n        } else {\r\n          const amount = this.easeOutCubic(animTime);\r\n          const size = 1 - amount + this.scaleFactor * amount;\r\n\r\n          this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\r\n\r\n          this.focus(point, size, amount);\r\n          this.dispatchEvent(_changeEvent);\r\n          const self = this;\r\n          this._animationId = window.requestAnimationFrame(function (t) {\r\n            self.onFocusAnim(t, point, cameraMatrix, gizmoMatrix.clone());\r\n          });\r\n        }\r\n      } else {\r\n        //interrupt animation\r\n        this._animationId = -1;\r\n        this._timeStart = -1;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"onRotationAnim\", (time, rotationAxis, w0) => {\r\n      if (this._timeStart == -1) {\r\n        //animation start\r\n        this._anglePrev = 0;\r\n        this._angleCurrent = 0;\r\n        this._timeStart = time;\r\n      }\r\n\r\n      if (this._state == STATE.ANIMATION_ROTATE) {\r\n        //w = w0 + alpha * t\r\n        const deltaTime = (time - this._timeStart) / 1000;\r\n        const w = w0 + -this.dampingFactor * deltaTime;\r\n\r\n        if (w > 0) {\r\n          //tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\r\n          this._angleCurrent = 0.5 * -this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0;\r\n          this.applyTransformMatrix(this.rotate(rotationAxis, this._angleCurrent));\r\n          this.dispatchEvent(_changeEvent);\r\n          const self = this;\r\n          this._animationId = window.requestAnimationFrame(function (t) {\r\n            self.onRotationAnim(t, rotationAxis, w0);\r\n          });\r\n        } else {\r\n          this._animationId = -1;\r\n          this._timeStart = -1;\r\n          this.updateTbState(STATE.IDLE, false);\r\n          this.activateGizmos(false);\r\n          this.dispatchEvent(_changeEvent);\r\n        }\r\n      } else {\r\n        //interrupt animation\r\n        this._animationId = -1;\r\n        this._timeStart = -1;\r\n\r\n        if (this._state != STATE.ROTATE) {\r\n          this.activateGizmos(false);\r\n          this.dispatchEvent(_changeEvent);\r\n        }\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"pan\", (p0, p1, adjust = false) => {\r\n      if (this.camera) {\r\n        const movement = p0.clone().sub(p1);\r\n\r\n        if (this.camera.type === 'OrthographicCamera') {\r\n          //adjust movement amount\r\n          movement.multiplyScalar(1 / this.camera.zoom);\r\n        }\r\n\r\n        if (this.camera.type === 'PerspectiveCamera' && adjust) {\r\n          //adjust movement amount\r\n          this._v3_1.setFromMatrixPosition(this._cameraMatrixState0); //camera's initial position\r\n\r\n\r\n          this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0); //gizmo's initial position\r\n\r\n\r\n          const distanceFactor = this._v3_1.distanceTo(this._v3_2) / this.camera.position.distanceTo(this._gizmos.position);\r\n          movement.multiplyScalar(1 / distanceFactor);\r\n        }\r\n\r\n        this._v3_1.set(movement.x, movement.y, 0).applyQuaternion(this.camera.quaternion);\r\n\r\n        this._m4_1.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z);\r\n\r\n        this.setTransformationMatrices(this._m4_1, this._m4_1);\r\n      }\r\n\r\n      return _transformation;\r\n    });\r\n\r\n    _defineProperty(this, \"reset\", () => {\r\n      if (this.camera) {\r\n        this.camera.zoom = this._zoom0;\r\n\r\n        if (this.camera.type === 'PerspectiveCamera') {\r\n          this.camera.fov = this._fov0;\r\n        }\r\n\r\n        this.camera.near = this._nearPos;\r\n        this.camera.far = this._farPos;\r\n\r\n        this._cameraMatrixState.copy(this._cameraMatrixState0);\r\n\r\n        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\r\n\r\n        this.camera.up.copy(this._up0);\r\n        this.camera.updateMatrix();\r\n        this.camera.updateProjectionMatrix();\r\n\r\n        this._gizmoMatrixState.copy(this._gizmoMatrixState0);\r\n\r\n        this._gizmoMatrixState0.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\r\n\r\n        this._gizmos.updateMatrix();\r\n\r\n        const tbRadius = this.calculateTbRadius(this.camera);\r\n\r\n        if (tbRadius !== undefined) {\r\n          this._tbRadius = tbRadius;\r\n        }\r\n\r\n        this.makeGizmos(this._gizmos.position, this._tbRadius);\r\n        this.camera.lookAt(this._gizmos.position);\r\n        this.updateTbState(STATE.IDLE, false);\r\n        this.dispatchEvent(_changeEvent);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"rotate\", (axis, angle) => {\r\n      const point = this._gizmos.position; //rotation center\r\n\r\n      this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\r\n\r\n      this._rotationMatrix.makeRotationAxis(axis, -angle); //rotate camera\r\n\r\n\r\n      this._m4_1.makeTranslation(point.x, point.y, point.z);\r\n\r\n      this._m4_1.multiply(this._rotationMatrix);\r\n\r\n      this._m4_1.multiply(this._translationMatrix);\r\n\r\n      this.setTransformationMatrices(this._m4_1);\r\n      return _transformation;\r\n    });\r\n\r\n    _defineProperty(this, \"copyState\", () => {\r\n      if (this.camera) {\r\n        var _this$camera12;\r\n\r\n        const state = JSON.stringify(((_this$camera12 = this.camera) === null || _this$camera12 === void 0 ? void 0 : _this$camera12.type) === 'OrthographicCamera' ? {\r\n          arcballState: {\r\n            cameraFar: this.camera.far,\r\n            cameraMatrix: this.camera.matrix,\r\n            cameraNear: this.camera.near,\r\n            cameraUp: this.camera.up,\r\n            cameraZoom: this.camera.zoom,\r\n            gizmoMatrix: this._gizmos.matrix\r\n          }\r\n        } : {\r\n          arcballState: {\r\n            cameraFar: this.camera.far,\r\n            cameraFov: this.camera.fov,\r\n            cameraMatrix: this.camera.matrix,\r\n            cameraNear: this.camera.near,\r\n            cameraUp: this.camera.up,\r\n            cameraZoom: this.camera.zoom,\r\n            gizmoMatrix: this._gizmos.matrix\r\n          }\r\n        });\r\n        navigator.clipboard.writeText(state);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"pasteState\", () => {\r\n      const self = this;\r\n      navigator.clipboard.readText().then(function resolved(value) {\r\n        self.setStateFromJSON(value);\r\n      });\r\n    });\r\n\r\n    _defineProperty(this, \"saveState\", () => {\r\n      if (!this.camera) return;\r\n\r\n      this._cameraMatrixState0.copy(this.camera.matrix);\r\n\r\n      this._gizmoMatrixState0.copy(this._gizmos.matrix);\r\n\r\n      this._nearPos = this.camera.near;\r\n      this._farPos = this.camera.far;\r\n      this._zoom0 = this.camera.zoom;\r\n\r\n      this._up0.copy(this.camera.up);\r\n\r\n      if (this.camera.type === 'PerspectiveCamera') {\r\n        this._fov0 = this.camera.fov;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"applyScale\", (size, point, scaleGizmos = true) => {\r\n      if (!this.camera) return;\r\n      const scalePoint = point.clone();\r\n      let sizeInverse = 1 / size;\r\n\r\n      if (this.camera.type === 'OrthographicCamera') {\r\n        //camera zoom\r\n        this.camera.zoom = this._zoomState;\r\n        this.camera.zoom *= size; //check min and max zoom\r\n\r\n        if (this.camera.zoom > this.maxZoom) {\r\n          this.camera.zoom = this.maxZoom;\r\n          sizeInverse = this._zoomState / this.maxZoom;\r\n        } else if (this.camera.zoom < this.minZoom) {\r\n          this.camera.zoom = this.minZoom;\r\n          sizeInverse = this._zoomState / this.minZoom;\r\n        }\r\n\r\n        this.camera.updateProjectionMatrix();\r\n\r\n        this._v3_1.setFromMatrixPosition(this._gizmoMatrixState); //gizmos position\r\n        //scale gizmos so they appear in the same spot having the same dimension\r\n\r\n\r\n        this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\r\n\r\n        this._translationMatrix.makeTranslation(-this._v3_1.x, -this._v3_1.y, -this._v3_1.z);\r\n\r\n        this._m4_2.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z).multiply(this._scaleMatrix);\r\n\r\n        this._m4_2.multiply(this._translationMatrix); //move camera and gizmos to obtain pinch effect\r\n\r\n\r\n        scalePoint.sub(this._v3_1);\r\n        const amount = scalePoint.clone().multiplyScalar(sizeInverse);\r\n        scalePoint.sub(amount);\r\n\r\n        this._m4_1.makeTranslation(scalePoint.x, scalePoint.y, scalePoint.z);\r\n\r\n        this._m4_2.premultiply(this._m4_1);\r\n\r\n        this.setTransformationMatrices(this._m4_1, this._m4_2);\r\n        return _transformation;\r\n      }\r\n\r\n      if (this.camera.type === 'PerspectiveCamera') {\r\n        this._v3_1.setFromMatrixPosition(this._cameraMatrixState);\r\n\r\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState); //move camera\r\n\r\n\r\n        let distance = this._v3_1.distanceTo(scalePoint);\r\n\r\n        let amount = distance - distance * sizeInverse; //check min and max distance\r\n\r\n        const newDistance = distance - amount;\r\n\r\n        if (newDistance < this.minDistance) {\r\n          sizeInverse = this.minDistance / distance;\r\n          amount = distance - distance * sizeInverse;\r\n        } else if (newDistance > this.maxDistance) {\r\n          sizeInverse = this.maxDistance / distance;\r\n          amount = distance - distance * sizeInverse;\r\n        }\r\n\r\n        let direction = scalePoint.clone().sub(this._v3_1).normalize().multiplyScalar(amount);\r\n\r\n        this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\r\n\r\n        if (scaleGizmos) {\r\n          //scale gizmos so they appear in the same spot having the same dimension\r\n          const pos = this._v3_2;\r\n          distance = pos.distanceTo(scalePoint);\r\n          amount = distance - distance * sizeInverse;\r\n          direction = scalePoint.clone().sub(this._v3_2).normalize().multiplyScalar(amount);\r\n\r\n          this._translationMatrix.makeTranslation(pos.x, pos.y, pos.z);\r\n\r\n          this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\r\n\r\n          this._m4_2.makeTranslation(direction.x, direction.y, direction.z).multiply(this._translationMatrix);\r\n\r\n          this._m4_2.multiply(this._scaleMatrix);\r\n\r\n          this._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z);\r\n\r\n          this._m4_2.multiply(this._translationMatrix);\r\n\r\n          this.setTransformationMatrices(this._m4_1, this._m4_2);\r\n        } else {\r\n          this.setTransformationMatrices(this._m4_1);\r\n        }\r\n\r\n        return _transformation;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"setFov\", value => {\r\n      var _this$camera13;\r\n\r\n      if (((_this$camera13 = this.camera) === null || _this$camera13 === void 0 ? void 0 : _this$camera13.type) === 'PerspectiveCamera') {\r\n        this.camera.fov = MathUtils.clamp(value, this.minFov, this.maxFov);\r\n        this.camera.updateProjectionMatrix();\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"setTarget\", (x, y, z) => {\r\n      if (this.camera) {\r\n        this.target.set(x, y, z);\r\n\r\n        this._gizmos.position.set(x, y, z); //for correct radius calculation\r\n\r\n\r\n        const tbRadius = this.calculateTbRadius(this.camera);\r\n\r\n        if (tbRadius !== undefined) {\r\n          this._tbRadius = tbRadius;\r\n        }\r\n\r\n        this.makeGizmos(this.target, this._tbRadius);\r\n        this.camera.lookAt(this.target);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"zRotate\", (point, angle) => {\r\n      this._rotationMatrix.makeRotationAxis(this._rotationAxis, angle);\r\n\r\n      this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\r\n\r\n      this._m4_1.makeTranslation(point.x, point.y, point.z);\r\n\r\n      this._m4_1.multiply(this._rotationMatrix);\r\n\r\n      this._m4_1.multiply(this._translationMatrix);\r\n\r\n      this._v3_1.setFromMatrixPosition(this._gizmoMatrixState).sub(point); //vector from rotation center to gizmos position\r\n\r\n\r\n      this._v3_2.copy(this._v3_1).applyAxisAngle(this._rotationAxis, angle); //apply rotation\r\n\r\n\r\n      this._v3_2.sub(this._v3_1);\r\n\r\n      this._m4_2.makeTranslation(this._v3_2.x, this._v3_2.y, this._v3_2.z);\r\n\r\n      this.setTransformationMatrices(this._m4_1, this._m4_2);\r\n      return _transformation;\r\n    });\r\n\r\n    _defineProperty(this, \"unprojectOnObj\", (cursor, camera) => {\r\n      if (!this.scene) return null;\r\n      const raycaster = new Raycaster();\r\n      raycaster.near = camera.near;\r\n      raycaster.far = camera.far;\r\n      raycaster.setFromCamera(cursor, camera);\r\n      const intersect = raycaster.intersectObjects(this.scene.children, true);\r\n\r\n      for (let i = 0; i < intersect.length; i++) {\r\n        if (intersect[i].object.uuid != this._gizmos.uuid && intersect[i].face) {\r\n          return intersect[i].point.clone();\r\n        }\r\n      }\r\n\r\n      return null;\r\n    });\r\n\r\n    _defineProperty(this, \"unprojectOnTbSurface\", (camera, cursorX, cursorY, canvas, tbRadius) => {\r\n      if (camera.type == 'OrthographicCamera') {\r\n        this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\r\n\r\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\r\n\r\n        const x2 = Math.pow(this._v2_1.x, 2);\r\n        const y2 = Math.pow(this._v2_1.y, 2);\r\n        const r2 = Math.pow(this._tbRadius, 2);\r\n\r\n        if (x2 + y2 <= r2 * 0.5) {\r\n          //intersection with sphere\r\n          this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)));\r\n        } else {\r\n          //intersection with hyperboloid\r\n          this._v3_1.setZ(r2 * 0.5 / Math.sqrt(x2 + y2));\r\n        }\r\n\r\n        return this._v3_1;\r\n      }\r\n\r\n      if (camera.type == 'PerspectiveCamera') {\r\n        //unproject cursor on the near plane\r\n        this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas));\r\n\r\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\r\n\r\n        this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\r\n\r\n        const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\r\n\r\n\r\n        const cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\r\n        const radius2 = Math.pow(tbRadius, 2); //\t  camera\r\n        //\t\t|\\\r\n        //\t\t| \\\r\n        //\t\t|  \\\r\n        //\th\t|\t\\\r\n        //\t\t| \t \\\r\n        //\t\t| \t  \\\r\n        //\t_ _ | _ _ _\\ _ _  near plane\r\n        //\t\t\tl\r\n\r\n        const h = this._v3_1.z;\r\n        const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\r\n\r\n        if (l == 0) {\r\n          //ray aligned with camera\r\n          rayDir.set(this._v3_1.x, this._v3_1.y, tbRadius);\r\n          return rayDir;\r\n        }\r\n\r\n        const m = h / l;\r\n        const q = cameraGizmoDistance;\r\n        /*\r\n         * calculate intersection point between unprojected ray and trackball surface\r\n         *|y = m * x + q\r\n         *|x^2 + y^2 = r^2\r\n         *\r\n         * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\r\n         */\r\n\r\n        let a = Math.pow(m, 2) + 1;\r\n        let b = 2 * m * q;\r\n        let c = Math.pow(q, 2) - radius2;\r\n        let delta = Math.pow(b, 2) - 4 * a * c;\r\n\r\n        if (delta >= 0) {\r\n          //intersection with sphere\r\n          this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\r\n\r\n          this._v2_1.setY(m * this._v2_1.x + q);\r\n\r\n          const angle = MathUtils.RAD2DEG * this._v2_1.angle();\r\n\r\n          if (angle >= 45) {\r\n            //if angle between intersection point and X' axis is >= 45°, return that point\r\n            //otherwise, calculate intersection point with hyperboloid\r\n            const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\r\n            rayDir.multiplyScalar(rayLength);\r\n            rayDir.z += cameraGizmoDistance;\r\n            return rayDir;\r\n          }\r\n        } //intersection with hyperboloid\r\n\r\n        /*\r\n         *|y = m * x + q\r\n         *|y = (1 / x) * (r^2 / 2)\r\n         *\r\n         * m * x^2 + q * x - r^2 / 2 = 0\r\n         */\r\n\r\n\r\n        a = m;\r\n        b = q;\r\n        c = -radius2 * 0.5;\r\n        delta = Math.pow(b, 2) - 4 * a * c;\r\n\r\n        this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\r\n\r\n        this._v2_1.setY(m * this._v2_1.x + q);\r\n\r\n        const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2));\r\n        rayDir.multiplyScalar(rayLength);\r\n        rayDir.z += cameraGizmoDistance;\r\n        return rayDir;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"unprojectOnTbPlane\", (camera, cursorX, cursorY, canvas, initialDistance = false) => {\r\n      if (camera.type == 'OrthographicCamera') {\r\n        this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas));\r\n\r\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, 0);\r\n\r\n        return this._v3_1.clone();\r\n      }\r\n\r\n      if (camera.type == 'PerspectiveCamera') {\r\n        this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas)); //unproject cursor on the near plane\r\n\r\n\r\n        this._v3_1.set(this._v2_1.x, this._v2_1.y, -1);\r\n\r\n        this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\r\n\r\n        const rayDir = this._v3_1.clone().normalize(); //unprojected ray direction\r\n        //\t  camera\r\n        //\t\t|\\\r\n        //\t\t| \\\r\n        //\t\t|  \\\r\n        //\th\t|\t\\\r\n        //\t\t| \t \\\r\n        //\t\t| \t  \\\r\n        //\t_ _ | _ _ _\\ _ _  near plane\r\n        //\t\t\tl\r\n\r\n\r\n        const h = this._v3_1.z;\r\n        const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2));\r\n        let cameraGizmoDistance;\r\n\r\n        if (initialDistance) {\r\n          cameraGizmoDistance = this._v3_1.setFromMatrixPosition(this._cameraMatrixState0).distanceTo(this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0));\r\n        } else {\r\n          cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position);\r\n        }\r\n        /*\r\n         * calculate intersection point between unprojected ray and the plane\r\n         *|y = mx + q\r\n         *|y = 0\r\n         *\r\n         * x = -q/m\r\n         */\r\n\r\n\r\n        if (l == 0) {\r\n          //ray aligned with camera\r\n          rayDir.set(0, 0, 0);\r\n          return rayDir;\r\n        }\r\n\r\n        const m = h / l;\r\n        const q = cameraGizmoDistance;\r\n        const x = -q / m;\r\n        const rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2));\r\n        rayDir.multiplyScalar(rayLength);\r\n        rayDir.z = 0;\r\n        return rayDir;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"updateMatrixState\", () => {\r\n      if (!this.camera) return; //update camera and gizmos state\r\n\r\n      this._cameraMatrixState.copy(this.camera.matrix);\r\n\r\n      this._gizmoMatrixState.copy(this._gizmos.matrix);\r\n\r\n      if (this.camera.type === 'OrthographicCamera') {\r\n        this._cameraProjectionState.copy(this.camera.projectionMatrix);\r\n\r\n        this.camera.updateProjectionMatrix();\r\n        this._zoomState = this.camera.zoom;\r\n      }\r\n\r\n      if (this.camera.type === 'PerspectiveCamera') {\r\n        this._fovState = this.camera.fov;\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"updateTbState\", (newState, updateMatrices) => {\r\n      this._state = newState;\r\n\r\n      if (updateMatrices) {\r\n        this.updateMatrixState();\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"update\", () => {\r\n      const EPS = 0.000001; // Update target and gizmos state\r\n\r\n      if (!this.target.equals(this._currentTarget) && this.camera) {\r\n        this._gizmos.position.set(this.target.x, this.target.y, this.target.z); //for correct radius calculation\r\n\r\n\r\n        const tbRadius = this.calculateTbRadius(this.camera);\r\n\r\n        if (tbRadius !== undefined) {\r\n          this._tbRadius = tbRadius;\r\n        }\r\n\r\n        this.makeGizmos(this.target, this._tbRadius);\r\n\r\n        this._currentTarget.copy(this.target);\r\n      }\r\n\r\n      if (!this.camera) return; //check min/max parameters\r\n\r\n      if (this.camera.type === 'OrthographicCamera') {\r\n        //check zoom\r\n        if (this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom) {\r\n          const newZoom = MathUtils.clamp(this.camera.zoom, this.minZoom, this.maxZoom);\r\n          this.applyTransformMatrix(this.applyScale(newZoom / this.camera.zoom, this._gizmos.position, true));\r\n        }\r\n      }\r\n\r\n      if (this.camera.type === 'PerspectiveCamera') {\r\n        //check distance\r\n        const distance = this.camera.position.distanceTo(this._gizmos.position);\r\n\r\n        if (distance > this.maxDistance + EPS || distance < this.minDistance - EPS) {\r\n          const newDistance = MathUtils.clamp(distance, this.minDistance, this.maxDistance);\r\n          this.applyTransformMatrix(this.applyScale(newDistance / distance, this._gizmos.position));\r\n          this.updateMatrixState();\r\n        } //check fov\r\n\r\n\r\n        if (this.camera.fov < this.minFov || this.camera.fov > this.maxFov) {\r\n          this.camera.fov = MathUtils.clamp(this.camera.fov, this.minFov, this.maxFov);\r\n          this.camera.updateProjectionMatrix();\r\n        }\r\n\r\n        const oldRadius = this._tbRadius;\r\n        const tbRadius = this.calculateTbRadius(this.camera);\r\n\r\n        if (tbRadius !== undefined) {\r\n          this._tbRadius = tbRadius;\r\n        }\r\n\r\n        if (oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS) {\r\n          const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3;\r\n          const newRadius = this._tbRadius / scale; // @ts-expect-error\r\n\r\n          const curve = new EllipseCurve(0, 0, newRadius, newRadius);\r\n          const points = curve.getPoints(this._curvePts);\r\n          const curveGeometry = new BufferGeometry().setFromPoints(points);\r\n\r\n          for (const gizmo in this._gizmos.children) {\r\n            const child = this._gizmos.children[gizmo];\r\n            child.geometry = curveGeometry;\r\n          }\r\n        }\r\n      }\r\n\r\n      this.camera.lookAt(this._gizmos.position);\r\n    });\r\n\r\n    _defineProperty(this, \"setStateFromJSON\", json => {\r\n      const state = JSON.parse(json);\r\n\r\n      if (state.arcballState && this.camera) {\r\n        this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements);\r\n\r\n        this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\r\n\r\n        this.camera.up.copy(state.arcballState.cameraUp);\r\n        this.camera.near = state.arcballState.cameraNear;\r\n        this.camera.far = state.arcballState.cameraFar;\r\n        this.camera.zoom = state.arcballState.cameraZoom;\r\n\r\n        if (this.camera.type === 'PerspectiveCamera') {\r\n          this.camera.fov = state.arcballState.cameraFov;\r\n        }\r\n\r\n        this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements);\r\n\r\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\r\n\r\n        this.camera.updateMatrix();\r\n        this.camera.updateProjectionMatrix();\r\n\r\n        this._gizmos.updateMatrix();\r\n\r\n        const tbRadius = this.calculateTbRadius(this.camera);\r\n\r\n        if (tbRadius !== undefined) {\r\n          this._tbRadius = tbRadius;\r\n        }\r\n\r\n        const gizmoTmp = new Matrix4().copy(this._gizmoMatrixState0);\r\n        this.makeGizmos(this._gizmos.position, this._tbRadius);\r\n\r\n        this._gizmoMatrixState0.copy(gizmoTmp);\r\n\r\n        this.camera.lookAt(this._gizmos.position);\r\n        this.updateTbState(STATE.IDLE, false);\r\n        this.dispatchEvent(_changeEvent);\r\n      }\r\n    });\r\n\r\n    this.camera = null;\r\n    this.domElement = _domElement;\r\n    this.scene = scene;\r\n    this.mouseActions = [];\r\n    this._mouseOp = null; //global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\r\n\r\n    this._v2_1 = new Vector2();\r\n    this._v3_1 = new Vector3();\r\n    this._v3_2 = new Vector3();\r\n    this._m4_1 = new Matrix4();\r\n    this._m4_2 = new Matrix4();\r\n    this._quat = new Quaternion(); //transformation matrices\r\n\r\n    this._translationMatrix = new Matrix4(); //matrix for translation operation\r\n\r\n    this._rotationMatrix = new Matrix4(); //matrix for rotation operation\r\n\r\n    this._scaleMatrix = new Matrix4(); //matrix for scaling operation\r\n\r\n    this._rotationAxis = new Vector3(); //axis for rotate operation\r\n    //camera state\r\n\r\n    this._cameraMatrixState = new Matrix4();\r\n    this._cameraProjectionState = new Matrix4();\r\n    this._fovState = 1;\r\n    this._upState = new Vector3();\r\n    this._zoomState = 1;\r\n    this._nearPos = 0;\r\n    this._farPos = 0;\r\n    this._gizmoMatrixState = new Matrix4(); //initial values\r\n\r\n    this._up0 = new Vector3();\r\n    this._zoom0 = 1;\r\n    this._fov0 = 0;\r\n    this._initialNear = 0;\r\n    this._nearPos0 = 0;\r\n    this._initialFar = 0;\r\n    this._farPos0 = 0;\r\n    this._cameraMatrixState0 = new Matrix4();\r\n    this._gizmoMatrixState0 = new Matrix4(); //pointers array\r\n\r\n    this._button = -1;\r\n    this._touchStart = [];\r\n    this._touchCurrent = [];\r\n    this._input = INPUT.NONE; //two fingers touch interaction\r\n\r\n    this._switchSensibility = 32; //minimum movement to be performed to fire single pan start after the second finger has been released\r\n\r\n    this._startFingerDistance = 0; //distance between two fingers\r\n\r\n    this._currentFingerDistance = 0;\r\n    this._startFingerRotation = 0; //amount of rotation performed with two fingers\r\n\r\n    this._currentFingerRotation = 0; //double tap\r\n\r\n    this._devPxRatio = 0;\r\n    this._downValid = true;\r\n    this._nclicks = 0;\r\n    this._downEvents = [];\r\n    this._clickStart = 0; //first click time\r\n\r\n    this._maxDownTime = 250;\r\n    this._maxInterval = 300;\r\n    this._posThreshold = 24;\r\n    this._movementThreshold = 24; //cursor positions\r\n\r\n    this._currentCursorPosition = new Vector3();\r\n    this._startCursorPosition = new Vector3(); //grid\r\n\r\n    this._grid = null; //grid to be visualized during pan operation\r\n\r\n    this._gridPosition = new Vector3(); //gizmos\r\n\r\n    this._gizmos = new Group();\r\n    this._curvePts = 128; //animations\r\n\r\n    this._timeStart = -1; //initial time\r\n\r\n    this._animationId = -1; //focus animation\r\n\r\n    this.focusAnimationTime = 500; //duration of focus animation in ms\r\n    //rotate animation\r\n\r\n    this._timePrev = 0; //time at which previous rotate operation has been detected\r\n\r\n    this._timeCurrent = 0; //time at which current rotate operation has been detected\r\n\r\n    this._anglePrev = 0; //angle of previous rotation\r\n\r\n    this._angleCurrent = 0; //angle of current rotation\r\n\r\n    this._cursorPosPrev = new Vector3(); //cursor position when previous rotate operation has been detected\r\n\r\n    this._cursorPosCurr = new Vector3(); //cursor position when current rotate operation has been detected\r\n\r\n    this._wPrev = 0; //angular velocity of the previous rotate operation\r\n\r\n    this._wCurr = 0; //angular velocity of the current rotate operation\r\n    //parameters\r\n\r\n    this.adjustNearFar = false;\r\n    this.scaleFactor = 1.1; //zoom/distance multiplier\r\n\r\n    this.dampingFactor = 25;\r\n    this.wMax = 20; //maximum angular velocity allowed\r\n\r\n    this.enableAnimations = true; //if animations should be performed\r\n\r\n    this.enableGrid = false; //if grid should be showed during pan operation\r\n\r\n    this.cursorZoom = false; //if wheel zoom should be cursor centered\r\n\r\n    this.minFov = 5;\r\n    this.maxFov = 90;\r\n    this.enabled = true;\r\n    this.enablePan = true;\r\n    this.enableRotate = true;\r\n    this.enableZoom = true;\r\n    this.minDistance = 0;\r\n    this.maxDistance = Infinity;\r\n    this.minZoom = 0;\r\n    this.maxZoom = Infinity; //trackball parameters\r\n\r\n    this.target = new Vector3(0, 0, 0);\r\n    this._currentTarget = new Vector3(0, 0, 0);\r\n    this._tbRadius = 1; //FSA\r\n\r\n    this._state = STATE.IDLE;\r\n    this.setCamera(_camera);\r\n\r\n    if (this.scene) {\r\n      this.scene.add(this._gizmos);\r\n    }\r\n\r\n    this._devPxRatio = window.devicePixelRatio;\r\n    this.initializeMouseActions();\r\n    if (this.domElement) this.connect(this.domElement);\r\n    window.addEventListener('resize', this.onWindowResize);\r\n  } //listeners\r\n\r\n\r\n  /**\r\n   * Apply a transformation matrix, to the camera and gizmos\r\n   * @param {Object} transformation Object containing matrices to apply to camera and gizmos\r\n   */\r\n  applyTransformMatrix(transformation) {\r\n    if (transformation !== null && transformation !== void 0 && transformation.camera && this.camera) {\r\n      this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera);\r\n\r\n      this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\r\n\r\n      this.camera.updateMatrix(); //update camera up vector\r\n\r\n      if (this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE) {\r\n        this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion);\r\n      }\r\n    }\r\n\r\n    if (transformation !== null && transformation !== void 0 && transformation.gizmos) {\r\n      this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos);\r\n\r\n      this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\r\n\r\n      this._gizmos.updateMatrix();\r\n    }\r\n\r\n    if ((this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS) && this.camera) {\r\n      const tbRadius = this.calculateTbRadius(this.camera);\r\n\r\n      if (tbRadius !== undefined) {\r\n        this._tbRadius = tbRadius;\r\n      }\r\n\r\n      if (this.adjustNearFar) {\r\n        const cameraDistance = this.camera.position.distanceTo(this._gizmos.position);\r\n        const bb = new Box3();\r\n        bb.setFromObject(this._gizmos);\r\n        const sphere = new Sphere();\r\n        bb.getBoundingSphere(sphere);\r\n        const adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length());\r\n        const regularNearPosition = cameraDistance - this._initialNear;\r\n        const minNearPos = Math.min(adjustedNearPosition, regularNearPosition);\r\n        this.camera.near = cameraDistance - minNearPos;\r\n        const adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length());\r\n        const regularFarPosition = cameraDistance - this._initialFar;\r\n        const minFarPos = Math.min(adjustedFarPosition, regularFarPosition);\r\n        this.camera.far = cameraDistance - minFarPos;\r\n        this.camera.updateProjectionMatrix();\r\n      } else {\r\n        let update = false;\r\n\r\n        if (this.camera.near != this._initialNear) {\r\n          this.camera.near = this._initialNear;\r\n          update = true;\r\n        }\r\n\r\n        if (this.camera.far != this._initialFar) {\r\n          this.camera.far = this._initialFar;\r\n          update = true;\r\n        }\r\n\r\n        if (update) {\r\n          this.camera.updateProjectionMatrix();\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Calculate the angular speed\r\n   * @param {Number} p0 Position at t0\r\n   * @param {Number} p1 Position at t1\r\n   * @param {Number} t0 Initial time in milliseconds\r\n   * @param {Number} t1 Ending time in milliseconds\r\n   */\r\n\r\n\r\n  /**\r\n   * Set gizmos visibility\r\n   * @param {Boolean} value Value of gizmos visibility\r\n   */\r\n  setGizmosVisible(value) {\r\n    this._gizmos.visible = value;\r\n    this.dispatchEvent(_changeEvent);\r\n  }\r\n  /**\r\n   * Creates the rotation gizmos matching trackball center and radius\r\n   * @param {Vector3} tbCenter The trackball center\r\n   * @param {number} tbRadius The trackball radius\r\n   */\r\n\r\n\r\n  /**\r\n   * Set values in transformation object\r\n   * @param {Matrix4} camera Transformation to be applied to the camera\r\n   * @param {Matrix4} gizmos Transformation to be applied to gizmos\r\n   */\r\n  setTransformationMatrices(camera = null, gizmos = null) {\r\n    if (camera) {\r\n      if (_transformation.camera) {\r\n        _transformation.camera.copy(camera);\r\n      } else {\r\n        _transformation.camera = camera.clone();\r\n      }\r\n    } else {\r\n      _transformation.camera = null;\r\n    }\r\n\r\n    if (gizmos) {\r\n      if (_transformation.gizmos) {\r\n        _transformation.gizmos.copy(gizmos);\r\n      } else {\r\n        _transformation.gizmos = gizmos.clone();\r\n      }\r\n    } else {\r\n      _transformation.gizmos = null;\r\n    }\r\n  }\r\n  /**\r\n   * Rotate camera around its direction axis passing by a given point by a given angle\r\n   * @param {Vector3} point The point where the rotation axis is passing trough\r\n   * @param {Number} angle Angle in radians\r\n   * @returns The computed transormation matix\r\n   */\r\n\r\n\r\n}\r\n\r\nexport { ArcballControls };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { OrthographicCamera, PlaneGeometry, Mesh } from 'three';\r\n\r\nclass Pass {\r\n  constructor() {\r\n    _defineProperty(this, \"enabled\", true);\r\n\r\n    _defineProperty(this, \"needsSwap\", true);\r\n\r\n    _defineProperty(this, \"clear\", false);\r\n\r\n    _defineProperty(this, \"renderToScreen\", false);\r\n  }\r\n\r\n  setSize(\r\n  /* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\n  /* eslint-disable no-unused-vars */\r\n  width, height) {}\r\n\r\n  render(\r\n  /* eslint-disable @typescript-eslint/no-unused-vars */\r\n\r\n  /* eslint-disable no-unused-vars */\r\n  renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\r\n    console.error('THREE.Pass: .render() must be implemented in derived pass.');\r\n  }\r\n\r\n} // Helper for passes that need to fill the viewport with a single quad.\r\n\r\n\r\nclass FullScreenQuad {\r\n  constructor(material) {\r\n    _defineProperty(this, \"camera\", new OrthographicCamera(-1, 1, 1, -1, 0, 1));\r\n\r\n    _defineProperty(this, \"geometry\", new PlaneGeometry(2, 2));\r\n\r\n    _defineProperty(this, \"mesh\", void 0);\r\n\r\n    this.mesh = new Mesh(this.geometry, material);\r\n  }\r\n\r\n  get material() {\r\n    return this.mesh.material;\r\n  }\r\n\r\n  set material(value) {\r\n    this.mesh.material = value;\r\n  }\r\n\r\n  dispose() {\r\n    this.mesh.geometry.dispose();\r\n  }\r\n\r\n  render(renderer) {\r\n    renderer.render(this.mesh, this.camera);\r\n  }\r\n\r\n}\r\n\r\nexport { FullScreenQuad, Pass };\r\n", "/**\r\n * RGB Halftone shader for three.js.\r\n *\tNOTE:\r\n * \t\tShape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)\r\n *\t\tBlending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)\r\n */\r\nconst HalftoneShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    shape: {\r\n      value: 1\r\n    },\r\n    radius: {\r\n      value: 4\r\n    },\r\n    rotateR: {\r\n      value: Math.PI / 12 * 1\r\n    },\r\n    rotateG: {\r\n      value: Math.PI / 12 * 2\r\n    },\r\n    rotateB: {\r\n      value: Math.PI / 12 * 3\r\n    },\r\n    scatter: {\r\n      value: 0\r\n    },\r\n    width: {\r\n      value: 1\r\n    },\r\n    height: {\r\n      value: 1\r\n    },\r\n    blending: {\r\n      value: 1\r\n    },\r\n    blendingMode: {\r\n      value: 1\r\n    },\r\n    greyscale: {\r\n      value: false\r\n    },\r\n    disable: {\r\n      value: false\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUV;', 'void main() {', '\tvUV = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);', '}'].join('\\n'),\r\n  fragmentShader: ['#define SQRT2_MINUS_ONE 0.41421356', '#define SQRT2_HALF_MINUS_ONE 0.20710678', '#define PI2 6.28318531', '#define SHAPE_DOT 1', '#define SHAPE_ELLIPSE 2', '#define SHAPE_LINE 3', '#define SHAPE_SQUARE 4', '#define BLENDING_LINEAR 1', '#define BLENDING_MULTIPLY 2', '#define BLENDING_ADD 3', '#define BLENDING_LIGHTER 4', '#define BLENDING_DARKER 5', 'uniform sampler2D tDiffuse;', 'uniform float radius;', 'uniform float rotateR;', 'uniform float rotateG;', 'uniform float rotateB;', 'uniform float scatter;', 'uniform float width;', 'uniform float height;', 'uniform int shape;', 'uniform bool disable;', 'uniform float blending;', 'uniform int blendingMode;', 'varying vec2 vUV;', 'uniform bool greyscale;', 'const int samples = 8;', 'float blend( float a, float b, float t ) {', // linear blend\r\n  '\treturn a * ( 1.0 - t ) + b * t;', '}', 'float hypot( float x, float y ) {', // vector magnitude\r\n  '\treturn sqrt( x * x + y * y );', '}', 'float rand( vec2 seed ){', // get pseudo-random number\r\n  'return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );', '}', 'float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {', // apply shape-specific transforms\r\n  '\tfloat dist = hypot( coord.x - p.x, coord.y - p.y );', '\tfloat rad = channel;', '\tif ( shape == SHAPE_DOT ) {', '\t\trad = pow( abs( rad ), 1.125 ) * rad_max;', '\t} else if ( shape == SHAPE_ELLIPSE ) {', '\t\trad = pow( abs( rad ), 1.125 ) * rad_max;', '\t\tif ( dist != 0.0 ) {', '\t\t\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );', '\t\t\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;', '\t\t}', '\t} else if ( shape == SHAPE_LINE ) {', '\t\trad = pow( abs( rad ), 1.5) * rad_max;', '\t\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;', '\t\tdist = hypot( normal.x * dot_p, normal.y * dot_p );', '\t} else if ( shape == SHAPE_SQUARE ) {', '\t\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;', '\t\tfloat sin_t = abs( sin( theta ) );', '\t\tfloat cos_t = abs( cos( theta ) );', '\t\trad = pow( abs( rad ), 1.4 );', '\t\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );', '\t}', '\treturn rad - dist;', '}', 'struct Cell {', // grid sample positions\r\n  '\tvec2 normal;', '\tvec2 p1;', '\tvec2 p2;', '\tvec2 p3;', '\tvec2 p4;', '\tfloat samp2;', '\tfloat samp1;', '\tfloat samp3;', '\tfloat samp4;', '};', 'vec4 getSample( vec2 point ) {', // multi-sampled point\r\n  '\tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );', '\tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;', '\tfloat step = PI2 / float( samples );', '\tfloat dist = radius * 0.66;', '\tfor ( int i = 0; i < samples; ++i ) {', '\t\tfloat r = base + step * float( i );', '\t\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );', '\t\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );', '\t}', '\ttex /= float( samples ) + 1.0;', '\treturn tex;', '}', 'float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {', // get colour for given point\r\n  '\tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;', '\tif ( channel == 0 ) {', '\t\tc.samp1 = getSample( c.p1 ).r;', '\t\tc.samp2 = getSample( c.p2 ).r;', '\t\tc.samp3 = getSample( c.p3 ).r;', '\t\tc.samp4 = getSample( c.p4 ).r;', '\t} else if (channel == 1) {', '\t\tc.samp1 = getSample( c.p1 ).g;', '\t\tc.samp2 = getSample( c.p2 ).g;', '\t\tc.samp3 = getSample( c.p3 ).g;', '\t\tc.samp4 = getSample( c.p4 ).g;', '\t} else {', '\t\tc.samp1 = getSample( c.p1 ).b;', '\t\tc.samp3 = getSample( c.p3 ).b;', '\t\tc.samp2 = getSample( c.p2 ).b;', '\t\tc.samp4 = getSample( c.p4 ).b;', '\t}', '\tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );', '\tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );', '\tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );', '\tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );', '\tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;', '\tres = clamp( res, 0.0, 1.0 );', '\treturn res;', '}', 'Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {', // get containing cell\r\n  '\tCell c;', // calc grid\r\n  '\tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );', '\tfloat threshold = step * 0.5;', '\tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );', '\tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );', '\tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );', '\tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );', '\tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;', '\tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;', '\tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );', '\tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;', '\tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;', // get closest corner\r\n  '\tc.normal = n;', '\tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;', '\tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;', // scatter\r\n  '\tif ( scatter != 0.0 ) {', '\t\tfloat off_mag = scatter * threshold * 0.5;', '\t\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;', '\t\tc.p1.x += cos( off_angle ) * off_mag;', '\t\tc.p1.y += sin( off_angle ) * off_mag;', '\t}', // find corners\r\n  '\tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );', '\tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );', '\tc.p2.x = c.p1.x - n.x * normal_step;', '\tc.p2.y = c.p1.y - n.y * normal_step;', '\tc.p3.x = c.p1.x + n.y * line_step;', '\tc.p3.y = c.p1.y - n.x * line_step;', '\tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;', '\tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;', '\treturn c;', '}', 'float blendColour( float a, float b, float t ) {', // blend colours\r\n  '\tif ( blendingMode == BLENDING_LINEAR ) {', '\t\treturn blend( a, b, 1.0 - t );', '\t} else if ( blendingMode == BLENDING_ADD ) {', '\t\treturn blend( a, min( 1.0, a + b ), t );', '\t} else if ( blendingMode == BLENDING_MULTIPLY ) {', '\t\treturn blend( a, max( 0.0, a * b ), t );', '\t} else if ( blendingMode == BLENDING_LIGHTER ) {', '\t\treturn blend( a, max( a, b ), t );', '\t} else if ( blendingMode == BLENDING_DARKER ) {', '\t\treturn blend( a, min( a, b ), t );', '\t} else {', '\t\treturn blend( a, b, 1.0 - t );', '\t}', '}', 'void main() {', '\tif ( ! disable ) {', // setup\r\n  '\t\tvec2 p = vec2( vUV.x * width, vUV.y * height );', '\t\tvec2 origin = vec2( 0, 0 );', '\t\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;', // get channel samples\r\n  '\t\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );', '\t\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );', '\t\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );', '\t\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );', '\t\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );', '\t\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );', // blend with original\r\n  '\t\tvec4 colour = texture2D( tDiffuse, vUV );', '\t\tr = blendColour( r, colour.r, blending );', '\t\tg = blendColour( g, colour.g, blending );', '\t\tb = blendColour( b, colour.b, blending );', '\t\tif ( greyscale ) {', '\t\t\tr = g = b = (r + b + g) / 3.0;', '\t\t}', '\t\tgl_FragColor = vec4( r, g, b, 1.0 );', '\t} else {', '\t\tgl_FragColor = texture2D( tDiffuse, vUV );', '\t}', '}'].join('\\n')\r\n};\r\n\r\nexport { HalftoneShader };\r\n", "import { Vector2 } from 'three';\r\n\r\n/**\r\n * WebGL port of Subpixel Morphological Antialiasing (SMAA) v2.8\r\n * Preset: SMAA 1x Medium (with color edge detection)\r\n * https://github.com/iryoku/smaa/releases/tag/v2.8\r\n */\r\n\r\nconst SMAAEdgesShader = {\r\n  defines: {\r\n    SMAA_THRESHOLD: '0.1'\r\n  },\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    resolution: {\r\n      value: new Vector2(1 / 1024, 1 / 512)\r\n    }\r\n  },\r\n  vertexShader: ['uniform vec2 resolution;', 'varying vec2 vUv;', 'varying vec4 vOffset[ 3 ];', 'void SMAAEdgeDetectionVS( vec2 texcoord ) {', '\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );', // WebGL port note: Changed sign in W component\r\n  '\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );', // WebGL port note: Changed sign in W component\r\n  '\tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );', // WebGL port note: Changed sign in W component\r\n  '}', 'void main() {', '\tvUv = uv;', '\tSMAAEdgeDetectionVS( vUv );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'varying vec4 vOffset[ 3 ];', 'vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {', '\tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );', // Calculate color deltas:\r\n  '\tvec4 delta;', '\tvec3 C = texture2D( colorTex, texcoord ).rgb;', '\tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;', '\tvec3 t = abs( C - Cleft );', '\tdelta.x = max( max( t.r, t.g ), t.b );', '\tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;', '\tt = abs( C - Ctop );', '\tdelta.y = max( max( t.r, t.g ), t.b );', // We do the usual threshold:\r\n  '\tvec2 edges = step( threshold, delta.xy );', // Then discard if there is no edge:\r\n  '\tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )', '\t\tdiscard;', // Calculate right and bottom deltas:\r\n  '\tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;', '\tt = abs( C - Cright );', '\tdelta.z = max( max( t.r, t.g ), t.b );', '\tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;', '\tt = abs( C - Cbottom );', '\tdelta.w = max( max( t.r, t.g ), t.b );', // Calculate the maximum delta in the direct neighborhood:\r\n  '\tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );', // Calculate left-left and top-top deltas:\r\n  '\tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;', '\tt = abs( C - Cleftleft );', '\tdelta.z = max( max( t.r, t.g ), t.b );', '\tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;', '\tt = abs( C - Ctoptop );', '\tdelta.w = max( max( t.r, t.g ), t.b );', // Calculate the final maximum delta:\r\n  '\tmaxDelta = max( max( maxDelta, delta.z ), delta.w );', // Local contrast adaptation in action:\r\n  '\tedges.xy *= step( 0.5 * maxDelta, delta.xy );', '\treturn vec4( edges, 0.0, 0.0 );', '}', 'void main() {', '\tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );', '}'].join('\\n')\r\n};\r\nconst SMAAWeightsShader = {\r\n  defines: {\r\n    SMAA_MAX_SEARCH_STEPS: '8',\r\n    SMAA_AREATEX_MAX_DISTANCE: '16',\r\n    SMAA_AREATEX_PIXEL_SIZE: '( 1.0 / vec2( 160.0, 560.0 ) )',\r\n    SMAA_AREATEX_SUBTEX_SIZE: '( 1.0 / 7.0 )'\r\n  },\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    tArea: {\r\n      value: null\r\n    },\r\n    tSearch: {\r\n      value: null\r\n    },\r\n    resolution: {\r\n      value: new Vector2(1 / 1024, 1 / 512)\r\n    }\r\n  },\r\n  vertexShader: ['uniform vec2 resolution;', 'varying vec2 vUv;', 'varying vec4 vOffset[ 3 ];', 'varying vec2 vPixcoord;', 'void SMAABlendingWeightCalculationVS( vec2 texcoord ) {', '\tvPixcoord = texcoord / resolution;', // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\r\n  '\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );', // WebGL port note: Changed sign in Y and W components\r\n  '\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );', // WebGL port note: Changed sign in Y and W components\r\n  // And these for the searches, they indicate the ends of the loops:\r\n  '\tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );', '}', 'void main() {', '\tvUv = uv;', '\tSMAABlendingWeightCalculationVS( vUv );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tArea;', 'uniform sampler2D tSearch;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'varying vec4 vOffset[3];', 'varying vec2 vPixcoord;', '#if __VERSION__ == 100', 'vec2 round( vec2 x ) {', '\treturn sign( x ) * floor( abs( x ) + 0.5 );', '}', '#endif', 'float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {', // Not required if searchTex accesses are set to point:\r\n  // float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\r\n  // e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\r\n  //     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\r\n  '\te.r = bias + e.r * scale;', '\treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;', '}', 'float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\r\n  /**\r\n   * @PSEUDO_GATHER4\r\n   * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\r\n   * sample between edge, thus fetching four edges in a row.\r\n   * Sampling with different offsets in each direction allows to disambiguate\r\n   * which edges are active from the four fetched ones.\r\n   */\r\n  '\tvec2 e = vec2( 0.0, 1.0 );', '\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {', // WebGL port note: Changed while to for\r\n  '\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;', '\t\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;', '\t\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;', '\t}', // We correct the previous (-0.25, -0.125) offset we applied:\r\n  '\ttexcoord.x += 0.25 * resolution.x;', // The searches are bias by 1, so adjust the coords accordingly:\r\n  '\ttexcoord.x += resolution.x;', // Disambiguate the length added by the last step:\r\n  '\ttexcoord.x += 2.0 * resolution.x;', // Undo last step\r\n  '\ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);', '\treturn texcoord.x;', '}', 'float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {', '\tvec2 e = vec2( 0.0, 1.0 );', '\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {', // WebGL port note: Changed while to for\r\n  '\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;', '\t\ttexcoord += vec2( 2.0, 0.0 ) * resolution;', '\t\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;', '\t}', '\ttexcoord.x -= 0.25 * resolution.x;', '\ttexcoord.x -= resolution.x;', '\ttexcoord.x -= 2.0 * resolution.x;', '\ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );', '\treturn texcoord.x;', '}', 'float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {', '\tvec2 e = vec2( 1.0, 0.0 );', '\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {', // WebGL port note: Changed while to for\r\n  '\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;', '\t\ttexcoord += vec2( 0.0, 2.0 ) * resolution;', // WebGL port note: Changed sign\r\n  '\t\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;', '\t}', '\ttexcoord.y -= 0.25 * resolution.y;', // WebGL port note: Changed sign\r\n  '\ttexcoord.y -= resolution.y;', // WebGL port note: Changed sign\r\n  '\ttexcoord.y -= 2.0 * resolution.y;', // WebGL port note: Changed sign\r\n  '\ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );', // WebGL port note: Changed sign\r\n  '\treturn texcoord.y;', '}', 'float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {', '\tvec2 e = vec2( 1.0, 0.0 );', '\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {', // WebGL port note: Changed while to for\r\n  '\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;', '\t\ttexcoord -= vec2( 0.0, 2.0 ) * resolution;', // WebGL port note: Changed sign\r\n  '\t\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;', '\t}', '\ttexcoord.y += 0.25 * resolution.y;', // WebGL port note: Changed sign\r\n  '\ttexcoord.y += resolution.y;', // WebGL port note: Changed sign\r\n  '\ttexcoord.y += 2.0 * resolution.y;', // WebGL port note: Changed sign\r\n  '\ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );', // WebGL port note: Changed sign\r\n  '\treturn texcoord.y;', '}', 'vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {', // Rounding prevents precision errors of bilinear filtering:\r\n  '\tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;', // We do a scale and bias for mapping to texel space:\r\n  '\ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );', // Move to proper place, according to the subpixel offset:\r\n  '\ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;', '\treturn texture2D( areaTex, texcoord, 0.0 ).rg;', '}', 'vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {', '\tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );', '\tvec2 e = texture2D( edgesTex, texcoord ).rg;', '\tif ( e.g > 0.0 ) {', // Edge at north\r\n  '\t\tvec2 d;', // Find the distance to the left:\r\n  '\t\tvec2 coords;', '\t\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );', '\t\tcoords.y = offset[ 1 ].y;', // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\r\n  '\t\td.x = coords.x;', // Now fetch the left crossing edges, two at a time using bilinear\r\n  // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\r\n  // discern what value each edge has:\r\n  '\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;', // Find the distance to the right:\r\n  '\t\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );', '\t\td.y = coords.x;', // We want the distances to be in pixel units (doing this here allow to\r\n  // better interleave arithmetic and memory accesses):\r\n  '\t\td = d / resolution.x - pixcoord.x;', // SMAAArea below needs a sqrt, as the areas texture is compressed\r\n  // quadratically:\r\n  '\t\tvec2 sqrt_d = sqrt( abs( d ) );', // Fetch the right crossing edges:\r\n  '\t\tcoords.y -= 1.0 * resolution.y;', // WebGL port note: Added\r\n  '\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;', // Ok, we know how this pattern looks like, now it is time for getting\r\n  // the actual area:\r\n  '\t\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );', '\t}', '\tif ( e.r > 0.0 ) {', // Edge at west\r\n  '\t\tvec2 d;', // Find the distance to the top:\r\n  '\t\tvec2 coords;', '\t\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );', '\t\tcoords.x = offset[ 0 ].x;', // offset[1].x = texcoord.x - 0.25 * resolution.x;\r\n  '\t\td.x = coords.y;', // Fetch the top crossing edges:\r\n  '\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;', // Find the distance to the bottom:\r\n  '\t\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );', '\t\td.y = coords.y;', // We want the distances to be in pixel units:\r\n  '\t\td = d / resolution.y - pixcoord.y;', // SMAAArea below needs a sqrt, as the areas texture is compressed\r\n  // quadratically:\r\n  '\t\tvec2 sqrt_d = sqrt( abs( d ) );', // Fetch the bottom crossing edges:\r\n  '\t\tcoords.y -= 1.0 * resolution.y;', // WebGL port note: Added\r\n  '\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;', // Get the area for this direction:\r\n  '\t\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );', '\t}', '\treturn weights;', '}', 'void main() {', '\tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );', '}'].join('\\n')\r\n};\r\nconst SMAABlendShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    tColor: {\r\n      value: null\r\n    },\r\n    resolution: {\r\n      value: new Vector2(1 / 1024, 1 / 512)\r\n    }\r\n  },\r\n  vertexShader: ['uniform vec2 resolution;', 'varying vec2 vUv;', 'varying vec4 vOffset[ 2 ];', 'void SMAANeighborhoodBlendingVS( vec2 texcoord ) {', '\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );', // WebGL port note: Changed sign in W component\r\n  '\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );', // WebGL port note: Changed sign in W component\r\n  '}', 'void main() {', '\tvUv = uv;', '\tSMAANeighborhoodBlendingVS( vUv );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform sampler2D tColor;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'varying vec4 vOffset[ 2 ];', 'vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {', // Fetch the blending weights for current pixel:\r\n  '\tvec4 a;', '\ta.xz = texture2D( blendTex, texcoord ).xz;', '\ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;', '\ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;', // Is there any blending weight with a value greater than 0.0?\r\n  '\tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {', '\t\treturn texture2D( colorTex, texcoord, 0.0 );', '\t} else {', // Up to 4 lines can be crossing a pixel (one through each edge). We\r\n  // favor blending by choosing the line with the maximum weight for each\r\n  // direction:\r\n  '\t\tvec2 offset;', '\t\toffset.x = a.a > a.b ? a.a : -a.b;', // left vs. right\r\n  '\t\toffset.y = a.g > a.r ? -a.g : a.r;', // top vs. bottom // WebGL port note: Changed signs\r\n  // Then we go in the direction that has the maximum weight:\r\n  '\t\tif ( abs( offset.x ) > abs( offset.y )) {', // horizontal vs. vertical\r\n  '\t\t\toffset.y = 0.0;', '\t\t} else {', '\t\t\toffset.x = 0.0;', '\t\t}', // Fetch the opposite color and lerp by hand:\r\n  '\t\tvec4 C = texture2D( colorTex, texcoord, 0.0 );', '\t\ttexcoord += sign( offset ) * resolution;', '\t\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );', '\t\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );', // WebGL port note: Added gamma correction\r\n  '\t\tC.xyz = pow(C.xyz, vec3(2.2));', '\t\tCop.xyz = pow(Cop.xyz, vec3(2.2));', '\t\tvec4 mixed = mix(C, Cop, s);', '\t\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));', '\t\treturn mixed;', '\t}', '}', 'void main() {', '\tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );', '}'].join('\\n')\r\n};\r\n\r\nexport { SMAABlendShader, SMAAEdgesShader, SMAAWeightsShader };\r\n", "/**\r\n * Film grain & scanlines shader\r\n *\r\n * - ported from HLSL to WebGL / GLSL\r\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\r\n *\r\n * Screen Space Static Postprocessor\r\n *\r\n * Produces an analogue noise overlay similar to a film grain / TV static\r\n *\r\n * Original implementation and noise algorithm\r\n * Pat 'Hawthorne' Shearon\r\n *\r\n * Optimized scanlines + noise version with intensity scaling\r\n * Georg 'Leviathan' Steinrohder\r\n *\r\n * This version is provided under a Creative Commons Attribution 3.0 License\r\n * http://creativecommons.org/licenses/by/3.0/\r\n */\r\nconst FilmShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    time: {\r\n      value: 0.0\r\n    },\r\n    nIntensity: {\r\n      value: 0.5\r\n    },\r\n    sIntensity: {\r\n      value: 0.05\r\n    },\r\n    sCount: {\r\n      value: 4096\r\n    },\r\n    grayscale: {\r\n      value: 1\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['#include <common>', // control parameter\r\n  'uniform float time;', 'uniform bool grayscale;', // noise effect intensity value (0 = no effect, 1 = full effect)\r\n  'uniform float nIntensity;', // scanlines effect intensity value (0 = no effect, 1 = full effect)\r\n  'uniform float sIntensity;', // scanlines effect count value (0 = no effect, 4096 = full effect)\r\n  'uniform float sCount;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', // sample the source\r\n  '\tvec4 cTextureScreen = texture2D( tDiffuse, vUv );', // make some noise\r\n  '\tfloat dx = rand( vUv + time );', // add noise\r\n  '\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );', // get us a sine and cosine\r\n  '\tvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );', // add scanlines\r\n  '\tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;', // interpolate between source and result by intensity\r\n  '\tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );', // convert to grayscale if desired\r\n  '\tif( grayscale ) {', '\t\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );', '\t}', '\tgl_FragColor =  vec4( cResult, cTextureScreen.a );', '}'].join('\\n')\r\n};\r\n\r\nexport { FilmShader };\r\n", "/**\r\n * Full-screen textured quad shader\r\n */\r\nconst CopyShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    opacity: {\r\n      value: 1.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform float opacity;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tgl_FragColor = opacity * texel;', '}'].join('\\n')\r\n};\r\n\r\nexport { CopyShader };\r\n", "import { Vector2, Matrix4 } from 'three';\r\n\r\n/**\r\n * References:\r\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\r\n * https://learnopengl.com/Advanced-Lighting/SSAO\r\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\r\n */\r\n\r\nconst SSAOShader = {\r\n  defines: {\r\n    PERSPECTIVE_CAMERA: 1,\r\n    KERNEL_SIZE: 32\r\n  },\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    tNormal: {\r\n      value: null\r\n    },\r\n    tDepth: {\r\n      value: null\r\n    },\r\n    tNoise: {\r\n      value: null\r\n    },\r\n    kernel: {\r\n      value: null\r\n    },\r\n    cameraNear: {\r\n      value: null\r\n    },\r\n    cameraFar: {\r\n      value: null\r\n    },\r\n    resolution: {\r\n      value: new Vector2()\r\n    },\r\n    cameraProjectionMatrix: {\r\n      value: new Matrix4()\r\n    },\r\n    cameraInverseProjectionMatrix: {\r\n      value: new Matrix4()\r\n    },\r\n    kernelRadius: {\r\n      value: 8\r\n    },\r\n    minDistance: {\r\n      value: 0.005\r\n    },\r\n    maxDistance: {\r\n      value: 0.05\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform sampler2D tNormal;', 'uniform sampler2D tDepth;', 'uniform sampler2D tNoise;', 'uniform vec3 kernel[ KERNEL_SIZE ];', 'uniform vec2 resolution;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float kernelRadius;', 'uniform float minDistance;', // avoid artifacts caused by neighbour fragments with minimal depth difference\r\n  'uniform float maxDistance;', // avoid the influence of fragments which are too far away\r\n  'varying vec2 vUv;', '#include <packing>', 'float getDepth( const in vec2 screenPosition ) {', '\treturn texture2D( tDepth, screenPosition ).x;', '}', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec2 screenPosition ) {', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tfloat viewZ = getViewZ( depth );', '\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );', '\tvec3 viewNormal = getViewNormal( vUv );', ' vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );', '\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;', // compute matrix used to reorient a kernel vector\r\n  '\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );', '\tvec3 bitangent = cross( viewNormal, tangent );', '\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );', ' float occlusion = 0.0;', ' for ( int i = 0; i < KERNEL_SIZE; i ++ ) {', '\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];', // reorient sample vector in view space\r\n  '\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );', // calculate sample point\r\n  '\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );', // project point and calculate NDC\r\n  '\t\tsamplePointNDC /= samplePointNDC.w;', '\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;', // compute uv coordinates\r\n  '\t\tfloat realDepth = getLinearDepth( samplePointUv );', // get linear depth from depth texture\r\n  '\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );', // compute linear depth of the sample view Z value\r\n  '\t\tfloat delta = sampleDepth - realDepth;', '\t\tif ( delta > minDistance && delta < maxDistance ) {', // if fragment is before sample point, increase occlusion\r\n  '\t\t\tocclusion += 1.0;', '\t\t}', '\t}', '\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );', '\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );', '}'].join('\\n')\r\n};\r\nconst SSAODepthShader = {\r\n  defines: {\r\n    PERSPECTIVE_CAMERA: 1\r\n  },\r\n  uniforms: {\r\n    tDepth: {\r\n      value: null\r\n    },\r\n    cameraNear: {\r\n      value: null\r\n    },\r\n    cameraFar: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'varying vec2 vUv;', '#include <packing>', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'void main() {', '\tfloat depth = getLinearDepth( vUv );', '\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );', '}'].join('\\n')\r\n};\r\nconst SSAOBlurShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    resolution: {\r\n      value: new Vector2()\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\tvec2 texelSize = ( 1.0 / resolution );', '\tfloat result = 0.0;', '\tfor ( int i = - 2; i <= 2; i ++ ) {', '\t\tfor ( int j = - 2; j <= 2; j ++ ) {', '\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;', '\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;', '\t\t}', '\t}', '\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );', '}'].join('\\n')\r\n};\r\n\r\nexport { SSAOBlurShader, SSAODepthShader, SSAOShader };\r\n", "import { DepthTexture, DepthStencilFormat, UnsignedInt248Type, WebGLRenderTarget, NearestFilter, ShaderMaterial, UniformsUtils, NoBlending, MeshNormalMaterial, DstColorFactor, ZeroFactor, AddEquation, DstAlphaFactor, Color, LuminanceFormat, CustomBlending, Vector3, MathUtils, DataTexture, RedFormat, FloatType, RepeatWrapping } from 'three';\r\nimport { Pass, FullScreenQuad } from './Pass.js';\r\nimport { SimplexNoise } from '../math/SimplexNoise.js';\r\nimport { SSAOShader, SSAOBlurShader, SSAODepthShader } from '../shaders/SSAOShader.js';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\n\r\nclass SSAOPass extends Pass {\r\n  constructor(scene, camera, width, height) {\r\n    super();\r\n    this.width = width !== undefined ? width : 512;\r\n    this.height = height !== undefined ? height : 512;\r\n    this.clear = true;\r\n    this.camera = camera;\r\n    this.scene = scene;\r\n    this.kernelRadius = 8;\r\n    this.kernelSize = 32;\r\n    this.kernel = [];\r\n    this.noiseTexture = null;\r\n    this.output = 0;\r\n    this.minDistance = 0.005;\r\n    this.maxDistance = 0.1;\r\n    this._visibilityCache = new Map(); //\r\n\r\n    this.generateSampleKernel();\r\n    this.generateRandomKernelRotations(); // beauty render target\r\n\r\n    const depthTexture = new DepthTexture();\r\n    depthTexture.format = DepthStencilFormat;\r\n    depthTexture.type = UnsignedInt248Type;\r\n    this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height); // normal render target with depth buffer\r\n\r\n    this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {\r\n      minFilter: NearestFilter,\r\n      magFilter: NearestFilter,\r\n      depthTexture: depthTexture\r\n    }); // ssao render target\r\n\r\n    this.ssaoRenderTarget = new WebGLRenderTarget(this.width, this.height);\r\n    this.blurRenderTarget = this.ssaoRenderTarget.clone(); // ssao material\r\n\r\n    if (SSAOShader === undefined) {\r\n      console.error('THREE.SSAOPass: The pass relies on SSAOShader.');\r\n    }\r\n\r\n    this.ssaoMaterial = new ShaderMaterial({\r\n      defines: Object.assign({}, SSAOShader.defines),\r\n      uniforms: UniformsUtils.clone(SSAOShader.uniforms),\r\n      vertexShader: SSAOShader.vertexShader,\r\n      fragmentShader: SSAOShader.fragmentShader,\r\n      blending: NoBlending\r\n    });\r\n    this.ssaoMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\r\n    this.ssaoMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture;\r\n    this.ssaoMaterial.uniforms['tDepth'].value = this.normalRenderTarget.depthTexture;\r\n    this.ssaoMaterial.uniforms['tNoise'].value = this.noiseTexture;\r\n    this.ssaoMaterial.uniforms['kernel'].value = this.kernel;\r\n    this.ssaoMaterial.uniforms['cameraNear'].value = this.camera.near;\r\n    this.ssaoMaterial.uniforms['cameraFar'].value = this.camera.far;\r\n    this.ssaoMaterial.uniforms['resolution'].value.set(this.width, this.height);\r\n    this.ssaoMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);\r\n    this.ssaoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse); // normal material\r\n\r\n    this.normalMaterial = new MeshNormalMaterial();\r\n    this.normalMaterial.blending = NoBlending; // blur material\r\n\r\n    this.blurMaterial = new ShaderMaterial({\r\n      defines: Object.assign({}, SSAOBlurShader.defines),\r\n      uniforms: UniformsUtils.clone(SSAOBlurShader.uniforms),\r\n      vertexShader: SSAOBlurShader.vertexShader,\r\n      fragmentShader: SSAOBlurShader.fragmentShader\r\n    });\r\n    this.blurMaterial.uniforms['tDiffuse'].value = this.ssaoRenderTarget.texture;\r\n    this.blurMaterial.uniforms['resolution'].value.set(this.width, this.height); // material for rendering the depth\r\n\r\n    this.depthRenderMaterial = new ShaderMaterial({\r\n      defines: Object.assign({}, SSAODepthShader.defines),\r\n      uniforms: UniformsUtils.clone(SSAODepthShader.uniforms),\r\n      vertexShader: SSAODepthShader.vertexShader,\r\n      fragmentShader: SSAODepthShader.fragmentShader,\r\n      blending: NoBlending\r\n    });\r\n    this.depthRenderMaterial.uniforms['tDepth'].value = this.normalRenderTarget.depthTexture;\r\n    this.depthRenderMaterial.uniforms['cameraNear'].value = this.camera.near;\r\n    this.depthRenderMaterial.uniforms['cameraFar'].value = this.camera.far; // material for rendering the content of a render target\r\n\r\n    this.copyMaterial = new ShaderMaterial({\r\n      uniforms: UniformsUtils.clone(CopyShader.uniforms),\r\n      vertexShader: CopyShader.vertexShader,\r\n      fragmentShader: CopyShader.fragmentShader,\r\n      transparent: true,\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      blendSrc: DstColorFactor,\r\n      blendDst: ZeroFactor,\r\n      blendEquation: AddEquation,\r\n      blendSrcAlpha: DstAlphaFactor,\r\n      blendDstAlpha: ZeroFactor,\r\n      blendEquationAlpha: AddEquation\r\n    });\r\n    this.fsQuad = new FullScreenQuad(null);\r\n    this.originalClearColor = new Color();\r\n  }\r\n\r\n  dispose() {\r\n    // dispose render targets\r\n    this.beautyRenderTarget.dispose();\r\n    this.normalRenderTarget.dispose();\r\n    this.ssaoRenderTarget.dispose();\r\n    this.blurRenderTarget.dispose(); // dispose materials\r\n\r\n    this.normalMaterial.dispose();\r\n    this.blurMaterial.dispose();\r\n    this.copyMaterial.dispose();\r\n    this.depthRenderMaterial.dispose(); // dipsose full screen quad\r\n\r\n    this.fsQuad.dispose();\r\n  }\r\n\r\n  render(renderer, writeBuffer\r\n  /*, readBuffer, deltaTime, maskActive */\r\n  ) {\r\n    if (renderer.capabilities.isWebGL2 === false) this.noiseTexture.format = LuminanceFormat; // render beauty\r\n\r\n    renderer.setRenderTarget(this.beautyRenderTarget);\r\n    renderer.clear();\r\n    renderer.render(this.scene, this.camera); // render normals and depth (honor only meshes, points and lines do not contribute to SSAO)\r\n\r\n    this.overrideVisibility();\r\n    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0);\r\n    this.restoreVisibility(); // render SSAO\r\n\r\n    this.ssaoMaterial.uniforms['kernelRadius'].value = this.kernelRadius;\r\n    this.ssaoMaterial.uniforms['minDistance'].value = this.minDistance;\r\n    this.ssaoMaterial.uniforms['maxDistance'].value = this.maxDistance;\r\n    this.renderPass(renderer, this.ssaoMaterial, this.ssaoRenderTarget); // render blur\r\n\r\n    this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget); // output result to screen\r\n\r\n    switch (this.output) {\r\n      case SSAOPass.OUTPUT.SSAO:\r\n        this.copyMaterial.uniforms['tDiffuse'].value = this.ssaoRenderTarget.texture;\r\n        this.copyMaterial.blending = NoBlending;\r\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\r\n        break;\r\n\r\n      case SSAOPass.OUTPUT.Blur:\r\n        this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget.texture;\r\n        this.copyMaterial.blending = NoBlending;\r\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\r\n        break;\r\n\r\n      case SSAOPass.OUTPUT.Beauty:\r\n        this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\r\n        this.copyMaterial.blending = NoBlending;\r\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\r\n        break;\r\n\r\n      case SSAOPass.OUTPUT.Depth:\r\n        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);\r\n        break;\r\n\r\n      case SSAOPass.OUTPUT.Normal:\r\n        this.copyMaterial.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;\r\n        this.copyMaterial.blending = NoBlending;\r\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\r\n        break;\r\n\r\n      case SSAOPass.OUTPUT.Default:\r\n        this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\r\n        this.copyMaterial.blending = NoBlending;\r\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\r\n        this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget.texture;\r\n        this.copyMaterial.blending = CustomBlending;\r\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\r\n        break;\r\n\r\n      default:\r\n        console.warn('THREE.SSAOPass: Unknown output type.');\r\n    }\r\n  }\r\n\r\n  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\r\n    // save original state\r\n    renderer.getClearColor(this.originalClearColor);\r\n    const originalClearAlpha = renderer.getClearAlpha();\r\n    const originalAutoClear = renderer.autoClear;\r\n    renderer.setRenderTarget(renderTarget); // setup pass state\r\n\r\n    renderer.autoClear = false;\r\n\r\n    if (clearColor !== undefined && clearColor !== null) {\r\n      renderer.setClearColor(clearColor);\r\n      renderer.setClearAlpha(clearAlpha || 0.0);\r\n      renderer.clear();\r\n    }\r\n\r\n    this.fsQuad.material = passMaterial;\r\n    this.fsQuad.render(renderer); // restore original state\r\n\r\n    renderer.autoClear = originalAutoClear;\r\n    renderer.setClearColor(this.originalClearColor);\r\n    renderer.setClearAlpha(originalClearAlpha);\r\n  }\r\n\r\n  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\r\n    renderer.getClearColor(this.originalClearColor);\r\n    const originalClearAlpha = renderer.getClearAlpha();\r\n    const originalAutoClear = renderer.autoClear;\r\n    renderer.setRenderTarget(renderTarget);\r\n    renderer.autoClear = false;\r\n    clearColor = overrideMaterial.clearColor || clearColor;\r\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;\r\n\r\n    if (clearColor !== undefined && clearColor !== null) {\r\n      renderer.setClearColor(clearColor);\r\n      renderer.setClearAlpha(clearAlpha || 0.0);\r\n      renderer.clear();\r\n    }\r\n\r\n    this.scene.overrideMaterial = overrideMaterial;\r\n    renderer.render(this.scene, this.camera);\r\n    this.scene.overrideMaterial = null; // restore original state\r\n\r\n    renderer.autoClear = originalAutoClear;\r\n    renderer.setClearColor(this.originalClearColor);\r\n    renderer.setClearAlpha(originalClearAlpha);\r\n  }\r\n\r\n  setSize(width, height) {\r\n    this.width = width;\r\n    this.height = height;\r\n    this.beautyRenderTarget.setSize(width, height);\r\n    this.ssaoRenderTarget.setSize(width, height);\r\n    this.normalRenderTarget.setSize(width, height);\r\n    this.blurRenderTarget.setSize(width, height);\r\n    this.ssaoMaterial.uniforms['resolution'].value.set(width, height);\r\n    this.ssaoMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);\r\n    this.ssaoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);\r\n    this.blurMaterial.uniforms['resolution'].value.set(width, height);\r\n  }\r\n\r\n  generateSampleKernel() {\r\n    const kernelSize = this.kernelSize;\r\n    const kernel = this.kernel;\r\n\r\n    for (let i = 0; i < kernelSize; i++) {\r\n      const sample = new Vector3();\r\n      sample.x = Math.random() * 2 - 1;\r\n      sample.y = Math.random() * 2 - 1;\r\n      sample.z = Math.random();\r\n      sample.normalize();\r\n      let scale = i / kernelSize;\r\n      scale = MathUtils.lerp(0.1, 1, scale * scale);\r\n      sample.multiplyScalar(scale);\r\n      kernel.push(sample);\r\n    }\r\n  }\r\n\r\n  generateRandomKernelRotations() {\r\n    const width = 4,\r\n          height = 4;\r\n\r\n    if (SimplexNoise === undefined) {\r\n      console.error('THREE.SSAOPass: The pass relies on SimplexNoise.');\r\n    }\r\n\r\n    const simplex = new SimplexNoise();\r\n    const size = width * height;\r\n    const data = new Float32Array(size);\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      const x = Math.random() * 2 - 1;\r\n      const y = Math.random() * 2 - 1;\r\n      const z = 0;\r\n      data[i] = simplex.noise3d(x, y, z);\r\n    }\r\n\r\n    this.noiseTexture = new DataTexture(data, width, height, RedFormat, FloatType);\r\n    this.noiseTexture.wrapS = RepeatWrapping;\r\n    this.noiseTexture.wrapT = RepeatWrapping;\r\n    this.noiseTexture.needsUpdate = true;\r\n  }\r\n\r\n  overrideVisibility() {\r\n    const scene = this.scene;\r\n    const cache = this._visibilityCache;\r\n    scene.traverse(function (object) {\r\n      cache.set(object, object.visible);\r\n      if (object.isPoints || object.isLine) object.visible = false;\r\n    });\r\n  }\r\n\r\n  restoreVisibility() {\r\n    const scene = this.scene;\r\n    const cache = this._visibilityCache;\r\n    scene.traverse(function (object) {\r\n      const visible = cache.get(object);\r\n      object.visible = visible;\r\n    });\r\n    cache.clear();\r\n  }\r\n\r\n}\r\n\r\nSSAOPass.OUTPUT = {\r\n  Default: 0,\r\n  SSAO: 1,\r\n  Blur: 2,\r\n  Beauty: 3,\r\n  Depth: 4,\r\n  Normal: 5\r\n};\r\n\r\nexport { SSAOPass };\r\n", "/**\r\n * Depth-of-field shader with bokeh\r\n * ported from GLSL shader by Martins Upitis\r\n * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html\r\n */\r\nconst BokehShader = {\r\n  defines: {\r\n    DEPTH_PACKING: 1,\r\n    PERSPECTIVE_CAMERA: 1\r\n  },\r\n  uniforms: {\r\n    tColor: {\r\n      value: null\r\n    },\r\n    tDepth: {\r\n      value: null\r\n    },\r\n    focus: {\r\n      value: 1.0\r\n    },\r\n    aspect: {\r\n      value: 1.0\r\n    },\r\n    aperture: {\r\n      value: 0.025\r\n    },\r\n    maxblur: {\r\n      value: 0.01\r\n    },\r\n    nearClip: {\r\n      value: 1.0\r\n    },\r\n    farClip: {\r\n      value: 1000.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', 'uniform sampler2D tColor;', 'uniform sampler2D tDepth;', 'uniform float maxblur;', // max blur amount\r\n  'uniform float aperture;', // aperture - bigger values for shallower depth of field\r\n  'uniform float nearClip;', 'uniform float farClip;', 'uniform float focus;', 'uniform float aspect;', '#include <packing>', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );', '\t#else', '\treturn orthographicDepthToViewZ( depth, nearClip, farClip );', '\t#endif', '}', 'void main() {', '\tvec2 aspectcorrect = vec2( 1.0, aspect );', '\tfloat viewZ = getViewZ( getDepth( vUv ) );', '\tfloat factor = ( focus + viewZ );', // viewZ is <= 0, so this is a difference equation\r\n  '\tvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );', '\tvec2 dofblur9 = dofblur * 0.9;', '\tvec2 dofblur7 = dofblur * 0.7;', '\tvec2 dofblur4 = dofblur * 0.4;', '\tvec4 col = vec4( 0.0 );', '\tcol += texture2D( tColor, vUv.xy );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );', '\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );', '\tgl_FragColor = col / 41.0;', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\r\n};\r\n\r\nexport { BokehShader };\r\n", "import { UniformsUtils, ShaderMaterial } from 'three';\r\nimport { FullScreenQuad, Pass } from './Pass.js';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\n\r\nvar TexturePass = function (map, opacity) {\r\n  if (CopyShader === undefined) console.error('THREE.TexturePass relies on CopyShader');\r\n  var shader = CopyShader;\r\n  this.map = map;\r\n  this.opacity = opacity !== undefined ? opacity : 1.0;\r\n  this.uniforms = UniformsUtils.clone(shader.uniforms);\r\n  this.material = new ShaderMaterial({\r\n    uniforms: this.uniforms,\r\n    vertexShader: shader.vertexShader,\r\n    fragmentShader: shader.fragmentShader,\r\n    depthTest: false,\r\n    depthWrite: false\r\n  });\r\n  this.needsSwap = false;\r\n  this.fsQuad = new FullScreenQuad(null);\r\n};\r\n\r\nTexturePass.prototype = Object.assign(Object.create(Pass.prototype), {\r\n  constructor: TexturePass,\r\n  render: function (renderer, writeBuffer, readBuffer\r\n  /*, deltaTime, maskActive */\r\n  ) {\r\n    var oldAutoClear = renderer.autoClear;\r\n    renderer.autoClear = false;\r\n    this.fsQuad.material = this.material;\r\n    this.uniforms['opacity'].value = this.opacity;\r\n    this.uniforms['tDiffuse'].value = this.map;\r\n    this.material.transparent = this.opacity < 1.0;\r\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\r\n    if (this.clear) renderer.clear();\r\n    this.fsQuad.render(renderer);\r\n    renderer.autoClear = oldAutoClear;\r\n  }\r\n});\r\n\r\nexport { TexturePass };\r\n", "/**\r\n * Luminosity\r\n * http://en.wikipedia.org/wiki/Luminosity\r\n */\r\nconst LuminosityShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['#include <common>', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tfloat l = linearToRelativeLuminance( texel.rgb );', '\tgl_FragColor = vec4( l, l, l, texel.w );', '}'].join('\\n')\r\n};\r\n\r\nexport { LuminosityShader };\r\n", "/**\r\n * Full-screen tone-mapping shader based on http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf\r\n */\r\nconst ToneMapShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    averageLuminance: {\r\n      value: 1.0\r\n    },\r\n    luminanceMap: {\r\n      value: null\r\n    },\r\n    maxLuminance: {\r\n      value: 16.0\r\n    },\r\n    minLuminance: {\r\n      value: 0.01\r\n    },\r\n    middleGrey: {\r\n      value: 0.6\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['#include <common>', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'uniform float middleGrey;', 'uniform float minLuminance;', 'uniform float maxLuminance;', '#ifdef ADAPTED_LUMINANCE', '\tuniform sampler2D luminanceMap;', '#else', '\tuniform float averageLuminance;', '#endif', 'vec3 ToneMap( vec3 vColor ) {', '\t#ifdef ADAPTED_LUMINANCE', // Get the calculated average luminance\r\n  '\t\tfloat fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;', '\t#else', '\t\tfloat fLumAvg = averageLuminance;', '\t#endif', // Calculate the luminance of the current pixel\r\n  '\tfloat fLumPixel = linearToRelativeLuminance( vColor );', // Apply the modified operator (Eq. 4)\r\n  '\tfloat fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );', '\tfloat fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);', '\treturn fLumCompressed * vColor;', '}', 'void main() {', '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tgl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );', '}'].join('\\n')\r\n};\r\n\r\nexport { ToneMapShader };\r\n", "import { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, LinearMipmapLinearFilter, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\r\nimport { FullScreenQuad, Pass } from './Pass.js';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\nimport { LuminosityShader } from '../shaders/LuminosityShader.js';\r\nimport { ToneMapShader } from '../shaders/ToneMapShader.js';\r\n\r\n/**\r\n * Generate a texture that represents the luminosity of the current scene, adapted over time\r\n * to simulate the optic nerve responding to the amount of light it is receiving.\r\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\r\n *\r\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\r\n */\r\n\r\nvar AdaptiveToneMappingPass = function (adaptive, resolution) {\r\n  this.resolution = resolution !== undefined ? resolution : 256;\r\n  this.needsInit = true;\r\n  this.adaptive = adaptive !== undefined ? !!adaptive : true;\r\n  this.luminanceRT = null;\r\n  this.previousLuminanceRT = null;\r\n  this.currentLuminanceRT = null;\r\n  if (CopyShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on CopyShader');\r\n  var copyShader = CopyShader;\r\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\r\n  this.materialCopy = new ShaderMaterial({\r\n    uniforms: this.copyUniforms,\r\n    vertexShader: copyShader.vertexShader,\r\n    fragmentShader: copyShader.fragmentShader,\r\n    blending: NoBlending,\r\n    depthTest: false\r\n  });\r\n  if (LuminosityShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on LuminosityShader');\r\n  this.materialLuminance = new ShaderMaterial({\r\n    uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\r\n    vertexShader: LuminosityShader.vertexShader,\r\n    fragmentShader: LuminosityShader.fragmentShader,\r\n    blending: NoBlending\r\n  });\r\n  this.adaptLuminanceShader = {\r\n    defines: {\r\n      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\r\n    },\r\n    uniforms: {\r\n      lastLum: {\r\n        value: null\r\n      },\r\n      currentLum: {\r\n        value: null\r\n      },\r\n      minLuminance: {\r\n        value: 0.01\r\n      },\r\n      delta: {\r\n        value: 0.016\r\n      },\r\n      tau: {\r\n        value: 1.0\r\n      }\r\n    },\r\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n    fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D lastLum;', 'uniform sampler2D currentLum;', 'uniform float minLuminance;', 'uniform float delta;', 'uniform float tau;', 'void main() {', '\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );', '\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );', '\tfloat fLastLum = max( minLuminance, lastLum.r );', '\tfloat fCurrentLum = max( minLuminance, currentLum.r );', //The adaption seems to work better in extreme lighting differences\r\n    //if the input luminance is squared.\r\n    '\tfCurrentLum *= fCurrentLum;', // Adapt the luminance using Pattanaik's technique\r\n    '\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));', // \"fAdaptedLum = sqrt(fAdaptedLum);\",\r\n    '\tgl_FragColor.r = fAdaptedLum;', '}'].join('\\n')\r\n  };\r\n  this.materialAdaptiveLum = new ShaderMaterial({\r\n    uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\r\n    vertexShader: this.adaptLuminanceShader.vertexShader,\r\n    fragmentShader: this.adaptLuminanceShader.fragmentShader,\r\n    defines: Object.assign({}, this.adaptLuminanceShader.defines),\r\n    blending: NoBlending\r\n  });\r\n  if (ToneMapShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on ToneMapShader');\r\n  this.materialToneMap = new ShaderMaterial({\r\n    uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\r\n    vertexShader: ToneMapShader.vertexShader,\r\n    fragmentShader: ToneMapShader.fragmentShader,\r\n    blending: NoBlending\r\n  });\r\n  this.fsQuad = new FullScreenQuad(null);\r\n};\r\n\r\nAdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass.prototype), {\r\n  constructor: AdaptiveToneMappingPass,\r\n  render: function (renderer, writeBuffer, readBuffer, deltaTime\r\n  /*, maskActive*/\r\n  ) {\r\n    if (this.needsInit) {\r\n      this.reset(renderer);\r\n      this.luminanceRT.texture.type = readBuffer.texture.type;\r\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\r\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\r\n      this.needsInit = false;\r\n    }\r\n\r\n    if (this.adaptive) {\r\n      //Render the luminance of the current scene into a render target with mipmapping enabled\r\n      this.fsQuad.material = this.materialLuminance;\r\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\r\n      renderer.setRenderTarget(this.currentLuminanceRT);\r\n      this.fsQuad.render(renderer); //Use the new luminance values, the previous luminance and the frame delta to\r\n      //adapt the luminance over time.\r\n\r\n      this.fsQuad.material = this.materialAdaptiveLum;\r\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\r\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\r\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\r\n      renderer.setRenderTarget(this.luminanceRT);\r\n      this.fsQuad.render(renderer); //Copy the new adapted luminance value so that it can be used by the next frame.\r\n\r\n      this.fsQuad.material = this.materialCopy;\r\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\r\n      renderer.setRenderTarget(this.previousLuminanceRT);\r\n      this.fsQuad.render(renderer);\r\n    }\r\n\r\n    this.fsQuad.material = this.materialToneMap;\r\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\r\n\r\n    if (this.renderToScreen) {\r\n      renderer.setRenderTarget(null);\r\n      this.fsQuad.render(renderer);\r\n    } else {\r\n      renderer.setRenderTarget(writeBuffer);\r\n      if (this.clear) renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n    }\r\n  },\r\n  reset: function () {\r\n    // render targets\r\n    if (this.luminanceRT) {\r\n      this.luminanceRT.dispose();\r\n    }\r\n\r\n    if (this.currentLuminanceRT) {\r\n      this.currentLuminanceRT.dispose();\r\n    }\r\n\r\n    if (this.previousLuminanceRT) {\r\n      this.previousLuminanceRT.dispose();\r\n    }\r\n\r\n    var pars = {\r\n      minFilter: LinearFilter,\r\n      magFilter: LinearFilter,\r\n      format: RGBAFormat\r\n    }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\r\n\r\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\r\n    this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l';\r\n    this.luminanceRT.texture.generateMipmaps = false;\r\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\r\n    this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl';\r\n    this.previousLuminanceRT.texture.generateMipmaps = false; // We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\r\n\r\n    pars.minFilter = LinearMipmapLinearFilter;\r\n    pars.generateMipmaps = true;\r\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\r\n    this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl';\r\n\r\n    if (this.adaptive) {\r\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\r\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\r\n    } //Put something in the adaptive luminance texture so that the scene can render initially\r\n\r\n\r\n    this.fsQuad.material = new MeshBasicMaterial({\r\n      color: 0x777777\r\n    });\r\n    this.materialLuminance.needsUpdate = true;\r\n    this.materialAdaptiveLum.needsUpdate = true;\r\n    this.materialToneMap.needsUpdate = true; // renderer.render( this.scene, this.camera, this.luminanceRT );\r\n    // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\r\n    // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\r\n  },\r\n  setAdaptive: function (adaptive) {\r\n    if (adaptive) {\r\n      this.adaptive = true;\r\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\r\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\r\n    } else {\r\n      this.adaptive = false;\r\n      delete this.materialToneMap.defines['ADAPTED_LUMINANCE'];\r\n      this.materialToneMap.uniforms.luminanceMap.value = null;\r\n    }\r\n\r\n    this.materialToneMap.needsUpdate = true;\r\n  },\r\n  setAdaptionRate: function (rate) {\r\n    if (rate) {\r\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\r\n    }\r\n  },\r\n  setMinLuminance: function (minLum) {\r\n    if (minLum) {\r\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\r\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\r\n    }\r\n  },\r\n  setMaxLuminance: function (maxLum) {\r\n    if (maxLum) {\r\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\r\n    }\r\n  },\r\n  setAverageLuminance: function (avgLum) {\r\n    if (avgLum) {\r\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\r\n    }\r\n  },\r\n  setMiddleGrey: function (middleGrey) {\r\n    if (middleGrey) {\r\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\r\n    }\r\n  },\r\n  dispose: function () {\r\n    if (this.luminanceRT) {\r\n      this.luminanceRT.dispose();\r\n    }\r\n\r\n    if (this.previousLuminanceRT) {\r\n      this.previousLuminanceRT.dispose();\r\n    }\r\n\r\n    if (this.currentLuminanceRT) {\r\n      this.currentLuminanceRT.dispose();\r\n    }\r\n\r\n    if (this.materialLuminance) {\r\n      this.materialLuminance.dispose();\r\n    }\r\n\r\n    if (this.materialAdaptiveLum) {\r\n      this.materialAdaptiveLum.dispose();\r\n    }\r\n\r\n    if (this.materialCopy) {\r\n      this.materialCopy.dispose();\r\n    }\r\n\r\n    if (this.materialToneMap) {\r\n      this.materialToneMap.dispose();\r\n    }\r\n  }\r\n});\r\n\r\nexport { AdaptiveToneMappingPass };\r\n", "import { Color } from 'three';\r\n\r\n/**\r\n * Luminosity\r\n * http://en.wikipedia.org/wiki/Luminosity\r\n */\r\n\r\nconst LuminosityHighPassShader = {\r\n  shaderID: 'luminosityHighPass',\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    luminosityThreshold: {\r\n      value: 1.0\r\n    },\r\n    smoothWidth: {\r\n      value: 1.0\r\n    },\r\n    defaultColor: {\r\n      value: new Color(0x000000)\r\n    },\r\n    defaultOpacity: {\r\n      value: 0.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec3 defaultColor;', 'uniform float defaultOpacity;', 'uniform float luminosityThreshold;', 'uniform float smoothWidth;', 'varying vec2 vUv;', 'void main() {', '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tvec3 luma = vec3( 0.299, 0.587, 0.114 );', '\tfloat v = dot( texel.xyz, luma );', '\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );', '\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );', '\tgl_FragColor = mix( outputColor, texel, alpha );', '}'].join('\\n')\r\n};\r\n\r\nexport { LuminosityHighPassShader };\r\n", "import { Vector2, Color, WebGLRenderTarget, UniformsUtils, ShaderMaterial, Vector3, AdditiveBlending, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\r\nimport { FullScreenQuad, Pass } from './Pass.js';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\r\n\r\n/**\r\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\r\n * mip map chain of bloom textures and blurs them with different radii. Because\r\n * of the weighted combination of mips, and because larger blurs are done on\r\n * higher mips, this effect provides good quality and performance.\r\n *\r\n * Reference:\r\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\r\n */\r\n\r\nvar UnrealBloomPass = function (resolution, strength, radius, threshold) {\r\n  this.strength = strength !== undefined ? strength : 1;\r\n  this.radius = radius;\r\n  this.threshold = threshold;\r\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256); // create color only once here, reuse it later inside the render function\r\n\r\n  this.clearColor = new Color(0, 0, 0); // render targets\r\n\r\n  var pars = {\r\n    minFilter: LinearFilter,\r\n    magFilter: LinearFilter,\r\n    format: RGBAFormat\r\n  };\r\n  this.renderTargetsHorizontal = [];\r\n  this.renderTargetsVertical = [];\r\n  this.nMips = 5;\r\n  var resx = Math.round(this.resolution.x / 2);\r\n  var resy = Math.round(this.resolution.y / 2);\r\n  this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);\r\n  this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\r\n  this.renderTargetBright.texture.generateMipmaps = false;\r\n\r\n  for (let i = 0; i < this.nMips; i++) {\r\n    var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);\r\n    renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\r\n    renderTargetHorizonal.texture.generateMipmaps = false;\r\n    this.renderTargetsHorizontal.push(renderTargetHorizonal);\r\n    var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);\r\n    renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\r\n    renderTargetVertical.texture.generateMipmaps = false;\r\n    this.renderTargetsVertical.push(renderTargetVertical);\r\n    resx = Math.round(resx / 2);\r\n    resy = Math.round(resy / 2);\r\n  } // luminosity high pass material\r\n\r\n\r\n  if (LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');\r\n  var highPassShader = LuminosityHighPassShader;\r\n  this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\r\n  this.highPassUniforms['luminosityThreshold'].value = threshold;\r\n  this.highPassUniforms['smoothWidth'].value = 0.01;\r\n  this.materialHighPassFilter = new ShaderMaterial({\r\n    uniforms: this.highPassUniforms,\r\n    vertexShader: highPassShader.vertexShader,\r\n    fragmentShader: highPassShader.fragmentShader,\r\n    defines: {}\r\n  }); // Gaussian Blur Materials\r\n\r\n  this.separableBlurMaterials = [];\r\n  var kernelSizeArray = [3, 5, 7, 9, 11];\r\n  var resx = Math.round(this.resolution.x / 2);\r\n  var resy = Math.round(this.resolution.y / 2);\r\n\r\n  for (let i = 0; i < this.nMips; i++) {\r\n    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\r\n    this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\r\n    resx = Math.round(resx / 2);\r\n    resy = Math.round(resy / 2);\r\n  } // Composite material\r\n\r\n\r\n  this.compositeMaterial = this.getCompositeMaterial(this.nMips);\r\n  this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\r\n  this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\r\n  this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\r\n  this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\r\n  this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\r\n  this.compositeMaterial.uniforms['bloomStrength'].value = strength;\r\n  this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\r\n  this.compositeMaterial.needsUpdate = true;\r\n  var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\r\n  this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\r\n  this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\r\n  this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors; // copy material\r\n\r\n  if (CopyShader === undefined) {\r\n    console.error('THREE.UnrealBloomPass relies on CopyShader');\r\n  }\r\n\r\n  var copyShader = CopyShader;\r\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\r\n  this.copyUniforms['opacity'].value = 1.0;\r\n  this.materialCopy = new ShaderMaterial({\r\n    uniforms: this.copyUniforms,\r\n    vertexShader: copyShader.vertexShader,\r\n    fragmentShader: copyShader.fragmentShader,\r\n    blending: AdditiveBlending,\r\n    depthTest: false,\r\n    depthWrite: false,\r\n    transparent: true\r\n  });\r\n  this.enabled = true;\r\n  this.needsSwap = false;\r\n  this._oldClearColor = new Color();\r\n  this.oldClearAlpha = 1;\r\n  this.basic = new MeshBasicMaterial();\r\n  this.fsQuad = new FullScreenQuad(null);\r\n};\r\n\r\nUnrealBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {\r\n  constructor: UnrealBloomPass,\r\n  dispose: function () {\r\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\r\n      this.renderTargetsHorizontal[i].dispose();\r\n    }\r\n\r\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\r\n      this.renderTargetsVertical[i].dispose();\r\n    }\r\n\r\n    this.renderTargetBright.dispose();\r\n  },\r\n  setSize: function (width, height) {\r\n    var resx = Math.round(width / 2);\r\n    var resy = Math.round(height / 2);\r\n    this.renderTargetBright.setSize(resx, resy);\r\n\r\n    for (let i = 0; i < this.nMips; i++) {\r\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\r\n      this.renderTargetsVertical[i].setSize(resx, resy);\r\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\r\n      resx = Math.round(resx / 2);\r\n      resy = Math.round(resy / 2);\r\n    }\r\n  },\r\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\r\n    renderer.getClearColor(this._oldClearColor);\r\n    this.oldClearAlpha = renderer.getClearAlpha();\r\n    var oldAutoClear = renderer.autoClear;\r\n    renderer.autoClear = false;\r\n    renderer.setClearColor(this.clearColor, 0);\r\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render input to screen\r\n\r\n    if (this.renderToScreen) {\r\n      this.fsQuad.material = this.basic;\r\n      this.basic.map = readBuffer.texture;\r\n      renderer.setRenderTarget(null);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n    } // 1. Extract Bright Areas\r\n\r\n\r\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\r\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\r\n    this.fsQuad.material = this.materialHighPassFilter;\r\n    renderer.setRenderTarget(this.renderTargetBright);\r\n    renderer.clear();\r\n    this.fsQuad.render(renderer); // 2. Blur All the mips progressively\r\n\r\n    var inputRenderTarget = this.renderTargetBright;\r\n\r\n    for (let i = 0; i < this.nMips; i++) {\r\n      this.fsQuad.material = this.separableBlurMaterials[i];\r\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\r\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\r\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\r\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\r\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n      inputRenderTarget = this.renderTargetsVertical[i];\r\n    } // Composite All the mips\r\n\r\n\r\n    this.fsQuad.material = this.compositeMaterial;\r\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\r\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\r\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\r\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\r\n    renderer.clear();\r\n    this.fsQuad.render(renderer); // Blend it additively over the input texture\r\n\r\n    this.fsQuad.material = this.materialCopy;\r\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\r\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\r\n\r\n    if (this.renderToScreen) {\r\n      renderer.setRenderTarget(null);\r\n      this.fsQuad.render(renderer);\r\n    } else {\r\n      renderer.setRenderTarget(readBuffer);\r\n      this.fsQuad.render(renderer);\r\n    } // Restore renderer settings\r\n\r\n\r\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\r\n    renderer.autoClear = oldAutoClear;\r\n  },\r\n  getSeperableBlurMaterial: function (kernelRadius) {\r\n    return new ShaderMaterial({\r\n      defines: {\r\n        KERNEL_RADIUS: kernelRadius,\r\n        SIGMA: kernelRadius\r\n      },\r\n      uniforms: {\r\n        colorTexture: {\r\n          value: null\r\n        },\r\n        texSize: {\r\n          value: new Vector2(0.5, 0.5)\r\n        },\r\n        direction: {\r\n          value: new Vector2(0.5, 0.5)\r\n        }\r\n      },\r\n      vertexShader: 'varying vec2 vUv;\\n' + 'void main() {\\n' + '\tvUv = uv;\\n' + '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n' + '}',\r\n      fragmentShader: '#include <common>' + 'varying vec2 vUv;\\n' + 'uniform sampler2D colorTexture;\\n' + 'uniform vec2 texSize;' + 'uniform vec2 direction;' + '\\n' + 'float gaussianPdf(in float x, in float sigma) {' + '\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;' + '}' + 'void main() {\\n' + '\tvec2 invSize = 1.0 / texSize;' + '\tfloat fSigma = float(SIGMA);' + '\tfloat weightSum = gaussianPdf(0.0, fSigma);' + '\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;' + '\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {' + '\t\tfloat x = float(i);' + '\t\tfloat w = gaussianPdf(x, fSigma);' + '\t\tvec2 uvOffset = direction * invSize * x;' + '\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;' + '\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;' + '\t\tdiffuseSum += (sample1 + sample2) * w;' + '\t\tweightSum += 2.0 * w;' + '\t}' + '\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n' + '}'\r\n    });\r\n  },\r\n  getCompositeMaterial: function (nMips) {\r\n    return new ShaderMaterial({\r\n      defines: {\r\n        NUM_MIPS: nMips\r\n      },\r\n      uniforms: {\r\n        blurTexture1: {\r\n          value: null\r\n        },\r\n        blurTexture2: {\r\n          value: null\r\n        },\r\n        blurTexture3: {\r\n          value: null\r\n        },\r\n        blurTexture4: {\r\n          value: null\r\n        },\r\n        blurTexture5: {\r\n          value: null\r\n        },\r\n        dirtTexture: {\r\n          value: null\r\n        },\r\n        bloomStrength: {\r\n          value: 1.0\r\n        },\r\n        bloomFactors: {\r\n          value: null\r\n        },\r\n        bloomTintColors: {\r\n          value: null\r\n        },\r\n        bloomRadius: {\r\n          value: 0.0\r\n        }\r\n      },\r\n      vertexShader: 'varying vec2 vUv;\\n' + 'void main() {\\n' + '\tvUv = uv;\\n' + '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n' + '}',\r\n      fragmentShader: 'varying vec2 vUv;' + 'uniform sampler2D blurTexture1;' + 'uniform sampler2D blurTexture2;' + 'uniform sampler2D blurTexture3;' + 'uniform sampler2D blurTexture4;' + 'uniform sampler2D blurTexture5;' + 'uniform sampler2D dirtTexture;' + 'uniform float bloomStrength;' + 'uniform float bloomRadius;' + 'uniform float bloomFactors[NUM_MIPS];' + 'uniform vec3 bloomTintColors[NUM_MIPS];' + '' + 'float lerpBloomFactor(const in float factor) { ' + '\tfloat mirrorFactor = 1.2 - factor;' + '\treturn mix(factor, mirrorFactor, bloomRadius);' + '}' + '' + 'void main() {' + '\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + ' + '\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );' + '}'\r\n    });\r\n  }\r\n});\r\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\r\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\r\n\r\nexport { UnrealBloomPass };\r\n", "import { ShaderLib, Mesh, BoxGeometry, ShaderMaterial, UniformsUtils, BackSide, Scene, PerspectiveCamera } from 'three';\r\nimport { Pass } from './Pass.js';\r\n\r\nvar CubeTexturePass = function (camera, envMap, opacity) {\r\n  this.camera = camera;\r\n  this.needsSwap = false;\r\n  this.cubeShader = ShaderLib['cube'];\r\n  this.cubeMesh = new Mesh(new BoxGeometry(10, 10, 10), new ShaderMaterial({\r\n    uniforms: UniformsUtils.clone(this.cubeShader.uniforms),\r\n    vertexShader: this.cubeShader.vertexShader,\r\n    fragmentShader: this.cubeShader.fragmentShader,\r\n    depthTest: false,\r\n    depthWrite: false,\r\n    side: BackSide\r\n  }));\r\n  Object.defineProperty(this.cubeMesh.material, 'envMap', {\r\n    get: function () {\r\n      return this.uniforms.envMap.value;\r\n    }\r\n  });\r\n  this.envMap = envMap;\r\n  this.opacity = opacity !== undefined ? opacity : 1.0;\r\n  this.cubeScene = new Scene();\r\n  this.cubeCamera = new PerspectiveCamera();\r\n  this.cubeScene.add(this.cubeMesh);\r\n};\r\n\r\nCubeTexturePass.prototype = Object.assign(Object.create(Pass.prototype), {\r\n  constructor: CubeTexturePass,\r\n  render: function (renderer, writeBuffer, readBuffer\r\n  /*, deltaTime, maskActive*/\r\n  ) {\r\n    var oldAutoClear = renderer.autoClear;\r\n    renderer.autoClear = false;\r\n    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\r\n    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\r\n    this.cubeMesh.material.uniforms.envMap.value = this.envMap;\r\n    this.cubeMesh.material.uniforms.flipEnvMap.value = this.envMap.isCubeTexture && this.envMap._needsFlipEnvMap ? -1 : 1;\r\n    this.cubeMesh.material.uniforms.opacity.value = this.opacity;\r\n    this.cubeMesh.material.transparent = this.opacity < 1.0;\r\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\r\n    if (this.clear) renderer.clear();\r\n    renderer.render(this.cubeScene, this.cubeCamera);\r\n    renderer.autoClear = oldAutoClear;\r\n  }\r\n});\r\n\r\nexport { CubeTexturePass };\r\n", "import { Vector2, Matrix4 } from 'three';\r\n\r\nconst SAOShader = {\r\n  defines: {\r\n    NUM_SAMPLES: 7,\r\n    NUM_RINGS: 4,\r\n    NORMAL_TEXTURE: 0,\r\n    DIFFUSE_TEXTURE: 0,\r\n    DEPTH_PACKING: 1,\r\n    PERSPECTIVE_CAMERA: 1\r\n  },\r\n  uniforms: {\r\n    tDepth: {\r\n      value: null\r\n    },\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    tNormal: {\r\n      value: null\r\n    },\r\n    size: {\r\n      value: new Vector2(512, 512)\r\n    },\r\n    cameraNear: {\r\n      value: 1\r\n    },\r\n    cameraFar: {\r\n      value: 100\r\n    },\r\n    cameraProjectionMatrix: {\r\n      value: new Matrix4()\r\n    },\r\n    cameraInverseProjectionMatrix: {\r\n      value: new Matrix4()\r\n    },\r\n    scale: {\r\n      value: 1.0\r\n    },\r\n    intensity: {\r\n      value: 0.1\r\n    },\r\n    bias: {\r\n      value: 0.5\r\n    },\r\n    minResolution: {\r\n      value: 0.0\r\n    },\r\n    kernelRadius: {\r\n      value: 100.0\r\n    },\r\n    randomSeed: {\r\n      value: 0.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', '#if DIFFUSE_TEXTURE == 1', 'uniform sampler2D tDiffuse;', '#endif', 'uniform sampler2D tDepth;', '#if NORMAL_TEXTURE == 1', 'uniform sampler2D tNormal;', '#endif', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float scale;', 'uniform float intensity;', 'uniform float bias;', 'uniform float kernelRadius;', 'uniform float minResolution;', 'uniform vec2 size;', 'uniform float randomSeed;', '// RGBA depth', '#include <packing>', 'vec4 getDefaultColor( const in vec2 screenPosition ) {', '\t#if DIFFUSE_TEXTURE == 1', '\treturn texture2D( tDiffuse, vUv );', '\t#else', '\treturn vec4( 1.0 );', '\t#endif', '}', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {', '\t#if NORMAL_TEXTURE == 1', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '\t#else', '\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );', '\t#endif', '}', 'float scaleDividedByCameraFar;', 'float minResolutionMultipliedByCameraFar;', 'float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {', '\tvec3 viewDelta = sampleViewPosition - centerViewPosition;', '\tfloat viewDistance = length( viewDelta );', '\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;', '\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );', '}', '// moving costly divides into consts', 'const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );', 'const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );', 'float getAmbientOcclusion( const in vec3 centerViewPosition ) {', '\t// precompute some variables require in getOcclusion.', '\tscaleDividedByCameraFar = scale / cameraFar;', '\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;', '\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );', '\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/', '\tfloat angle = rand( vUv + randomSeed ) * PI2;', '\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;', '\tvec2 radiusStep = radius;', '\tfloat occlusionSum = 0.0;', '\tfloat weightSum = 0.0;', '\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {', '\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;', '\t\tradius += radiusStep;', '\t\tangle += ANGLE_STEP;', '\t\tfloat sampleDepth = getDepth( sampleUv );', '\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {', '\t\t\tcontinue;', '\t\t}', '\t\tfloat sampleViewZ = getViewZ( sampleDepth );', '\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );', '\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );', '\t\tweightSum += 1.0;', '\t}', '\tif( weightSum == 0.0 ) discard;', '\treturn occlusionSum * ( intensity / weightSum );', '}', 'void main() {', '\tfloat centerDepth = getDepth( vUv );', '\tif( centerDepth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = getViewZ( centerDepth );', '\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );', '\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );', '\tgl_FragColor = getDefaultColor( vUv );', '\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;', '}'].join('\\n')\r\n};\r\n\r\nexport { SAOShader };\r\n", "import { Vector2 } from 'three';\r\n\r\nconst DepthLimitedBlurShader = {\r\n  defines: {\r\n    KERNEL_RADIUS: 4,\r\n    DEPTH_PACKING: 1,\r\n    PERSPECTIVE_CAMERA: 1\r\n  },\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    size: {\r\n      value: new Vector2(512, 512)\r\n    },\r\n    sampleUvOffsets: {\r\n      value: [new Vector2(0, 0)]\r\n    },\r\n    sampleWeights: {\r\n      value: [1.0]\r\n    },\r\n    tDepth: {\r\n      value: null\r\n    },\r\n    cameraNear: {\r\n      value: 10\r\n    },\r\n    cameraFar: {\r\n      value: 1000\r\n    },\r\n    depthCutoff: {\r\n      value: 10\r\n    }\r\n  },\r\n  vertexShader: ['#include <common>', 'uniform vec2 size;', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'void main() {', '\tvUv = uv;', '\tvInvSize = 1.0 / size;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['#include <common>', '#include <packing>', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform float depthCutoff;', 'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];', 'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tif( depth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = -getViewZ( depth );', '\tbool rBreak = false, lBreak = false;', '\tfloat weightSum = sampleWeights[0];', '\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;', '\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {', '\t\tfloat sampleWeight = sampleWeights[i];', '\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;', '\t\tvec2 sampleUv = vUv + sampleUvOffset;', '\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;', '\t\tif( ! rBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t\tsampleUv = vUv - sampleUvOffset;', '\t\tviewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;', '\t\tif( ! lBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t}', '\tgl_FragColor = diffuseSum / weightSum;', '}'].join('\\n')\r\n};\r\nconst BlurShaderUtils = {\r\n  createSampleWeights: (kernelRadius, stdDev) => {\r\n    const gaussian = (x, stdDev) => {\r\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);\r\n    };\r\n\r\n    const weights = [];\r\n\r\n    for (let i = 0; i <= kernelRadius; i++) {\r\n      weights.push(gaussian(i, stdDev));\r\n    }\r\n\r\n    return weights;\r\n  },\r\n  createSampleOffsets: (kernelRadius, uvIncrement) => {\r\n    const offsets = [];\r\n\r\n    for (let i = 0; i <= kernelRadius; i++) {\r\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\r\n    }\r\n\r\n    return offsets;\r\n  },\r\n  configure: (shader, kernelRadius, stdDev, uvIncrement) => {\r\n    shader.defines['KERNEL_RADIUS'] = kernelRadius;\r\n    shader.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\r\n    shader.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\r\n    shader.needsUpdate = true;\r\n  }\r\n};\r\n\r\nexport { BlurShaderUtils, DepthLimitedBlurShader };\r\n", "import { Color, Vector2, WebGLRenderTarget, LinearFilter, RGBAFormat, NearestFilter, DepthTexture, UnsignedShortType, MeshDepthMaterial, RGBADepthPacking, NoBlending, MeshNormalMaterial, ShaderMaterial, UniformsUtils, CustomBlending, DstColorFactor, ZeroFactor, AddEquation, DstAlphaFactor } from 'three';\r\nimport { FullScreenQuad, Pass } from './Pass.js';\r\nimport { SAOShader } from '../shaders/SAOShader.js';\r\nimport { DepthLimitedBlurShader, BlurShaderUtils } from '../shaders/DepthLimitedBlurShader.js';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';\r\n\r\n/**\r\n * SAO implementation inspired from bhouston previous SAO work\r\n */\r\n\r\nvar SAOPass = function (scene, camera, depthTexture, useNormals, resolution) {\r\n  this.scene = scene;\r\n  this.camera = camera;\r\n  this.clear = true;\r\n  this.needsSwap = false;\r\n  this.supportsDepthTextureExtension = depthTexture !== undefined ? depthTexture : false;\r\n  this.supportsNormalTexture = useNormals !== undefined ? useNormals : false;\r\n  this.originalClearColor = new Color();\r\n  this._oldClearColor = new Color();\r\n  this.oldClearAlpha = 1;\r\n  this.params = {\r\n    output: 0,\r\n    saoBias: 0.5,\r\n    saoIntensity: 0.18,\r\n    saoScale: 1,\r\n    saoKernelRadius: 100,\r\n    saoMinResolution: 0,\r\n    saoBlur: true,\r\n    saoBlurRadius: 8,\r\n    saoBlurStdDev: 4,\r\n    saoBlurDepthCutoff: 0.01\r\n  };\r\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\r\n  this.saoRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {\r\n    minFilter: LinearFilter,\r\n    magFilter: LinearFilter,\r\n    format: RGBAFormat\r\n  });\r\n  this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();\r\n  this.beautyRenderTarget = this.saoRenderTarget.clone();\r\n  this.normalRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {\r\n    minFilter: NearestFilter,\r\n    magFilter: NearestFilter,\r\n    format: RGBAFormat\r\n  });\r\n  this.depthRenderTarget = this.normalRenderTarget.clone();\r\n\r\n  if (this.supportsDepthTextureExtension) {\r\n    var depthTexture = new DepthTexture();\r\n    depthTexture.type = UnsignedShortType;\r\n    this.beautyRenderTarget.depthTexture = depthTexture;\r\n    this.beautyRenderTarget.depthBuffer = true;\r\n  }\r\n\r\n  this.depthMaterial = new MeshDepthMaterial();\r\n  this.depthMaterial.depthPacking = RGBADepthPacking;\r\n  this.depthMaterial.blending = NoBlending;\r\n  this.normalMaterial = new MeshNormalMaterial();\r\n  this.normalMaterial.blending = NoBlending;\r\n\r\n  if (SAOShader === undefined) {\r\n    console.error('THREE.SAOPass relies on SAOShader');\r\n  }\r\n\r\n  this.saoMaterial = new ShaderMaterial({\r\n    defines: Object.assign({}, SAOShader.defines),\r\n    fragmentShader: SAOShader.fragmentShader,\r\n    vertexShader: SAOShader.vertexShader,\r\n    uniforms: UniformsUtils.clone(SAOShader.uniforms)\r\n  });\r\n  this.saoMaterial.extensions.derivatives = true;\r\n  this.saoMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;\r\n  this.saoMaterial.defines['NORMAL_TEXTURE'] = this.supportsNormalTexture ? 1 : 0;\r\n  this.saoMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;\r\n  this.saoMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\r\n  this.saoMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture;\r\n  this.saoMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);\r\n  this.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);\r\n  this.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix;\r\n  this.saoMaterial.blending = NoBlending;\r\n\r\n  if (DepthLimitedBlurShader === undefined) {\r\n    console.error('THREE.SAOPass relies on DepthLimitedBlurShader');\r\n  }\r\n\r\n  this.vBlurMaterial = new ShaderMaterial({\r\n    uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),\r\n    defines: Object.assign({}, DepthLimitedBlurShader.defines),\r\n    vertexShader: DepthLimitedBlurShader.vertexShader,\r\n    fragmentShader: DepthLimitedBlurShader.fragmentShader\r\n  });\r\n  this.vBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;\r\n  this.vBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;\r\n  this.vBlurMaterial.uniforms['tDiffuse'].value = this.saoRenderTarget.texture;\r\n  this.vBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\r\n  this.vBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);\r\n  this.vBlurMaterial.blending = NoBlending;\r\n  this.hBlurMaterial = new ShaderMaterial({\r\n    uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),\r\n    defines: Object.assign({}, DepthLimitedBlurShader.defines),\r\n    vertexShader: DepthLimitedBlurShader.vertexShader,\r\n    fragmentShader: DepthLimitedBlurShader.fragmentShader\r\n  });\r\n  this.hBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;\r\n  this.hBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;\r\n  this.hBlurMaterial.uniforms['tDiffuse'].value = this.blurIntermediateRenderTarget.texture;\r\n  this.hBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\r\n  this.hBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);\r\n  this.hBlurMaterial.blending = NoBlending;\r\n\r\n  if (CopyShader === undefined) {\r\n    console.error('THREE.SAOPass relies on CopyShader');\r\n  }\r\n\r\n  this.materialCopy = new ShaderMaterial({\r\n    uniforms: UniformsUtils.clone(CopyShader.uniforms),\r\n    vertexShader: CopyShader.vertexShader,\r\n    fragmentShader: CopyShader.fragmentShader,\r\n    blending: NoBlending\r\n  });\r\n  this.materialCopy.transparent = true;\r\n  this.materialCopy.depthTest = false;\r\n  this.materialCopy.depthWrite = false;\r\n  this.materialCopy.blending = CustomBlending;\r\n  this.materialCopy.blendSrc = DstColorFactor;\r\n  this.materialCopy.blendDst = ZeroFactor;\r\n  this.materialCopy.blendEquation = AddEquation;\r\n  this.materialCopy.blendSrcAlpha = DstAlphaFactor;\r\n  this.materialCopy.blendDstAlpha = ZeroFactor;\r\n  this.materialCopy.blendEquationAlpha = AddEquation;\r\n\r\n  if (UnpackDepthRGBAShader === undefined) {\r\n    console.error('THREE.SAOPass relies on UnpackDepthRGBAShader');\r\n  }\r\n\r\n  this.depthCopy = new ShaderMaterial({\r\n    uniforms: UniformsUtils.clone(UnpackDepthRGBAShader.uniforms),\r\n    vertexShader: UnpackDepthRGBAShader.vertexShader,\r\n    fragmentShader: UnpackDepthRGBAShader.fragmentShader,\r\n    blending: NoBlending\r\n  });\r\n  this.fsQuad = new FullScreenQuad(null);\r\n};\r\n\r\nSAOPass.OUTPUT = {\r\n  Beauty: 1,\r\n  Default: 0,\r\n  SAO: 2,\r\n  Depth: 3,\r\n  Normal: 4\r\n};\r\nSAOPass.prototype = Object.assign(Object.create(Pass.prototype), {\r\n  constructor: SAOPass,\r\n  render: function (renderer, writeBuffer, readBuffer\r\n  /*, deltaTime, maskActive*/\r\n  ) {\r\n    // Rendering readBuffer first when rendering to screen\r\n    if (this.renderToScreen) {\r\n      this.materialCopy.blending = NoBlending;\r\n      this.materialCopy.uniforms['tDiffuse'].value = readBuffer.texture;\r\n      this.materialCopy.needsUpdate = true;\r\n      this.renderPass(renderer, this.materialCopy, null);\r\n    }\r\n\r\n    if (this.params.output === 1) {\r\n      return;\r\n    }\r\n\r\n    renderer.getClearColor(this._oldClearColor);\r\n    this.oldClearAlpha = renderer.getClearAlpha();\r\n    var oldAutoClear = renderer.autoClear;\r\n    renderer.autoClear = false;\r\n    renderer.setRenderTarget(this.depthRenderTarget);\r\n    renderer.clear();\r\n    this.saoMaterial.uniforms['bias'].value = this.params.saoBias;\r\n    this.saoMaterial.uniforms['intensity'].value = this.params.saoIntensity;\r\n    this.saoMaterial.uniforms['scale'].value = this.params.saoScale;\r\n    this.saoMaterial.uniforms['kernelRadius'].value = this.params.saoKernelRadius;\r\n    this.saoMaterial.uniforms['minResolution'].value = this.params.saoMinResolution;\r\n    this.saoMaterial.uniforms['cameraNear'].value = this.camera.near;\r\n    this.saoMaterial.uniforms['cameraFar'].value = this.camera.far; // this.saoMaterial.uniforms['randomSeed'].value = Math.random();\r\n\r\n    var depthCutoff = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);\r\n    this.vBlurMaterial.uniforms['depthCutoff'].value = depthCutoff;\r\n    this.hBlurMaterial.uniforms['depthCutoff'].value = depthCutoff;\r\n    this.vBlurMaterial.uniforms['cameraNear'].value = this.camera.near;\r\n    this.vBlurMaterial.uniforms['cameraFar'].value = this.camera.far;\r\n    this.hBlurMaterial.uniforms['cameraNear'].value = this.camera.near;\r\n    this.hBlurMaterial.uniforms['cameraFar'].value = this.camera.far;\r\n    this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius);\r\n\r\n    if (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) {\r\n      BlurShaderUtils.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(0, 1));\r\n      BlurShaderUtils.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(1, 0));\r\n      this.prevStdDev = this.params.saoBlurStdDev;\r\n      this.prevNumSamples = this.params.saoBlurRadius;\r\n    } // Rendering scene to depth texture\r\n\r\n\r\n    renderer.setClearColor(0x000000);\r\n    renderer.setRenderTarget(this.beautyRenderTarget);\r\n    renderer.clear();\r\n    renderer.render(this.scene, this.camera); // Re-render scene if depth texture extension is not supported\r\n\r\n    if (!this.supportsDepthTextureExtension) {\r\n      // Clear rule : far clipping plane in both RGBA and Basic encoding\r\n      this.renderOverride(renderer, this.depthMaterial, this.depthRenderTarget, 0x000000, 1.0);\r\n    }\r\n\r\n    if (this.supportsNormalTexture) {\r\n      // Clear rule : default normal is facing the camera\r\n      this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0);\r\n    } // Rendering SAO texture\r\n\r\n\r\n    this.renderPass(renderer, this.saoMaterial, this.saoRenderTarget, 0xffffff, 1.0); // Blurring SAO texture\r\n\r\n    if (this.params.saoBlur) {\r\n      this.renderPass(renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 0xffffff, 1.0);\r\n      this.renderPass(renderer, this.hBlurMaterial, this.saoRenderTarget, 0xffffff, 1.0);\r\n    }\r\n\r\n    var outputMaterial = this.materialCopy; // Setting up SAO rendering\r\n\r\n    if (this.params.output === 3) {\r\n      if (this.supportsDepthTextureExtension) {\r\n        this.materialCopy.uniforms['tDiffuse'].value = this.beautyRenderTarget.depthTexture;\r\n        this.materialCopy.needsUpdate = true;\r\n      } else {\r\n        this.depthCopy.uniforms['tDiffuse'].value = this.depthRenderTarget.texture;\r\n        this.depthCopy.needsUpdate = true;\r\n        outputMaterial = this.depthCopy;\r\n      }\r\n    } else if (this.params.output === 4) {\r\n      this.materialCopy.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;\r\n      this.materialCopy.needsUpdate = true;\r\n    } else {\r\n      this.materialCopy.uniforms['tDiffuse'].value = this.saoRenderTarget.texture;\r\n      this.materialCopy.needsUpdate = true;\r\n    } // Blending depends on output, only want a CustomBlending when showing SAO\r\n\r\n\r\n    if (this.params.output === 0) {\r\n      outputMaterial.blending = CustomBlending;\r\n    } else {\r\n      outputMaterial.blending = NoBlending;\r\n    } // Rendering SAOPass result on top of previous pass\r\n\r\n\r\n    this.renderPass(renderer, outputMaterial, this.renderToScreen ? null : readBuffer);\r\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\r\n    renderer.autoClear = oldAutoClear;\r\n  },\r\n  renderPass: function (renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\r\n    // save original state\r\n    renderer.getClearColor(this.originalClearColor);\r\n    var originalClearAlpha = renderer.getClearAlpha();\r\n    var originalAutoClear = renderer.autoClear;\r\n    renderer.setRenderTarget(renderTarget); // setup pass state\r\n\r\n    renderer.autoClear = false;\r\n\r\n    if (clearColor !== undefined && clearColor !== null) {\r\n      renderer.setClearColor(clearColor);\r\n      renderer.setClearAlpha(clearAlpha || 0.0);\r\n      renderer.clear();\r\n    }\r\n\r\n    this.fsQuad.material = passMaterial;\r\n    this.fsQuad.render(renderer); // restore original state\r\n\r\n    renderer.autoClear = originalAutoClear;\r\n    renderer.setClearColor(this.originalClearColor);\r\n    renderer.setClearAlpha(originalClearAlpha);\r\n  },\r\n  renderOverride: function (renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\r\n    renderer.getClearColor(this.originalClearColor);\r\n    var originalClearAlpha = renderer.getClearAlpha();\r\n    var originalAutoClear = renderer.autoClear;\r\n    renderer.setRenderTarget(renderTarget);\r\n    renderer.autoClear = false;\r\n    clearColor = overrideMaterial.clearColor || clearColor;\r\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;\r\n\r\n    if (clearColor !== undefined && clearColor !== null) {\r\n      renderer.setClearColor(clearColor);\r\n      renderer.setClearAlpha(clearAlpha || 0.0);\r\n      renderer.clear();\r\n    }\r\n\r\n    this.scene.overrideMaterial = overrideMaterial;\r\n    renderer.render(this.scene, this.camera);\r\n    this.scene.overrideMaterial = null; // restore original state\r\n\r\n    renderer.autoClear = originalAutoClear;\r\n    renderer.setClearColor(this.originalClearColor);\r\n    renderer.setClearAlpha(originalClearAlpha);\r\n  },\r\n  setSize: function (width, height) {\r\n    this.beautyRenderTarget.setSize(width, height);\r\n    this.saoRenderTarget.setSize(width, height);\r\n    this.blurIntermediateRenderTarget.setSize(width, height);\r\n    this.normalRenderTarget.setSize(width, height);\r\n    this.depthRenderTarget.setSize(width, height);\r\n    this.saoMaterial.uniforms['size'].value.set(width, height);\r\n    this.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);\r\n    this.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix;\r\n    this.saoMaterial.needsUpdate = true;\r\n    this.vBlurMaterial.uniforms['size'].value.set(width, height);\r\n    this.vBlurMaterial.needsUpdate = true;\r\n    this.hBlurMaterial.uniforms['size'].value.set(width, height);\r\n    this.hBlurMaterial.needsUpdate = true;\r\n  }\r\n});\r\n\r\nexport { SAOPass };\r\n", "/**\r\n * Afterimage shader\r\n * I created this effect inspired by a demo on codepen:\r\n * https://codepen.io/brunoimbrizi/pen/MoRJaN?page=1&\r\n */\r\nconst AfterimageShader = {\r\n  uniforms: {\r\n    damp: {\r\n      value: 0.96\r\n    },\r\n    tOld: {\r\n      value: null\r\n    },\r\n    tNew: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform float damp;', 'uniform sampler2D tOld;', 'uniform sampler2D tNew;', 'varying vec2 vUv;', 'vec4 when_gt( vec4 x, float y ) {', '\treturn max( sign( x - y ), 0.0 );', '}', 'void main() {', '\tvec4 texelOld = texture2D( tOld, vUv );', '\tvec4 texelNew = texture2D( tNew, vUv );', '\ttexelOld *= damp * when_gt( texelOld, 0.1 );', '\tgl_FragColor = max(texelNew, texelOld);', '}'].join('\\n')\r\n};\r\n\r\nexport { AfterimageShader };\r\n", "import { Vector2 } from 'three';\r\n\r\n/**\r\n * Dot screen shader\r\n * based on glfx.js sepia shader\r\n * https://github.com/evanw/glfx.js\r\n */\r\n\r\nconst DotScreenShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    tSize: {\r\n      value: new Vector2(256, 256)\r\n    },\r\n    center: {\r\n      value: new Vector2(0.5, 0.5)\r\n    },\r\n    angle: {\r\n      value: 1.57\r\n    },\r\n    scale: {\r\n      value: 1.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform vec2 center;', 'uniform float angle;', 'uniform float scale;', 'uniform vec2 tSize;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'float pattern() {', '\tfloat s = sin( angle ), c = cos( angle );', '\tvec2 tex = vUv * tSize - center;', '\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;', '\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;', '}', 'void main() {', '\tvec4 color = texture2D( tDiffuse, vUv );', '\tfloat average = ( color.r + color.g + color.b ) / 3.0;', '\tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );', '}'].join('\\n')\r\n};\r\n\r\nexport { DotScreenShader };\r\n", "import { Vector2, Matrix4 } from 'three';\r\n\r\n/**\r\n * References:\r\n * https://lettier.github.io/3d-game-shaders-for-beginners/screen-space-reflection.html\r\n */\r\n\r\nconst SSRShader = {\r\n  defines: {\r\n    MAX_STEP: 0,\r\n    isPerspectiveCamera: true,\r\n    isDistanceAttenuation: true,\r\n    isFresnel: true,\r\n    isInfiniteThick: false,\r\n    isSelective: false\r\n  },\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    tNormal: {\r\n      value: null\r\n    },\r\n    tMetalness: {\r\n      value: null\r\n    },\r\n    tDepth: {\r\n      value: null\r\n    },\r\n    cameraNear: {\r\n      value: null\r\n    },\r\n    cameraFar: {\r\n      value: null\r\n    },\r\n    resolution: {\r\n      value: new Vector2()\r\n    },\r\n    cameraProjectionMatrix: {\r\n      value: new Matrix4()\r\n    },\r\n    cameraInverseProjectionMatrix: {\r\n      value: new Matrix4()\r\n    },\r\n    opacity: {\r\n      value: 0.5\r\n    },\r\n    maxDistance: {\r\n      value: 180\r\n    },\r\n    cameraRange: {\r\n      value: 0\r\n    },\r\n    surfDist: {\r\n      value: 0.007\r\n    },\r\n    thickTolerance: {\r\n      value: 0.03\r\n    }\r\n  },\r\n  vertexShader:\r\n  /* glsl */\r\n  `\r\n\r\n    varying vec2 vUv;\r\n\r\n    void main() {\r\n\r\n\t\t\tvUv = uv;\r\n\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n    }\r\n\r\n  `,\r\n  fragmentShader:\r\n  /* glsl */\r\n  `\r\n\t\t// precision highp float;\r\n\t\tprecision highp sampler2D;\r\n\t\tvarying vec2 vUv;\r\n\t\tuniform sampler2D tDepth;\r\n\t\tuniform sampler2D tNormal;\r\n\t\tuniform sampler2D tMetalness;\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tuniform float cameraRange;\r\n\t\tuniform vec2 resolution;\r\n\t\tuniform float opacity;\r\n\t\tuniform float cameraNear;\r\n\t\tuniform float cameraFar;\r\n\t\tuniform float maxDistance;\r\n\t\tuniform float surfDist;\r\n\t\tuniform mat4 cameraProjectionMatrix;\r\n\t\tuniform mat4 cameraInverseProjectionMatrix;\r\n\t\tuniform float thickTolerance;\r\n\t\t#include <packing>\r\n\t\tfloat pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {\r\n\t\t\t//x0: point, x1: linePointA, x2: linePointB\r\n\t\t\t//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\r\n\t\t\treturn length(cross(x0-x1,x0-x2))/length(x2-x1);\r\n\t\t}\r\n\t\tfloat pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){\r\n\t\t\t// https://mathworld.wolfram.com/Point-PlaneDistance.html\r\n\t\t\t//// https://en.wikipedia.org/wiki/Plane_(geometry)\r\n\t\t\t//// http://paulbourke.net/geometry/pointlineplane/\r\n\t\t\tfloat a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;\r\n\t\t\tfloat x0=point.x,y0=point.y,z0=point.z;\r\n\t\t\tfloat x=planePoint.x,y=planePoint.y,z=planePoint.z;\r\n\t\t\tfloat d=-(a*x+b*y+c*z);\r\n\t\t\tfloat distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);\r\n\t\t\treturn distance;\r\n\t\t}\r\n\t\tfloat getDepth( const in vec2 uv ) {\r\n\t\t\treturn texture2D( tDepth, uv ).x;\r\n\t\t}\r\n\t\tfloat getViewZ( const in float depth ) {\r\n\t\t\t#ifdef isPerspectiveCamera\r\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\r\n\t\t\t#else\r\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\r\n\t\t\t#endif\r\n\t\t}\r\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\r\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\r\n\t\t\tclipPosition *= clipW; //clip\r\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view\r\n\t\t}\r\n\t\tvec3 getViewNormal( const in vec2 uv ) {\r\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, uv ).xyz );\r\n\t\t}\r\n\t\tvec2 viewPositionToXY(vec3 viewPosition){\r\n\t\t\tvec2 xy;\r\n\t\t\tvec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);\r\n\t\t\txy=clip.xy;//clip\r\n\t\t\tfloat clipW=clip.w;\r\n\t\t\txy/=clipW;//NDC\r\n\t\t\txy=(xy+1.)/2.;//uv\r\n\t\t\txy*=resolution;//screen\r\n\t\t\treturn xy;\r\n\t\t}\r\n\t\tvoid main(){\r\n\t\t\t#ifdef isSelective\r\n\t\t\t\tfloat metalness=texture2D(tMetalness,vUv).r;\r\n\t\t\t\tif(metalness==0.) return;\r\n\t\t\t#endif\r\n\r\n\t\t\tfloat depth = getDepth( vUv );\r\n\t\t\tfloat viewZ = getViewZ( depth );\r\n\t\t\tif(-viewZ>=cameraFar) return;\r\n\r\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];\r\n\t\t\tvec3 viewPosition=getViewPosition( vUv, depth, clipW );\r\n\r\n\t\t\tvec2 d0=gl_FragCoord.xy;\r\n\t\t\tvec2 d1;\r\n\r\n\t\t\tvec3 viewNormal=getViewNormal( vUv );\r\n\r\n\t\t\t#ifdef isPerspectiveCamera\r\n\t\t\t\tvec3 viewIncidenceDir=normalize(viewPosition);\r\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);\r\n\t\t\t#else\r\n\t\t\t\tvec3 viewIncidenceDir=vec3(0,0,-1);\r\n\t\t\t\tvec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);\r\n\t\t\t#endif\r\n\r\n\t\t\tfloat maxReflectRayLen=maxDistance/dot(-viewIncidenceDir,viewNormal);\r\n\t\t\t// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html\r\n\t\t\t// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)\r\n\t\t\t// maxDistance/maxReflectRayLen=cos(theta)\r\n\t\t\t// maxDistance/maxReflectRayLen==dot(a,b)\r\n\t\t\t// maxReflectRayLen==maxDistance/dot(a,b)\r\n\r\n\t\t\tvec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;\r\n\t\t\t#ifdef isPerspectiveCamera\r\n\t\t\t\tif(d1viewPosition.z>-cameraNear){\r\n\t\t\t\t\t//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx\r\n\t\t\t\t\tfloat t=(-cameraNear-viewPosition.z)/viewReflectDir.z;\r\n\t\t\t\t\td1viewPosition=viewPosition+viewReflectDir*t;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\td1=viewPositionToXY(d1viewPosition);\r\n\r\n\t\t\tfloat totalLen=length(d1-d0);\r\n\t\t\tfloat xLen=d1.x-d0.x;\r\n\t\t\tfloat yLen=d1.y-d0.y;\r\n\t\t\tfloat totalStep=max(abs(xLen),abs(yLen));\r\n\t\t\tfloat xSpan=xLen/totalStep;\r\n\t\t\tfloat ySpan=yLen/totalStep;\r\n\t\t\tfor(float i=0.;i<MAX_STEP;i++){\r\n\t\t\t\tif(i>=totalStep) break;\r\n\t\t\t\tvec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);\r\n\t\t\t\tif(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;\r\n\t\t\t\tfloat s=length(xy-d0)/totalLen;\r\n\t\t\t\tvec2 uv=xy/resolution;\r\n\r\n\t\t\t\tfloat d = getDepth(uv);\r\n\t\t\t\tfloat vZ = getViewZ( d );\r\n\t\t\t\tif(-vZ>=cameraFar) continue;\r\n\t\t\t\tfloat cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];\r\n\t\t\t\tvec3 vP=getViewPosition( uv, d, cW );\r\n\r\n\t\t\t\t#ifdef isPerspectiveCamera\r\n\t\t\t\t\t// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf\r\n\t\t\t\t\tfloat recipVPZ=1./viewPosition.z;\r\n\t\t\t\t\tfloat viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));\r\n\t\t\t\t\tfloat sD=surfDist*cW;\r\n\t\t\t\t#else\r\n\t\t\t\t\tfloat viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);\r\n\t\t\t\t\tfloat sD=surfDist;\r\n\t\t\t\t#endif\r\n\t\t\t\tif(viewReflectRayZ-sD>vZ) continue;\r\n\r\n\t\t\t\t#ifdef isInfiniteThick\r\n\t\t\t\t\tif(viewReflectRayZ+thickTolerance*clipW<vP.z) break;\r\n\t\t\t\t#endif\r\n\t\t\t\tfloat away=pointToLineDistance(vP,viewPosition,d1viewPosition);\r\n\r\n\t\t\t\tfloat op=opacity;\r\n\r\n\t\t\t\tif(away<sD){\r\n\t\t\t\t\tvec3 vN=getViewNormal( uv );\r\n\t\t\t\t\tif(dot(viewReflectDir,vN)>=0.) continue;\r\n\t\t\t\t\tfloat distance=pointPlaneDistance(vP,viewPosition,viewNormal);\r\n\t\t\t\t\tif(distance>maxDistance) break;\r\n\t\t\t\t\t#ifdef isDistanceAttenuation\r\n\t\t\t\t\t\tfloat ratio=1.-(distance/maxDistance);\r\n\t\t\t\t\t\tfloat attenuation=ratio*ratio;\r\n\t\t\t\t\t\top=opacity*attenuation;\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\t#ifdef isFresnel\r\n\t\t\t\t\t\tfloat fresnel=(dot(viewIncidenceDir,viewReflectDir)+1.)/2.;\r\n\t\t\t\t\t\top*=fresnel;\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\tvec4 reflectColor=texture2D(tDiffuse,uv);\r\n\t\t\t\t\tgl_FragColor.xyz=reflectColor.xyz;\r\n\t\t\t\t\tgl_FragColor.a=op;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t`\r\n};\r\nconst SSRDepthShader = {\r\n  defines: {\r\n    PERSPECTIVE_CAMERA: 1\r\n  },\r\n  uniforms: {\r\n    tDepth: {\r\n      value: null\r\n    },\r\n    cameraNear: {\r\n      value: null\r\n    },\r\n    cameraFar: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader:\r\n  /* glsl */\r\n  `\r\n\r\n    varying vec2 vUv;\r\n\r\n    void main() {\r\n\r\n    \tvUv = uv;\r\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n    }\r\n\r\n  `,\r\n  fragmentShader:\r\n  /* glsl */\r\n  `\r\n\r\n    uniform sampler2D tDepth;\r\n\r\n    uniform float cameraNear;\r\n    uniform float cameraFar;\r\n\r\n    varying vec2 vUv;\r\n\r\n    #include <packing>\r\n\r\n\t\tfloat getLinearDepth( const in vec2 uv ) {\r\n\r\n\t\t\t#if PERSPECTIVE_CAMERA == 1\r\n\r\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, uv ).x;\r\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\r\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\treturn texture2D( tDepth, uv ).x;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t}\r\n\r\n    void main() {\r\n\r\n    \tfloat depth = getLinearDepth( vUv );\r\n\t\t\tfloat d = 1.0 - depth;\r\n\t\t\t// d=(d-.999)*1000.;\r\n    \tgl_FragColor = vec4( vec3( d ), 1.0 );\r\n\r\n    }\r\n\r\n  `\r\n};\r\nconst SSRBlurShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    resolution: {\r\n      value: new Vector2()\r\n    },\r\n    opacity: {\r\n      value: 0.5\r\n    }\r\n  },\r\n  vertexShader:\r\n  /* glsl */\r\n  `\r\n\r\n    varying vec2 vUv;\r\n\r\n    void main() {\r\n\r\n    \tvUv = uv;\r\n    \tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n    }\r\n\r\n  `,\r\n  fragmentShader:\r\n  /* glsl */\r\n  `\r\n\r\n    uniform sampler2D tDiffuse;\r\n    uniform vec2 resolution;\r\n    varying vec2 vUv;\r\n    void main() {\r\n\t\t\t//reverse engineering from PhotoShop blur filter, then change coefficient\r\n\r\n    \tvec2 texelSize = ( 1.0 / resolution );\r\n\r\n\t\t\tvec4 c=texture2D(tDiffuse,vUv);\r\n\r\n\t\t\tvec2 offset;\r\n\r\n\t\t\toffset=(vec2(-1,0))*texelSize;\r\n\t\t\tvec4 cl=texture2D(tDiffuse,vUv+offset);\r\n\r\n\t\t\toffset=(vec2(1,0))*texelSize;\r\n\t\t\tvec4 cr=texture2D(tDiffuse,vUv+offset);\r\n\r\n\t\t\toffset=(vec2(0,-1))*texelSize;\r\n\t\t\tvec4 cb=texture2D(tDiffuse,vUv+offset);\r\n\r\n\t\t\toffset=(vec2(0,1))*texelSize;\r\n\t\t\tvec4 ct=texture2D(tDiffuse,vUv+offset);\r\n\r\n\t\t\t// float coeCenter=.5;\r\n\t\t\t// float coeSide=.125;\r\n\t\t\tfloat coeCenter=.2;\r\n\t\t\tfloat coeSide=.2;\r\n\t\t\tfloat a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;\r\n\t\t\tvec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;\r\n\t\t\tgl_FragColor=vec4(rgb,a);\r\n\r\n\t\t}\r\n\t`\r\n};\r\n\r\nexport { SSRBlurShader, SSRDepthShader, SSRShader };\r\n", "import { Color, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, LinearFilter, RGBAFormat, HalfFloatType, ShaderMaterial, UniformsUtils, NoBlending, MeshNormalMaterial, MeshBasicMaterial, SrcAlphaFactor, OneMinusSrcAlphaFactor, AddEquation, NormalBlending } from 'three';\r\nimport { FullScreenQuad, Pass } from './Pass.js';\r\nimport { SSRShader, SSRBlurShader, SSRDepthShader } from '../shaders/SSRShader.js';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\n\r\nvar SSRPass = function ({\r\n  renderer,\r\n  scene,\r\n  camera,\r\n  width,\r\n  height,\r\n  selects,\r\n  encoding,\r\n  isPerspectiveCamera = true,\r\n  isBouncing = false,\r\n  morphTargets = false,\r\n  groundReflector\r\n}) {\r\n  this.width = width !== undefined ? width : 512;\r\n  this.height = height !== undefined ? height : 512;\r\n  this.clear = true;\r\n  this.renderer = renderer;\r\n  this.scene = scene;\r\n  this.camera = camera;\r\n  this.groundReflector = groundReflector;\r\n  this.opacity = SSRShader.uniforms.opacity.value;\r\n  this.output = 0;\r\n  this.maxDistance = SSRShader.uniforms.maxDistance.value;\r\n  this.surfDist = SSRShader.uniforms.surfDist.value;\r\n  this.encoding = encoding;\r\n  this.tempColor = new Color();\r\n  this._selects = selects;\r\n  this.isSelective = Array.isArray(this._selects);\r\n  Object.defineProperty(this, 'selects', {\r\n    get() {\r\n      return this._selects;\r\n    },\r\n\r\n    set(val) {\r\n      if (this._selects === val) return;\r\n      this._selects = val;\r\n\r\n      if (Array.isArray(val)) {\r\n        this.isSelective = true;\r\n        this.ssrMaterial.defines.isSelective = true;\r\n        this.ssrMaterial.needsUpdate = true;\r\n      } else {\r\n        this.isSelective = false;\r\n        this.ssrMaterial.defines.isSelective = false;\r\n        this.ssrMaterial.needsUpdate = true;\r\n      }\r\n    }\r\n\r\n  });\r\n  this._isBouncing = isBouncing; ///todo: don't need defineProperty\r\n\r\n  Object.defineProperty(this, 'isBouncing', {\r\n    get() {\r\n      return this._isBouncing;\r\n    },\r\n\r\n    set(val) {\r\n      if (this._isBouncing === val) return;\r\n      this._isBouncing = val;\r\n\r\n      if (val) {\r\n        this.ssrMaterial.uniforms['tDiffuse'].value = this.prevRenderTarget.texture;\r\n      } else {\r\n        this.ssrMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\r\n      }\r\n    }\r\n\r\n  });\r\n  this.isBlur = true;\r\n  this._isDistanceAttenuation = SSRShader.defines.isDistanceAttenuation;\r\n  Object.defineProperty(this, 'isDistanceAttenuation', {\r\n    get() {\r\n      return this._isDistanceAttenuation;\r\n    },\r\n\r\n    set(val) {\r\n      if (this._isDistanceAttenuation === val) return;\r\n      this._isDistanceAttenuation = val;\r\n      this.ssrMaterial.defines.isDistanceAttenuation = val;\r\n      this.ssrMaterial.needsUpdate = true;\r\n    }\r\n\r\n  });\r\n  this._isFresnel = SSRShader.defines.isFresnel;\r\n  Object.defineProperty(this, 'isFresnel', {\r\n    get() {\r\n      return this._isFresnel;\r\n    },\r\n\r\n    set(val) {\r\n      if (this._isFresnel === val) return;\r\n      this._isFresnel = val;\r\n      this.ssrMaterial.defines.isFresnel = val;\r\n      this.ssrMaterial.needsUpdate = true;\r\n    }\r\n\r\n  });\r\n  this._isInfiniteThick = SSRShader.defines.isInfiniteThick;\r\n  Object.defineProperty(this, 'isInfiniteThick', {\r\n    get() {\r\n      return this._isInfiniteThick;\r\n    },\r\n\r\n    set(val) {\r\n      if (this._isInfiniteThick === val) return;\r\n      this._isInfiniteThick = val;\r\n      this.ssrMaterial.defines.isInfiniteThick = val;\r\n      this.ssrMaterial.needsUpdate = true;\r\n    }\r\n\r\n  });\r\n  this.thickTolerance = SSRShader.uniforms.thickTolerance.value; // beauty render target with depth buffer\r\n\r\n  var depthTexture = new DepthTexture();\r\n  depthTexture.type = UnsignedShortType;\r\n  depthTexture.minFilter = NearestFilter;\r\n  depthTexture.maxFilter = NearestFilter;\r\n  this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {\r\n    minFilter: LinearFilter,\r\n    magFilter: LinearFilter,\r\n    format: RGBAFormat,\r\n    depthTexture: depthTexture,\r\n    depthBuffer: true\r\n  }); //for bouncing\r\n\r\n  this.prevRenderTarget = new WebGLRenderTarget(this.width, this.height, {\r\n    minFilter: LinearFilter,\r\n    magFilter: LinearFilter,\r\n    format: RGBAFormat\r\n  }); // normal render target\r\n\r\n  this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {\r\n    minFilter: NearestFilter,\r\n    magFilter: NearestFilter,\r\n    format: RGBAFormat,\r\n    type: HalfFloatType\r\n  }); // metalness render target\r\n  // if (this.isSelective) {\r\n\r\n  this.metalnessRenderTarget = new WebGLRenderTarget(this.width, this.height, {\r\n    minFilter: NearestFilter,\r\n    magFilter: NearestFilter,\r\n    format: RGBAFormat\r\n  }); // }\r\n  // ssr render target\r\n\r\n  this.ssrRenderTarget = new WebGLRenderTarget(this.width, this.height, {\r\n    minFilter: LinearFilter,\r\n    magFilter: LinearFilter,\r\n    format: RGBAFormat\r\n  });\r\n  this.blurRenderTarget = this.ssrRenderTarget.clone();\r\n  this.blurRenderTarget2 = this.ssrRenderTarget.clone(); // this.blurRenderTarget3 = this.ssrRenderTarget.clone();\r\n  // ssr material\r\n\r\n  if (SSRShader === undefined) {\r\n    console.error('THREE.SSRPass: The pass relies on SSRShader.');\r\n  }\r\n\r\n  this.ssrMaterial = new ShaderMaterial({\r\n    defines: Object.assign({\r\n      MAX_STEP: Math.sqrt(window.innerWidth * window.innerWidth + window.innerHeight * window.innerHeight)\r\n    }, SSRShader.defines),\r\n    uniforms: UniformsUtils.clone(SSRShader.uniforms),\r\n    vertexShader: SSRShader.vertexShader,\r\n    fragmentShader: SSRShader.fragmentShader,\r\n    blending: NoBlending\r\n  });\r\n\r\n  if (!isPerspectiveCamera) {\r\n    this.ssrMaterial.defines.isPerspectiveCamera = isPerspectiveCamera;\r\n    this.ssrMaterial.needsUpdate = true;\r\n  }\r\n\r\n  this.ssrMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\r\n  this.ssrMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture; // if (this.isSelective) {\r\n\r\n  this.ssrMaterial.defines.isSelective = this.isSelective;\r\n  this.ssrMaterial.needsUpdate = true;\r\n  this.ssrMaterial.uniforms['tMetalness'].value = this.metalnessRenderTarget.texture; // }\r\n\r\n  this.ssrMaterial.uniforms['tDepth'].value = this.beautyRenderTarget.depthTexture;\r\n  this.ssrMaterial.uniforms['cameraNear'].value = this.camera.near;\r\n  this.ssrMaterial.uniforms['cameraFar'].value = this.camera.far;\r\n  this.ssrMaterial.uniforms['surfDist'].value = this.surfDist;\r\n  this.ssrMaterial.uniforms['resolution'].value.set(this.width, this.height);\r\n  this.ssrMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);\r\n  this.ssrMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse); // normal material\r\n\r\n  this.normalMaterial = new MeshNormalMaterial({\r\n    morphTargets\r\n  });\r\n  this.normalMaterial.blending = NoBlending; // if (this.isSelective) {\r\n  // metalnessOn material\r\n\r\n  this.metalnessOnMaterial = new MeshBasicMaterial({\r\n    color: 'white'\r\n  }); // metalnessOff material\r\n\r\n  this.metalnessOffMaterial = new MeshBasicMaterial({\r\n    color: 'black'\r\n  }); // }\r\n  // blur material\r\n\r\n  this.blurMaterial = new ShaderMaterial({\r\n    defines: Object.assign({}, SSRBlurShader.defines),\r\n    uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),\r\n    vertexShader: SSRBlurShader.vertexShader,\r\n    fragmentShader: SSRBlurShader.fragmentShader\r\n  });\r\n  this.blurMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\r\n  this.blurMaterial.uniforms['resolution'].value.set(this.width, this.height); // blur material 2\r\n\r\n  this.blurMaterial2 = new ShaderMaterial({\r\n    defines: Object.assign({}, SSRBlurShader.defines),\r\n    uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),\r\n    vertexShader: SSRBlurShader.vertexShader,\r\n    fragmentShader: SSRBlurShader.fragmentShader\r\n  });\r\n  this.blurMaterial2.uniforms['tDiffuse'].value = this.blurRenderTarget.texture;\r\n  this.blurMaterial2.uniforms['resolution'].value.set(this.width, this.height); // // blur material 3\r\n  // this.blurMaterial3 = new ShaderMaterial({\r\n  //   defines: Object.assign({}, SSRBlurShader.defines),\r\n  //   uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),\r\n  //   vertexShader: SSRBlurShader.vertexShader,\r\n  //   fragmentShader: SSRBlurShader.fragmentShader\r\n  // });\r\n  // this.blurMaterial3.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;\r\n  // this.blurMaterial3.uniforms['resolution'].value.set(this.width, this.height);\r\n  // material for rendering the depth\r\n\r\n  this.depthRenderMaterial = new ShaderMaterial({\r\n    defines: Object.assign({}, SSRDepthShader.defines),\r\n    uniforms: UniformsUtils.clone(SSRDepthShader.uniforms),\r\n    vertexShader: SSRDepthShader.vertexShader,\r\n    fragmentShader: SSRDepthShader.fragmentShader,\r\n    blending: NoBlending\r\n  });\r\n  this.depthRenderMaterial.uniforms['tDepth'].value = this.beautyRenderTarget.depthTexture;\r\n  this.depthRenderMaterial.uniforms['cameraNear'].value = this.camera.near;\r\n  this.depthRenderMaterial.uniforms['cameraFar'].value = this.camera.far; // material for rendering the content of a render target\r\n\r\n  this.copyMaterial = new ShaderMaterial({\r\n    uniforms: UniformsUtils.clone(CopyShader.uniforms),\r\n    vertexShader: CopyShader.vertexShader,\r\n    fragmentShader: CopyShader.fragmentShader,\r\n    transparent: true,\r\n    depthTest: false,\r\n    depthWrite: false,\r\n    blendSrc: SrcAlphaFactor,\r\n    blendDst: OneMinusSrcAlphaFactor,\r\n    blendEquation: AddEquation,\r\n    blendSrcAlpha: SrcAlphaFactor,\r\n    blendDstAlpha: OneMinusSrcAlphaFactor,\r\n    blendEquationAlpha: AddEquation // premultipliedAlpha:true,\r\n\r\n  });\r\n  this.fsQuad = new FullScreenQuad(null);\r\n  this.originalClearColor = new Color();\r\n};\r\n\r\nSSRPass.prototype = Object.assign(Object.create(Pass.prototype), {\r\n  constructor: SSRPass,\r\n  dispose: function () {\r\n    // dispose render targets\r\n    this.beautyRenderTarget.dispose();\r\n    this.prevRenderTarget.dispose();\r\n    this.normalRenderTarget.dispose(); // if (this.isSelective)\r\n\r\n    this.metalnessRenderTarget.dispose();\r\n    this.ssrRenderTarget.dispose();\r\n    this.blurRenderTarget.dispose();\r\n    this.blurRenderTarget2.dispose(); // this.blurRenderTarget3.dispose();\r\n    // dispose materials\r\n\r\n    this.normalMaterial.dispose(); // if (this.isSelective) {\r\n\r\n    this.metalnessOnMaterial.dispose();\r\n    this.metalnessOffMaterial.dispose(); // }\r\n\r\n    this.blurMaterial.dispose();\r\n    this.blurMaterial2.dispose();\r\n    this.copyMaterial.dispose();\r\n    this.depthRenderMaterial.dispose(); // dipsose full screen quad\r\n\r\n    this.fsQuad.dispose();\r\n  },\r\n  render: function (renderer, writeBuffer\r\n  /*, readBuffer, deltaTime, maskActive */\r\n  ) {\r\n    // render beauty and depth\r\n    if (this.encoding) this.beautyRenderTarget.texture.encoding = this.encoding;\r\n    renderer.setRenderTarget(this.beautyRenderTarget);\r\n    renderer.clear();\r\n\r\n    if (this.groundReflector) {\r\n      this.groundReflector.doRender(this.renderer, this.scene, this.camera);\r\n      this.groundReflector.visible = true;\r\n    }\r\n\r\n    renderer.render(this.scene, this.camera);\r\n    if (this.groundReflector) this.groundReflector.visible = false; // render normals\r\n\r\n    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0, 0); // render metalnesses\r\n\r\n    if (this.isSelective) {\r\n      this.renderMetalness(renderer, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0);\r\n    } // render SSR\r\n\r\n\r\n    this.ssrMaterial.uniforms['opacity'].value = this.opacity;\r\n    this.ssrMaterial.uniforms['maxDistance'].value = this.maxDistance;\r\n    this.ssrMaterial.uniforms['surfDist'].value = this.surfDist;\r\n    this.ssrMaterial.uniforms['thickTolerance'].value = this.thickTolerance;\r\n    this.renderPass(renderer, this.ssrMaterial, this.ssrRenderTarget); // render blur\r\n\r\n    if (this.isBlur) {\r\n      this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);\r\n      this.renderPass(renderer, this.blurMaterial2, this.blurRenderTarget2); // this.renderPass(renderer, this.blurMaterial3, this.blurRenderTarget3);\r\n    } // output result to screen\r\n\r\n\r\n    switch (this.output) {\r\n      case SSRPass.OUTPUT.Default:\r\n        if (this.isBouncing) {\r\n          this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\r\n          this.copyMaterial.blending = NoBlending;\r\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);\r\n          if (this.isBlur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\r\n          this.copyMaterial.blending = NormalBlending;\r\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);\r\n          this.copyMaterial.uniforms['tDiffuse'].value = this.prevRenderTarget.texture;\r\n          this.copyMaterial.blending = NoBlending;\r\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\r\n        } else {\r\n          this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\r\n          this.copyMaterial.blending = NoBlending;\r\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\r\n          if (this.isBlur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\r\n          this.copyMaterial.blending = NormalBlending;\r\n          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\r\n        }\r\n\r\n        break;\r\n\r\n      case SSRPass.OUTPUT.SSR:\r\n        if (this.isBlur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;else this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\r\n        this.copyMaterial.blending = NoBlending;\r\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\r\n\r\n        if (this.isBouncing) {\r\n          if (this.isBlur) this.copyMaterial.uniforms['tDiffuse'].value = this.blurRenderTarget2.texture;else this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\r\n          this.copyMaterial.blending = NoBlending;\r\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);\r\n          this.copyMaterial.uniforms['tDiffuse'].value = this.ssrRenderTarget.texture;\r\n          this.copyMaterial.blending = NormalBlending;\r\n          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);\r\n        }\r\n\r\n        break;\r\n\r\n      case SSRPass.OUTPUT.Beauty:\r\n        this.copyMaterial.uniforms['tDiffuse'].value = this.beautyRenderTarget.texture;\r\n        this.copyMaterial.blending = NoBlending;\r\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\r\n        break;\r\n\r\n      case SSRPass.OUTPUT.Depth:\r\n        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);\r\n        break;\r\n\r\n      case SSRPass.OUTPUT.Normal:\r\n        this.copyMaterial.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;\r\n        this.copyMaterial.blending = NoBlending;\r\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\r\n        break;\r\n\r\n      case SSRPass.OUTPUT.Metalness:\r\n        this.copyMaterial.uniforms['tDiffuse'].value = this.metalnessRenderTarget.texture;\r\n        this.copyMaterial.blending = NoBlending;\r\n        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);\r\n        break;\r\n\r\n      default:\r\n        console.warn('THREE.SSRPass: Unknown output type.');\r\n    }\r\n  },\r\n  renderPass: function (renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\r\n    // save original state\r\n    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));\r\n    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);\r\n    var originalAutoClear = renderer.autoClear;\r\n    renderer.setRenderTarget(renderTarget); // setup pass state\r\n\r\n    renderer.autoClear = false;\r\n\r\n    if (clearColor !== undefined && clearColor !== null) {\r\n      renderer.setClearColor(clearColor);\r\n      renderer.setClearAlpha(clearAlpha || 0.0);\r\n      renderer.clear();\r\n    }\r\n\r\n    this.fsQuad.material = passMaterial;\r\n    this.fsQuad.render(renderer); // restore original state\r\n\r\n    renderer.autoClear = originalAutoClear;\r\n    renderer.setClearColor(this.originalClearColor);\r\n    renderer.setClearAlpha(originalClearAlpha);\r\n  },\r\n  renderOverride: function (renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\r\n    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));\r\n    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);\r\n    var originalAutoClear = renderer.autoClear;\r\n    renderer.setRenderTarget(renderTarget);\r\n    renderer.autoClear = false;\r\n    clearColor = overrideMaterial.clearColor || clearColor;\r\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;\r\n\r\n    if (clearColor !== undefined && clearColor !== null) {\r\n      renderer.setClearColor(clearColor);\r\n      renderer.setClearAlpha(clearAlpha || 0.0);\r\n      renderer.clear();\r\n    }\r\n\r\n    this.scene.overrideMaterial = overrideMaterial;\r\n    renderer.render(this.scene, this.camera);\r\n    this.scene.overrideMaterial = null; // restore original state\r\n\r\n    renderer.autoClear = originalAutoClear;\r\n    renderer.setClearColor(this.originalClearColor);\r\n    renderer.setClearAlpha(originalClearAlpha);\r\n  },\r\n  renderMetalness: function (renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\r\n    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));\r\n    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);\r\n    var originalAutoClear = renderer.autoClear;\r\n    renderer.setRenderTarget(renderTarget);\r\n    renderer.autoClear = false;\r\n    clearColor = overrideMaterial.clearColor || clearColor;\r\n    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;\r\n\r\n    if (clearColor !== undefined && clearColor !== null) {\r\n      renderer.setClearColor(clearColor);\r\n      renderer.setClearAlpha(clearAlpha || 0.0);\r\n      renderer.clear();\r\n    }\r\n\r\n    this.scene.traverseVisible(child => {\r\n      child._SSRPassMaterialBack = child.material;\r\n\r\n      if (this._selects.includes(child)) {\r\n        child.material = this.metalnessOnMaterial;\r\n      } else {\r\n        child.material = this.metalnessOffMaterial;\r\n      }\r\n    });\r\n    renderer.render(this.scene, this.camera);\r\n    this.scene.traverseVisible(child => {\r\n      child.material = child._SSRPassMaterialBack;\r\n    }); // restore original state\r\n\r\n    renderer.autoClear = originalAutoClear;\r\n    renderer.setClearColor(this.originalClearColor);\r\n    renderer.setClearAlpha(originalClearAlpha);\r\n  },\r\n  setSize: function (width, height) {\r\n    this.width = width;\r\n    this.height = height;\r\n    this.ssrMaterial.defines.MAX_STEP = Math.sqrt(width * width + height * height);\r\n    this.ssrMaterial.needsUpdate = true;\r\n    this.beautyRenderTarget.setSize(width, height);\r\n    this.prevRenderTarget.setSize(width, height);\r\n    this.ssrRenderTarget.setSize(width, height);\r\n    this.normalRenderTarget.setSize(width, height); // if (this.isSelective)\r\n\r\n    this.metalnessRenderTarget.setSize(width, height);\r\n    this.blurRenderTarget.setSize(width, height);\r\n    this.blurRenderTarget2.setSize(width, height); // this.blurRenderTarget3.setSize(width, height);\r\n\r\n    this.ssrMaterial.uniforms['resolution'].value.set(width, height);\r\n    this.ssrMaterial.uniforms['cameraProjectionMatrix'].value.copy(this.camera.projectionMatrix);\r\n    this.ssrMaterial.uniforms['cameraInverseProjectionMatrix'].value.copy(this.camera.projectionMatrixInverse);\r\n    this.blurMaterial.uniforms['resolution'].value.set(width, height);\r\n    this.blurMaterial2.uniforms['resolution'].value.set(width, height);\r\n  }\r\n});\r\nSSRPass.OUTPUT = {\r\n  Default: 0,\r\n  SSR: 1,\r\n  Beauty: 3,\r\n  Depth: 4,\r\n  Normal: 5,\r\n  Metalness: 7\r\n};\r\n\r\nexport { SSRPass };\r\n", "import { Color, UniformsUtils, ShaderMaterial, AdditiveBlending, WebGLRenderTarget, LinearFilter, RGBAFormat } from 'three';\r\nimport { FullScreenQuad, Pass } from './Pass.js';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\n\r\n/**\r\n *\r\n * Supersample Anti-Aliasing Render Pass\r\n *\r\n * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\r\n *\r\n * References: https://en.wikipedia.org/wiki/Supersampling\r\n *\r\n */\r\n\r\nvar SSAARenderPass = function (scene, camera, clearColor, clearAlpha) {\r\n  this.scene = scene;\r\n  this.camera = camera;\r\n  this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\r\n\r\n  this.unbiased = true; // as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\r\n\r\n  this.clearColor = clearColor !== undefined ? clearColor : 0x000000;\r\n  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\r\n  this._oldClearColor = new Color();\r\n  if (CopyShader === undefined) console.error('THREE.SSAARenderPass relies on CopyShader');\r\n  var copyShader = CopyShader;\r\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\r\n  this.copyMaterial = new ShaderMaterial({\r\n    uniforms: this.copyUniforms,\r\n    vertexShader: copyShader.vertexShader,\r\n    fragmentShader: copyShader.fragmentShader,\r\n    premultipliedAlpha: true,\r\n    transparent: true,\r\n    blending: AdditiveBlending,\r\n    depthTest: false,\r\n    depthWrite: false\r\n  });\r\n  this.fsQuad = new FullScreenQuad(this.copyMaterial);\r\n};\r\n\r\nSSAARenderPass.prototype = Object.assign(Object.create(Pass.prototype), {\r\n  constructor: SSAARenderPass,\r\n  dispose: function () {\r\n    if (this.sampleRenderTarget) {\r\n      this.sampleRenderTarget.dispose();\r\n      this.sampleRenderTarget = null;\r\n    }\r\n  },\r\n  setSize: function (width, height) {\r\n    if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);\r\n  },\r\n  render: function (renderer, writeBuffer, readBuffer) {\r\n    if (!this.sampleRenderTarget) {\r\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\r\n        minFilter: LinearFilter,\r\n        magFilter: LinearFilter,\r\n        format: RGBAFormat\r\n      });\r\n      this.sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\r\n    }\r\n\r\n    var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\r\n    var autoClear = renderer.autoClear;\r\n    renderer.autoClear = false;\r\n    renderer.getClearColor(this._oldClearColor);\r\n    var oldClearAlpha = renderer.getClearAlpha();\r\n    var baseSampleWeight = 1.0 / jitterOffsets.length;\r\n    var roundingRange = 1 / 32;\r\n    this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\r\n    var width = readBuffer.width,\r\n        height = readBuffer.height; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\r\n\r\n    for (let i = 0; i < jitterOffsets.length; i++) {\r\n      var jitterOffset = jitterOffsets[i];\r\n\r\n      if (this.camera.setViewOffset) {\r\n        this.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\r\n        width, height);\r\n      }\r\n\r\n      var sampleWeight = baseSampleWeight;\r\n\r\n      if (this.unbiased) {\r\n        // the theory is that equal weights for each sample lead to an accumulation of rounding errors.\r\n        // The following equation varies the sampleWeight per sample so that it is uniformly distributed\r\n        // across a range of values whose rounding errors cancel each other out.\r\n        var uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\r\n        sampleWeight += roundingRange * uniformCenteredDistribution;\r\n      }\r\n\r\n      this.copyUniforms['opacity'].value = sampleWeight;\r\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\r\n      renderer.setRenderTarget(this.sampleRenderTarget);\r\n      renderer.clear();\r\n      renderer.render(this.scene, this.camera);\r\n      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\r\n\r\n      if (i === 0) {\r\n        renderer.setClearColor(0x000000, 0.0);\r\n        renderer.clear();\r\n      }\r\n\r\n      this.fsQuad.render(renderer);\r\n    }\r\n\r\n    if (this.camera.clearViewOffset) this.camera.clearViewOffset();\r\n    renderer.autoClear = autoClear;\r\n    renderer.setClearColor(this._oldClearColor, oldClearAlpha);\r\n  }\r\n}); // These jitter vectors are specified in integers because it is easier.\r\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\r\n// before being used, thus these integers need to be scaled by 1/16.\r\n//\r\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\r\n\r\nSSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\r\n\r\nexport { SSAARenderPass };\r\n", "import { WebGLRenderTarget } from 'three';\r\nimport { SSAARenderPass } from './SSAARenderPass.js';\r\n\r\n/**\r\n *\r\n * Temporal Anti-Aliasing Render Pass\r\n *\r\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\r\n *\r\n * References:\r\n *\r\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\r\n *\r\n */\r\n\r\nvar TAARenderPass = function (scene, camera, clearColor, clearAlpha) {\r\n  if (SSAARenderPass === undefined) {\r\n    console.error('THREE.TAARenderPass relies on SSAARenderPass');\r\n  }\r\n\r\n  SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);\r\n  this.sampleLevel = 0;\r\n  this.accumulate = false;\r\n};\r\n\r\nTAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;\r\nTAARenderPass.prototype = Object.assign(Object.create(SSAARenderPass.prototype), {\r\n  constructor: TAARenderPass,\r\n  render: function (renderer, writeBuffer, readBuffer, deltaTime) {\r\n    if (!this.accumulate) {\r\n      SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);\r\n      this.accumulateIndex = -1;\r\n      return;\r\n    }\r\n\r\n    var jitterOffsets = TAARenderPass.JitterVectors[5];\r\n\r\n    if (!this.sampleRenderTarget) {\r\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\r\n      this.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\r\n    }\r\n\r\n    if (!this.holdRenderTarget) {\r\n      this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\r\n      this.holdRenderTarget.texture.name = 'TAARenderPass.hold';\r\n    }\r\n\r\n    if (this.accumulate && this.accumulateIndex === -1) {\r\n      SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\r\n      this.accumulateIndex = 0;\r\n    }\r\n\r\n    var autoClear = renderer.autoClear;\r\n    renderer.autoClear = false;\r\n    var sampleWeight = 1.0 / jitterOffsets.length;\r\n\r\n    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\r\n      this.copyUniforms['opacity'].value = sampleWeight;\r\n      this.copyUniforms['tDiffuse'].value = writeBuffer.texture; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\r\n\r\n      var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\r\n\r\n      for (let i = 0; i < numSamplesPerFrame; i++) {\r\n        var j = this.accumulateIndex;\r\n        var jitterOffset = jitterOffsets[j];\r\n\r\n        if (this.camera.setViewOffset) {\r\n          this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\r\n          readBuffer.width, readBuffer.height);\r\n        }\r\n\r\n        renderer.setRenderTarget(writeBuffer);\r\n        renderer.clear();\r\n        renderer.render(this.scene, this.camera);\r\n        renderer.setRenderTarget(this.sampleRenderTarget);\r\n        if (this.accumulateIndex === 0) renderer.clear();\r\n        this.fsQuad.render(renderer);\r\n        this.accumulateIndex++;\r\n        if (this.accumulateIndex >= jitterOffsets.length) break;\r\n      }\r\n\r\n      if (this.camera.clearViewOffset) this.camera.clearViewOffset();\r\n    }\r\n\r\n    var accumulationWeight = this.accumulateIndex * sampleWeight;\r\n\r\n    if (accumulationWeight > 0) {\r\n      this.copyUniforms['opacity'].value = 1.0;\r\n      this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\r\n      renderer.setRenderTarget(writeBuffer);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n    }\r\n\r\n    if (accumulationWeight < 1.0) {\r\n      this.copyUniforms['opacity'].value = 1.0 - accumulationWeight;\r\n      this.copyUniforms['tDiffuse'].value = this.holdRenderTarget.texture;\r\n      renderer.setRenderTarget(writeBuffer);\r\n      if (accumulationWeight === 0) renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n    }\r\n\r\n    renderer.autoClear = autoClear;\r\n  }\r\n});\r\n\r\nexport { TAARenderPass };\r\n", "import { Vector2 } from 'three';\r\n\r\n/**\r\n * Convolution shader\r\n * ported from o3d sample to WebGL / GLSL\r\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\r\n */\r\n\r\nconst ConvolutionShader = {\r\n  defines: {\r\n    KERNEL_SIZE_FLOAT: '25.0',\r\n    KERNEL_SIZE_INT: '25'\r\n  },\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    uImageIncrement: {\r\n      value: new Vector2(0.001953125, 0.0)\r\n    },\r\n    cKernel: {\r\n      value: []\r\n    }\r\n  },\r\n  vertexShader: ['uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform float cKernel[ KERNEL_SIZE_INT ];', 'uniform sampler2D tDiffuse;', 'uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvec2 imageCoord = vUv;', '\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );', '\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {', '\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];', '\t\timageCoord += uImageIncrement;', '\t}', '\tgl_FragColor = sum;', '}'].join('\\n'),\r\n  buildKernel: function (sigma) {\r\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\r\n    function gauss(x, sigma) {\r\n      return Math.exp(-(x * x) / (2.0 * sigma * sigma));\r\n    }\r\n\r\n    const kMaxKernelSize = 25;\r\n    const kernelSize = Math.min(2 * Math.ceil(sigma * 3.0) + 1, kMaxKernelSize);\r\n    const halfWidth = (kernelSize - 1) * 0.5;\r\n    const values = new Array(kernelSize);\r\n    let sum = 0.0;\r\n\r\n    for (let i = 0; i < kernelSize; ++i) {\r\n      values[i] = gauss(i - halfWidth, sigma);\r\n      sum += values[i];\r\n    } // normalize the kernel\r\n\r\n\r\n    for (let i = 0; i < kernelSize; ++i) values[i] /= sum;\r\n\r\n    return values;\r\n  }\r\n};\r\n\r\nexport { ConvolutionShader };\r\n", "import { Loader, LoaderUtils, FileLoader, Color, SpotLight, PointLight, DirectionalLight, MeshBasicMaterial, sRGBEncoding, MeshPhysicalMaterial, Vector2, TangentSpaceNormalMap, Quaternion, TextureLoader, ImageBitmapLoader, InterleavedBuffer, InterleavedBufferAttribute, BufferAttribute, LinearFilter, LinearMipmapLinearFilter, RepeatWrapping, PointsMaterial, Material, LineBasicMaterial, MeshStandardMaterial, DoubleSide, PropertyBinding, BufferGeometry, SkinnedMesh, Mesh, LineSegments, Line, LineLoop, Points, Group, PerspectiveCamera, MathUtils, OrthographicCamera, InterpolateLinear, AnimationClip, Bone, Object3D, Matrix4, Skeleton, TriangleFanDrawMode, NearestFilter, NearestMipmapNearestFilter, LinearMipmapNearestFilter, NearestMipmapLinearFilter, ClampToEdgeWrapping, MirroredRepeatWrapping, InterpolateDiscrete, FrontSide, Texture, TriangleStripDrawMode, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Box3, Vector3, Sphere, Interpolant } from 'three';\r\n\r\nclass GLTFLoader extends Loader {\r\n  constructor(manager) {\r\n    super(manager);\r\n    this.dracoLoader = null;\r\n    this.ktx2Loader = null;\r\n    this.meshoptDecoder = null;\r\n    this.pluginCallbacks = [];\r\n    this.register(function (parser) {\r\n      return new GLTFMaterialsClearcoatExtension(parser);\r\n    });\r\n    this.register(function (parser) {\r\n      return new GLTFTextureBasisUExtension(parser);\r\n    });\r\n    this.register(function (parser) {\r\n      return new GLTFTextureWebPExtension(parser);\r\n    });\r\n    this.register(function (parser) {\r\n      return new GLTFMaterialsSheenExtension(parser);\r\n    });\r\n    this.register(function (parser) {\r\n      return new GLTFMaterialsTransmissionExtension(parser);\r\n    });\r\n    this.register(function (parser) {\r\n      return new GLTFMaterialsVolumeExtension(parser);\r\n    });\r\n    this.register(function (parser) {\r\n      return new GLTFMaterialsIorExtension(parser);\r\n    });\r\n    this.register(function (parser) {\r\n      return new GLTFMaterialsEmissiveStrengthExtension(parser);\r\n    });\r\n    this.register(function (parser) {\r\n      return new GLTFMaterialsSpecularExtension(parser);\r\n    });\r\n    this.register(function (parser) {\r\n      return new GLTFMaterialsIridescenceExtension(parser);\r\n    });\r\n    this.register(function (parser) {\r\n      return new GLTFLightsExtension(parser);\r\n    });\r\n    this.register(function (parser) {\r\n      return new GLTFMeshoptCompression(parser);\r\n    });\r\n  }\r\n\r\n  load(url, onLoad, onProgress, onError) {\r\n    const scope = this;\r\n    let resourcePath;\r\n\r\n    if (this.resourcePath !== '') {\r\n      resourcePath = this.resourcePath;\r\n    } else if (this.path !== '') {\r\n      resourcePath = this.path;\r\n    } else {\r\n      resourcePath = LoaderUtils.extractUrlBase(url);\r\n    } // Tells the LoadingManager to track an extra item, which resolves after\r\n    // the model is fully loaded. This means the count of items loaded will\r\n    // be incorrect, but ensures manager.onLoad() does not fire early.\r\n\r\n\r\n    this.manager.itemStart(url);\r\n\r\n    const _onError = function (e) {\r\n      if (onError) {\r\n        onError(e);\r\n      } else {\r\n        console.error(e);\r\n      }\r\n\r\n      scope.manager.itemError(url);\r\n      scope.manager.itemEnd(url);\r\n    };\r\n\r\n    const loader = new FileLoader(this.manager);\r\n    loader.setPath(this.path);\r\n    loader.setResponseType('arraybuffer');\r\n    loader.setRequestHeader(this.requestHeader);\r\n    loader.setWithCredentials(this.withCredentials);\r\n    loader.load(url, function (data) {\r\n      try {\r\n        scope.parse(data, resourcePath, function (gltf) {\r\n          onLoad(gltf);\r\n          scope.manager.itemEnd(url);\r\n        }, _onError);\r\n      } catch (e) {\r\n        _onError(e);\r\n      }\r\n    }, onProgress, _onError);\r\n  }\r\n\r\n  setDRACOLoader(dracoLoader) {\r\n    this.dracoLoader = dracoLoader;\r\n    return this;\r\n  }\r\n\r\n  setDDSLoader() {\r\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\r\n  }\r\n\r\n  setKTX2Loader(ktx2Loader) {\r\n    this.ktx2Loader = ktx2Loader;\r\n    return this;\r\n  }\r\n\r\n  setMeshoptDecoder(meshoptDecoder) {\r\n    this.meshoptDecoder = meshoptDecoder;\r\n    return this;\r\n  }\r\n\r\n  register(callback) {\r\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\r\n      this.pluginCallbacks.push(callback);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  unregister(callback) {\r\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\r\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  parse(data, path, onLoad, onError) {\r\n    let content;\r\n    const extensions = {};\r\n    const plugins = {};\r\n\r\n    if (typeof data === 'string') {\r\n      content = data;\r\n    } else {\r\n      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\r\n\r\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\r\n        try {\r\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\r\n        } catch (error) {\r\n          if (onError) onError(error);\r\n          return;\r\n        }\r\n\r\n        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\r\n      } else {\r\n        content = LoaderUtils.decodeText(new Uint8Array(data));\r\n      }\r\n    }\r\n\r\n    const json = JSON.parse(content);\r\n\r\n    if (json.asset === undefined || json.asset.version[0] < 2) {\r\n      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));\r\n      return;\r\n    }\r\n\r\n    const parser = new GLTFParser(json, {\r\n      path: path || this.resourcePath || '',\r\n      crossOrigin: this.crossOrigin,\r\n      requestHeader: this.requestHeader,\r\n      manager: this.manager,\r\n      ktx2Loader: this.ktx2Loader,\r\n      meshoptDecoder: this.meshoptDecoder\r\n    });\r\n    parser.fileLoader.setRequestHeader(this.requestHeader);\r\n\r\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\r\n      const plugin = this.pluginCallbacks[i](parser);\r\n      plugins[plugin.name] = plugin; // Workaround to avoid determining as unknown extension\r\n      // in addUnknownExtensionsToUserData().\r\n      // Remove this workaround if we move all the existing\r\n      // extension handlers to plugin system\r\n\r\n      extensions[plugin.name] = true;\r\n    }\r\n\r\n    if (json.extensionsUsed) {\r\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\r\n        const extensionName = json.extensionsUsed[i];\r\n        const extensionsRequired = json.extensionsRequired || [];\r\n\r\n        switch (extensionName) {\r\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\r\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\r\n            break;\r\n\r\n          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\r\n            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\r\n            break;\r\n\r\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\r\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\r\n            break;\r\n\r\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\r\n            extensions[extensionName] = new GLTFTextureTransformExtension();\r\n            break;\r\n\r\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\r\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\r\n            break;\r\n\r\n          default:\r\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\r\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\r\n            }\r\n\r\n        }\r\n      }\r\n    }\r\n\r\n    parser.setExtensions(extensions);\r\n    parser.setPlugins(plugins);\r\n    parser.parse(onLoad, onError);\r\n  }\r\n\r\n  parseAsync(data, path) {\r\n    const scope = this;\r\n    return new Promise(function (resolve, reject) {\r\n      scope.parse(data, path, resolve, reject);\r\n    });\r\n  }\r\n\r\n}\r\n/* GLTFREGISTRY */\r\n\r\n\r\nfunction GLTFRegistry() {\r\n  let objects = {};\r\n  return {\r\n    get: function (key) {\r\n      return objects[key];\r\n    },\r\n    add: function (key, object) {\r\n      objects[key] = object;\r\n    },\r\n    remove: function (key) {\r\n      delete objects[key];\r\n    },\r\n    removeAll: function () {\r\n      objects = {};\r\n    }\r\n  };\r\n}\r\n/*********************************/\r\n\r\n/********** EXTENSIONS ***********/\r\n\r\n/*********************************/\r\n\r\n\r\nconst EXTENSIONS = {\r\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\r\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\r\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\r\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\r\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\r\n  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\r\n  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\r\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\r\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\r\n  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\r\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\r\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\r\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\r\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\r\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\r\n  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\r\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\r\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\r\n};\r\n/**\r\n * Punctual Lights Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n */\r\n\r\nclass GLTFLightsExtension {\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; // Object3D instance caches\r\n\r\n    this.cache = {\r\n      refs: {},\r\n      uses: {}\r\n    };\r\n  }\r\n\r\n  _markDefs() {\r\n    const parser = this.parser;\r\n    const nodeDefs = this.parser.json.nodes || [];\r\n\r\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\r\n      const nodeDef = nodeDefs[nodeIndex];\r\n\r\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\r\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\r\n      }\r\n    }\r\n  }\r\n\r\n  _loadLight(lightIndex) {\r\n    const parser = this.parser;\r\n    const cacheKey = 'light:' + lightIndex;\r\n    let dependency = parser.cache.get(cacheKey);\r\n    if (dependency) return dependency;\r\n    const json = parser.json;\r\n    const extensions = json.extensions && json.extensions[this.name] || {};\r\n    const lightDefs = extensions.lights || [];\r\n    const lightDef = lightDefs[lightIndex];\r\n    let lightNode;\r\n    const color = new Color(0xffffff);\r\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color);\r\n    const range = lightDef.range !== undefined ? lightDef.range : 0;\r\n\r\n    switch (lightDef.type) {\r\n      case 'directional':\r\n        lightNode = new DirectionalLight(color);\r\n        lightNode.target.position.set(0, 0, -1);\r\n        lightNode.add(lightNode.target);\r\n        break;\r\n\r\n      case 'point':\r\n        lightNode = new PointLight(color);\r\n        lightNode.distance = range;\r\n        break;\r\n\r\n      case 'spot':\r\n        lightNode = new SpotLight(color);\r\n        lightNode.distance = range; // Handle spotlight properties.\r\n\r\n        lightDef.spot = lightDef.spot || {};\r\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\r\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\r\n        lightNode.angle = lightDef.spot.outerConeAngle;\r\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\r\n        lightNode.target.position.set(0, 0, -1);\r\n        lightNode.add(lightNode.target);\r\n        break;\r\n\r\n      default:\r\n        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type);\r\n    } // Some lights (e.g. spot) default to a position other than the origin. Reset the position\r\n    // here, because node-level parsing will only override position if explicitly specified.\r\n\r\n\r\n    lightNode.position.set(0, 0, 0);\r\n    lightNode.decay = 2;\r\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\r\n    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex);\r\n    dependency = Promise.resolve(lightNode);\r\n    parser.cache.add(cacheKey, dependency);\r\n    return dependency;\r\n  }\r\n\r\n  createNodeAttachment(nodeIndex) {\r\n    const self = this;\r\n    const parser = this.parser;\r\n    const json = parser.json;\r\n    const nodeDef = json.nodes[nodeIndex];\r\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\r\n    const lightIndex = lightDef.light;\r\n    if (lightIndex === undefined) return null;\r\n    return this._loadLight(lightIndex).then(function (light) {\r\n      return parser._getNodeRef(self.cache, lightIndex, light);\r\n    });\r\n  }\r\n\r\n}\r\n/**\r\n * Unlit Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n */\r\n\r\n\r\nclass GLTFMaterialsUnlitExtension {\r\n  constructor() {\r\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\r\n  }\r\n\r\n  getMaterialType() {\r\n    return MeshBasicMaterial;\r\n  }\r\n\r\n  extendParams(materialParams, materialDef, parser) {\r\n    const pending = [];\r\n    materialParams.color = new Color(1.0, 1.0, 1.0);\r\n    materialParams.opacity = 1.0;\r\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\r\n\r\n    if (metallicRoughness) {\r\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\r\n        const array = metallicRoughness.baseColorFactor;\r\n        materialParams.color.fromArray(array);\r\n        materialParams.opacity = array[3];\r\n      }\r\n\r\n      if (metallicRoughness.baseColorTexture !== undefined) {\r\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding));\r\n      }\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  }\r\n\r\n}\r\n/**\r\n * Materials Emissive Strength Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\r\n */\r\n\r\n\r\nclass GLTFMaterialsEmissiveStrengthExtension {\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\r\n  }\r\n\r\n  extendMaterialParams(materialIndex, materialParams) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\r\n\r\n    if (emissiveStrength !== undefined) {\r\n      materialParams.emissiveIntensity = emissiveStrength;\r\n    }\r\n\r\n    return Promise.resolve();\r\n  }\r\n\r\n}\r\n/**\r\n * Clearcoat Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n */\r\n\r\n\r\nclass GLTFMaterialsClearcoatExtension {\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\r\n  }\r\n\r\n  getMaterialType(materialIndex) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\r\n    return MeshPhysicalMaterial;\r\n  }\r\n\r\n  extendMaterialParams(materialIndex, materialParams) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const pending = [];\r\n    const extension = materialDef.extensions[this.name];\r\n\r\n    if (extension.clearcoatFactor !== undefined) {\r\n      materialParams.clearcoat = extension.clearcoatFactor;\r\n    }\r\n\r\n    if (extension.clearcoatTexture !== undefined) {\r\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));\r\n    }\r\n\r\n    if (extension.clearcoatRoughnessFactor !== undefined) {\r\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\r\n    }\r\n\r\n    if (extension.clearcoatRoughnessTexture !== undefined) {\r\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));\r\n    }\r\n\r\n    if (extension.clearcoatNormalTexture !== undefined) {\r\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));\r\n\r\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\r\n        const scale = extension.clearcoatNormalTexture.scale;\r\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale);\r\n      }\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  }\r\n\r\n}\r\n/**\r\n * Iridescence Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\r\n */\r\n\r\n\r\nclass GLTFMaterialsIridescenceExtension {\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\r\n  }\r\n\r\n  getMaterialType(materialIndex) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\r\n    return MeshPhysicalMaterial;\r\n  }\r\n\r\n  extendMaterialParams(materialIndex, materialParams) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const pending = [];\r\n    const extension = materialDef.extensions[this.name];\r\n\r\n    if (extension.iridescenceFactor !== undefined) {\r\n      materialParams.iridescence = extension.iridescenceFactor;\r\n    }\r\n\r\n    if (extension.iridescenceTexture !== undefined) {\r\n      pending.push(parser.assignTexture(materialParams, 'iridescenceMap', extension.iridescenceTexture));\r\n    }\r\n\r\n    if (extension.iridescenceIor !== undefined) {\r\n      materialParams.iridescenceIOR = extension.iridescenceIor;\r\n    }\r\n\r\n    if (materialParams.iridescenceThicknessRange === undefined) {\r\n      materialParams.iridescenceThicknessRange = [100, 400];\r\n    }\r\n\r\n    if (extension.iridescenceThicknessMinimum !== undefined) {\r\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\r\n    }\r\n\r\n    if (extension.iridescenceThicknessMaximum !== undefined) {\r\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\r\n    }\r\n\r\n    if (extension.iridescenceThicknessTexture !== undefined) {\r\n      pending.push(parser.assignTexture(materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture));\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  }\r\n\r\n}\r\n/**\r\n * Sheen Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\r\n */\r\n\r\n\r\nclass GLTFMaterialsSheenExtension {\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\r\n  }\r\n\r\n  getMaterialType(materialIndex) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\r\n    return MeshPhysicalMaterial;\r\n  }\r\n\r\n  extendMaterialParams(materialIndex, materialParams) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const pending = [];\r\n    materialParams.sheenColor = new Color(0, 0, 0);\r\n    materialParams.sheenRoughness = 0;\r\n    materialParams.sheen = 1;\r\n    const extension = materialDef.extensions[this.name];\r\n\r\n    if (extension.sheenColorFactor !== undefined) {\r\n      materialParams.sheenColor.fromArray(extension.sheenColorFactor);\r\n    }\r\n\r\n    if (extension.sheenRoughnessFactor !== undefined) {\r\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor;\r\n    }\r\n\r\n    if (extension.sheenColorTexture !== undefined) {\r\n      pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture, sRGBEncoding));\r\n    }\r\n\r\n    if (extension.sheenRoughnessTexture !== undefined) {\r\n      pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture));\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  }\r\n\r\n}\r\n/**\r\n * Transmission Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\r\n */\r\n\r\n\r\nclass GLTFMaterialsTransmissionExtension {\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\r\n  }\r\n\r\n  getMaterialType(materialIndex) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\r\n    return MeshPhysicalMaterial;\r\n  }\r\n\r\n  extendMaterialParams(materialIndex, materialParams) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const pending = [];\r\n    const extension = materialDef.extensions[this.name];\r\n\r\n    if (extension.transmissionFactor !== undefined) {\r\n      materialParams.transmission = extension.transmissionFactor;\r\n    }\r\n\r\n    if (extension.transmissionTexture !== undefined) {\r\n      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  }\r\n\r\n}\r\n/**\r\n * Materials Volume Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\r\n */\r\n\r\n\r\nclass GLTFMaterialsVolumeExtension {\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\r\n  }\r\n\r\n  getMaterialType(materialIndex) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\r\n    return MeshPhysicalMaterial;\r\n  }\r\n\r\n  extendMaterialParams(materialIndex, materialParams) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const pending = [];\r\n    const extension = materialDef.extensions[this.name];\r\n    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\r\n\r\n    if (extension.thicknessTexture !== undefined) {\r\n      pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture));\r\n    }\r\n\r\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\r\n    const colorArray = extension.attenuationColor || [1, 1, 1];\r\n    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);\r\n    return Promise.all(pending);\r\n  }\r\n\r\n}\r\n/**\r\n * Materials ior Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\r\n */\r\n\r\n\r\nclass GLTFMaterialsIorExtension {\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\r\n  }\r\n\r\n  getMaterialType(materialIndex) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\r\n    return MeshPhysicalMaterial;\r\n  }\r\n\r\n  extendMaterialParams(materialIndex, materialParams) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const extension = materialDef.extensions[this.name];\r\n    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\r\n    return Promise.resolve();\r\n  }\r\n\r\n}\r\n/**\r\n * Materials specular Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\r\n */\r\n\r\n\r\nclass GLTFMaterialsSpecularExtension {\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\r\n  }\r\n\r\n  getMaterialType(materialIndex) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\r\n    return MeshPhysicalMaterial;\r\n  }\r\n\r\n  extendMaterialParams(materialIndex, materialParams) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const pending = [];\r\n    const extension = materialDef.extensions[this.name];\r\n    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\r\n\r\n    if (extension.specularTexture !== undefined) {\r\n      pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture));\r\n    }\r\n\r\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\r\n    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);\r\n\r\n    if (extension.specularColorTexture !== undefined) {\r\n      pending.push(parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture, sRGBEncoding));\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  }\r\n\r\n}\r\n/**\r\n * BasisU Texture Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\r\n */\r\n\r\n\r\nclass GLTFTextureBasisUExtension {\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\r\n  }\r\n\r\n  loadTexture(textureIndex) {\r\n    const parser = this.parser;\r\n    const json = parser.json;\r\n    const textureDef = json.textures[textureIndex];\r\n\r\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\r\n      return null;\r\n    }\r\n\r\n    const extension = textureDef.extensions[this.name];\r\n    const loader = parser.options.ktx2Loader;\r\n\r\n    if (!loader) {\r\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\r\n        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');\r\n      } else {\r\n        // Assumes that the extension is optional and that a fallback texture is present\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return parser.loadTextureImage(textureIndex, extension.source, loader);\r\n  }\r\n\r\n}\r\n/**\r\n * WebP Texture Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\r\n */\r\n\r\n\r\nclass GLTFTextureWebPExtension {\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\r\n    this.isSupported = null;\r\n  }\r\n\r\n  loadTexture(textureIndex) {\r\n    const name = this.name;\r\n    const parser = this.parser;\r\n    const json = parser.json;\r\n    const textureDef = json.textures[textureIndex];\r\n\r\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\r\n      return null;\r\n    }\r\n\r\n    const extension = textureDef.extensions[name];\r\n    const source = json.images[extension.source];\r\n    let loader = parser.textureLoader;\r\n\r\n    if (source.uri) {\r\n      const handler = parser.options.manager.getHandler(source.uri);\r\n      if (handler !== null) loader = handler;\r\n    }\r\n\r\n    return this.detectSupport().then(function (isSupported) {\r\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\r\n\r\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\r\n        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');\r\n      } // Fall back to PNG or JPEG.\r\n\r\n\r\n      return parser.loadTexture(textureIndex);\r\n    });\r\n  }\r\n\r\n  detectSupport() {\r\n    if (!this.isSupported) {\r\n      this.isSupported = new Promise(function (resolve) {\r\n        const image = new Image(); // Lossy test image. Support for lossy images doesn't guarantee support for all\r\n        // WebP images, unfortunately.\r\n\r\n        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\r\n\r\n        image.onload = image.onerror = function () {\r\n          resolve(image.height === 1);\r\n        };\r\n      });\r\n    }\r\n\r\n    return this.isSupported;\r\n  }\r\n\r\n}\r\n/**\r\n * meshopt BufferView Compression Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\r\n */\r\n\r\n\r\nclass GLTFMeshoptCompression {\r\n  constructor(parser) {\r\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\r\n    this.parser = parser;\r\n  }\r\n\r\n  loadBufferView(index) {\r\n    const json = this.parser.json;\r\n    const bufferView = json.bufferViews[index];\r\n\r\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\r\n      const extensionDef = bufferView.extensions[this.name];\r\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer);\r\n      const decoder = this.parser.options.meshoptDecoder;\r\n\r\n      if (!decoder || !decoder.supported) {\r\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\r\n          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');\r\n        } else {\r\n          // Assumes that the extension is optional and that fallback buffer data is present\r\n          return null;\r\n        }\r\n      }\r\n\r\n      return buffer.then(function (res) {\r\n        const byteOffset = extensionDef.byteOffset || 0;\r\n        const byteLength = extensionDef.byteLength || 0;\r\n        const count = extensionDef.count;\r\n        const stride = extensionDef.byteStride;\r\n        const source = new Uint8Array(res, byteOffset, byteLength);\r\n\r\n        if (decoder.decodeGltfBufferAsync) {\r\n          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function (res) {\r\n            return res.buffer;\r\n          });\r\n        } else {\r\n          // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\r\n          return decoder.ready.then(function () {\r\n            const result = new ArrayBuffer(count * stride);\r\n            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\r\n            return result;\r\n          });\r\n        }\r\n      });\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n}\r\n/* BINARY EXTENSION */\r\n\r\n\r\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\r\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\r\nconst BINARY_EXTENSION_CHUNK_TYPES = {\r\n  JSON: 0x4e4f534a,\r\n  BIN: 0x004e4942\r\n};\r\n\r\nclass GLTFBinaryExtension {\r\n  constructor(data) {\r\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\r\n    this.content = null;\r\n    this.body = null;\r\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\r\n    this.header = {\r\n      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\r\n      version: headerView.getUint32(4, true),\r\n      length: headerView.getUint32(8, true)\r\n    };\r\n\r\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\r\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\r\n    } else if (this.header.version < 2.0) {\r\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.');\r\n    }\r\n\r\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\r\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\r\n    let chunkIndex = 0;\r\n\r\n    while (chunkIndex < chunkContentsLength) {\r\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\r\n      chunkIndex += 4;\r\n      const chunkType = chunkView.getUint32(chunkIndex, true);\r\n      chunkIndex += 4;\r\n\r\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\r\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\r\n        this.content = LoaderUtils.decodeText(contentArray);\r\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\r\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\r\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\r\n      } // Clients must ignore chunks with unknown types.\r\n\r\n\r\n      chunkIndex += chunkLength;\r\n    }\r\n\r\n    if (this.content === null) {\r\n      throw new Error('THREE.GLTFLoader: JSON content not found.');\r\n    }\r\n  }\r\n\r\n}\r\n/**\r\n * DRACO Mesh Compression Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\r\n */\r\n\r\n\r\nclass GLTFDracoMeshCompressionExtension {\r\n  constructor(json, dracoLoader) {\r\n    if (!dracoLoader) {\r\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\r\n    }\r\n\r\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\r\n    this.json = json;\r\n    this.dracoLoader = dracoLoader;\r\n    this.dracoLoader.preload();\r\n  }\r\n\r\n  decodePrimitive(primitive, parser) {\r\n    const json = this.json;\r\n    const dracoLoader = this.dracoLoader;\r\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\r\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\r\n    const threeAttributeMap = {};\r\n    const attributeNormalizedMap = {};\r\n    const attributeTypeMap = {};\r\n\r\n    for (const attributeName in gltfAttributeMap) {\r\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\r\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\r\n    }\r\n\r\n    for (const attributeName in primitive.attributes) {\r\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\r\n\r\n      if (gltfAttributeMap[attributeName] !== undefined) {\r\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\r\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\r\n        attributeTypeMap[threeAttributeName] = componentType.name;\r\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\r\n      }\r\n    }\r\n\r\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\r\n      return new Promise(function (resolve) {\r\n        dracoLoader.decodeDracoFile(bufferView, function (geometry) {\r\n          for (const attributeName in geometry.attributes) {\r\n            const attribute = geometry.attributes[attributeName];\r\n            const normalized = attributeNormalizedMap[attributeName];\r\n            if (normalized !== undefined) attribute.normalized = normalized;\r\n          }\r\n\r\n          resolve(geometry);\r\n        }, threeAttributeMap, attributeTypeMap);\r\n      });\r\n    });\r\n  }\r\n\r\n}\r\n/**\r\n * Texture Transform Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\r\n */\r\n\r\n\r\nclass GLTFTextureTransformExtension {\r\n  constructor() {\r\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\r\n  }\r\n\r\n  extendTexture(texture, transform) {\r\n    if (transform.texCoord !== undefined) {\r\n      console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\r\n    }\r\n\r\n    if (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {\r\n      // See https://github.com/mrdoob/three.js/issues/21819.\r\n      return texture;\r\n    }\r\n\r\n    texture = texture.clone();\r\n\r\n    if (transform.offset !== undefined) {\r\n      texture.offset.fromArray(transform.offset);\r\n    }\r\n\r\n    if (transform.rotation !== undefined) {\r\n      texture.rotation = transform.rotation;\r\n    }\r\n\r\n    if (transform.scale !== undefined) {\r\n      texture.repeat.fromArray(transform.scale);\r\n    }\r\n\r\n    texture.needsUpdate = true;\r\n    return texture;\r\n  }\r\n\r\n}\r\n/**\r\n * Specular-Glossiness Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness\r\n */\r\n\r\n/**\r\n * A sub class of StandardMaterial with some of the functionality\r\n * changed via the `onBeforeCompile` callback\r\n * @pailhead\r\n */\r\n\r\n\r\nclass GLTFMeshStandardSGMaterial extends MeshStandardMaterial {\r\n  constructor(params) {\r\n    super();\r\n    this.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing\r\n\r\n    const specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\r\n    const glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\r\n    const specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\r\n    const glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\r\n    const lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.roughness += geometryRoughness;', 'material.roughness = min( material.roughness, 1.0 );', 'material.specularColor = specularFactor;'].join('\\n');\r\n    const uniforms = {\r\n      specular: {\r\n        value: new Color().setHex(0xffffff)\r\n      },\r\n      glossiness: {\r\n        value: 1\r\n      },\r\n      specularMap: {\r\n        value: null\r\n      },\r\n      glossinessMap: {\r\n        value: null\r\n      }\r\n    };\r\n    this._extraUniforms = uniforms;\r\n\r\n    this.onBeforeCompile = function (shader) {\r\n      for (const uniformName in uniforms) {\r\n        shader.uniforms[uniformName] = uniforms[uniformName];\r\n      }\r\n\r\n      shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\r\n    };\r\n\r\n    Object.defineProperties(this, {\r\n      specular: {\r\n        get: function () {\r\n          return uniforms.specular.value;\r\n        },\r\n        set: function (v) {\r\n          uniforms.specular.value = v;\r\n        }\r\n      },\r\n      specularMap: {\r\n        get: function () {\r\n          return uniforms.specularMap.value;\r\n        },\r\n        set: function (v) {\r\n          uniforms.specularMap.value = v;\r\n\r\n          if (v) {\r\n            this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\r\n          } else {\r\n            delete this.defines.USE_SPECULARMAP;\r\n          }\r\n        }\r\n      },\r\n      glossiness: {\r\n        get: function () {\r\n          return uniforms.glossiness.value;\r\n        },\r\n        set: function (v) {\r\n          uniforms.glossiness.value = v;\r\n        }\r\n      },\r\n      glossinessMap: {\r\n        get: function () {\r\n          return uniforms.glossinessMap.value;\r\n        },\r\n        set: function (v) {\r\n          uniforms.glossinessMap.value = v;\r\n\r\n          if (v) {\r\n            this.defines.USE_GLOSSINESSMAP = '';\r\n            this.defines.USE_UV = '';\r\n          } else {\r\n            delete this.defines.USE_GLOSSINESSMAP;\r\n            delete this.defines.USE_UV;\r\n          }\r\n        }\r\n      }\r\n    });\r\n    delete this.metalness;\r\n    delete this.roughness;\r\n    delete this.metalnessMap;\r\n    delete this.roughnessMap;\r\n    this.setValues(params);\r\n  }\r\n\r\n  copy(source) {\r\n    super.copy(source);\r\n    this.specularMap = source.specularMap;\r\n    this.specular.copy(source.specular);\r\n    this.glossinessMap = source.glossinessMap;\r\n    this.glossiness = source.glossiness;\r\n    delete this.metalness;\r\n    delete this.roughness;\r\n    delete this.metalnessMap;\r\n    delete this.roughnessMap;\r\n    return this;\r\n  }\r\n\r\n}\r\n\r\nclass GLTFMaterialsPbrSpecularGlossinessExtension {\r\n  constructor() {\r\n    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\r\n    this.specularGlossinessParams = ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'];\r\n  }\r\n\r\n  getMaterialType() {\r\n    return GLTFMeshStandardSGMaterial;\r\n  }\r\n\r\n  extendParams(materialParams, materialDef, parser) {\r\n    const pbrSpecularGlossiness = materialDef.extensions[this.name];\r\n    materialParams.color = new Color(1.0, 1.0, 1.0);\r\n    materialParams.opacity = 1.0;\r\n    const pending = [];\r\n\r\n    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\r\n      const array = pbrSpecularGlossiness.diffuseFactor;\r\n      materialParams.color.fromArray(array);\r\n      materialParams.opacity = array[3];\r\n    }\r\n\r\n    if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\r\n      pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture, sRGBEncoding));\r\n    }\r\n\r\n    materialParams.emissive = new Color(0.0, 0.0, 0.0);\r\n    materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\r\n    materialParams.specular = new Color(1.0, 1.0, 1.0);\r\n\r\n    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\r\n      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\r\n    }\r\n\r\n    if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\r\n      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\r\n      pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\r\n      pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef, sRGBEncoding));\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  }\r\n\r\n  createMaterial(materialParams) {\r\n    const material = new GLTFMeshStandardSGMaterial(materialParams);\r\n    material.fog = true;\r\n    material.color = materialParams.color;\r\n    material.map = materialParams.map === undefined ? null : materialParams.map;\r\n    material.lightMap = null;\r\n    material.lightMapIntensity = 1.0;\r\n    material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\r\n    material.aoMapIntensity = 1.0;\r\n    material.emissive = materialParams.emissive;\r\n    material.emissiveIntensity = materialParams.emissiveIntensity === undefined ? 1.0 : materialParams.emissiveIntensity;\r\n    material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\r\n    material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\r\n    material.bumpScale = 1;\r\n    material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\r\n    material.normalMapType = TangentSpaceNormalMap;\r\n    if (materialParams.normalScale) material.normalScale = materialParams.normalScale;\r\n    material.displacementMap = null;\r\n    material.displacementScale = 1;\r\n    material.displacementBias = 0;\r\n    material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\r\n    material.specular = materialParams.specular;\r\n    material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\r\n    material.glossiness = materialParams.glossiness;\r\n    material.alphaMap = null;\r\n    material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\r\n    material.envMapIntensity = 1.0;\r\n    material.refractionRatio = 0.98;\r\n    return material;\r\n  }\r\n\r\n}\r\n/**\r\n * Mesh Quantization Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\r\n */\r\n\r\n\r\nclass GLTFMeshQuantizationExtension {\r\n  constructor() {\r\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\r\n  }\r\n\r\n}\r\n/*********************************/\r\n\r\n/********** INTERPOLATION ********/\r\n\r\n/*********************************/\r\n// Spline Interpolation\r\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\r\n\r\n\r\nclass GLTFCubicSplineInterpolant extends Interpolant {\r\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\r\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\r\n  }\r\n\r\n  copySampleValue_(index) {\r\n    // Copies a sample value to the result buffer. See description of glTF\r\n    // CUBICSPLINE values layout in interpolate_() function below.\r\n    const result = this.resultBuffer,\r\n          values = this.sampleValues,\r\n          valueSize = this.valueSize,\r\n          offset = index * valueSize * 3 + valueSize;\r\n\r\n    for (let i = 0; i !== valueSize; i++) {\r\n      result[i] = values[offset + i];\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  interpolate_(i1, t0, t, t1) {\r\n    const result = this.resultBuffer;\r\n    const values = this.sampleValues;\r\n    const stride = this.valueSize;\r\n    const stride2 = stride * 2;\r\n    const stride3 = stride * 3;\r\n    const td = t1 - t0;\r\n    const p = (t - t0) / td;\r\n    const pp = p * p;\r\n    const ppp = pp * p;\r\n    const offset1 = i1 * stride3;\r\n    const offset0 = offset1 - stride3;\r\n    const s2 = -2 * ppp + 3 * pp;\r\n    const s3 = ppp - pp;\r\n    const s0 = 1 - s2;\r\n    const s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:\r\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\r\n\r\n    for (let i = 0; i !== stride; i++) {\r\n      const p0 = values[offset0 + i + stride]; // splineVertex_k\r\n\r\n      const m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\r\n\r\n      const p1 = values[offset1 + i + stride]; // splineVertex_k+1\r\n\r\n      const m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\r\n\r\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n}\r\n\r\nconst _q = new Quaternion();\r\n\r\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\r\n  interpolate_(i1, t0, t, t1) {\r\n    const result = super.interpolate_(i1, t0, t, t1);\r\n\r\n    _q.fromArray(result).normalize().toArray(result);\r\n\r\n    return result;\r\n  }\r\n\r\n}\r\n/*********************************/\r\n\r\n/********** INTERNALS ************/\r\n\r\n/*********************************/\r\n\r\n/* CONSTANTS */\r\n\r\n\r\nconst WEBGL_CONSTANTS = {\r\n  FLOAT: 5126,\r\n  //FLOAT_MAT2: 35674,\r\n  FLOAT_MAT3: 35675,\r\n  FLOAT_MAT4: 35676,\r\n  FLOAT_VEC2: 35664,\r\n  FLOAT_VEC3: 35665,\r\n  FLOAT_VEC4: 35666,\r\n  LINEAR: 9729,\r\n  REPEAT: 10497,\r\n  SAMPLER_2D: 35678,\r\n  POINTS: 0,\r\n  LINES: 1,\r\n  LINE_LOOP: 2,\r\n  LINE_STRIP: 3,\r\n  TRIANGLES: 4,\r\n  TRIANGLE_STRIP: 5,\r\n  TRIANGLE_FAN: 6,\r\n  UNSIGNED_BYTE: 5121,\r\n  UNSIGNED_SHORT: 5123\r\n};\r\nconst WEBGL_COMPONENT_TYPES = {\r\n  5120: Int8Array,\r\n  5121: Uint8Array,\r\n  5122: Int16Array,\r\n  5123: Uint16Array,\r\n  5125: Uint32Array,\r\n  5126: Float32Array\r\n};\r\nconst WEBGL_FILTERS = {\r\n  9728: NearestFilter,\r\n  9729: LinearFilter,\r\n  9984: NearestMipmapNearestFilter,\r\n  9985: LinearMipmapNearestFilter,\r\n  9986: NearestMipmapLinearFilter,\r\n  9987: LinearMipmapLinearFilter\r\n};\r\nconst WEBGL_WRAPPINGS = {\r\n  33071: ClampToEdgeWrapping,\r\n  33648: MirroredRepeatWrapping,\r\n  10497: RepeatWrapping\r\n};\r\nconst WEBGL_TYPE_SIZES = {\r\n  SCALAR: 1,\r\n  VEC2: 2,\r\n  VEC3: 3,\r\n  VEC4: 4,\r\n  MAT2: 4,\r\n  MAT3: 9,\r\n  MAT4: 16\r\n};\r\nconst ATTRIBUTES = {\r\n  POSITION: 'position',\r\n  NORMAL: 'normal',\r\n  TANGENT: 'tangent',\r\n  TEXCOORD_0: 'uv',\r\n  TEXCOORD_1: 'uv2',\r\n  COLOR_0: 'color',\r\n  WEIGHTS_0: 'skinWeight',\r\n  JOINTS_0: 'skinIndex'\r\n};\r\nconst PATH_PROPERTIES = {\r\n  scale: 'scale',\r\n  translation: 'position',\r\n  rotation: 'quaternion',\r\n  weights: 'morphTargetInfluences'\r\n};\r\nconst INTERPOLATION = {\r\n  CUBICSPLINE: undefined,\r\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\r\n  // keyframe track will be initialized with a default interpolation type, then modified.\r\n  LINEAR: InterpolateLinear,\r\n  STEP: InterpolateDiscrete\r\n};\r\nconst ALPHA_MODES = {\r\n  OPAQUE: 'OPAQUE',\r\n  MASK: 'MASK',\r\n  BLEND: 'BLEND'\r\n};\r\n/**\r\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\r\n */\r\n\r\nfunction createDefaultMaterial(cache) {\r\n  if (cache['DefaultMaterial'] === undefined) {\r\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\r\n      color: 0xffffff,\r\n      emissive: 0x000000,\r\n      metalness: 1,\r\n      roughness: 1,\r\n      transparent: false,\r\n      depthTest: true,\r\n      side: FrontSide\r\n    });\r\n  }\r\n\r\n  return cache['DefaultMaterial'];\r\n}\r\n\r\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\r\n  // Add unknown glTF extensions to an object's userData.\r\n  for (const name in objectDef.extensions) {\r\n    if (knownExtensions[name] === undefined) {\r\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\r\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\r\n    }\r\n  }\r\n}\r\n/**\r\n * @param {Object3D|Material|BufferGeometry} object\r\n * @param {GLTF.definition} gltfDef\r\n */\r\n\r\n\r\nfunction assignExtrasToUserData(object, gltfDef) {\r\n  if (gltfDef.extras !== undefined) {\r\n    if (typeof gltfDef.extras === 'object') {\r\n      Object.assign(object.userData, gltfDef.extras);\r\n    } else {\r\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\r\n    }\r\n  }\r\n}\r\n/**\r\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\r\n *\r\n * @param {BufferGeometry} geometry\r\n * @param {Array<GLTF.Target>} targets\r\n * @param {GLTFParser} parser\r\n * @return {Promise<BufferGeometry>}\r\n */\r\n\r\n\r\nfunction addMorphTargets(geometry, targets, parser) {\r\n  let hasMorphPosition = false;\r\n  let hasMorphNormal = false;\r\n  let hasMorphColor = false;\r\n\r\n  for (let i = 0, il = targets.length; i < il; i++) {\r\n    const target = targets[i];\r\n    if (target.POSITION !== undefined) hasMorphPosition = true;\r\n    if (target.NORMAL !== undefined) hasMorphNormal = true;\r\n    if (target.COLOR_0 !== undefined) hasMorphColor = true;\r\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;\r\n  }\r\n\r\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);\r\n  const pendingPositionAccessors = [];\r\n  const pendingNormalAccessors = [];\r\n  const pendingColorAccessors = [];\r\n\r\n  for (let i = 0, il = targets.length; i < il; i++) {\r\n    const target = targets[i];\r\n\r\n    if (hasMorphPosition) {\r\n      const pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;\r\n      pendingPositionAccessors.push(pendingAccessor);\r\n    }\r\n\r\n    if (hasMorphNormal) {\r\n      const pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;\r\n      pendingNormalAccessors.push(pendingAccessor);\r\n    }\r\n\r\n    if (hasMorphColor) {\r\n      const pendingAccessor = target.COLOR_0 !== undefined ? parser.getDependency('accessor', target.COLOR_0) : geometry.attributes.color;\r\n      pendingColorAccessors.push(pendingAccessor);\r\n    }\r\n  }\r\n\r\n  return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors), Promise.all(pendingColorAccessors)]).then(function (accessors) {\r\n    const morphPositions = accessors[0];\r\n    const morphNormals = accessors[1];\r\n    const morphColors = accessors[2];\r\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\r\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\r\n    if (hasMorphColor) geometry.morphAttributes.color = morphColors;\r\n    geometry.morphTargetsRelative = true;\r\n    return geometry;\r\n  });\r\n}\r\n/**\r\n * @param {Mesh} mesh\r\n * @param {GLTF.Mesh} meshDef\r\n */\r\n\r\n\r\nfunction updateMorphTargets(mesh, meshDef) {\r\n  mesh.updateMorphTargets();\r\n\r\n  if (meshDef.weights !== undefined) {\r\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\r\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\r\n    }\r\n  } // .extras has user-defined data, so check that .extras.targetNames is an array.\r\n\r\n\r\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\r\n    const targetNames = meshDef.extras.targetNames;\r\n\r\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\r\n      mesh.morphTargetDictionary = {};\r\n\r\n      for (let i = 0, il = targetNames.length; i < il; i++) {\r\n        mesh.morphTargetDictionary[targetNames[i]] = i;\r\n      }\r\n    } else {\r\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\r\n    }\r\n  }\r\n}\r\n\r\nfunction createPrimitiveKey(primitiveDef) {\r\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\r\n  let geometryKey;\r\n\r\n  if (dracoExtension) {\r\n    geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\r\n  } else {\r\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\r\n  }\r\n\r\n  return geometryKey;\r\n}\r\n\r\nfunction createAttributesKey(attributes) {\r\n  let attributesKey = '';\r\n  const keys = Object.keys(attributes).sort();\r\n\r\n  for (let i = 0, il = keys.length; i < il; i++) {\r\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\r\n  }\r\n\r\n  return attributesKey;\r\n}\r\n\r\nfunction getNormalizedComponentScale(constructor) {\r\n  // Reference:\r\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\r\n  switch (constructor) {\r\n    case Int8Array:\r\n      return 1 / 127;\r\n\r\n    case Uint8Array:\r\n      return 1 / 255;\r\n\r\n    case Int16Array:\r\n      return 1 / 32767;\r\n\r\n    case Uint16Array:\r\n      return 1 / 65535;\r\n\r\n    default:\r\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');\r\n  }\r\n}\r\n\r\nfunction getImageURIMimeType(uri) {\r\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return 'image/jpeg';\r\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return 'image/webp';\r\n  return 'image/png';\r\n}\r\n/* GLTF PARSER */\r\n\r\n\r\nclass GLTFParser {\r\n  constructor(json = {}, options = {}) {\r\n    var _navigator$userAgent, _navigator$userAgent2;\r\n\r\n    this.json = json;\r\n    this.extensions = {};\r\n    this.plugins = {};\r\n    this.options = options; // loader object cache\r\n\r\n    this.cache = new GLTFRegistry(); // associations between Three.js objects and glTF elements\r\n\r\n    this.associations = new Map(); // BufferGeometry caching\r\n\r\n    this.primitiveCache = {}; // Object3D instance caches\r\n\r\n    this.meshCache = {\r\n      refs: {},\r\n      uses: {}\r\n    };\r\n    this.cameraCache = {\r\n      refs: {},\r\n      uses: {}\r\n    };\r\n    this.lightCache = {\r\n      refs: {},\r\n      uses: {}\r\n    };\r\n    this.sourceCache = {};\r\n    this.textureCache = {}; // Track node names, to ensure no duplicates\r\n\r\n    this.nodeNamesUsed = {}; // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\r\n    // expensive work of uploading a texture to the GPU off the main thread.\r\n\r\n    const isSafari = typeof navigator !== 'undefined' && /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\r\n    const isFirefox = typeof navigator !== 'undefined' && ((_navigator$userAgent = navigator.userAgent) === null || _navigator$userAgent === void 0 ? void 0 : _navigator$userAgent.indexOf('Firefox')) > -1;\r\n    const firefoxVersion = typeof navigator !== 'undefined' && isFirefox ? (_navigator$userAgent2 = navigator.userAgent) === null || _navigator$userAgent2 === void 0 ? void 0 : _navigator$userAgent2.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\r\n\r\n    if (typeof createImageBitmap === 'undefined' || isSafari || isFirefox && firefoxVersion < 98) {\r\n      this.textureLoader = new TextureLoader(this.options.manager);\r\n    } else {\r\n      this.textureLoader = new ImageBitmapLoader(this.options.manager);\r\n    }\r\n\r\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\r\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\r\n    this.fileLoader = new FileLoader(this.options.manager);\r\n    this.fileLoader.setResponseType('arraybuffer');\r\n\r\n    if (this.options.crossOrigin === 'use-credentials') {\r\n      this.fileLoader.setWithCredentials(true);\r\n    }\r\n  }\r\n\r\n  setExtensions(extensions) {\r\n    this.extensions = extensions;\r\n  }\r\n\r\n  setPlugins(plugins) {\r\n    this.plugins = plugins;\r\n  }\r\n\r\n  parse(onLoad, onError) {\r\n    const parser = this;\r\n    const json = this.json;\r\n    const extensions = this.extensions; // Clear the loader cache\r\n\r\n    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\r\n\r\n    this._invokeAll(function (ext) {\r\n      return ext._markDefs && ext._markDefs();\r\n    });\r\n\r\n    Promise.all(this._invokeAll(function (ext) {\r\n      return ext.beforeRoot && ext.beforeRoot();\r\n    })).then(function () {\r\n      return Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera')]);\r\n    }).then(function (dependencies) {\r\n      const result = {\r\n        scene: dependencies[0][json.scene || 0],\r\n        scenes: dependencies[0],\r\n        animations: dependencies[1],\r\n        cameras: dependencies[2],\r\n        asset: json.asset,\r\n        parser: parser,\r\n        userData: {}\r\n      };\r\n      addUnknownExtensionsToUserData(extensions, result, json);\r\n      assignExtrasToUserData(result, json);\r\n      Promise.all(parser._invokeAll(function (ext) {\r\n        return ext.afterRoot && ext.afterRoot(result);\r\n      })).then(function () {\r\n        onLoad(result);\r\n      });\r\n    }).catch(onError);\r\n  }\r\n  /**\r\n   * Marks the special nodes/meshes in json for efficient parse.\r\n   */\r\n\r\n\r\n  _markDefs() {\r\n    const nodeDefs = this.json.nodes || [];\r\n    const skinDefs = this.json.skins || [];\r\n    const meshDefs = this.json.meshes || []; // Nothing in the node definition indicates whether it is a Bone or an\r\n    // Object3D. Use the skins' joint references to mark bones.\r\n\r\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\r\n      const joints = skinDefs[skinIndex].joints;\r\n\r\n      for (let i = 0, il = joints.length; i < il; i++) {\r\n        nodeDefs[joints[i]].isBone = true;\r\n      }\r\n    } // Iterate over all nodes, marking references to shared resources,\r\n    // as well as skeleton joints.\r\n\r\n\r\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\r\n      const nodeDef = nodeDefs[nodeIndex];\r\n\r\n      if (nodeDef.mesh !== undefined) {\r\n        this._addNodeRef(this.meshCache, nodeDef.mesh); // Nothing in the mesh definition indicates whether it is\r\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\r\n        // to mark SkinnedMesh if node has skin.\r\n\r\n\r\n        if (nodeDef.skin !== undefined) {\r\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\r\n        }\r\n      }\r\n\r\n      if (nodeDef.camera !== undefined) {\r\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Counts references to shared node / Object3D resources. These resources\r\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\r\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\r\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\r\n   * Textures) can be reused directly and are not marked here.\r\n   *\r\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\r\n   */\r\n\r\n\r\n  _addNodeRef(cache, index) {\r\n    if (index === undefined) return;\r\n\r\n    if (cache.refs[index] === undefined) {\r\n      cache.refs[index] = cache.uses[index] = 0;\r\n    }\r\n\r\n    cache.refs[index]++;\r\n  }\r\n  /** Returns a reference to a shared resource, cloning it if necessary. */\r\n\r\n\r\n  _getNodeRef(cache, index, object) {\r\n    if (cache.refs[index] <= 1) return object;\r\n    const ref = object.clone(); // Propagates mappings to the cloned object, prevents mappings on the\r\n    // original object from being lost.\r\n\r\n    const updateMappings = (original, clone) => {\r\n      const mappings = this.associations.get(original);\r\n\r\n      if (mappings != null) {\r\n        this.associations.set(clone, mappings);\r\n      }\r\n\r\n      for (const [i, child] of original.children.entries()) {\r\n        updateMappings(child, clone.children[i]);\r\n      }\r\n    };\r\n\r\n    updateMappings(object, ref);\r\n    ref.name += '_instance_' + cache.uses[index]++;\r\n    return ref;\r\n  }\r\n\r\n  _invokeOne(func) {\r\n    const extensions = Object.values(this.plugins);\r\n    extensions.push(this);\r\n\r\n    for (let i = 0; i < extensions.length; i++) {\r\n      const result = func(extensions[i]);\r\n      if (result) return result;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _invokeAll(func) {\r\n    const extensions = Object.values(this.plugins);\r\n    extensions.unshift(this);\r\n    const pending = [];\r\n\r\n    for (let i = 0; i < extensions.length; i++) {\r\n      const result = func(extensions[i]);\r\n      if (result) pending.push(result);\r\n    }\r\n\r\n    return pending;\r\n  }\r\n  /**\r\n   * Requests the specified dependency asynchronously, with caching.\r\n   * @param {string} type\r\n   * @param {number} index\r\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\r\n   */\r\n\r\n\r\n  getDependency(type, index) {\r\n    const cacheKey = type + ':' + index;\r\n    let dependency = this.cache.get(cacheKey);\r\n\r\n    if (!dependency) {\r\n      switch (type) {\r\n        case 'scene':\r\n          dependency = this.loadScene(index);\r\n          break;\r\n\r\n        case 'node':\r\n          dependency = this.loadNode(index);\r\n          break;\r\n\r\n        case 'mesh':\r\n          dependency = this._invokeOne(function (ext) {\r\n            return ext.loadMesh && ext.loadMesh(index);\r\n          });\r\n          break;\r\n\r\n        case 'accessor':\r\n          dependency = this.loadAccessor(index);\r\n          break;\r\n\r\n        case 'bufferView':\r\n          dependency = this._invokeOne(function (ext) {\r\n            return ext.loadBufferView && ext.loadBufferView(index);\r\n          });\r\n          break;\r\n\r\n        case 'buffer':\r\n          dependency = this.loadBuffer(index);\r\n          break;\r\n\r\n        case 'material':\r\n          dependency = this._invokeOne(function (ext) {\r\n            return ext.loadMaterial && ext.loadMaterial(index);\r\n          });\r\n          break;\r\n\r\n        case 'texture':\r\n          dependency = this._invokeOne(function (ext) {\r\n            return ext.loadTexture && ext.loadTexture(index);\r\n          });\r\n          break;\r\n\r\n        case 'skin':\r\n          dependency = this.loadSkin(index);\r\n          break;\r\n\r\n        case 'animation':\r\n          dependency = this._invokeOne(function (ext) {\r\n            return ext.loadAnimation && ext.loadAnimation(index);\r\n          });\r\n          break;\r\n\r\n        case 'camera':\r\n          dependency = this.loadCamera(index);\r\n          break;\r\n\r\n        default:\r\n          throw new Error('Unknown type: ' + type);\r\n      }\r\n\r\n      this.cache.add(cacheKey, dependency);\r\n    }\r\n\r\n    return dependency;\r\n  }\r\n  /**\r\n   * Requests all dependencies of the specified type asynchronously, with caching.\r\n   * @param {string} type\r\n   * @return {Promise<Array<Object>>}\r\n   */\r\n\r\n\r\n  getDependencies(type) {\r\n    let dependencies = this.cache.get(type);\r\n\r\n    if (!dependencies) {\r\n      const parser = this;\r\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\r\n      dependencies = Promise.all(defs.map(function (def, index) {\r\n        return parser.getDependency(type, index);\r\n      }));\r\n      this.cache.add(type, dependencies);\r\n    }\r\n\r\n    return dependencies;\r\n  }\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n   * @param {number} bufferIndex\r\n   * @return {Promise<ArrayBuffer>}\r\n   */\r\n\r\n\r\n  loadBuffer(bufferIndex) {\r\n    const bufferDef = this.json.buffers[bufferIndex];\r\n    const loader = this.fileLoader;\r\n\r\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\r\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\r\n    } // If present, GLB container is required to be the first buffer.\r\n\r\n\r\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\r\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\r\n    }\r\n\r\n    const options = this.options;\r\n    return new Promise(function (resolve, reject) {\r\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\r\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\r\n      });\r\n    });\r\n  }\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n   * @param {number} bufferViewIndex\r\n   * @return {Promise<ArrayBuffer>}\r\n   */\r\n\r\n\r\n  loadBufferView(bufferViewIndex) {\r\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\r\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\r\n      const byteLength = bufferViewDef.byteLength || 0;\r\n      const byteOffset = bufferViewDef.byteOffset || 0;\r\n      return buffer.slice(byteOffset, byteOffset + byteLength);\r\n    });\r\n  }\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\r\n   * @param {number} accessorIndex\r\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\r\n   */\r\n\r\n\r\n  loadAccessor(accessorIndex) {\r\n    const parser = this;\r\n    const json = this.json;\r\n    const accessorDef = this.json.accessors[accessorIndex];\r\n\r\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\r\n      // Ignore empty accessors, which may be used to declare runtime\r\n      // information about attributes coming from another source (e.g. Draco\r\n      // compression extension).\r\n      return Promise.resolve(null);\r\n    }\r\n\r\n    const pendingBufferViews = [];\r\n\r\n    if (accessorDef.bufferView !== undefined) {\r\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\r\n    } else {\r\n      pendingBufferViews.push(null);\r\n    }\r\n\r\n    if (accessorDef.sparse !== undefined) {\r\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\r\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\r\n    }\r\n\r\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\r\n      const bufferView = bufferViews[0];\r\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\r\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\r\n\r\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\r\n      const itemBytes = elementBytes * itemSize;\r\n      const byteOffset = accessorDef.byteOffset || 0;\r\n      const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\r\n      const normalized = accessorDef.normalized === true;\r\n      let array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\r\n\r\n      if (byteStride && byteStride !== itemBytes) {\r\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\r\n        // This makes sure that IBA.count reflects accessor.count properly\r\n        const ibSlice = Math.floor(byteOffset / byteStride);\r\n        const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\r\n        let ib = parser.cache.get(ibCacheKey);\r\n\r\n        if (!ib) {\r\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.\r\n\r\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\r\n          parser.cache.add(ibCacheKey, ib);\r\n        }\r\n\r\n        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\r\n      } else {\r\n        if (bufferView === null) {\r\n          array = new TypedArray(accessorDef.count * itemSize);\r\n        } else {\r\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\r\n        }\r\n\r\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\r\n      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\r\n\r\n\r\n      if (accessorDef.sparse !== undefined) {\r\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\r\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\r\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\r\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\r\n        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\r\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\r\n\r\n        if (bufferView !== null) {\r\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\r\n          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\r\n        }\r\n\r\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\r\n          const index = sparseIndices[i];\r\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\r\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\r\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\r\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\r\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\r\n        }\r\n      }\r\n\r\n      return bufferAttribute;\r\n    });\r\n  }\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\r\n   * @param {number} textureIndex\r\n   * @return {Promise<THREE.Texture>}\r\n   */\r\n\r\n\r\n  loadTexture(textureIndex) {\r\n    const json = this.json;\r\n    const options = this.options;\r\n    const textureDef = json.textures[textureIndex];\r\n    const sourceIndex = textureDef.source;\r\n    const sourceDef = json.images[sourceIndex];\r\n    let loader = this.textureLoader;\r\n\r\n    if (sourceDef.uri) {\r\n      const handler = options.manager.getHandler(sourceDef.uri);\r\n      if (handler !== null) loader = handler;\r\n    }\r\n\r\n    return this.loadTextureImage(textureIndex, sourceIndex, loader);\r\n  }\r\n\r\n  loadTextureImage(textureIndex, sourceIndex, loader) {\r\n    const parser = this;\r\n    const json = this.json;\r\n    const textureDef = json.textures[textureIndex];\r\n    const sourceDef = json.images[sourceIndex];\r\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler;\r\n\r\n    if (this.textureCache[cacheKey]) {\r\n      // See https://github.com/mrdoob/three.js/issues/21559.\r\n      return this.textureCache[cacheKey];\r\n    }\r\n\r\n    const promise = this.loadImageSource(sourceIndex, loader).then(function (texture) {\r\n      texture.flipY = false;\r\n      if (textureDef.name) texture.name = textureDef.name;\r\n      const samplers = json.samplers || {};\r\n      const sampler = samplers[textureDef.sampler] || {};\r\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\r\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\r\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\r\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\r\n      parser.associations.set(texture, {\r\n        textures: textureIndex\r\n      });\r\n      return texture;\r\n    }).catch(function () {\r\n      return null;\r\n    });\r\n    this.textureCache[cacheKey] = promise;\r\n    return promise;\r\n  }\r\n\r\n  loadImageSource(sourceIndex, loader) {\r\n    const parser = this;\r\n    const json = this.json;\r\n    const options = this.options;\r\n\r\n    if (this.sourceCache[sourceIndex] !== undefined) {\r\n      return this.sourceCache[sourceIndex].then(texture => texture.clone());\r\n    }\r\n\r\n    const sourceDef = json.images[sourceIndex];\r\n    const URL = self.URL || self.webkitURL;\r\n    let sourceURI = sourceDef.uri || '';\r\n    let isObjectURL = false;\r\n\r\n    if (sourceDef.bufferView !== undefined) {\r\n      // Load binary image data from bufferView, if provided.\r\n      sourceURI = parser.getDependency('bufferView', sourceDef.bufferView).then(function (bufferView) {\r\n        isObjectURL = true;\r\n        const blob = new Blob([bufferView], {\r\n          type: sourceDef.mimeType\r\n        });\r\n        sourceURI = URL.createObjectURL(blob);\r\n        return sourceURI;\r\n      });\r\n    } else if (sourceDef.uri === undefined) {\r\n      throw new Error('THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView');\r\n    }\r\n\r\n    const promise = Promise.resolve(sourceURI).then(function (sourceURI) {\r\n      return new Promise(function (resolve, reject) {\r\n        let onLoad = resolve;\r\n\r\n        if (loader.isImageBitmapLoader === true) {\r\n          onLoad = function (imageBitmap) {\r\n            const texture = new Texture(imageBitmap);\r\n            texture.needsUpdate = true;\r\n            resolve(texture);\r\n          };\r\n        }\r\n\r\n        loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject);\r\n      });\r\n    }).then(function (texture) {\r\n      // Clean up resources and configure Texture.\r\n      if (isObjectURL === true) {\r\n        URL.revokeObjectURL(sourceURI);\r\n      }\r\n\r\n      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\r\n      return texture;\r\n    }).catch(function (error) {\r\n      console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\r\n      throw error;\r\n    });\r\n    this.sourceCache[sourceIndex] = promise;\r\n    return promise;\r\n  }\r\n  /**\r\n   * Asynchronously assigns a texture to the given material parameters.\r\n   * @param {Object} materialParams\r\n   * @param {string} mapName\r\n   * @param {Object} mapDef\r\n   * @return {Promise<Texture>}\r\n   */\r\n\r\n\r\n  assignTexture(materialParams, mapName, mapDef, encoding) {\r\n    const parser = this;\r\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\r\n      // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\r\n      // However, we will copy UV set 0 to UV set 1 on demand for aoMap\r\n      if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {\r\n        console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');\r\n      }\r\n\r\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\r\n        const transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\r\n\r\n        if (transform) {\r\n          const gltfReference = parser.associations.get(texture);\r\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\r\n          parser.associations.set(texture, gltfReference);\r\n        }\r\n      }\r\n\r\n      if (encoding !== undefined) {\r\n        texture.encoding = encoding;\r\n      }\r\n\r\n      materialParams[mapName] = texture;\r\n      return texture;\r\n    });\r\n  }\r\n  /**\r\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\r\n   * already has a material (generated from the glTF material options alone)\r\n   * but reuse of the same glTF material may require multiple threejs materials\r\n   * to accommodate different primitive types, defines, etc. New materials will\r\n   * be created if necessary, and reused from a cache.\r\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\r\n   */\r\n\r\n\r\n  assignFinalMaterial(mesh) {\r\n    const geometry = mesh.geometry;\r\n    let material = mesh.material;\r\n    const useDerivativeTangents = geometry.attributes.tangent === undefined;\r\n    const useVertexColors = geometry.attributes.color !== undefined;\r\n    const useFlatShading = geometry.attributes.normal === undefined;\r\n\r\n    if (mesh.isPoints) {\r\n      const cacheKey = 'PointsMaterial:' + material.uuid;\r\n      let pointsMaterial = this.cache.get(cacheKey);\r\n\r\n      if (!pointsMaterial) {\r\n        pointsMaterial = new PointsMaterial();\r\n        Material.prototype.copy.call(pointsMaterial, material);\r\n        pointsMaterial.color.copy(material.color);\r\n        pointsMaterial.map = material.map;\r\n        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\r\n\r\n        this.cache.add(cacheKey, pointsMaterial);\r\n      }\r\n\r\n      material = pointsMaterial;\r\n    } else if (mesh.isLine) {\r\n      const cacheKey = 'LineBasicMaterial:' + material.uuid;\r\n      let lineMaterial = this.cache.get(cacheKey);\r\n\r\n      if (!lineMaterial) {\r\n        lineMaterial = new LineBasicMaterial();\r\n        Material.prototype.copy.call(lineMaterial, material);\r\n        lineMaterial.color.copy(material.color);\r\n        this.cache.add(cacheKey, lineMaterial);\r\n      }\r\n\r\n      material = lineMaterial;\r\n    } // Clone the material if it will be modified\r\n\r\n\r\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\r\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':';\r\n      if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';\r\n      if (useDerivativeTangents) cacheKey += 'derivative-tangents:';\r\n      if (useVertexColors) cacheKey += 'vertex-colors:';\r\n      if (useFlatShading) cacheKey += 'flat-shading:';\r\n      let cachedMaterial = this.cache.get(cacheKey);\r\n\r\n      if (!cachedMaterial) {\r\n        cachedMaterial = material.clone();\r\n        if (useVertexColors) cachedMaterial.vertexColors = true;\r\n        if (useFlatShading) cachedMaterial.flatShading = true;\r\n\r\n        if (useDerivativeTangents) {\r\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\r\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\r\n        }\r\n\r\n        this.cache.add(cacheKey, cachedMaterial);\r\n        this.associations.set(cachedMaterial, this.associations.get(material));\r\n      }\r\n\r\n      material = cachedMaterial;\r\n    } // workarounds for mesh and geometry\r\n\r\n\r\n    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\r\n      geometry.setAttribute('uv2', geometry.attributes.uv);\r\n    }\r\n\r\n    mesh.material = material;\r\n  }\r\n\r\n  getMaterialType() {\r\n    return MeshStandardMaterial;\r\n  }\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\r\n   * @param {number} materialIndex\r\n   * @return {Promise<Material>}\r\n   */\r\n\r\n\r\n  loadMaterial(materialIndex) {\r\n    const parser = this;\r\n    const json = this.json;\r\n    const extensions = this.extensions;\r\n    const materialDef = json.materials[materialIndex];\r\n    let materialType;\r\n    const materialParams = {};\r\n    const materialExtensions = materialDef.extensions || {};\r\n    const pending = [];\r\n\r\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\r\n      const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\r\n      materialType = sgExtension.getMaterialType();\r\n      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\r\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\r\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\r\n      materialType = kmuExtension.getMaterialType();\r\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\r\n    } else {\r\n      // Specification:\r\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\r\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\r\n      materialParams.color = new Color(1.0, 1.0, 1.0);\r\n      materialParams.opacity = 1.0;\r\n\r\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\r\n        const array = metallicRoughness.baseColorFactor;\r\n        materialParams.color.fromArray(array);\r\n        materialParams.opacity = array[3];\r\n      }\r\n\r\n      if (metallicRoughness.baseColorTexture !== undefined) {\r\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding));\r\n      }\r\n\r\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\r\n      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\r\n\r\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\r\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\r\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\r\n      }\r\n\r\n      materialType = this._invokeOne(function (ext) {\r\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\r\n      });\r\n      pending.push(Promise.all(this._invokeAll(function (ext) {\r\n        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\r\n      })));\r\n    }\r\n\r\n    if (materialDef.doubleSided === true) {\r\n      materialParams.side = DoubleSide;\r\n    }\r\n\r\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\r\n\r\n    if (alphaMode === ALPHA_MODES.BLEND) {\r\n      materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706\r\n\r\n      materialParams.depthWrite = false;\r\n    } else {\r\n      materialParams.transparent = false;\r\n\r\n      if (alphaMode === ALPHA_MODES.MASK) {\r\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\r\n      }\r\n    }\r\n\r\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\r\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));\r\n      materialParams.normalScale = new Vector2(1, 1);\r\n\r\n      if (materialDef.normalTexture.scale !== undefined) {\r\n        const scale = materialDef.normalTexture.scale;\r\n        materialParams.normalScale.set(scale, scale);\r\n      }\r\n    }\r\n\r\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\r\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\r\n\r\n      if (materialDef.occlusionTexture.strength !== undefined) {\r\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\r\n      }\r\n    }\r\n\r\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\r\n      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);\r\n    }\r\n\r\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\r\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture, sRGBEncoding));\r\n    }\r\n\r\n    return Promise.all(pending).then(function () {\r\n      let material;\r\n\r\n      if (materialType === GLTFMeshStandardSGMaterial) {\r\n        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\r\n      } else {\r\n        material = new materialType(materialParams);\r\n      }\r\n\r\n      if (materialDef.name) material.name = materialDef.name;\r\n      assignExtrasToUserData(material, materialDef);\r\n      parser.associations.set(material, {\r\n        materials: materialIndex\r\n      });\r\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\r\n      return material;\r\n    });\r\n  }\r\n  /** When Object3D instances are targeted by animation, they need unique names. */\r\n\r\n\r\n  createUniqueName(originalName) {\r\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '');\r\n    let name = sanitizedName;\r\n\r\n    for (let i = 1; this.nodeNamesUsed[name]; ++i) {\r\n      name = sanitizedName + '_' + i;\r\n    }\r\n\r\n    this.nodeNamesUsed[name] = true;\r\n    return name;\r\n  }\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\r\n   *\r\n   * Creates BufferGeometries from primitives.\r\n   *\r\n   * @param {Array<GLTF.Primitive>} primitives\r\n   * @return {Promise<Array<BufferGeometry>>}\r\n   */\r\n\r\n\r\n  loadGeometries(primitives) {\r\n    const parser = this;\r\n    const extensions = this.extensions;\r\n    const cache = this.primitiveCache;\r\n\r\n    function createDracoPrimitive(primitive) {\r\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\r\n        return addPrimitiveAttributes(geometry, primitive, parser);\r\n      });\r\n    }\r\n\r\n    const pending = [];\r\n\r\n    for (let i = 0, il = primitives.length; i < il; i++) {\r\n      const primitive = primitives[i];\r\n      const cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\r\n\r\n      const cached = cache[cacheKey];\r\n\r\n      if (cached) {\r\n        // Use the cached geometry if it exists\r\n        pending.push(cached.promise);\r\n      } else {\r\n        let geometryPromise;\r\n\r\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\r\n          // Use DRACO geometry if available\r\n          geometryPromise = createDracoPrimitive(primitive);\r\n        } else {\r\n          // Otherwise create a new geometry\r\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);\r\n        } // Cache this geometry\r\n\r\n\r\n        cache[cacheKey] = {\r\n          primitive: primitive,\r\n          promise: geometryPromise\r\n        };\r\n        pending.push(geometryPromise);\r\n      }\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  }\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\r\n   * @param {number} meshIndex\r\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\r\n   */\r\n\r\n\r\n  loadMesh(meshIndex) {\r\n    const parser = this;\r\n    const json = this.json;\r\n    const extensions = this.extensions;\r\n    const meshDef = json.meshes[meshIndex];\r\n    const primitives = meshDef.primitives;\r\n    const pending = [];\r\n\r\n    for (let i = 0, il = primitives.length; i < il; i++) {\r\n      const material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);\r\n      pending.push(material);\r\n    }\r\n\r\n    pending.push(parser.loadGeometries(primitives));\r\n    return Promise.all(pending).then(function (results) {\r\n      const materials = results.slice(0, results.length - 1);\r\n      const geometries = results[results.length - 1];\r\n      const meshes = [];\r\n\r\n      for (let i = 0, il = geometries.length; i < il; i++) {\r\n        const geometry = geometries[i];\r\n        const primitive = primitives[i]; // 1. create Mesh\r\n\r\n        let mesh;\r\n        const material = materials[i];\r\n\r\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\r\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\r\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);\r\n\r\n          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\r\n            // we normalize floating point skin weight array to fix malformed assets (see #15319)\r\n            // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\r\n            mesh.normalizeSkinWeights();\r\n          }\r\n\r\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\r\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);\r\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\r\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);\r\n          }\r\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\r\n          mesh = new LineSegments(geometry, material);\r\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\r\n          mesh = new Line(geometry, material);\r\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\r\n          mesh = new LineLoop(geometry, material);\r\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\r\n          mesh = new Points(geometry, material);\r\n        } else {\r\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\r\n        }\r\n\r\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\r\n          updateMorphTargets(mesh, meshDef);\r\n        }\r\n\r\n        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex);\r\n        assignExtrasToUserData(mesh, meshDef);\r\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\r\n        parser.assignFinalMaterial(mesh);\r\n        meshes.push(mesh);\r\n      }\r\n\r\n      for (let i = 0, il = meshes.length; i < il; i++) {\r\n        parser.associations.set(meshes[i], {\r\n          meshes: meshIndex,\r\n          primitives: i\r\n        });\r\n      }\r\n\r\n      if (meshes.length === 1) {\r\n        return meshes[0];\r\n      }\r\n\r\n      const group = new Group();\r\n      parser.associations.set(group, {\r\n        meshes: meshIndex\r\n      });\r\n\r\n      for (let i = 0, il = meshes.length; i < il; i++) {\r\n        group.add(meshes[i]);\r\n      }\r\n\r\n      return group;\r\n    });\r\n  }\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\r\n   * @param {number} cameraIndex\r\n   * @return {Promise<THREE.Camera>}\r\n   */\r\n\r\n\r\n  loadCamera(cameraIndex) {\r\n    let camera;\r\n    const cameraDef = this.json.cameras[cameraIndex];\r\n    const params = cameraDef[cameraDef.type];\r\n\r\n    if (!params) {\r\n      console.warn('THREE.GLTFLoader: Missing camera parameters.');\r\n      return;\r\n    }\r\n\r\n    if (cameraDef.type === 'perspective') {\r\n      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\r\n    } else if (cameraDef.type === 'orthographic') {\r\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\r\n    }\r\n\r\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\r\n    assignExtrasToUserData(camera, cameraDef);\r\n    return Promise.resolve(camera);\r\n  }\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\r\n   * @param {number} skinIndex\r\n   * @return {Promise<Object>}\r\n   */\r\n\r\n\r\n  loadSkin(skinIndex) {\r\n    const skinDef = this.json.skins[skinIndex];\r\n    const skinEntry = {\r\n      joints: skinDef.joints\r\n    };\r\n\r\n    if (skinDef.inverseBindMatrices === undefined) {\r\n      return Promise.resolve(skinEntry);\r\n    }\r\n\r\n    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\r\n      skinEntry.inverseBindMatrices = accessor;\r\n      return skinEntry;\r\n    });\r\n  }\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n   * @param {number} animationIndex\r\n   * @return {Promise<AnimationClip>}\r\n   */\r\n\r\n\r\n  loadAnimation(animationIndex) {\r\n    const json = this.json;\r\n    const animationDef = json.animations[animationIndex];\r\n    const pendingNodes = [];\r\n    const pendingInputAccessors = [];\r\n    const pendingOutputAccessors = [];\r\n    const pendingSamplers = [];\r\n    const pendingTargets = [];\r\n\r\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\r\n      const channel = animationDef.channels[i];\r\n      const sampler = animationDef.samplers[channel.sampler];\r\n      const target = channel.target;\r\n      const name = target.node;\r\n      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\r\n      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\r\n      pendingNodes.push(this.getDependency('node', name));\r\n      pendingInputAccessors.push(this.getDependency('accessor', input));\r\n      pendingOutputAccessors.push(this.getDependency('accessor', output));\r\n      pendingSamplers.push(sampler);\r\n      pendingTargets.push(target);\r\n    }\r\n\r\n    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\r\n      const nodes = dependencies[0];\r\n      const inputAccessors = dependencies[1];\r\n      const outputAccessors = dependencies[2];\r\n      const samplers = dependencies[3];\r\n      const targets = dependencies[4];\r\n      const tracks = [];\r\n\r\n      for (let i = 0, il = nodes.length; i < il; i++) {\r\n        const node = nodes[i];\r\n        const inputAccessor = inputAccessors[i];\r\n        const outputAccessor = outputAccessors[i];\r\n        const sampler = samplers[i];\r\n        const target = targets[i];\r\n        if (node === undefined) continue;\r\n        node.updateMatrix();\r\n        let TypedKeyframeTrack;\r\n\r\n        switch (PATH_PROPERTIES[target.path]) {\r\n          case PATH_PROPERTIES.weights:\r\n            TypedKeyframeTrack = NumberKeyframeTrack;\r\n            break;\r\n\r\n          case PATH_PROPERTIES.rotation:\r\n            TypedKeyframeTrack = QuaternionKeyframeTrack;\r\n            break;\r\n\r\n          case PATH_PROPERTIES.position:\r\n          case PATH_PROPERTIES.scale:\r\n          default:\r\n            TypedKeyframeTrack = VectorKeyframeTrack;\r\n            break;\r\n        }\r\n\r\n        const targetName = node.name ? node.name : node.uuid;\r\n        const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;\r\n        const targetNames = [];\r\n\r\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\r\n          node.traverse(function (object) {\r\n            if (object.morphTargetInfluences) {\r\n              targetNames.push(object.name ? object.name : object.uuid);\r\n            }\r\n          });\r\n        } else {\r\n          targetNames.push(targetName);\r\n        }\r\n\r\n        let outputArray = outputAccessor.array;\r\n\r\n        if (outputAccessor.normalized) {\r\n          const scale = getNormalizedComponentScale(outputArray.constructor);\r\n          const scaled = new Float32Array(outputArray.length);\r\n\r\n          for (let j = 0, jl = outputArray.length; j < jl; j++) {\r\n            scaled[j] = outputArray[j] * scale;\r\n          }\r\n\r\n          outputArray = scaled;\r\n        }\r\n\r\n        for (let j = 0, jl = targetNames.length; j < jl; j++) {\r\n          const track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.\r\n\r\n          if (sampler.interpolation === 'CUBICSPLINE') {\r\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\r\n              // A CUBICSPLINE keyframe in glTF has three output values for each input value,\r\n              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\r\n              // must be divided by three to get the interpolant's sampleSize argument.\r\n              const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\r\n              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\r\n            }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\r\n\r\n\r\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\r\n          }\r\n\r\n          tracks.push(track);\r\n        }\r\n      }\r\n\r\n      const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\r\n      return new AnimationClip(name, undefined, tracks);\r\n    });\r\n  }\r\n\r\n  createNodeMesh(nodeIndex) {\r\n    const json = this.json;\r\n    const parser = this;\r\n    const nodeDef = json.nodes[nodeIndex];\r\n    if (nodeDef.mesh === undefined) return null;\r\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\r\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh); // if weights are provided on the node, override weights on the mesh.\r\n\r\n\r\n      if (nodeDef.weights !== undefined) {\r\n        node.traverse(function (o) {\r\n          if (!o.isMesh) return;\r\n\r\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\r\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\r\n          }\r\n        });\r\n      }\r\n\r\n      return node;\r\n    });\r\n  }\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\r\n   * @param {number} nodeIndex\r\n   * @return {Promise<Object3D>}\r\n   */\r\n\r\n\r\n  loadNode(nodeIndex) {\r\n    const json = this.json;\r\n    const extensions = this.extensions;\r\n    const parser = this;\r\n    const nodeDef = json.nodes[nodeIndex]; // reserve node's name before its dependencies, so the root has the intended name.\r\n\r\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';\r\n    return function () {\r\n      const pending = [];\r\n\r\n      const meshPromise = parser._invokeOne(function (ext) {\r\n        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\r\n      });\r\n\r\n      if (meshPromise) {\r\n        pending.push(meshPromise);\r\n      }\r\n\r\n      if (nodeDef.camera !== undefined) {\r\n        pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {\r\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\r\n        }));\r\n      }\r\n\r\n      parser._invokeAll(function (ext) {\r\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\r\n      }).forEach(function (promise) {\r\n        pending.push(promise);\r\n      });\r\n\r\n      return Promise.all(pending);\r\n    }().then(function (objects) {\r\n      let node; // .isBone isn't in glTF spec. See ._markDefs\r\n\r\n      if (nodeDef.isBone === true) {\r\n        node = new Bone();\r\n      } else if (objects.length > 1) {\r\n        node = new Group();\r\n      } else if (objects.length === 1) {\r\n        node = objects[0];\r\n      } else {\r\n        node = new Object3D();\r\n      }\r\n\r\n      if (node !== objects[0]) {\r\n        for (let i = 0, il = objects.length; i < il; i++) {\r\n          node.add(objects[i]);\r\n        }\r\n      }\r\n\r\n      if (nodeDef.name) {\r\n        node.userData.name = nodeDef.name;\r\n        node.name = nodeName;\r\n      }\r\n\r\n      assignExtrasToUserData(node, nodeDef);\r\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\r\n\r\n      if (nodeDef.matrix !== undefined) {\r\n        const matrix = new Matrix4();\r\n        matrix.fromArray(nodeDef.matrix);\r\n        node.applyMatrix4(matrix);\r\n      } else {\r\n        if (nodeDef.translation !== undefined) {\r\n          node.position.fromArray(nodeDef.translation);\r\n        }\r\n\r\n        if (nodeDef.rotation !== undefined) {\r\n          node.quaternion.fromArray(nodeDef.rotation);\r\n        }\r\n\r\n        if (nodeDef.scale !== undefined) {\r\n          node.scale.fromArray(nodeDef.scale);\r\n        }\r\n      }\r\n\r\n      if (!parser.associations.has(node)) {\r\n        parser.associations.set(node, {});\r\n      }\r\n\r\n      parser.associations.get(node).nodes = nodeIndex;\r\n      return node;\r\n    });\r\n  }\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\r\n   * @param {number} sceneIndex\r\n   * @return {Promise<Group>}\r\n   */\r\n\r\n\r\n  loadScene(sceneIndex) {\r\n    const json = this.json;\r\n    const extensions = this.extensions;\r\n    const sceneDef = this.json.scenes[sceneIndex];\r\n    const parser = this; // Loader returns Group, not Scene.\r\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\r\n\r\n    const scene = new Group();\r\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\r\n    assignExtrasToUserData(scene, sceneDef);\r\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\r\n    const nodeIds = sceneDef.nodes || [];\r\n    const pending = [];\r\n\r\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\r\n      pending.push(buildNodeHierarchy(nodeIds[i], scene, json, parser));\r\n    }\r\n\r\n    return Promise.all(pending).then(function () {\r\n      // Removes dangling associations, associations that reference a node that\r\n      // didn't make it into the scene.\r\n      const reduceAssociations = node => {\r\n        const reducedAssociations = new Map();\r\n\r\n        for (const [key, value] of parser.associations) {\r\n          if (key instanceof Material || key instanceof Texture) {\r\n            reducedAssociations.set(key, value);\r\n          }\r\n        }\r\n\r\n        node.traverse(node => {\r\n          const mappings = parser.associations.get(node);\r\n\r\n          if (mappings != null) {\r\n            reducedAssociations.set(node, mappings);\r\n          }\r\n        });\r\n        return reducedAssociations;\r\n      };\r\n\r\n      parser.associations = reduceAssociations(scene);\r\n      return scene;\r\n    });\r\n  }\r\n\r\n}\r\n\r\nfunction buildNodeHierarchy(nodeId, parentObject, json, parser) {\r\n  const nodeDef = json.nodes[nodeId];\r\n  return parser.getDependency('node', nodeId).then(function (node) {\r\n    if (nodeDef.skin === undefined) return node; // build skeleton here as well\r\n\r\n    let skinEntry;\r\n    return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\r\n      skinEntry = skin;\r\n      const pendingJoints = [];\r\n\r\n      for (let i = 0, il = skinEntry.joints.length; i < il; i++) {\r\n        pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\r\n      }\r\n\r\n      return Promise.all(pendingJoints);\r\n    }).then(function (jointNodes) {\r\n      node.traverse(function (mesh) {\r\n        if (!mesh.isMesh) return;\r\n        const bones = [];\r\n        const boneInverses = [];\r\n\r\n        for (let j = 0, jl = jointNodes.length; j < jl; j++) {\r\n          const jointNode = jointNodes[j];\r\n\r\n          if (jointNode) {\r\n            bones.push(jointNode);\r\n            const mat = new Matrix4();\r\n\r\n            if (skinEntry.inverseBindMatrices !== undefined) {\r\n              mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\r\n            }\r\n\r\n            boneInverses.push(mat);\r\n          } else {\r\n            console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\r\n          }\r\n        }\r\n\r\n        mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);\r\n      });\r\n      return node;\r\n    });\r\n  }).then(function (node) {\r\n    // build node hierachy\r\n    parentObject.add(node);\r\n    const pending = [];\r\n\r\n    if (nodeDef.children) {\r\n      const children = nodeDef.children;\r\n\r\n      for (let i = 0, il = children.length; i < il; i++) {\r\n        const child = children[i];\r\n        pending.push(buildNodeHierarchy(child, node, json, parser));\r\n      }\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  });\r\n}\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {GLTF.Primitive} primitiveDef\r\n * @param {GLTFParser} parser\r\n */\r\n\r\n\r\nfunction computeBounds(geometry, primitiveDef, parser) {\r\n  const attributes = primitiveDef.attributes;\r\n  const box = new Box3();\r\n\r\n  if (attributes.POSITION !== undefined) {\r\n    const accessor = parser.json.accessors[attributes.POSITION];\r\n    const min = accessor.min;\r\n    const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n    if (min !== undefined && max !== undefined) {\r\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));\r\n\r\n      if (accessor.normalized) {\r\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\r\n        box.min.multiplyScalar(boxScale);\r\n        box.max.multiplyScalar(boxScale);\r\n      }\r\n    } else {\r\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\r\n      return;\r\n    }\r\n  } else {\r\n    return;\r\n  }\r\n\r\n  const targets = primitiveDef.targets;\r\n\r\n  if (targets !== undefined) {\r\n    const maxDisplacement = new Vector3();\r\n    const vector = new Vector3();\r\n\r\n    for (let i = 0, il = targets.length; i < il; i++) {\r\n      const target = targets[i];\r\n\r\n      if (target.POSITION !== undefined) {\r\n        const accessor = parser.json.accessors[target.POSITION];\r\n        const min = accessor.min;\r\n        const max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n        if (min !== undefined && max !== undefined) {\r\n          // we need to get max of absolute components because target weight is [-1,1]\r\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\r\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\r\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\r\n\r\n          if (accessor.normalized) {\r\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\r\n            vector.multiplyScalar(boxScale);\r\n          } // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\r\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\r\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\r\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\r\n\r\n\r\n          maxDisplacement.max(vector);\r\n        } else {\r\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\r\n        }\r\n      }\r\n    } // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\r\n\r\n\r\n    box.expandByVector(maxDisplacement);\r\n  }\r\n\r\n  geometry.boundingBox = box;\r\n  const sphere = new Sphere();\r\n  box.getCenter(sphere.center);\r\n  sphere.radius = box.min.distanceTo(box.max) / 2;\r\n  geometry.boundingSphere = sphere;\r\n}\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {GLTF.Primitive} primitiveDef\r\n * @param {GLTFParser} parser\r\n * @return {Promise<BufferGeometry>}\r\n */\r\n\r\n\r\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\r\n  const attributes = primitiveDef.attributes;\r\n  const pending = [];\r\n\r\n  function assignAttributeAccessor(accessorIndex, attributeName) {\r\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\r\n      geometry.setAttribute(attributeName, accessor);\r\n    });\r\n  }\r\n\r\n  for (const gltfAttributeName in attributes) {\r\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\r\n\r\n    if (threeAttributeName in geometry.attributes) continue;\r\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\r\n  }\r\n\r\n  if (primitiveDef.indices !== undefined && !geometry.index) {\r\n    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\r\n      geometry.setIndex(accessor);\r\n    });\r\n    pending.push(accessor);\r\n  }\r\n\r\n  assignExtrasToUserData(geometry, primitiveDef);\r\n  computeBounds(geometry, primitiveDef, parser);\r\n  return Promise.all(pending).then(function () {\r\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\r\n  });\r\n}\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {Number} drawMode\r\n * @return {BufferGeometry}\r\n */\r\n\r\n\r\nfunction toTrianglesDrawMode(geometry, drawMode) {\r\n  let index = geometry.getIndex(); // generate index if not present\r\n\r\n  if (index === null) {\r\n    const indices = [];\r\n    const position = geometry.getAttribute('position');\r\n\r\n    if (position !== undefined) {\r\n      for (let i = 0; i < position.count; i++) {\r\n        indices.push(i);\r\n      }\r\n\r\n      geometry.setIndex(indices);\r\n      index = geometry.getIndex();\r\n    } else {\r\n      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\r\n      return geometry;\r\n    }\r\n  } //\r\n\r\n\r\n  const numberOfTriangles = index.count - 2;\r\n  const newIndices = [];\r\n\r\n  if (drawMode === TriangleFanDrawMode) {\r\n    // gl.TRIANGLE_FAN\r\n    for (let i = 1; i <= numberOfTriangles; i++) {\r\n      newIndices.push(index.getX(0));\r\n      newIndices.push(index.getX(i));\r\n      newIndices.push(index.getX(i + 1));\r\n    }\r\n  } else {\r\n    // gl.TRIANGLE_STRIP\r\n    for (let i = 0; i < numberOfTriangles; i++) {\r\n      if (i % 2 === 0) {\r\n        newIndices.push(index.getX(i));\r\n        newIndices.push(index.getX(i + 1));\r\n        newIndices.push(index.getX(i + 2));\r\n      } else {\r\n        newIndices.push(index.getX(i + 2));\r\n        newIndices.push(index.getX(i + 1));\r\n        newIndices.push(index.getX(i));\r\n      }\r\n    }\r\n  }\r\n\r\n  if (newIndices.length / 3 !== numberOfTriangles) {\r\n    console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\r\n  } // build final geometry\r\n\r\n\r\n  const newGeometry = geometry.clone();\r\n  newGeometry.setIndex(newIndices);\r\n  return newGeometry;\r\n}\r\n\r\nexport { GLTFLoader };\r\n", "import * as THREE from 'three';\r\n\r\nconst PINCH_MAX = 0.05;\r\nconst PINCH_THRESHOLD = 0.02;\r\nconst PINCH_MIN = 0.01;\r\nconst POINTER_ADVANCE_MAX = 0.02;\r\nconst POINTER_OPACITY_MAX = 1;\r\nconst POINTER_OPACITY_MIN = 0.4;\r\nconst POINTER_FRONT_RADIUS = 0.002;\r\nconst POINTER_REAR_RADIUS = 0.01;\r\nconst POINTER_REAR_RADIUS_MIN = 0.003;\r\nconst POINTER_LENGTH = 0.035;\r\nconst POINTER_SEGMENTS = 16;\r\nconst POINTER_RINGS = 12;\r\nconst POINTER_HEMISPHERE_ANGLE = 110;\r\nconst YAXIS = new THREE.Vector3(0, 1, 0);\r\nconst ZAXIS = new THREE.Vector3(0, 0, 1);\r\nconst CURSOR_RADIUS = 0.02;\r\nconst CURSOR_MAX_DISTANCE = 1.5;\r\n\r\nclass OculusHandPointerModel extends THREE.Object3D {\r\n  constructor(hand, controller) {\r\n    super();\r\n    this.hand = hand;\r\n    this.controller = controller;\r\n    this.motionController = null;\r\n    this.envMap = null;\r\n    this.mesh = null;\r\n    this.pointerGeometry = null;\r\n    this.pointerMesh = null;\r\n    this.pointerObject = null;\r\n    this.pinched = false;\r\n    this.attached = false;\r\n    this.cursorObject = null;\r\n    this.raycaster = null;\r\n    hand.addEventListener('connected', event => {\r\n      const xrInputSource = event.data;\r\n\r\n      if (xrInputSource.hand) {\r\n        this.visible = true;\r\n        this.xrInputSource = xrInputSource;\r\n        this.createPointer();\r\n      }\r\n    });\r\n  }\r\n\r\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\r\n    const segmentVector = baseVector.clone();\r\n\r\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\r\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\r\n      const vid = ringIndex * POINTER_SEGMENTS + i;\r\n      vertices[3 * vid] = segmentVector.x;\r\n      vertices[3 * vid + 1] = segmentVector.y;\r\n      vertices[3 * vid + 2] = segmentVector.z;\r\n    }\r\n  }\r\n\r\n  _updatePointerVertices(rearRadius) {\r\n    const vertices = this.pointerGeometry.attributes.position.array; // first ring for front face\r\n\r\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\r\n\r\n    this._drawVerticesRing(vertices, frontFaceBase, 0); // rings for rear hemisphere\r\n\r\n\r\n    const rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\r\n\r\n    for (var i = 0; i < POINTER_RINGS; i++) {\r\n      this._drawVerticesRing(vertices, rearBase, i + 1);\r\n\r\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\r\n    } // front and rear face center vertices\r\n\r\n\r\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\r\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\r\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\r\n    vertices[frontCenterIndex * 3] = frontCenter.x;\r\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\r\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\r\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\r\n    vertices[rearCenterIndex * 3] = rearCenter.x;\r\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\r\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\r\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); // verticesNeedUpdate = true;\r\n  }\r\n\r\n  createPointer() {\r\n    var i, j;\r\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0); // const vertices = [];\r\n\r\n    const indices = [];\r\n    this.pointerGeometry = new THREE.BufferGeometry();\r\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\r\n\r\n    this._updatePointerVertices(POINTER_REAR_RADIUS); // construct faces to connect rings\r\n\r\n\r\n    for (i = 0; i < POINTER_RINGS; i++) {\r\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\r\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\r\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\r\n      }\r\n\r\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\r\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\r\n    } // construct front and rear face\r\n\r\n\r\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\r\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\r\n\r\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\r\n      indices.push(frontCenterIndex, i + 1, i);\r\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\r\n    }\r\n\r\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\r\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\r\n    const material = new THREE.MeshBasicMaterial();\r\n    material.transparent = true;\r\n    material.opacity = POINTER_OPACITY_MIN;\r\n    this.pointerGeometry.setIndex(indices);\r\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\r\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\r\n    this.pointerObject = new THREE.Object3D();\r\n    this.pointerObject.add(this.pointerMesh);\r\n    this.raycaster = new THREE.Raycaster(); // create cursor\r\n\r\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\r\n    const cursorMaterial = new THREE.MeshBasicMaterial();\r\n    cursorMaterial.transparent = true;\r\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\r\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\r\n    this.pointerObject.add(this.cursorObject);\r\n    this.add(this.pointerObject);\r\n  }\r\n\r\n  _updateRaycaster() {\r\n    if (this.raycaster) {\r\n      const pointerMatrix = this.pointerObject.matrixWorld;\r\n      const tempMatrix = new THREE.Matrix4();\r\n      tempMatrix.identity().extractRotation(pointerMatrix);\r\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\r\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\r\n    }\r\n  }\r\n\r\n  _updatePointer() {\r\n    this.pointerObject.visible = this.controller.visible;\r\n    const indexTip = this.hand.joints['index-finger-tip'];\r\n    const thumbTip = this.hand.joints['thumb-tip'];\r\n    const distance = indexTip.position.distanceTo(thumbTip.position);\r\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\r\n    this.pointerObject.position.copy(position);\r\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\r\n    this.pinched = distance <= PINCH_THRESHOLD;\r\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\r\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\r\n\r\n    if (pinchScale > 1) {\r\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\r\n\r\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\r\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\r\n    } else if (pinchScale > 0) {\r\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\r\n\r\n      this._updatePointerVertices(rearRadius);\r\n\r\n      if (focusScale < 1) {\r\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\r\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\r\n      } else {\r\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\r\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\r\n      }\r\n    } else {\r\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\r\n\r\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\r\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\r\n    }\r\n\r\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\r\n  }\r\n\r\n  updateMatrixWorld(force) {\r\n    super.updateMatrixWorld(force);\r\n\r\n    if (this.pointerGeometry) {\r\n      this._updatePointer();\r\n\r\n      this._updateRaycaster();\r\n    }\r\n  }\r\n\r\n  isPinched() {\r\n    return this.pinched;\r\n  }\r\n\r\n  setAttached(attached) {\r\n    this.attached = attached;\r\n  }\r\n\r\n  isAttached() {\r\n    return this.attached;\r\n  }\r\n\r\n  intersectObject(object, recursive = true) {\r\n    if (this.raycaster) {\r\n      return this.raycaster.intersectObject(object, recursive);\r\n    }\r\n  }\r\n\r\n  intersectObjects(objects, recursive = true) {\r\n    if (this.raycaster) {\r\n      return this.raycaster.intersectObjects(objects, recursive);\r\n    }\r\n  }\r\n\r\n  checkIntersections(objects, recursive = false) {\r\n    if (this.raycaster && !this.attached) {\r\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\r\n      const direction = new THREE.Vector3(0, 0, -1);\r\n\r\n      if (intersections.length > 0) {\r\n        const intersection = intersections[0];\r\n        const distance = intersection.distance;\r\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\r\n      } else {\r\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\r\n      }\r\n    }\r\n  }\r\n\r\n  setCursor(distance) {\r\n    const direction = new THREE.Vector3(0, 0, -1);\r\n\r\n    if (this.raycaster && !this.attached) {\r\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport { OculusHandPointerModel };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\n\r\nclass VRButton {\r\n  static createButton(renderer, sessionInit = {}) {\r\n    const button = document.createElement('button');\r\n\r\n    function\r\n      /*device*/\r\n    showEnterVR() {\r\n      let currentSession = null;\r\n\r\n      async function onSessionStarted(session) {\r\n        session.addEventListener('end', onSessionEnded);\r\n        await renderer.xr.setSession(session);\r\n        button.textContent = 'EXIT VR';\r\n        currentSession = session;\r\n      }\r\n\r\n      function\r\n        /*event*/\r\n      onSessionEnded() {\r\n        currentSession.removeEventListener('end', onSessionEnded);\r\n        button.textContent = 'ENTER VR';\r\n        currentSession = null;\r\n      } //\r\n\r\n\r\n      button.style.display = '';\r\n      button.style.cursor = 'pointer';\r\n      button.style.left = 'calc(50% - 50px)';\r\n      button.style.width = '100px';\r\n      button.textContent = 'ENTER VR';\r\n\r\n      button.onmouseenter = () => {\r\n        button.style.opacity = '1.0';\r\n      };\r\n\r\n      button.onmouseleave = () => {\r\n        button.style.opacity = '0.5';\r\n      };\r\n\r\n      button.onclick = () => {\r\n        if (currentSession === null) {\r\n          var _xr;\r\n\r\n          // WebXR's requestReferenceSpace only works if the corresponding feature\r\n          // was requested at session creation time. For simplicity, just ask for\r\n          // the interesting ones as optional features, but be aware that the\r\n          // requestReferenceSpace call will fail if it turns out to be unavailable.\r\n          // ('local' is always available for immersive sessions and doesn't need to\r\n          // be requested separately.)\r\n          const optionalFeatures = [sessionInit.optionalFeatures, 'local-floor', 'bounded-floor', 'hand-tracking'].flat().filter(Boolean);\r\n          (_xr = navigator.xr) === null || _xr === void 0 ? void 0 : _xr.requestSession('immersive-vr', { ...sessionInit,\r\n            optionalFeatures\r\n          }).then(onSessionStarted);\r\n        } else {\r\n          currentSession.end();\r\n        }\r\n      };\r\n    }\r\n\r\n    function disableButton() {\r\n      button.style.display = '';\r\n      button.style.cursor = 'auto';\r\n      button.style.left = 'calc(50% - 75px)';\r\n      button.style.width = '150px';\r\n      button.onmouseenter = null;\r\n      button.onmouseleave = null;\r\n      button.onclick = null;\r\n    }\r\n\r\n    function showWebXRNotFound() {\r\n      disableButton();\r\n      button.textContent = 'VR NOT SUPPORTED';\r\n    }\r\n\r\n    function stylizeElement(element) {\r\n      element.style.position = 'absolute';\r\n      element.style.bottom = '20px';\r\n      element.style.padding = '12px 6px';\r\n      element.style.border = '1px solid #fff';\r\n      element.style.borderRadius = '4px';\r\n      element.style.background = 'rgba(0,0,0,0.1)';\r\n      element.style.color = '#fff';\r\n      element.style.font = 'normal 13px sans-serif';\r\n      element.style.textAlign = 'center';\r\n      element.style.opacity = '0.5';\r\n      element.style.outline = 'none';\r\n      element.style.zIndex = '999';\r\n    }\r\n\r\n    if ('xr' in navigator) {\r\n      stylizeElement(button);\r\n      button.id = 'VRButton';\r\n      button.style.display = 'none' // Query for session mode\r\n      ;\r\n      navigator.xr.isSessionSupported('immersive-vr').then(supported => {\r\n        supported ? showEnterVR() : showWebXRNotFound();\r\n\r\n        if (supported && VRButton.xrSessionIsGranted) {\r\n          button.click();\r\n        }\r\n      });\r\n      return button;\r\n    } else {\r\n      const message = document.createElement('a');\r\n\r\n      if (window.isSecureContext === false) {\r\n        message.href = document.location.href.replace(/^http:/, 'https:');\r\n        message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message\r\n      } else {\r\n        message.href = 'https://immersiveweb.dev/';\r\n        message.innerHTML = 'WEBXR NOT AVAILABLE';\r\n      }\r\n\r\n      message.style.left = 'calc(50% - 90px)';\r\n      message.style.width = '180px';\r\n      message.style.textDecoration = 'none';\r\n      stylizeElement(message);\r\n      return message;\r\n    }\r\n  }\r\n\r\n  static registerSessionGrantedListener() {\r\n    if ('xr' in navigator) {\r\n      navigator.xr.addEventListener('sessiongranted', () => {\r\n        VRButton.xrSessionIsGranted = true;\r\n      });\r\n    }\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(VRButton, \"xrSessionIsGranted\", false);\r\n\r\nexport { VRButton };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\n\r\n/**\r\n * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles\r\n */\r\nconst MotionControllerConstants = {\r\n  Handedness: Object.freeze({\r\n    NONE: 'none',\r\n    LEFT: 'left',\r\n    RIGHT: 'right'\r\n  }),\r\n  ComponentState: Object.freeze({\r\n    DEFAULT: 'default',\r\n    TOUCHED: 'touched',\r\n    PRESSED: 'pressed'\r\n  }),\r\n  ComponentProperty: Object.freeze({\r\n    BUTTON: 'button',\r\n    X_AXIS: 'xAxis',\r\n    Y_AXIS: 'yAxis',\r\n    STATE: 'state'\r\n  }),\r\n  ComponentType: Object.freeze({\r\n    TRIGGER: 'trigger',\r\n    SQUEEZE: 'squeeze',\r\n    TOUCHPAD: 'touchpad',\r\n    THUMBSTICK: 'thumbstick',\r\n    BUTTON: 'button'\r\n  }),\r\n  ButtonTouchThreshold: 0.05,\r\n  AxisTouchThreshold: 0.1,\r\n  VisualResponseProperty: Object.freeze({\r\n    TRANSFORM: 'transform',\r\n    VISIBILITY: 'visibility'\r\n  })\r\n};\r\n/**\r\n * @description Static helper function to fetch a JSON file and turn it into a JS object\r\n * @param {string} path - Path to JSON file to be fetched\r\n */\r\n\r\nasync function fetchJsonFile(path) {\r\n  const response = await fetch(path);\r\n\r\n  if (!response.ok) {\r\n    throw new Error(response.statusText);\r\n  } else {\r\n    return response.json();\r\n  }\r\n}\r\n\r\nasync function fetchProfilesList(basePath) {\r\n  if (!basePath) {\r\n    throw new Error('No basePath supplied');\r\n  }\r\n\r\n  const profileListFileName = 'profilesList.json';\r\n  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);\r\n  return profilesList;\r\n}\r\n\r\nasync function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {\r\n  if (!xrInputSource) {\r\n    throw new Error('No xrInputSource supplied');\r\n  }\r\n\r\n  if (!basePath) {\r\n    throw new Error('No basePath supplied');\r\n  } // Get the list of profiles\r\n\r\n\r\n  const supportedProfilesList = await fetchProfilesList(basePath); // Find the relative path to the first requested profile that is recognized\r\n\r\n  let match = undefined;\r\n  xrInputSource.profiles.some(profileId => {\r\n    const supportedProfile = supportedProfilesList[profileId];\r\n\r\n    if (supportedProfile) {\r\n      match = {\r\n        profileId,\r\n        profilePath: `${basePath}/${supportedProfile.path}`,\r\n        deprecated: !!supportedProfile.deprecated\r\n      };\r\n    }\r\n\r\n    return !!match;\r\n  });\r\n\r\n  if (!match) {\r\n    if (!defaultProfile) {\r\n      throw new Error('No matching profile name found');\r\n    }\r\n\r\n    const supportedProfile = supportedProfilesList[defaultProfile];\r\n\r\n    if (!supportedProfile) {\r\n      throw new Error(`No matching profile name found and default profile \"${defaultProfile}\" missing.`);\r\n    }\r\n\r\n    match = {\r\n      profileId: defaultProfile,\r\n      profilePath: `${basePath}/${supportedProfile.path}`,\r\n      deprecated: !!supportedProfile.deprecated\r\n    };\r\n  }\r\n\r\n  const profile = await fetchJsonFile(match.profilePath);\r\n  let assetPath = undefined;\r\n\r\n  if (getAssetPath) {\r\n    let layout;\r\n\r\n    if (xrInputSource.handedness === 'any') {\r\n      layout = profile.layouts[Object.keys(profile.layouts)[0]];\r\n    } else {\r\n      layout = profile.layouts[xrInputSource.handedness];\r\n    }\r\n\r\n    if (!layout) {\r\n      throw new Error(`No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`);\r\n    }\r\n\r\n    if (layout.assetPath) {\r\n      assetPath = match.profilePath.replace('profile.json', layout.assetPath);\r\n    }\r\n  }\r\n\r\n  return {\r\n    profile,\r\n    assetPath\r\n  };\r\n}\r\n/** @constant {Object} */\r\n\r\n\r\nconst defaultComponentValues = {\r\n  xAxis: 0,\r\n  yAxis: 0,\r\n  button: 0,\r\n  state: MotionControllerConstants.ComponentState.DEFAULT\r\n};\r\n/**\r\n * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad\r\n * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within\r\n * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical\r\n * range of motion and touchpads do not report touch locations off their physical bounds.\r\n * @param {number | undefined} x The original x coordinate in the range -1 to 1\r\n * @param {number | undefined} y The original y coordinate in the range -1 to 1\r\n */\r\n\r\nfunction normalizeAxes(x = 0, y = 0) {\r\n  let xAxis = x;\r\n  let yAxis = y; // Determine if the point is outside the bounds of the circle\r\n  // and, if so, place it on the edge of the circle\r\n\r\n  const hypotenuse = Math.sqrt(x * x + y * y);\r\n\r\n  if (hypotenuse > 1) {\r\n    const theta = Math.atan2(y, x);\r\n    xAxis = Math.cos(theta);\r\n    yAxis = Math.sin(theta);\r\n  } // Scale and move the circle so values are in the interpolation range.  The circle's origin moves\r\n  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.\r\n\r\n\r\n  const result = {\r\n    normalizedXAxis: xAxis * 0.5 + 0.5,\r\n    normalizedYAxis: yAxis * 0.5 + 0.5\r\n  };\r\n  return result;\r\n}\r\n/**\r\n * Contains the description of how the 3D model should visually respond to a specific user input.\r\n * This is accomplished by initializing the object with the name of a node in the 3D model and\r\n * property that need to be modified in response to user input, the name of the nodes representing\r\n * the allowable range of motion, and the name of the input which triggers the change. In response\r\n * to the named input changing, this object computes the appropriate weighting to use for\r\n * interpolating between the range of motion nodes.\r\n */\r\n\r\n\r\nclass VisualResponse {\r\n  constructor(visualResponseDescription) {\r\n    _defineProperty(this, \"value\", void 0);\r\n\r\n    _defineProperty(this, \"componentProperty\", void 0);\r\n\r\n    _defineProperty(this, \"states\", void 0);\r\n\r\n    _defineProperty(this, \"valueNodeName\", void 0);\r\n\r\n    _defineProperty(this, \"valueNodeProperty\", void 0);\r\n\r\n    _defineProperty(this, \"minNodeName\", void 0);\r\n\r\n    _defineProperty(this, \"maxNodeName\", void 0);\r\n\r\n    _defineProperty(this, \"valueNode\", void 0);\r\n\r\n    _defineProperty(this, \"minNode\", void 0);\r\n\r\n    _defineProperty(this, \"maxNode\", void 0);\r\n\r\n    this.componentProperty = visualResponseDescription.componentProperty;\r\n    this.states = visualResponseDescription.states;\r\n    this.valueNodeName = visualResponseDescription.valueNodeName;\r\n    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;\r\n\r\n    if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.TRANSFORM) {\r\n      this.minNodeName = visualResponseDescription.minNodeName;\r\n      this.maxNodeName = visualResponseDescription.maxNodeName;\r\n    } // Initializes the response's current value based on default data\r\n\r\n\r\n    this.value = 0;\r\n    this.updateFromComponent(defaultComponentValues);\r\n  }\r\n  /**\r\n   * Computes the visual response's interpolation weight based on component state\r\n   * @param {Object} componentValues - The component from which to update\r\n   * @param {number | undefined} xAxis - The reported X axis value of the component\r\n   * @param {number | undefined} yAxis - The reported Y axis value of the component\r\n   * @param {number | undefined} button - The reported value of the component's button\r\n   * @param {string} state - The component's active state\r\n   */\r\n\r\n\r\n  updateFromComponent({\r\n    xAxis,\r\n    yAxis,\r\n    button,\r\n    state\r\n  }) {\r\n    const {\r\n      normalizedXAxis,\r\n      normalizedYAxis\r\n    } = normalizeAxes(xAxis, yAxis);\r\n\r\n    switch (this.componentProperty) {\r\n      case MotionControllerConstants.ComponentProperty.X_AXIS:\r\n        this.value = this.states.includes(state) ? normalizedXAxis : 0.5;\r\n        break;\r\n\r\n      case MotionControllerConstants.ComponentProperty.Y_AXIS:\r\n        this.value = this.states.includes(state) ? normalizedYAxis : 0.5;\r\n        break;\r\n\r\n      case MotionControllerConstants.ComponentProperty.BUTTON:\r\n        this.value = this.states.includes(state) && button ? button : 0;\r\n        break;\r\n\r\n      case MotionControllerConstants.ComponentProperty.STATE:\r\n        if (this.valueNodeProperty === MotionControllerConstants.VisualResponseProperty.VISIBILITY) {\r\n          this.value = this.states.includes(state);\r\n        } else {\r\n          this.value = this.states.includes(state) ? 1.0 : 0.0;\r\n        }\r\n\r\n        break;\r\n\r\n      default:\r\n        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nclass Component {\r\n  /**\r\n   * @param {string} componentId - Id of the component\r\n   * @param {InputProfileComponent} componentDescription - Description of the component to be created\r\n   */\r\n  constructor(componentId, componentDescription) {\r\n    _defineProperty(this, \"id\", void 0);\r\n\r\n    _defineProperty(this, \"values\", void 0);\r\n\r\n    _defineProperty(this, \"type\", void 0);\r\n\r\n    _defineProperty(this, \"gamepadIndices\", void 0);\r\n\r\n    _defineProperty(this, \"rootNodeName\", void 0);\r\n\r\n    _defineProperty(this, \"visualResponses\", void 0);\r\n\r\n    _defineProperty(this, \"touchPointNodeName\", void 0);\r\n\r\n    _defineProperty(this, \"touchPointNode\", void 0);\r\n\r\n    if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {\r\n      throw new Error('Invalid arguments supplied');\r\n    }\r\n\r\n    this.id = componentId;\r\n    this.type = componentDescription.type;\r\n    this.rootNodeName = componentDescription.rootNodeName;\r\n    this.touchPointNodeName = componentDescription.touchPointNodeName; // Build all the visual responses for this component\r\n\r\n    this.visualResponses = {};\r\n    Object.keys(componentDescription.visualResponses).forEach(responseName => {\r\n      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);\r\n      this.visualResponses[responseName] = visualResponse;\r\n    }); // Set default values\r\n\r\n    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);\r\n    this.values = {\r\n      state: MotionControllerConstants.ComponentState.DEFAULT,\r\n      button: this.gamepadIndices.button !== undefined ? 0 : undefined,\r\n      xAxis: this.gamepadIndices.xAxis !== undefined ? 0 : undefined,\r\n      yAxis: this.gamepadIndices.yAxis !== undefined ? 0 : undefined\r\n    };\r\n  }\r\n\r\n  get data() {\r\n    const data = {\r\n      id: this.id,\r\n      ...this.values\r\n    };\r\n    return data;\r\n  }\r\n  /**\r\n   * @description Poll for updated data based on current gamepad state\r\n   * @param {Object} gamepad - The gamepad object from which the component data should be polled\r\n   */\r\n\r\n\r\n  updateFromGamepad(gamepad) {\r\n    // Set the state to default before processing other data sources\r\n    this.values.state = MotionControllerConstants.ComponentState.DEFAULT; // Get and normalize button\r\n\r\n    if (this.gamepadIndices.button !== undefined && gamepad.buttons.length > this.gamepadIndices.button) {\r\n      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];\r\n      this.values.button = gamepadButton.value;\r\n      this.values.button = this.values.button < 0 ? 0 : this.values.button;\r\n      this.values.button = this.values.button > 1 ? 1 : this.values.button; // Set the state based on the button\r\n\r\n      if (gamepadButton.pressed || this.values.button === 1) {\r\n        this.values.state = MotionControllerConstants.ComponentState.PRESSED;\r\n      } else if (gamepadButton.touched || this.values.button > MotionControllerConstants.ButtonTouchThreshold) {\r\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\r\n      }\r\n    } // Get and normalize x axis value\r\n\r\n\r\n    if (this.gamepadIndices.xAxis !== undefined && gamepad.axes.length > this.gamepadIndices.xAxis) {\r\n      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];\r\n      this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;\r\n      this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis; // If the state is still default, check if the xAxis makes it touched\r\n\r\n      if (this.values.state === MotionControllerConstants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > MotionControllerConstants.AxisTouchThreshold) {\r\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\r\n      }\r\n    } // Get and normalize Y axis value\r\n\r\n\r\n    if (this.gamepadIndices.yAxis !== undefined && gamepad.axes.length > this.gamepadIndices.yAxis) {\r\n      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];\r\n      this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;\r\n      this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis; // If the state is still default, check if the yAxis makes it touched\r\n\r\n      if (this.values.state === MotionControllerConstants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > MotionControllerConstants.AxisTouchThreshold) {\r\n        this.values.state = MotionControllerConstants.ComponentState.TOUCHED;\r\n      }\r\n    } // Update the visual response weights based on the current component data\r\n\r\n\r\n    Object.values(this.visualResponses).forEach(visualResponse => {\r\n      visualResponse.updateFromComponent(this.values);\r\n    });\r\n  }\r\n\r\n}\r\n/**\r\n * @description Builds a motion controller with components and visual responses based on the\r\n * supplied profile description. Data is polled from the xrInputSource's gamepad.\r\n * @author Nell Waliczek / https://github.com/NellWaliczek\r\n */\r\n\r\n\r\nclass MotionController {\r\n  /**\r\n   * @param {XRInputSource} xrInputSource - The XRInputSource to build the MotionController around\r\n   * @param {Profile} profile - The best matched profile description for the supplied xrInputSource\r\n   * @param {string} assetUrl\r\n   */\r\n  constructor(xrInputSource, profile, assetUrl) {\r\n    _defineProperty(this, \"xrInputSource\", void 0);\r\n\r\n    _defineProperty(this, \"assetUrl\", void 0);\r\n\r\n    _defineProperty(this, \"layoutDescription\", void 0);\r\n\r\n    _defineProperty(this, \"id\", void 0);\r\n\r\n    _defineProperty(this, \"components\", void 0);\r\n\r\n    if (!xrInputSource) {\r\n      throw new Error('No xrInputSource supplied');\r\n    }\r\n\r\n    if (!profile) {\r\n      throw new Error('No profile supplied');\r\n    }\r\n\r\n    if (!profile.layouts[xrInputSource.handedness]) {\r\n      throw new Error('No layout for ' + xrInputSource.handedness + ' handedness');\r\n    }\r\n\r\n    this.xrInputSource = xrInputSource;\r\n    this.assetUrl = assetUrl;\r\n    this.id = profile.profileId; // Build child components as described in the profile description\r\n\r\n    this.layoutDescription = profile.layouts[xrInputSource.handedness];\r\n    this.components = {};\r\n    Object.keys(this.layoutDescription.components).forEach(componentId => {\r\n      const componentDescription = this.layoutDescription.components[componentId];\r\n      this.components[componentId] = new Component(componentId, componentDescription);\r\n    }); // Initialize components based on current gamepad state\r\n\r\n    this.updateFromGamepad();\r\n  }\r\n\r\n  get gripSpace() {\r\n    return this.xrInputSource.gripSpace;\r\n  }\r\n\r\n  get targetRaySpace() {\r\n    return this.xrInputSource.targetRaySpace;\r\n  }\r\n  /**\r\n   * @description Returns a subset of component data for simplified debugging\r\n   */\r\n\r\n\r\n  get data() {\r\n    const data = [];\r\n    Object.values(this.components).forEach(component => {\r\n      data.push(component.data);\r\n    });\r\n    return data;\r\n  }\r\n  /**\r\n   * @description Poll for updated data based on current gamepad state\r\n   */\r\n\r\n\r\n  updateFromGamepad() {\r\n    Object.values(this.components).forEach(component => {\r\n      component.updateFromGamepad(this.xrInputSource.gamepad);\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport { MotionController, MotionControllerConstants, fetchProfile, fetchProfilesList };\r\n", "import { Matrix4, Vector3, SphereGeometry, BoxGeometry, MeshStandardMaterial, InstancedMesh, DynamicDrawUsage } from 'three';\r\n\r\nconst _matrix = new Matrix4();\r\n\r\nconst _vector = new Vector3();\r\n\r\nclass XRHandPrimitiveModel {\r\n  constructor(handModel, controller, path, handedness, options) {\r\n    this.controller = controller;\r\n    this.handModel = handModel;\r\n    this.envMap = null;\r\n    let geometry;\r\n\r\n    if (!options || !options.primitive || options.primitive === 'sphere') {\r\n      geometry = new SphereGeometry(1, 10, 10);\r\n    } else if (options.primitive === 'box') {\r\n      geometry = new BoxGeometry(1, 1, 1);\r\n    }\r\n\r\n    const material = new MeshStandardMaterial();\r\n    this.handMesh = new InstancedMesh(geometry, material, 30);\r\n    this.handMesh.instanceMatrix.setUsage(DynamicDrawUsage); // will be updated every frame\r\n\r\n    this.handMesh.castShadow = true;\r\n    this.handMesh.receiveShadow = true;\r\n    this.handModel.add(this.handMesh);\r\n    this.joints = ['wrist', 'thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip', 'index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip', 'middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip', 'ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip', 'pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip'];\r\n  }\r\n\r\n  updateMesh() {\r\n    const defaultRadius = 0.008;\r\n    const joints = this.controller.joints;\r\n    let count = 0;\r\n\r\n    for (let i = 0; i < this.joints.length; i++) {\r\n      const joint = joints[this.joints[i]];\r\n\r\n      if (joint.visible) {\r\n        _vector.setScalar(joint.jointRadius || defaultRadius);\r\n\r\n        _matrix.compose(joint.position, joint.quaternion, _vector);\r\n\r\n        this.handMesh.setMatrixAt(i, _matrix);\r\n        count++;\r\n      }\r\n    }\r\n\r\n    this.handMesh.count = count;\r\n    this.handMesh.instanceMatrix.needsUpdate = true;\r\n  }\r\n\r\n}\r\n\r\nexport { XRHandPrimitiveModel };\r\n", "import { BufferGeometry, Vector3, Float32BufferAttribute } from 'three';\r\n\r\n/**\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\r\n */\r\n\r\nclass ParametricGeometry extends BufferGeometry {\r\n  constructor(func = (u, v, target) => target.set(u, v, Math.cos(u) * Math.sin(v)), slices = 8, stacks = 8) {\r\n    super();\r\n    this.type = 'ParametricGeometry';\r\n    this.parameters = {\r\n      func: func,\r\n      slices: slices,\r\n      stacks: stacks\r\n    }; // buffers\r\n\r\n    const indices = [];\r\n    const vertices = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    const EPS = 0.00001;\r\n    const normal = new Vector3();\r\n    const p0 = new Vector3(),\r\n          p1 = new Vector3();\r\n    const pu = new Vector3(),\r\n          pv = new Vector3(); // generate vertices, normals and uvs\r\n\r\n    const sliceCount = slices + 1;\r\n\r\n    for (let i = 0; i <= stacks; i++) {\r\n      const v = i / stacks;\r\n\r\n      for (let j = 0; j <= slices; j++) {\r\n        const u = j / slices; // vertex\r\n\r\n        func(u, v, p0);\r\n        vertices.push(p0.x, p0.y, p0.z); // normal\r\n        // approximate tangent vectors via finite differences\r\n\r\n        if (u - EPS >= 0) {\r\n          func(u - EPS, v, p1);\r\n          pu.subVectors(p0, p1);\r\n        } else {\r\n          func(u + EPS, v, p1);\r\n          pu.subVectors(p1, p0);\r\n        }\r\n\r\n        if (v - EPS >= 0) {\r\n          func(u, v - EPS, p1);\r\n          pv.subVectors(p0, p1);\r\n        } else {\r\n          func(u, v + EPS, p1);\r\n          pv.subVectors(p1, p0);\r\n        } // cross product of tangent vectors returns surface normal\r\n\r\n\r\n        normal.crossVectors(pu, pv).normalize();\r\n        normals.push(normal.x, normal.y, normal.z); // uv\r\n\r\n        uvs.push(u, v);\r\n      }\r\n    } // generate indices\r\n\r\n\r\n    for (let i = 0; i < stacks; i++) {\r\n      for (let j = 0; j < slices; j++) {\r\n        const a = i * sliceCount + j;\r\n        const b = i * sliceCount + j + 1;\r\n        const c = (i + 1) * sliceCount + j + 1;\r\n        const d = (i + 1) * sliceCount + j; // faces one and two\r\n\r\n        indices.push(a, b, d);\r\n        indices.push(b, c, d);\r\n      }\r\n    } // build geometry\r\n\r\n\r\n    this.setIndex(indices);\r\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\r\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n  }\r\n\r\n}\r\n\r\nexport { ParametricGeometry };\r\n", "import { Vector3, Curve } from 'three';\r\nimport { ParametricGeometry } from './ParametricGeometry.js';\r\n\r\n/**\r\n * Experimenting of primitive geometry creation using Surface Parametric equations\r\n */\r\n\r\nconst ParametricGeometries = {\r\n  klein: function (v, u, target) {\r\n    u *= Math.PI;\r\n    v *= 2 * Math.PI;\r\n    u = u * 2;\r\n    let x, z;\r\n\r\n    if (u < Math.PI) {\r\n      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v);\r\n      z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);\r\n    } else {\r\n      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI);\r\n      z = -8 * Math.sin(u);\r\n    }\r\n\r\n    const y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);\r\n    target.set(x, y, z);\r\n  },\r\n  plane: function (width, height) {\r\n    return function (u, v, target) {\r\n      const x = u * width;\r\n      const y = 0;\r\n      const z = v * height;\r\n      target.set(x, y, z);\r\n    };\r\n  },\r\n  mobius: function (u, t, target) {\r\n    // flat mobius strip\r\n    // http://www.wolframalpha.com/input/?i=M%C3%B6bius+strip+parametric+equations&lk=1&a=ClashPrefs_*Surface.MoebiusStrip.SurfaceProperty.ParametricEquations-\r\n    u = u - 0.5;\r\n    const v = 2 * Math.PI * t;\r\n    const a = 2;\r\n    const x = Math.cos(v) * (a + u * Math.cos(v / 2));\r\n    const y = Math.sin(v) * (a + u * Math.cos(v / 2));\r\n    const z = u * Math.sin(v / 2);\r\n    target.set(x, y, z);\r\n  },\r\n  mobius3d: function (u, t, target) {\r\n    // volumetric mobius strip\r\n    u *= Math.PI;\r\n    t *= 2 * Math.PI;\r\n    u = u * 2;\r\n    const phi = u / 2;\r\n    const major = 2.25,\r\n          a = 0.125,\r\n          b = 0.65;\r\n    let x = a * Math.cos(t) * Math.cos(phi) - b * Math.sin(t) * Math.sin(phi);\r\n    const z = a * Math.cos(t) * Math.sin(phi) + b * Math.sin(t) * Math.cos(phi);\r\n    const y = (major + x) * Math.sin(u);\r\n    x = (major + x) * Math.cos(u);\r\n    target.set(x, y, z);\r\n  }\r\n};\r\n/*********************************************\r\n *\r\n * Parametric Replacement for TubeGeometry\r\n *\r\n *********************************************/\r\n\r\nParametricGeometries.TubeGeometry = class TubeGeometry extends ParametricGeometry {\r\n  constructor(path, segments = 64, radius = 1, segmentsRadius = 8, closed = false) {\r\n    const numpoints = segments + 1;\r\n    const frames = path.computeFrenetFrames(segments, closed),\r\n          tangents = frames.tangents,\r\n          normals = frames.normals,\r\n          binormals = frames.binormals;\r\n    const position = new Vector3();\r\n\r\n    function ParametricTube(u, v, target) {\r\n      v *= 2 * Math.PI;\r\n      const i = Math.floor(u * (numpoints - 1));\r\n      path.getPointAt(u, position);\r\n      const normal = normals[i];\r\n      const binormal = binormals[i];\r\n      const cx = -radius * Math.cos(v); // TODO: Hack: Negating it so it faces outside.\r\n\r\n      const cy = radius * Math.sin(v);\r\n      position.x += cx * normal.x + cy * binormal.x;\r\n      position.y += cx * normal.y + cy * binormal.y;\r\n      position.z += cx * normal.z + cy * binormal.z;\r\n      target.copy(position);\r\n    }\r\n\r\n    super(ParametricTube, segments, segmentsRadius); // proxy internals\r\n\r\n    this.tangents = tangents;\r\n    this.normals = normals;\r\n    this.binormals = binormals;\r\n    this.path = path;\r\n    this.segments = segments;\r\n    this.radius = radius;\r\n    this.segmentsRadius = segmentsRadius;\r\n    this.closed = closed;\r\n  }\r\n\r\n};\r\n/*********************************************\r\n *\r\n * Parametric Replacement for TorusKnotGeometry\r\n *\r\n *********************************************/\r\n\r\nParametricGeometries.TorusKnotGeometry = class TorusKnotGeometry extends ParametricGeometries.TubeGeometry {\r\n  constructor(radius = 200, tube = 40, segmentsT = 64, segmentsR = 8, p = 2, q = 3) {\r\n    class TorusKnotCurve extends Curve {\r\n      getPoint(t, optionalTarget = new Vector3()) {\r\n        const point = optionalTarget;\r\n        t *= Math.PI * 2;\r\n        const r = 0.5;\r\n        const x = (1 + r * Math.cos(q * t)) * Math.cos(p * t);\r\n        const y = (1 + r * Math.cos(q * t)) * Math.sin(p * t);\r\n        const z = r * Math.sin(q * t);\r\n        return point.set(x, y, z).multiplyScalar(radius);\r\n      }\r\n\r\n    }\r\n\r\n    const segments = segmentsT;\r\n    const radiusSegments = segmentsR;\r\n    const extrudePath = new TorusKnotCurve();\r\n    super(extrudePath, segments, tube, radiusSegments, true, false);\r\n    this.radius = radius;\r\n    this.tube = tube;\r\n    this.segmentsT = segmentsT;\r\n    this.segmentsR = segmentsR;\r\n    this.p = p;\r\n    this.q = q;\r\n  }\r\n\r\n};\r\n/*********************************************\r\n *\r\n * Parametric Replacement for SphereGeometry\r\n *\r\n *********************************************/\r\n\r\nParametricGeometries.SphereGeometry = class SphereGeometry extends ParametricGeometry {\r\n  constructor(size, u, v) {\r\n    function sphere(u, v, target) {\r\n      u *= Math.PI;\r\n      v *= 2 * Math.PI;\r\n      const x = size * Math.sin(u) * Math.cos(v);\r\n      const y = size * Math.sin(u) * Math.sin(v);\r\n      const z = size * Math.cos(u);\r\n      target.set(x, y, z);\r\n    }\r\n\r\n    super(sphere, u, v);\r\n  }\r\n\r\n};\r\n/*********************************************\r\n *\r\n * Parametric Replacement for PlaneGeometry\r\n *\r\n *********************************************/\r\n\r\nParametricGeometries.PlaneGeometry = class PlaneGeometry extends ParametricGeometry {\r\n  constructor(width, depth, segmentsWidth, segmentsDepth) {\r\n    function plane(u, v, target) {\r\n      const x = u * width;\r\n      const y = 0;\r\n      const z = v * depth;\r\n      target.set(x, y, z);\r\n    }\r\n\r\n    super(plane, segmentsWidth, segmentsDepth);\r\n  }\r\n\r\n};\r\n\r\nexport { ParametricGeometries };\r\n", "import { Vector3, BoxGeometry } from 'three';\r\n\r\nconst tempNormal = new Vector3();\r\n\r\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\r\n  const totArcLength = 2 * Math.PI * radius / 4; // length of the planes between the arcs on each axis\r\n\r\n  const centerLength = Math.max(sideLength - 2 * radius, 0);\r\n  const halfArc = Math.PI / 4; // Get the vector projected onto the Y plane\r\n\r\n  tempNormal.copy(normal);\r\n  tempNormal[projectionAxis] = 0;\r\n  tempNormal.normalize(); // total amount of UV space alloted to a single arc\r\n\r\n  const arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength); // the distance along one arc the point is at\r\n\r\n  const arcAngleRatio = 1.0 - tempNormal.angleTo(faceDirVector) / halfArc;\r\n\r\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\r\n    return arcAngleRatio * arcUvRatio;\r\n  } else {\r\n    // total amount of UV space alloted to the plane between the arcs\r\n    const lenUv = centerLength / (totArcLength + centerLength);\r\n    return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio);\r\n  }\r\n}\r\n\r\nclass RoundedBoxGeometry extends BoxGeometry {\r\n  constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1) {\r\n    // ensure segments is odd so we have a plane connecting the rounded corners\r\n    segments = segments * 2 + 1; // ensure radius isn't bigger than shortest side\r\n\r\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\r\n    super(1, 1, 1, segments, segments, segments); // if we just have one segment we're the same as a regular box\r\n\r\n    if (segments === 1) return;\r\n    const geometry2 = this.toNonIndexed();\r\n    this.index = null;\r\n    this.attributes.position = geometry2.attributes.position;\r\n    this.attributes.normal = geometry2.attributes.normal;\r\n    this.attributes.uv = geometry2.attributes.uv; //\r\n\r\n    const position = new Vector3();\r\n    const normal = new Vector3();\r\n    const box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius);\r\n    const positions = this.attributes.position.array;\r\n    const normals = this.attributes.normal.array;\r\n    const uvs = this.attributes.uv.array;\r\n    const faceTris = positions.length / 6;\r\n    const faceDirVector = new Vector3();\r\n    const halfSegmentSize = 0.5 / segments;\r\n\r\n    for (let i = 0, j = 0; i < positions.length; i += 3, j += 2) {\r\n      position.fromArray(positions, i);\r\n      normal.copy(position);\r\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\r\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\r\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\r\n      normal.normalize();\r\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\r\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\r\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\r\n      normals[i + 0] = normal.x;\r\n      normals[i + 1] = normal.y;\r\n      normals[i + 2] = normal.z;\r\n      const side = Math.floor(i / faceTris);\r\n\r\n      switch (side) {\r\n        case 0:\r\n          // right\r\n          // generate UVs along Z then Y\r\n          faceDirVector.set(1, 0, 0);\r\n          uvs[j + 0] = getUv(faceDirVector, normal, 'z', 'y', radius, depth);\r\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\r\n          break;\r\n\r\n        case 1:\r\n          // left\r\n          // generate UVs along Z then Y\r\n          faceDirVector.set(-1, 0, 0);\r\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'z', 'y', radius, depth);\r\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\r\n          break;\r\n\r\n        case 2:\r\n          // top\r\n          // generate UVs along X then Z\r\n          faceDirVector.set(0, 1, 0);\r\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\r\n          uvs[j + 1] = getUv(faceDirVector, normal, 'z', 'x', radius, depth);\r\n          break;\r\n\r\n        case 3:\r\n          // bottom\r\n          // generate UVs along X then Z\r\n          faceDirVector.set(0, -1, 0);\r\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\r\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'z', 'x', radius, depth);\r\n          break;\r\n\r\n        case 4:\r\n          // front\r\n          // generate UVs along X then Y\r\n          faceDirVector.set(0, 0, 1);\r\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'y', radius, width);\r\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\r\n          break;\r\n\r\n        case 5:\r\n          // back\r\n          // generate UVs along X then Y\r\n          faceDirVector.set(0, 0, -1);\r\n          uvs[j + 0] = getUv(faceDirVector, normal, 'x', 'y', radius, width);\r\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport { RoundedBoxGeometry };\r\n", "import { Matrix4, Vector3 } from 'three';\r\n\r\nconst inverseProjectionMatrix = new Matrix4();\r\n\r\nclass CSMFrustum {\r\n  constructor(data) {\r\n    data = data || {};\r\n    this.vertices = {\r\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\r\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\r\n    };\r\n\r\n    if (data.projectionMatrix !== undefined) {\r\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000);\r\n    }\r\n  }\r\n\r\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\r\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\r\n    inverseProjectionMatrix.copy(projectionMatrix).invert(); // 3 --- 0  vertices.near/far order\r\n    // |     |\r\n    // 2 --- 1\r\n    // clip space spans from [-1, 1]\r\n\r\n    this.vertices.near[0].set(1, 1, -1);\r\n    this.vertices.near[1].set(1, -1, -1);\r\n    this.vertices.near[2].set(-1, -1, -1);\r\n    this.vertices.near[3].set(-1, 1, -1);\r\n    this.vertices.near.forEach(function (v) {\r\n      v.applyMatrix4(inverseProjectionMatrix);\r\n    });\r\n    this.vertices.far[0].set(1, 1, 1);\r\n    this.vertices.far[1].set(1, -1, 1);\r\n    this.vertices.far[2].set(-1, -1, 1);\r\n    this.vertices.far[3].set(-1, 1, 1);\r\n    this.vertices.far.forEach(function (v) {\r\n      v.applyMatrix4(inverseProjectionMatrix);\r\n      const absZ = Math.abs(v.z);\r\n\r\n      if (isOrthographic) {\r\n        v.z *= Math.min(maxFar / absZ, 1.0);\r\n      } else {\r\n        v.multiplyScalar(Math.min(maxFar / absZ, 1.0));\r\n      }\r\n    });\r\n    return this.vertices;\r\n  }\r\n\r\n  split(breaks, target) {\r\n    while (breaks.length > target.length) {\r\n      target.push(new CSMFrustum());\r\n    }\r\n\r\n    target.length = breaks.length;\r\n\r\n    for (let i = 0; i < breaks.length; i++) {\r\n      const cascade = target[i];\r\n\r\n      if (i === 0) {\r\n        for (let j = 0; j < 4; j++) {\r\n          cascade.vertices.near[j].copy(this.vertices.near[j]);\r\n        }\r\n      } else {\r\n        for (let j = 0; j < 4; j++) {\r\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);\r\n        }\r\n      }\r\n\r\n      if (i === breaks.length - 1) {\r\n        for (let j = 0; j < 4; j++) {\r\n          cascade.vertices.far[j].copy(this.vertices.far[j]);\r\n        }\r\n      } else {\r\n        for (let j = 0; j < 4; j++) {\r\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  toSpace(cameraMatrix, target) {\r\n    for (let i = 0; i < 4; i++) {\r\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\r\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport { CSMFrustum };\r\n", "import { ShaderChunk } from 'three';\r\n\r\nconst CSMShader = {\r\n  lights_fragment_begin:\r\n  /* glsl */\r\n  `\r\nGeometricContext geometry;\r\n\r\ngeometry.position = - vViewPosition;\r\ngeometry.normal = normal;\r\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\r\n\r\n#ifdef CLEARCOAT\r\n\r\n\tgeometry.clearcoatNormal = clearcoatNormal;\r\n\r\n#endif\r\n\r\nIncidentLight directLight;\r\n\r\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tPointLight pointLight;\r\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\r\n\tPointLightShadow pointLightShadow;\r\n\t#endif\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\r\n\t\tpointLight = pointLights[ i ];\r\n\r\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\r\n\t\tpointLightShadow = pointLightShadows[ i ];\r\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tSpotLight spotLight;\r\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\r\n\tSpotLightShadow spotLightShadow;\r\n\t#endif\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\r\n\t\tspotLight = spotLights[ i ];\r\n\r\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\r\n\t\tspotLightShadow = spotLightShadows[ i ];\r\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\r\n\r\n\tDirectionalLight directionalLight;\r\n\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\r\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\r\n\tDirectionalLightShadow directionalLightShadow;\r\n\t#endif\r\n\r\n\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\r\n\tvec2 cascade;\r\n\tfloat cascadeCenter;\r\n\tfloat closestEdge;\r\n\tfloat margin;\r\n\tfloat csmx;\r\n\tfloat csmy;\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\r\n\r\n\t  \t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\r\n\t\t\t// NOTE: Depth gets larger away from the camera.\r\n\t\t\t// cascade.x is closer, cascade.y is further\r\n\t\t\tcascade = CSM_cascades[ i ];\r\n\t\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\r\n\t\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\r\n\t\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\r\n\t\t\tcsmx = cascade.x - margin / 2.0;\r\n\t\t\tcsmy = cascade.y + margin / 2.0;\r\n\t\t\tif( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\r\n\r\n\t\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\r\n\t\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\r\n\r\n\t\t\t\tvec3 prevColor = directLight.color;\r\n\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\r\n\t\t\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\r\n\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\r\n\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\r\n\r\n\t\t\t\tReflectedLight prevLight = reflectedLight;\r\n\t\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\r\n\t\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\r\n\r\n\t\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\r\n\t\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\r\n\t\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\r\n\t\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\r\n\r\n\t\t\t}\r\n\t  \t#endif\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\t#else\r\n\r\n\t\t#pragma unroll_loop_start\r\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\tdirectionalLight = directionalLights[ i ];\r\n\t\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\r\n\r\n\t\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\r\n\r\n\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\r\n\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\r\n\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t}\r\n\t\t#pragma unroll_loop_end\r\n\r\n\t#endif\r\n\r\n\t#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)\r\n\t\t// compute the lights not casting shadows (if any)\r\n\r\n\t\t#pragma unroll_loop_start\r\n\t\tfor ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\t\tdirectionalLight = directionalLights[ i ];\r\n\r\n\t\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\r\n\r\n\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t\t}\r\n\t\t#pragma unroll_loop_end\r\n\r\n\t#endif\r\n\r\n#endif\r\n\r\n\r\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\r\n\r\n\tDirectionalLight directionalLight;\r\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\r\n\tDirectionalLightShadow directionalLightShadow;\r\n\t#endif\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\r\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\r\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\r\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\r\n\r\n\tRectAreaLight rectAreaLight;\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\r\n\r\n\t\trectAreaLight = rectAreaLights[ i ];\r\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if defined( RE_IndirectDiffuse )\r\n\r\n\tvec3 iblIrradiance = vec3( 0.0 );\r\n\r\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\r\n\r\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\r\n\r\n\t#if ( NUM_HEMI_LIGHTS > 0 )\r\n\r\n\t\t#pragma unroll_loop_start\r\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n\r\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\r\n\r\n\t\t}\r\n\t\t#pragma unroll_loop_end\r\n\r\n\t#endif\r\n\r\n#endif\r\n\r\n#if defined( RE_IndirectSpecular )\r\n\r\n\tvec3 radiance = vec3( 0.0 );\r\n\tvec3 clearcoatRadiance = vec3( 0.0 );\r\n\r\n#endif\r\n`,\r\n  lights_pars_begin:\r\n  /* glsl */\r\n  `\r\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\r\nuniform vec2 CSM_cascades[CSM_CASCADES];\r\nuniform float cameraNear;\r\nuniform float shadowFar;\r\n#endif\r\n\t` + ShaderChunk.lights_pars_begin\r\n};\r\n\r\nexport { CSMShader };\r\n", "import { Matrix4, Vector3, Box3, DirectionalLight, MathUtils, ShaderChunk, Vector2 } from 'three';\r\nimport { CSMFrustum } from './CSMFrustum.js';\r\nimport { CSMShader } from './CSMShader.js';\r\n\r\nconst _cameraToLightMatrix = new Matrix4();\r\n\r\nconst _lightSpaceFrustum = new CSMFrustum();\r\n\r\nconst _center = new Vector3();\r\n\r\nconst _bbox = new Box3();\r\n\r\nconst _uniformArray = [];\r\nconst _logArray = [];\r\nclass CSM {\r\n  constructor(data) {\r\n    data = data || {};\r\n    this.camera = data.camera;\r\n    this.parent = data.parent;\r\n    this.cascades = data.cascades || 3;\r\n    this.maxFar = data.maxFar || 100000;\r\n    this.mode = data.mode || 'practical';\r\n    this.shadowMapSize = data.shadowMapSize || 2048;\r\n    this.shadowBias = data.shadowBias || 0.000001;\r\n    this.lightDirection = data.lightDirection || new Vector3(1, -1, 1).normalize();\r\n    this.lightIntensity = data.lightIntensity || 1;\r\n    this.lightNear = data.lightNear || 1;\r\n    this.lightFar = data.lightFar || 2000;\r\n    this.lightMargin = data.lightMargin || 200;\r\n    this.customSplitsCallback = data.customSplitsCallback;\r\n    this.fade = false;\r\n    this.mainFrustum = new CSMFrustum();\r\n    this.frustums = [];\r\n    this.breaks = [];\r\n    this.lights = [];\r\n    this.shaders = new Map();\r\n    this.createLights();\r\n    this.updateFrustums();\r\n    this.injectInclude();\r\n  }\r\n\r\n  createLights() {\r\n    for (let i = 0; i < this.cascades; i++) {\r\n      const light = new DirectionalLight(0xffffff, this.lightIntensity);\r\n      light.castShadow = true;\r\n      light.shadow.mapSize.width = this.shadowMapSize;\r\n      light.shadow.mapSize.height = this.shadowMapSize;\r\n      light.shadow.camera.near = this.lightNear;\r\n      light.shadow.camera.far = this.lightFar;\r\n      light.shadow.bias = this.shadowBias;\r\n      this.parent.add(light);\r\n      this.parent.add(light.target);\r\n      this.lights.push(light);\r\n    }\r\n  }\r\n\r\n  initCascades() {\r\n    const camera = this.camera;\r\n    camera.updateProjectionMatrix();\r\n    this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);\r\n    this.mainFrustum.split(this.breaks, this.frustums);\r\n  }\r\n\r\n  updateShadowBounds() {\r\n    const frustums = this.frustums;\r\n\r\n    for (let i = 0; i < frustums.length; i++) {\r\n      const light = this.lights[i];\r\n      const shadowCam = light.shadow.camera;\r\n      const frustum = this.frustums[i]; // Get the two points that represent that furthest points on the frustum assuming\r\n      // that's either the diagonal across the far plane or the diagonal across the whole\r\n      // frustum itself.\r\n\r\n      const nearVerts = frustum.vertices.near;\r\n      const farVerts = frustum.vertices.far;\r\n      const point1 = farVerts[0];\r\n      let point2;\r\n\r\n      if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {\r\n        point2 = farVerts[2];\r\n      } else {\r\n        point2 = nearVerts[2];\r\n      }\r\n\r\n      let squaredBBWidth = point1.distanceTo(point2);\r\n\r\n      if (this.fade) {\r\n        // expand the shadow extents by the fade margin if fade is enabled.\r\n        const camera = this.camera;\r\n        const far = Math.max(camera.far, this.maxFar);\r\n        const linearDepth = frustum.vertices.far[0].z / (far - camera.near);\r\n        const margin = 0.25 * Math.pow(linearDepth, 2.0) * (far - camera.near);\r\n        squaredBBWidth += margin;\r\n      }\r\n\r\n      shadowCam.left = -squaredBBWidth / 2;\r\n      shadowCam.right = squaredBBWidth / 2;\r\n      shadowCam.top = squaredBBWidth / 2;\r\n      shadowCam.bottom = -squaredBBWidth / 2;\r\n      shadowCam.updateProjectionMatrix();\r\n    }\r\n  }\r\n\r\n  getBreaks() {\r\n    const camera = this.camera;\r\n    const far = Math.min(camera.far, this.maxFar);\r\n    this.breaks.length = 0;\r\n\r\n    switch (this.mode) {\r\n      case 'uniform':\r\n        uniformSplit(this.cascades, camera.near, far, this.breaks);\r\n        break;\r\n\r\n      case 'logarithmic':\r\n        logarithmicSplit(this.cascades, camera.near, far, this.breaks);\r\n        break;\r\n\r\n      case 'practical':\r\n        practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);\r\n        break;\r\n\r\n      case 'custom':\r\n        if (this.customSplitsCallback === undefined) console.error('CSM: Custom split scheme callback not defined.');\r\n        this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);\r\n        break;\r\n    }\r\n\r\n    function uniformSplit(amount, near, far, target) {\r\n      for (let i = 1; i < amount; i++) {\r\n        target.push((near + (far - near) * i / amount) / far);\r\n      }\r\n\r\n      target.push(1);\r\n    }\r\n\r\n    function logarithmicSplit(amount, near, far, target) {\r\n      for (let i = 1; i < amount; i++) {\r\n        target.push(near * (far / near) ** (i / amount) / far);\r\n      }\r\n\r\n      target.push(1);\r\n    }\r\n\r\n    function practicalSplit(amount, near, far, lambda, target) {\r\n      _uniformArray.length = 0;\r\n      _logArray.length = 0;\r\n      logarithmicSplit(amount, near, far, _logArray);\r\n      uniformSplit(amount, near, far, _uniformArray);\r\n\r\n      for (let i = 1; i < amount; i++) {\r\n        target.push(MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));\r\n      }\r\n\r\n      target.push(1);\r\n    }\r\n  }\r\n\r\n  update() {\r\n    const camera = this.camera;\r\n    const frustums = this.frustums;\r\n\r\n    for (let i = 0; i < frustums.length; i++) {\r\n      const light = this.lights[i];\r\n      const shadowCam = light.shadow.camera;\r\n      const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;\r\n      const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;\r\n      light.shadow.camera.updateMatrixWorld(true);\r\n\r\n      _cameraToLightMatrix.multiplyMatrices(light.shadow.camera.matrixWorldInverse, camera.matrixWorld);\r\n\r\n      frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);\r\n      const nearVerts = _lightSpaceFrustum.vertices.near;\r\n      const farVerts = _lightSpaceFrustum.vertices.far;\r\n\r\n      _bbox.makeEmpty();\r\n\r\n      for (let j = 0; j < 4; j++) {\r\n        _bbox.expandByPoint(nearVerts[j]);\r\n\r\n        _bbox.expandByPoint(farVerts[j]);\r\n      }\r\n\r\n      _bbox.getCenter(_center);\r\n\r\n      _center.z = _bbox.max.z + this.lightMargin;\r\n      _center.x = Math.floor(_center.x / texelWidth) * texelWidth;\r\n      _center.y = Math.floor(_center.y / texelHeight) * texelHeight;\r\n\r\n      _center.applyMatrix4(light.shadow.camera.matrixWorld);\r\n\r\n      light.position.copy(_center);\r\n      light.target.position.copy(_center);\r\n      light.target.position.x += this.lightDirection.x;\r\n      light.target.position.y += this.lightDirection.y;\r\n      light.target.position.z += this.lightDirection.z;\r\n    }\r\n  }\r\n\r\n  injectInclude() {\r\n    ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin;\r\n    ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin;\r\n  }\r\n\r\n  setupMaterial(material) {\r\n    material.defines = material.defines || {};\r\n    material.defines.USE_CSM = 1;\r\n    material.defines.CSM_CASCADES = this.cascades;\r\n\r\n    if (this.fade) {\r\n      material.defines.CSM_FADE = '';\r\n    }\r\n\r\n    const breaksVec2 = [];\r\n    const scope = this;\r\n    const shaders = this.shaders;\r\n\r\n    material.onBeforeCompile = function (shader) {\r\n      const far = Math.min(scope.camera.far, scope.maxFar);\r\n      scope.getExtendedBreaks(breaksVec2);\r\n      shader.uniforms.CSM_cascades = {\r\n        value: breaksVec2\r\n      };\r\n      shader.uniforms.cameraNear = {\r\n        value: scope.camera.near\r\n      };\r\n      shader.uniforms.shadowFar = {\r\n        value: far\r\n      };\r\n      shaders.set(material, shader);\r\n    };\r\n\r\n    shaders.set(material, null);\r\n  }\r\n\r\n  updateUniforms() {\r\n    const far = Math.min(this.camera.far, this.maxFar);\r\n    const shaders = this.shaders;\r\n    shaders.forEach(function (shader, material) {\r\n      if (shader !== null) {\r\n        const uniforms = shader.uniforms;\r\n        this.getExtendedBreaks(uniforms.CSM_cascades.value);\r\n        uniforms.cameraNear.value = this.camera.near;\r\n        uniforms.shadowFar.value = far;\r\n      }\r\n\r\n      if (!this.fade && 'CSM_FADE' in material.defines) {\r\n        delete material.defines.CSM_FADE;\r\n        material.needsUpdate = true;\r\n      } else if (this.fade && !('CSM_FADE' in material.defines)) {\r\n        material.defines.CSM_FADE = '';\r\n        material.needsUpdate = true;\r\n      }\r\n    }, this);\r\n  }\r\n\r\n  getExtendedBreaks(target) {\r\n    while (target.length < this.breaks.length) {\r\n      target.push(new Vector2());\r\n    }\r\n\r\n    target.length = this.breaks.length;\r\n\r\n    for (let i = 0; i < this.cascades; i++) {\r\n      const amount = this.breaks[i];\r\n      const prev = this.breaks[i - 1] || 0;\r\n      target[i].x = prev;\r\n      target[i].y = amount;\r\n    }\r\n  }\r\n\r\n  updateFrustums() {\r\n    this.getBreaks();\r\n    this.initCascades();\r\n    this.updateShadowBounds();\r\n    this.updateUniforms();\r\n  }\r\n\r\n  remove() {\r\n    for (let i = 0; i < this.lights.length; i++) {\r\n      this.parent.remove(this.lights[i]);\r\n    }\r\n  }\r\n\r\n  dispose() {\r\n    const shaders = this.shaders;\r\n    shaders.forEach(function (shader, material) {\r\n      delete material.onBeforeCompile;\r\n      delete material.defines.USE_CSM;\r\n      delete material.defines.CSM_CASCADES;\r\n      delete material.defines.CSM_FADE;\r\n\r\n      if (shader !== null) {\r\n        delete shader.uniforms.CSM_cascades;\r\n        delete shader.uniforms.cameraNear;\r\n        delete shader.uniforms.shadowFar;\r\n      }\r\n\r\n      material.needsUpdate = true;\r\n    });\r\n    shaders.clear();\r\n  }\r\n\r\n}\r\n\r\nexport { CSM };\r\n", "/**\r\n * ACES Filmic Tone Mapping Shader by Stephen Hill\r\n * source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\r\n *\r\n * this implementation of ACES is modified to accommodate a brighter viewing environment.\r\n * the scale factor of 1/0.6 is subjective. see discussion in #19621.\r\n */\r\nconst ACESFilmicToneMappingShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    exposure: {\r\n      value: 1.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['#define saturate(a) clamp( a, 0.0, 1.0 )', 'uniform sampler2D tDiffuse;', 'uniform float exposure;', 'varying vec2 vUv;', 'vec3 RRTAndODTFit( vec3 v ) {', '\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;', '\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;', '\treturn a / b;', '}', 'vec3 ACESFilmicToneMapping( vec3 color ) {', // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\r\n  '\tconst mat3 ACESInputMat = mat3(', '\t\tvec3( 0.59719, 0.07600, 0.02840 ),', // transposed from source\r\n  '\t\tvec3( 0.35458, 0.90834, 0.13383 ),', '\t\tvec3( 0.04823, 0.01566, 0.83777 )', '\t);', // ODT_SAT => XYZ => D60_2_D65 => sRGB\r\n  '\tconst mat3 ACESOutputMat = mat3(', '\t\tvec3(  1.60475, -0.10208, -0.00327 ),', // transposed from source\r\n  '\t\tvec3( -0.53108,  1.10813, -0.07276 ),', '\t\tvec3( -0.07367, -0.00605,  1.07602 )', '\t);', '\tcolor = ACESInputMat * color;', // Apply RRT and ODT\r\n  '\tcolor = RRTAndODTFit( color );', '\tcolor = ACESOutputMat * color;', // Clamp to [0, 1]\r\n  '\treturn saturate( color );', '}', 'void main() {', '\tvec4 tex = texture2D( tDiffuse, vUv );', '\ttex.rgb *= exposure / 0.6;', // pre-exposed, outside of the tone mapping function\r\n  '\tgl_FragColor = vec4( ACESFilmicToneMapping( tex.rgb ), tex.a );', '}'].join('\\n')\r\n};\r\n\r\nexport { ACESFilmicToneMappingShader };\r\n", "/**\r\n * Simple test shader\r\n */\r\nconst BasicShader = {\r\n  uniforms: {},\r\n  vertexShader: ['void main() {', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['void main() {', '\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );', '}'].join('\\n')\r\n};\r\n\r\nexport { BasicShader };\r\n", "/**\r\n * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]\r\n * - based on Nvidia example\r\n * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass\r\n */\r\nconst BleachBypassShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    opacity: {\r\n      value: 1.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform float opacity;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 base = texture2D( tDiffuse, vUv );', '\tvec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );', '\tfloat lum = dot( lumCoeff, base.rgb );', '\tvec3 blend = vec3( lum );', '\tfloat L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );', '\tvec3 result1 = 2.0 * base.rgb * blend;', '\tvec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );', '\tvec3 newColor = mix( result1, result2, L );', '\tfloat A2 = opacity * base.a;', '\tvec3 mixRGB = A2 * newColor.rgb;', '\tmixRGB += ( ( 1.0 - A2 ) * base.rgb );', '\tgl_FragColor = vec4( mixRGB, base.a );', '}'].join('\\n')\r\n};\r\n\r\nexport { BleachBypassShader };\r\n", "/**\r\n * Blend two textures\r\n */\r\nconst BlendShader = {\r\n  uniforms: {\r\n    tDiffuse1: {\r\n      value: null\r\n    },\r\n    tDiffuse2: {\r\n      value: null\r\n    },\r\n    mixRatio: {\r\n      value: 0.5\r\n    },\r\n    opacity: {\r\n      value: 1.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform float opacity;', 'uniform float mixRatio;', 'uniform sampler2D tDiffuse1;', 'uniform sampler2D tDiffuse2;', 'varying vec2 vUv;', 'void main() {', '\tvec4 texel1 = texture2D( tDiffuse1, vUv );', '\tvec4 texel2 = texture2D( tDiffuse2, vUv );', '\tgl_FragColor = opacity * mix( texel1, texel2, mixRatio );', '}'].join('\\n')\r\n};\r\n\r\nexport { BlendShader };\r\n", "/**\r\n * Brightness and contrast adjustment\r\n * https://github.com/evanw/glfx.js\r\n * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)\r\n * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\r\n */\r\nconst BrightnessContrastShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    brightness: {\r\n      value: 0\r\n    },\r\n    contrast: {\r\n      value: 0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float brightness;', 'uniform float contrast;', 'varying vec2 vUv;', 'void main() {', '\tgl_FragColor = texture2D( tDiffuse, vUv );', '\tgl_FragColor.rgb += brightness;', '\tif (contrast > 0.0) {', '\t\tgl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;', '\t} else {', '\t\tgl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;', '\t}', '}'].join('\\n')\r\n};\r\n\r\nexport { BrightnessContrastShader };\r\n", "import { Vector3 } from 'three';\r\n\r\n/**\r\n * Color correction\r\n */\r\n\r\nconst ColorCorrectionShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    powRGB: {\r\n      value: new Vector3(2, 2, 2)\r\n    },\r\n    mulRGB: {\r\n      value: new Vector3(1, 1, 1)\r\n    },\r\n    addRGB: {\r\n      value: new Vector3(0, 0, 0)\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec3 powRGB;', 'uniform vec3 mulRGB;', 'uniform vec3 addRGB;', 'varying vec2 vUv;', 'void main() {', '\tgl_FragColor = texture2D( tDiffuse, vUv );', '\tgl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );', '}'].join('\\n')\r\n};\r\n\r\nexport { ColorCorrectionShader };\r\n", "import { Color } from 'three';\r\n\r\n/**\r\n * Colorify shader\r\n */\r\n\r\nconst ColorifyShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    color: {\r\n      value: new Color(0xffffff)\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tvec3 luma = vec3( 0.299, 0.587, 0.114 );', '\tfloat v = dot( texel.xyz, luma );', '\tgl_FragColor = vec4( v * color, texel.w );', '}'].join('\\n')\r\n};\r\n\r\nexport { ColorifyShader };\r\n", "/**\r\n * Depth-of-field shader using mipmaps\r\n * - from Matt Handley @applmak\r\n * - requires power-of-2 sized render target with enabled mipmaps\r\n */\r\nconst DOFMipMapShader = {\r\n  uniforms: {\r\n    tColor: {\r\n      value: null\r\n    },\r\n    tDepth: {\r\n      value: null\r\n    },\r\n    focus: {\r\n      value: 1.0\r\n    },\r\n    maxblur: {\r\n      value: 1.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform float focus;', 'uniform float maxblur;', 'uniform sampler2D tColor;', 'uniform sampler2D tDepth;', 'varying vec2 vUv;', 'void main() {', '\tvec4 depth = texture2D( tDepth, vUv );', '\tfloat factor = depth.x - focus;', '\tvec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );', '\tgl_FragColor = col;', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\r\n};\r\n\r\nexport { DOFMipMapShader };\r\n", "import { Vector2 } from 'three';\r\n\r\n/**\r\n * NVIDIA FXAA by Timothy Lottes\r\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\r\n * - WebGL port by @supereggbert\r\n * http://www.glge.org/demos/fxaa/\r\n */\r\n\r\nconst FXAAShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    resolution: {\r\n      value: new Vector2(1 / 1024, 1 / 512)\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['precision highp float;', '', 'uniform sampler2D tDiffuse;', '', 'uniform vec2 resolution;', '', 'varying vec2 vUv;', '', '// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)', '', '//----------------------------------------------------------------------------------', '// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag', '// SDK Version: v3.00', '// Email:       gameworks@nvidia.com', '// Site:        http://developer.nvidia.com/', '//', '// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.', '//', '// Redistribution and use in source and binary forms, with or without', '// modification, are permitted provided that the following conditions', '// are met:', '//  * Redistributions of source code must retain the above copyright', '//    notice, this list of conditions and the following disclaimer.', '//  * Redistributions in binary form must reproduce the above copyright', '//    notice, this list of conditions and the following disclaimer in the', '//    documentation and/or other materials provided with the distribution.', '//  * Neither the name of NVIDIA CORPORATION nor the names of its', '//    contributors may be used to endorse or promote products derived', '//    from this software without specific prior written permission.', '//', \"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\", '// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE', '// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR', '// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR', '// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,', '// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,', '// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR', '// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY', '// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT', '// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE', '// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.', '//', '//----------------------------------------------------------------------------------', '', '#define FXAA_PC 1', '#define FXAA_GLSL_100 1', '#define FXAA_QUALITY_PRESET 12', '', '#define FXAA_GREEN_AS_LUMA 1', '', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_PC_CONSOLE', '    //', '    // The console algorithm for PC is included', '    // for developers targeting really low spec machines.', '    // Likely better to just run FXAA_PC, and use a really low preset.', '    //', '    #define FXAA_PC_CONSOLE 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_GLSL_120', '    #define FXAA_GLSL_120 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_GLSL_130', '    #define FXAA_GLSL_130 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_HLSL_3', '    #define FXAA_HLSL_3 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_HLSL_4', '    #define FXAA_HLSL_4 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_HLSL_5', '    #define FXAA_HLSL_5 0', '#endif', '/*==========================================================================*/', '#ifndef FXAA_GREEN_AS_LUMA', '    //', '    // For those using non-linear color,', '    // and either not able to get luma in alpha, or not wanting to,', '    // this enables FXAA to run using green as a proxy for luma.', '    // So with this enabled, no need to pack luma in alpha.', '    //', '    // This will turn off AA on anything which lacks some amount of green.', '    // Pure red and blue or combination of only R and B, will get no AA.', '    //', '    // Might want to lower the settings for both,', '    //    fxaaConsoleEdgeThresholdMin', '    //    fxaaQualityEdgeThresholdMin', '    // In order to insure AA does not get turned off on colors', '    // which contain a minor amount of green.', '    //', '    // 1 = On.', '    // 0 = Off.', '    //', '    #define FXAA_GREEN_AS_LUMA 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_EARLY_EXIT', '    //', \"    // Controls algorithm's early exit path.\", '    // On PS3 turning this ON adds 2 cycles to the shader.', '    // On 360 turning this OFF adds 10ths of a millisecond to the shader.', '    // Turning this off on console will result in a more blurry image.', '    // So this defaults to on.', '    //', '    // 1 = On.', '    // 0 = Off.', '    //', '    #define FXAA_EARLY_EXIT 1', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_DISCARD', '    //', '    // Only valid for PC OpenGL currently.', '    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.', '    //', \"    // 1 = Use discard on pixels which don't need AA.\", '    //     For APIs which enable concurrent TEX+ROP from same surface.', \"    // 0 = Return unchanged color on pixels which don't need AA.\", '    //', '    #define FXAA_DISCARD 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_FAST_PIXEL_OFFSET', '    //', '    // Used for GLSL 120 only.', '    //', '    // 1 = GL API supports fast pixel offsets', '    // 0 = do not use fast pixel offsets', '    //', '    #ifdef GL_EXT_gpu_shader4', '        #define FXAA_FAST_PIXEL_OFFSET 1', '    #endif', '    #ifdef GL_NV_gpu_shader5', '        #define FXAA_FAST_PIXEL_OFFSET 1', '    #endif', '    #ifdef GL_ARB_gpu_shader5', '        #define FXAA_FAST_PIXEL_OFFSET 1', '    #endif', '    #ifndef FXAA_FAST_PIXEL_OFFSET', '        #define FXAA_FAST_PIXEL_OFFSET 0', '    #endif', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_GATHER4_ALPHA', '    //', '    // 1 = API supports gather4 on alpha channel.', '    // 0 = API does not support gather4 on alpha channel.', '    //', '    #if (FXAA_HLSL_5 == 1)', '        #define FXAA_GATHER4_ALPHA 1', '    #endif', '    #ifdef GL_ARB_gpu_shader5', '        #define FXAA_GATHER4_ALPHA 1', '    #endif', '    #ifdef GL_NV_gpu_shader5', '        #define FXAA_GATHER4_ALPHA 1', '    #endif', '    #ifndef FXAA_GATHER4_ALPHA', '        #define FXAA_GATHER4_ALPHA 0', '    #endif', '#endif', '', '', '/*============================================================================', '                        FXAA QUALITY - TUNING KNOBS', '------------------------------------------------------------------------------', 'NOTE the other tuning knobs are now in the shader function inputs!', '============================================================================*/', '#ifndef FXAA_QUALITY_PRESET', '    //', '    // Choose the quality preset.', '    // This needs to be compiled into the shader as it effects code.', '    // Best option to include multiple presets is to', '    // in each shader define the preset, then include this file.', '    //', '    // OPTIONS', '    // -----------------------------------------------------------------------', '    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)', '    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)', '    // 39       - no dither, very expensive', '    //', '    // NOTES', '    // -----------------------------------------------------------------------', '    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)', '    // 13 = about same speed as FXAA 3.9 and better than 12', '    // 23 = closest to FXAA 3.9 visually and performance wise', '    //  _ = the lowest digit is directly related to performance', '    // _  = the highest digit is directly related to style', '    //', '    #define FXAA_QUALITY_PRESET 12', '#endif', '', '', '/*============================================================================', '', '                           FXAA QUALITY - PRESETS', '', '============================================================================*/', '', '/*============================================================================', '                     FXAA QUALITY - MEDIUM DITHER PRESETS', '============================================================================*/', '#if (FXAA_QUALITY_PRESET == 10)', '    #define FXAA_QUALITY_PS 3', '    #define FXAA_QUALITY_P0 1.5', '    #define FXAA_QUALITY_P1 3.0', '    #define FXAA_QUALITY_P2 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 11)', '    #define FXAA_QUALITY_PS 4', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 3.0', '    #define FXAA_QUALITY_P3 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 12)', '    #define FXAA_QUALITY_PS 5', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 4.0', '    #define FXAA_QUALITY_P4 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 13)', '    #define FXAA_QUALITY_PS 6', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 4.0', '    #define FXAA_QUALITY_P5 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 14)', '    #define FXAA_QUALITY_PS 7', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 4.0', '    #define FXAA_QUALITY_P6 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 15)', '    #define FXAA_QUALITY_PS 8', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 4.0', '    #define FXAA_QUALITY_P7 12.0', '#endif', '', '/*============================================================================', '                     FXAA QUALITY - LOW DITHER PRESETS', '============================================================================*/', '#if (FXAA_QUALITY_PRESET == 20)', '    #define FXAA_QUALITY_PS 3', '    #define FXAA_QUALITY_P0 1.5', '    #define FXAA_QUALITY_P1 2.0', '    #define FXAA_QUALITY_P2 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 21)', '    #define FXAA_QUALITY_PS 4', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 22)', '    #define FXAA_QUALITY_PS 5', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 23)', '    #define FXAA_QUALITY_PS 6', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 24)', '    #define FXAA_QUALITY_PS 7', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 3.0', '    #define FXAA_QUALITY_P6 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 25)', '    #define FXAA_QUALITY_PS 8', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 4.0', '    #define FXAA_QUALITY_P7 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 26)', '    #define FXAA_QUALITY_PS 9', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 4.0', '    #define FXAA_QUALITY_P8 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 27)', '    #define FXAA_QUALITY_PS 10', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 4.0', '    #define FXAA_QUALITY_P9 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 28)', '    #define FXAA_QUALITY_PS 11', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 2.0', '    #define FXAA_QUALITY_P9 4.0', '    #define FXAA_QUALITY_P10 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 29)', '    #define FXAA_QUALITY_PS 12', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 2.0', '    #define FXAA_QUALITY_P9 2.0', '    #define FXAA_QUALITY_P10 4.0', '    #define FXAA_QUALITY_P11 8.0', '#endif', '', '/*============================================================================', '                     FXAA QUALITY - EXTREME QUALITY', '============================================================================*/', '#if (FXAA_QUALITY_PRESET == 39)', '    #define FXAA_QUALITY_PS 12', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.0', '    #define FXAA_QUALITY_P2 1.0', '    #define FXAA_QUALITY_P3 1.0', '    #define FXAA_QUALITY_P4 1.0', '    #define FXAA_QUALITY_P5 1.5', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 2.0', '    #define FXAA_QUALITY_P9 2.0', '    #define FXAA_QUALITY_P10 4.0', '    #define FXAA_QUALITY_P11 8.0', '#endif', '', '', '', '/*============================================================================', '', '                                API PORTING', '', '============================================================================*/', '#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)', '    #define FxaaBool bool', '    #define FxaaDiscard discard', '    #define FxaaFloat float', '    #define FxaaFloat2 vec2', '    #define FxaaFloat3 vec3', '    #define FxaaFloat4 vec4', '    #define FxaaHalf float', '    #define FxaaHalf2 vec2', '    #define FxaaHalf3 vec3', '    #define FxaaHalf4 vec4', '    #define FxaaInt2 ivec2', '    #define FxaaSat(x) clamp(x, 0.0, 1.0)', '    #define FxaaTex sampler2D', '#else', '    #define FxaaBool bool', '    #define FxaaDiscard clip(-1)', '    #define FxaaFloat float', '    #define FxaaFloat2 float2', '    #define FxaaFloat3 float3', '    #define FxaaFloat4 float4', '    #define FxaaHalf half', '    #define FxaaHalf2 half2', '    #define FxaaHalf3 half3', '    #define FxaaHalf4 half4', '    #define FxaaSat(x) saturate(x)', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_GLSL_100 == 1)', '  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)', '  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_GLSL_120 == 1)', '    // Requires,', '    //  #version 120', '    // And at least,', '    //  #extension GL_EXT_gpu_shader4 : enable', '    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)', '    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)', '    #if (FXAA_FAST_PIXEL_OFFSET == 1)', '        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)', '    #else', '        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)', '    #endif', '    #if (FXAA_GATHER4_ALPHA == 1)', '        // use #extension GL_ARB_gpu_shader5 : enable', '        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)', '        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)', '        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)', '        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)', '    #endif', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_GLSL_130 == 1)', '    // Requires \"#version 130\" or better', '    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)', '    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)', '    #if (FXAA_GATHER4_ALPHA == 1)', '        // use #extension GL_ARB_gpu_shader5 : enable', '        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)', '        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)', '        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)', '        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)', '    #endif', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_HLSL_3 == 1)', '    #define FxaaInt2 float2', '    #define FxaaTex sampler2D', '    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))', '    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_HLSL_4 == 1)', '    #define FxaaInt2 int2', '    struct FxaaTex { SamplerState smpl; Texture2D tex; };', '    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)', '    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_HLSL_5 == 1)', '    #define FxaaInt2 int2', '    struct FxaaTex { SamplerState smpl; Texture2D tex; };', '    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)', '    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)', '    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)', '    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)', '    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)', '    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)', '#endif', '', '', '/*============================================================================', '                   GREEN AS LUMA OPTION SUPPORT FUNCTION', '============================================================================*/', '#if (FXAA_GREEN_AS_LUMA == 0)', '    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }', '#else', '    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }', '#endif', '', '', '', '', '/*============================================================================', '', '                             FXAA3 QUALITY - PC', '', '============================================================================*/', '#if (FXAA_PC == 1)', '/*--------------------------------------------------------------------------*/', 'FxaaFloat4 FxaaPixelShader(', '    //', '    // Use noperspective interpolation here (turn off perspective interpolation).', '    // {xy} = center of pixel', '    FxaaFloat2 pos,', '    //', '    // Used only for FXAA Console, and not used on the 360 version.', '    // Use noperspective interpolation here (turn off perspective interpolation).', '    // {xy_} = upper left of pixel', '    // {_zw} = lower right of pixel', '    FxaaFloat4 fxaaConsolePosPos,', '    //', '    // Input color texture.', '    // {rgb_} = color in linear or perceptual color space', '    // if (FXAA_GREEN_AS_LUMA == 0)', '    //     {__a} = luma in perceptual color space (not linear)', '    FxaaTex tex,', '    //', '    // Only used on the optimized 360 version of FXAA Console.', '    // For everything but 360, just use the same input here as for \"tex\".', '    // For 360, same texture, just alias with a 2nd sampler.', '    // This sampler needs to have an exponent bias of -1.', '    FxaaTex fxaaConsole360TexExpBiasNegOne,', '    //', '    // Only used on the optimized 360 version of FXAA Console.', '    // For everything but 360, just use the same input here as for \"tex\".', '    // For 360, same texture, just alias with a 3nd sampler.', '    // This sampler needs to have an exponent bias of -2.', '    FxaaTex fxaaConsole360TexExpBiasNegTwo,', '    //', '    // Only used on FXAA Quality.', '    // This must be from a constant/uniform.', '    // {x_} = 1.0/screenWidthInPixels', '    // {_y} = 1.0/screenHeightInPixels', '    FxaaFloat2 fxaaQualityRcpFrame,', '    //', '    // Only used on FXAA Console.', '    // This must be from a constant/uniform.', '    // This effects sub-pixel AA quality and inversely sharpness.', '    //   Where N ranges between,', '    //     N = 0.50 (default)', '    //     N = 0.33 (sharper)', '    // {x__} = -N/screenWidthInPixels', '    // {_y_} = -N/screenHeightInPixels', '    // {_z_} =  N/screenWidthInPixels', '    // {__w} =  N/screenHeightInPixels', '    FxaaFloat4 fxaaConsoleRcpFrameOpt,', '    //', '    // Only used on FXAA Console.', '    // Not used on 360, but used on PS3 and PC.', '    // This must be from a constant/uniform.', '    // {x__} = -2.0/screenWidthInPixels', '    // {_y_} = -2.0/screenHeightInPixels', '    // {_z_} =  2.0/screenWidthInPixels', '    // {__w} =  2.0/screenHeightInPixels', '    FxaaFloat4 fxaaConsoleRcpFrameOpt2,', '    //', '    // Only used on FXAA Console.', '    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.', '    // This must be from a constant/uniform.', '    // {x__} =  8.0/screenWidthInPixels', '    // {_y_} =  8.0/screenHeightInPixels', '    // {_z_} = -4.0/screenWidthInPixels', '    // {__w} = -4.0/screenHeightInPixels', '    FxaaFloat4 fxaaConsole360RcpFrameOpt2,', '    //', '    // Only used on FXAA Quality.', '    // This used to be the FXAA_QUALITY_SUBPIX define.', '    // It is here now to allow easier tuning.', '    // Choose the amount of sub-pixel aliasing removal.', '    // This can effect sharpness.', '    //   1.00 - upper limit (softer)', '    //   0.75 - default amount of filtering', '    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)', '    //   0.25 - almost off', '    //   0.00 - completely off', '    FxaaFloat fxaaQualitySubpix,', '    //', '    // Only used on FXAA Quality.', '    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.', '    // It is here now to allow easier tuning.', '    // The minimum amount of local contrast required to apply algorithm.', '    //   0.333 - too little (faster)', '    //   0.250 - low quality', '    //   0.166 - default', '    //   0.125 - high quality', '    //   0.063 - overkill (slower)', '    FxaaFloat fxaaQualityEdgeThreshold,', '    //', '    // Only used on FXAA Quality.', '    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.', '    // It is here now to allow easier tuning.', '    // Trims the algorithm from processing darks.', '    //   0.0833 - upper limit (default, the start of visible unfiltered edges)', '    //   0.0625 - high quality (faster)', '    //   0.0312 - visible limit (slower)', '    // Special notes when using FXAA_GREEN_AS_LUMA,', '    //   Likely want to set this to zero.', '    //   As colors that are mostly not-green', '    //   will appear very dark in the green channel!', '    //   Tune by looking at mostly non-green content,', '    //   then start at zero and increase until aliasing is a problem.', '    FxaaFloat fxaaQualityEdgeThresholdMin,', '    //', '    // Only used on FXAA Console.', '    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.', '    // It is here now to allow easier tuning.', '    // This does not effect PS3, as this needs to be compiled in.', '    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.', '    //   Due to the PS3 being ALU bound,', '    //   there are only three safe values here: 2 and 4 and 8.', '    //   These options use the shaders ability to a free *|/ by 2|4|8.', '    // For all other platforms can be a non-power of two.', '    //   8.0 is sharper (default!!!)', '    //   4.0 is softer', '    //   2.0 is really soft (good only for vector graphics inputs)', '    FxaaFloat fxaaConsoleEdgeSharpness,', '    //', '    // Only used on FXAA Console.', '    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.', '    // It is here now to allow easier tuning.', '    // This does not effect PS3, as this needs to be compiled in.', '    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.', '    //   Due to the PS3 being ALU bound,', '    //   there are only two safe values here: 1/4 and 1/8.', '    //   These options use the shaders ability to a free *|/ by 2|4|8.', '    // The console setting has a different mapping than the quality setting.', '    // Other platforms can use other values.', '    //   0.125 leaves less aliasing, but is softer (default!!!)', '    //   0.25 leaves more aliasing, and is sharper', '    FxaaFloat fxaaConsoleEdgeThreshold,', '    //', '    // Only used on FXAA Console.', '    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.', '    // It is here now to allow easier tuning.', '    // Trims the algorithm from processing darks.', '    // The console setting has a different mapping than the quality setting.', '    // This only applies when FXAA_EARLY_EXIT is 1.', '    // This does not apply to PS3,', '    // PS3 was simplified to avoid more shader instructions.', '    //   0.06 - faster but more aliasing in darks', '    //   0.05 - default', '    //   0.04 - slower and less aliasing in darks', '    // Special notes when using FXAA_GREEN_AS_LUMA,', '    //   Likely want to set this to zero.', '    //   As colors that are mostly not-green', '    //   will appear very dark in the green channel!', '    //   Tune by looking at mostly non-green content,', '    //   then start at zero and increase until aliasing is a problem.', '    FxaaFloat fxaaConsoleEdgeThresholdMin,', '    //', '    // Extra constants for 360 FXAA Console only.', '    // Use zeros or anything else for other platforms.', '    // These must be in physical constant registers and NOT immediates.', '    // Immediates will result in compiler un-optimizing.', '    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)', '    FxaaFloat4 fxaaConsole360ConstDir', ') {', '/*--------------------------------------------------------------------------*/', '    FxaaFloat2 posM;', '    posM.x = pos.x;', '    posM.y = pos.y;', '    #if (FXAA_GATHER4_ALPHA == 1)', '        #if (FXAA_DISCARD == 0)', '            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);', '            #if (FXAA_GREEN_AS_LUMA == 0)', '                #define lumaM rgbyM.w', '            #else', '                #define lumaM rgbyM.y', '            #endif', '        #endif', '        #if (FXAA_GREEN_AS_LUMA == 0)', '            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);', '            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));', '        #else', '            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);', '            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));', '        #endif', '        #if (FXAA_DISCARD == 1)', '            #define lumaM luma4A.w', '        #endif', '        #define lumaE luma4A.z', '        #define lumaS luma4A.x', '        #define lumaSE luma4A.y', '        #define lumaNW luma4B.w', '        #define lumaN luma4B.z', '        #define lumaW luma4B.x', '    #else', '        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);', '        #if (FXAA_GREEN_AS_LUMA == 0)', '            #define lumaM rgbyM.w', '        #else', '            #define lumaM rgbyM.y', '        #endif', '        #if (FXAA_GLSL_100 == 1)', '          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));', '        #else', '          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));', '        #endif', '    #endif', '/*--------------------------------------------------------------------------*/', '    FxaaFloat maxSM = max(lumaS, lumaM);', '    FxaaFloat minSM = min(lumaS, lumaM);', '    FxaaFloat maxESM = max(lumaE, maxSM);', '    FxaaFloat minESM = min(lumaE, minSM);', '    FxaaFloat maxWN = max(lumaN, lumaW);', '    FxaaFloat minWN = min(lumaN, lumaW);', '    FxaaFloat rangeMax = max(maxWN, maxESM);', '    FxaaFloat rangeMin = min(minWN, minESM);', '    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;', '    FxaaFloat range = rangeMax - rangeMin;', '    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);', '    FxaaBool earlyExit = range < rangeMaxClamped;', '/*--------------------------------------------------------------------------*/', '    if(earlyExit)', '        #if (FXAA_DISCARD == 1)', '            FxaaDiscard;', '        #else', '            return rgbyM;', '        #endif', '/*--------------------------------------------------------------------------*/', '    #if (FXAA_GATHER4_ALPHA == 0)', '        #if (FXAA_GLSL_100 == 1)', '          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));', '        #else', '          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));', '        #endif', '    #else', '        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));', '        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));', '    #endif', '/*--------------------------------------------------------------------------*/', '    FxaaFloat lumaNS = lumaN + lumaS;', '    FxaaFloat lumaWE = lumaW + lumaE;', '    FxaaFloat subpixRcpRange = 1.0/range;', '    FxaaFloat subpixNSWE = lumaNS + lumaWE;', '    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;', '    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat lumaNESE = lumaNE + lumaSE;', '    FxaaFloat lumaNWNE = lumaNW + lumaNE;', '    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;', '    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat lumaNWSW = lumaNW + lumaSW;', '    FxaaFloat lumaSWSE = lumaSW + lumaSE;', '    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);', '    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);', '    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;', '    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;', '    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;', '    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;', '    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;', '    FxaaBool horzSpan = edgeHorz >= edgeVert;', '    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;', '/*--------------------------------------------------------------------------*/', '    if(!horzSpan) lumaN = lumaW;', '    if(!horzSpan) lumaS = lumaE;', '    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;', '    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat gradientN = lumaN - lumaM;', '    FxaaFloat gradientS = lumaS - lumaM;', '    FxaaFloat lumaNN = lumaN + lumaM;', '    FxaaFloat lumaSS = lumaS + lumaM;', '    FxaaBool pairN = abs(gradientN) >= abs(gradientS);', '    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));', '    if(pairN) lengthSign = -lengthSign;', '    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);', '/*--------------------------------------------------------------------------*/', '    FxaaFloat2 posB;', '    posB.x = posM.x;', '    posB.y = posM.y;', '    FxaaFloat2 offNP;', '    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;', '    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;', '    if(!horzSpan) posB.x += lengthSign * 0.5;', '    if( horzSpan) posB.y += lengthSign * 0.5;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat2 posN;', '    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;', '    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;', '    FxaaFloat2 posP;', '    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;', '    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;', '    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;', '    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));', '    FxaaFloat subpixE = subpixC * subpixC;', '    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));', '/*--------------------------------------------------------------------------*/', '    if(!pairN) lumaNN = lumaSS;', '    FxaaFloat gradientScaled = gradient * 1.0/4.0;', '    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;', '    FxaaFloat subpixF = subpixD * subpixE;', '    FxaaBool lumaMLTZero = lumaMM < 0.0;', '/*--------------------------------------------------------------------------*/', '    lumaEndN -= lumaNN * 0.5;', '    lumaEndP -= lumaNN * 0.5;', '    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;', '    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;', '    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;', '    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;', '    FxaaBool doneNP = (!doneN) || (!doneP);', '    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;', '    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;', '/*--------------------------------------------------------------------------*/', '    if(doneNP) {', '        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '        doneN = abs(lumaEndN) >= gradientScaled;', '        doneP = abs(lumaEndP) >= gradientScaled;', '        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;', '        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;', '        doneNP = (!doneN) || (!doneP);', '        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;', '        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;', '/*--------------------------------------------------------------------------*/', '        #if (FXAA_QUALITY_PS > 3)', '        if(doneNP) {', '            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '            doneN = abs(lumaEndN) >= gradientScaled;', '            doneP = abs(lumaEndP) >= gradientScaled;', '            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;', '            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;', '            doneNP = (!doneN) || (!doneP);', '            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;', '            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;', '/*--------------------------------------------------------------------------*/', '            #if (FXAA_QUALITY_PS > 4)', '            if(doneNP) {', '                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                doneN = abs(lumaEndN) >= gradientScaled;', '                doneP = abs(lumaEndP) >= gradientScaled;', '                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;', '                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;', '                doneNP = (!doneN) || (!doneP);', '                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;', '                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;', '/*--------------------------------------------------------------------------*/', '                #if (FXAA_QUALITY_PS > 5)', '                if(doneNP) {', '                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                    doneN = abs(lumaEndN) >= gradientScaled;', '                    doneP = abs(lumaEndP) >= gradientScaled;', '                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;', '                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;', '                    doneNP = (!doneN) || (!doneP);', '                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;', '                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;', '/*--------------------------------------------------------------------------*/', '                    #if (FXAA_QUALITY_PS > 6)', '                    if(doneNP) {', '                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                        doneN = abs(lumaEndN) >= gradientScaled;', '                        doneP = abs(lumaEndP) >= gradientScaled;', '                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;', '                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;', '                        doneNP = (!doneN) || (!doneP);', '                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;', '                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;', '/*--------------------------------------------------------------------------*/', '                        #if (FXAA_QUALITY_PS > 7)', '                        if(doneNP) {', '                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                            doneN = abs(lumaEndN) >= gradientScaled;', '                            doneP = abs(lumaEndP) >= gradientScaled;', '                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;', '                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;', '                            doneNP = (!doneN) || (!doneP);', '                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;', '                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;', '/*--------------------------------------------------------------------------*/', '    #if (FXAA_QUALITY_PS > 8)', '    if(doneNP) {', '        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '        doneN = abs(lumaEndN) >= gradientScaled;', '        doneP = abs(lumaEndP) >= gradientScaled;', '        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;', '        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;', '        doneNP = (!doneN) || (!doneP);', '        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;', '        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;', '/*--------------------------------------------------------------------------*/', '        #if (FXAA_QUALITY_PS > 9)', '        if(doneNP) {', '            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '            doneN = abs(lumaEndN) >= gradientScaled;', '            doneP = abs(lumaEndP) >= gradientScaled;', '            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;', '            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;', '            doneNP = (!doneN) || (!doneP);', '            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;', '            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;', '/*--------------------------------------------------------------------------*/', '            #if (FXAA_QUALITY_PS > 10)', '            if(doneNP) {', '                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                doneN = abs(lumaEndN) >= gradientScaled;', '                doneP = abs(lumaEndP) >= gradientScaled;', '                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;', '                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;', '                doneNP = (!doneN) || (!doneP);', '                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;', '                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;', '/*--------------------------------------------------------------------------*/', '                #if (FXAA_QUALITY_PS > 11)', '                if(doneNP) {', '                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                    doneN = abs(lumaEndN) >= gradientScaled;', '                    doneP = abs(lumaEndP) >= gradientScaled;', '                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;', '                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;', '                    doneNP = (!doneN) || (!doneP);', '                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;', '                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;', '/*--------------------------------------------------------------------------*/', '                    #if (FXAA_QUALITY_PS > 12)', '                    if(doneNP) {', '                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                        doneN = abs(lumaEndN) >= gradientScaled;', '                        doneP = abs(lumaEndP) >= gradientScaled;', '                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;', '                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;', '                        doneNP = (!doneN) || (!doneP);', '                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;', '                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;', '/*--------------------------------------------------------------------------*/', '                    }', '                    #endif', '/*--------------------------------------------------------------------------*/', '                }', '                #endif', '/*--------------------------------------------------------------------------*/', '            }', '            #endif', '/*--------------------------------------------------------------------------*/', '        }', '        #endif', '/*--------------------------------------------------------------------------*/', '    }', '    #endif', '/*--------------------------------------------------------------------------*/', '                        }', '                        #endif', '/*--------------------------------------------------------------------------*/', '                    }', '                    #endif', '/*--------------------------------------------------------------------------*/', '                }', '                #endif', '/*--------------------------------------------------------------------------*/', '            }', '            #endif', '/*--------------------------------------------------------------------------*/', '        }', '        #endif', '/*--------------------------------------------------------------------------*/', '    }', '/*--------------------------------------------------------------------------*/', '    FxaaFloat dstN = posM.x - posN.x;', '    FxaaFloat dstP = posP.x - posM.x;', '    if(!horzSpan) dstN = posM.y - posN.y;', '    if(!horzSpan) dstP = posP.y - posM.y;', '/*--------------------------------------------------------------------------*/', '    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;', '    FxaaFloat spanLength = (dstP + dstN);', '    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;', '    FxaaFloat spanLengthRcp = 1.0/spanLength;', '/*--------------------------------------------------------------------------*/', '    FxaaBool directionN = dstN < dstP;', '    FxaaFloat dst = min(dstN, dstP);', '    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;', '    FxaaFloat subpixG = subpixF * subpixF;', '    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;', '    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;', '    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);', '    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;', '    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;', '    #if (FXAA_DISCARD == 1)', '        return FxaaTexTop(tex, posM);', '    #else', '        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);', '    #endif', '}', '/*==========================================================================*/', '#endif', '', 'void main() {', '  gl_FragColor = FxaaPixelShader(', '    vUv,', '    vec4(0.0),', '    tDiffuse,', '    tDiffuse,', '    tDiffuse,', '    resolution,', '    vec4(0.0),', '    vec4(0.0),', '    vec4(0.0),', '    0.75,', '    0.166,', '    0.0833,', '    0.0,', '    0.0,', '    0.0,', '    vec4(0.0)', '  );', '', '  // TODO avoid querying texture twice for same texel', '  gl_FragColor.a = texture2D(tDiffuse, vUv).a;', '}'].join('\\n')\r\n};\r\n\r\nexport { FXAAShader };\r\n", "/**\r\n * Focus shader\r\n * based on PaintEffect postprocess from ro.me\r\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\r\n */\r\nconst FocusShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    screenWidth: {\r\n      value: 1024\r\n    },\r\n    screenHeight: {\r\n      value: 1024\r\n    },\r\n    sampleDistance: {\r\n      value: 0.94\r\n    },\r\n    waveFactor: {\r\n      value: 0.00125\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform float screenWidth;', 'uniform float screenHeight;', 'uniform float sampleDistance;', 'uniform float waveFactor;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 color, org, tmp, add;', '\tfloat sample_dist, f;', '\tvec2 vin;', '\tvec2 uv = vUv;', '\tadd = color = org = texture2D( tDiffuse, uv );', '\tvin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );', '\tsample_dist = dot( vin, vin ) * 2.0;', '\tf = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;', '\tvec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tadd += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );', '\tif( tmp.b < color.b ) color = tmp;', '\tcolor = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );', '\tcolor = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );', '\tgl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );', '}'].join('\\n')\r\n};\r\n\r\nexport { FocusShader };\r\n", "import { Vector2 } from 'three';\r\n\r\n/**\r\n * Edge Detection Shader using Frei-Chen filter\r\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\r\n *\r\n * aspect: vec2 of (1/width, 1/height)\r\n */\r\n\r\nconst FreiChenShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    aspect: {\r\n      value: new Vector2(512, 512)\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'uniform vec2 aspect;', 'vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);', 'mat3 G[9];', // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\r\n  'const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );', 'const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );', 'const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );', 'const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );', 'const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );', 'const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );', 'const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );', 'const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );', 'const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );', 'void main(void)', '{', '\tG[0] = g0,', '\tG[1] = g1,', '\tG[2] = g2,', '\tG[3] = g3,', '\tG[4] = g4,', '\tG[5] = g5,', '\tG[6] = g6,', '\tG[7] = g7,', '\tG[8] = g8;', '\tmat3 I;', '\tfloat cnv[9];', '\tvec3 sample;',\r\n  /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\r\n  '\tfor (float i=0.0; i<3.0; i++) {', '\t\tfor (float j=0.0; j<3.0; j++) {', '\t\t\tsample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;', '\t\t\tI[int(i)][int(j)] = length(sample);', '\t\t}', '\t}',\r\n  /* calculate the convolution values for all the masks */\r\n  '\tfor (int i=0; i<9; i++) {', '\t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);', '\t\tcnv[i] = dp3 * dp3;', '\t}', '\tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);', '\tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);', '\tgl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);', '}'].join('\\n')\r\n};\r\n\r\nexport { FreiChenShader };\r\n", "/**\r\n * Based on Nvidia Cg tutorial\r\n */\r\nconst FresnelShader = {\r\n  uniforms: {\r\n    mRefractionRatio: {\r\n      value: 1.02\r\n    },\r\n    mFresnelBias: {\r\n      value: 0.1\r\n    },\r\n    mFresnelPower: {\r\n      value: 2.0\r\n    },\r\n    mFresnelScale: {\r\n      value: 1.0\r\n    },\r\n    tCube: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader: ['uniform float mRefractionRatio;', 'uniform float mFresnelBias;', 'uniform float mFresnelScale;', 'uniform float mFresnelPower;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );', '\tvec3 I = worldPosition.xyz - cameraPosition;', '\tvReflect = reflect( I, worldNormal );', '\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );', '\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );', '\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );', '\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\r\n  fragmentShader: ['uniform samplerCube tCube;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );', '\tvec4 refractedColor = vec4( 1.0 );', '\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;', '\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;', '\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;', '\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );', '}'].join('\\n')\r\n};\r\n\r\nexport { FresnelShader };\r\n", "/**\r\n * Gamma Correction Shader\r\n * http://en.wikipedia.org/wiki/gamma_correction\r\n */\r\nconst GammaCorrectionShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 tex = texture2D( tDiffuse, vUv );', '\tgl_FragColor = LinearTosRGB( tex );', '}'].join('\\n')\r\n};\r\n\r\nexport { GammaCorrectionShader };\r\n", "import { Vector3, Color } from 'three';\r\n\r\n/**\r\n * God-rays (crepuscular rays)\r\n *\r\n * Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].\r\n * Blurs a mask generated from the depth map along radial lines emanating from the light\r\n * source. The blur repeatedly applies a blur filter of increasing support but constant\r\n * sample count to produce a blur filter with large support.\r\n *\r\n * My implementation performs 3 passes, similar to the implementation from Sousa. I found\r\n * just 6 samples per pass produced acceptible results. The blur is applied three times,\r\n * with decreasing filter support. The result is equivalent to a single pass with\r\n * 6*6*6 = 216 samples.\r\n *\r\n * References:\r\n *\r\n * Sousa2008 - Crysis Next Gen Effects, GDC2008, http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt\r\n */\r\n\r\nconst GodRaysDepthMaskShader = {\r\n  uniforms: {\r\n    tInput: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = uv;', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D tInput;', 'void main() {', '\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );', '}'].join('\\n')\r\n};\r\n/**\r\n * The god-ray generation shader.\r\n *\r\n * First pass:\r\n *\r\n * The depth map is blurred along radial lines towards the \"sun\". The\r\n * output is written to a temporary render target (I used a 1/4 sized\r\n * target).\r\n *\r\n * Pass two & three:\r\n *\r\n * The results of the previous pass are re-blurred, each time with a\r\n * decreased distance between samples.\r\n */\r\n\r\nconst GodRaysGenerateShader = {\r\n  uniforms: {\r\n    tInput: {\r\n      value: null\r\n    },\r\n    fStepSize: {\r\n      value: 1.0\r\n    },\r\n    vSunPositionScreenSpace: {\r\n      value: new Vector3()\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = uv;', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['#define TAPS_PER_PASS 6.0', 'varying vec2 vUv;', 'uniform sampler2D tInput;', 'uniform vec3 vSunPositionScreenSpace;', 'uniform float fStepSize;', // filter step size\r\n  'void main() {', // delta from current pixel to \"sun\" position\r\n  '\tvec2 delta = vSunPositionScreenSpace.xy - vUv;', '\tfloat dist = length( delta );', // Step vector (uv space)\r\n  '\tvec2 stepv = fStepSize * delta / dist;', // Number of iterations between pixel and sun\r\n  '\tfloat iters = dist/fStepSize;', '\tvec2 uv = vUv.xy;', '\tfloat col = 0.0;', // This breaks ANGLE in Chrome 22\r\n  //\t- see http://code.google.com/p/chromium/issues/detail?id=153105\r\n\r\n  /*\r\n  // Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\r\n  // so i've just left the loop\r\n  \"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\",\r\n  // Accumulate samples, making sure we dont walk past the light source.\r\n  // The check for uv.y < 1 would not be necessary with \"border\" UV wrap\r\n  // mode, with a black border color. I don't think this is currently\r\n  // exposed by three.js. As a result there might be artifacts when the\r\n  // sun is to the left, right or bottom of screen as these cases are\r\n  // not specifically handled.\r\n  \"\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\",\r\n  \"\tuv += stepv;\",\r\n  \"}\",\r\n  */\r\n  // Unrolling loop manually makes it work in ANGLE\r\n  '\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );', // used to fade out godrays\r\n  '\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', // Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\r\n  // objectionable artifacts, in particular near the sun position. The side\r\n  // effect is that the result is darker than it should be around the sun, as\r\n  // TAPS_PER_PASS is greater than the number of samples actually accumulated.\r\n  // When the result is inverted (in the shader 'godrays_combine', this produces\r\n  // a slight bright spot at the position of the sun, even when it is occluded.\r\n  '\tgl_FragColor = vec4( col/TAPS_PER_PASS );', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\r\n};\r\n/**\r\n * Additively applies god rays from texture tGodRays to a background (tColors).\r\n * fGodRayIntensity attenuates the god rays.\r\n */\r\n\r\nconst GodRaysCombineShader = {\r\n  uniforms: {\r\n    tColors: {\r\n      value: null\r\n    },\r\n    tGodRays: {\r\n      value: null\r\n    },\r\n    fGodRayIntensity: {\r\n      value: 0.69\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D tColors;', 'uniform sampler2D tGodRays;', 'uniform float fGodRayIntensity;', 'void main() {', // Since THREE.MeshDepthMaterial renders foreground objects white and background\r\n  // objects black, the god-rays will be white streaks. Therefore value is inverted\r\n  // before being combined with tColors\r\n  '\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\r\n};\r\n/**\r\n * A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be\r\n * cheaper/faster/simpler to implement this as a simple sun sprite.\r\n */\r\n\r\nconst GodRaysFakeSunShader = {\r\n  uniforms: {\r\n    vSunPositionScreenSpace: {\r\n      value: new Vector3()\r\n    },\r\n    fAspect: {\r\n      value: 1.0\r\n    },\r\n    sunColor: {\r\n      value: new Color(0xffee00)\r\n    },\r\n    bgColor: {\r\n      value: new Color(0x000000)\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['varying vec2 vUv;', 'uniform vec3 vSunPositionScreenSpace;', 'uniform float fAspect;', 'uniform vec3 sunColor;', 'uniform vec3 bgColor;', 'void main() {', '\tvec2 diff = vUv - vSunPositionScreenSpace.xy;', // Correct for aspect ratio\r\n  '\tdiff.x *= fAspect;', '\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );', '\tprop = 0.35 * pow( 1.0 - prop, 3.0 );', '\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;', '\tgl_FragColor.w = 1.0;', '}'].join('\\n')\r\n};\r\n\r\nexport { GodRaysCombineShader, GodRaysDepthMaskShader, GodRaysFakeSunShader, GodRaysGenerateShader };\r\n", "/**\r\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\r\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\r\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\r\n *\r\n * - 9 samples per pass\r\n * - standard deviation 2.7\r\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\r\n */\r\nconst HorizontalBlurShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    h: {\r\n      value: 1.0 / 512.0\r\n    }\r\n  },\r\n  vertexShader:\r\n  /* glsl */\r\n  `\r\n      varying vec2 vUv;\r\n\r\n      void main() {\r\n\r\n        vUv = uv;\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n      }\r\n  `,\r\n  fragmentShader:\r\n  /* glsl */\r\n  `\r\n    uniform sampler2D tDiffuse;\r\n    uniform float h;\r\n\r\n    varying vec2 vUv;\r\n\r\n    void main() {\r\n\r\n    \tvec4 sum = vec4( 0.0 );\r\n\r\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\r\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\r\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\r\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\r\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\r\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\r\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\r\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\r\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\r\n\r\n    \tgl_FragColor = sum;\r\n\r\n    }\r\n  `\r\n};\r\n\r\nexport { HorizontalBlurShader };\r\n", "/**\r\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\r\n *\r\n * - 9 samples per pass\r\n * - standard deviation 2.7\r\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\r\n * - \"r\" parameter control where \"focused\" horizontal line lies\r\n */\r\nconst HorizontalTiltShiftShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    h: {\r\n      value: 1.0 / 512.0\r\n    },\r\n    r: {\r\n      value: 0.35\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float h;', 'uniform float r;', 'varying vec2 vUv;', 'void main() {', '\tvec4 sum = vec4( 0.0 );', '\tfloat hh = h * abs( r - vUv.y );', '\tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;', '\tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;', '\tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;', '\tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;', '\tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;', '\tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;', '\tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;', '\tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;', '\tgl_FragColor = sum;', '}'].join('\\n')\r\n};\r\n\r\nexport { HorizontalTiltShiftShader };\r\n", "/**\r\n * Hue and saturation adjustment\r\n * https://github.com/evanw/glfx.js\r\n * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.\r\n * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\r\n */\r\nconst HueSaturationShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    hue: {\r\n      value: 0\r\n    },\r\n    saturation: {\r\n      value: 0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float hue;', 'uniform float saturation;', 'varying vec2 vUv;', 'void main() {', '\tgl_FragColor = texture2D( tDiffuse, vUv );', // hue\r\n  '\tfloat angle = hue * 3.14159265;', '\tfloat s = sin(angle), c = cos(angle);', '\tvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;', '\tfloat len = length(gl_FragColor.rgb);', '\tgl_FragColor.rgb = vec3(', '\t\tdot(gl_FragColor.rgb, weights.xyz),', '\t\tdot(gl_FragColor.rgb, weights.zxy),', '\t\tdot(gl_FragColor.rgb, weights.yzx)', '\t);', // saturation\r\n  '\tfloat average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;', '\tif (saturation > 0.0) {', '\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));', '\t} else {', '\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);', '\t}', '}'].join('\\n')\r\n};\r\n\r\nexport { HueSaturationShader };\r\n", "/**\r\n * Kaleidoscope Shader\r\n * Radial reflection around center point\r\n * Ported from: http://pixelshaders.com/editor/\r\n * by Toby Schachman / http://tobyschachman.com/\r\n *\r\n * sides: number of reflections\r\n * angle: initial angle in radians\r\n */\r\nconst KaleidoShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    sides: {\r\n      value: 6.0\r\n    },\r\n    angle: {\r\n      value: 0.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float sides;', 'uniform float angle;', 'varying vec2 vUv;', 'void main() {', '\tvec2 p = vUv - 0.5;', '\tfloat r = length(p);', '\tfloat a = atan(p.y, p.x) + angle;', '\tfloat tau = 2. * 3.1416 ;', '\ta = mod(a, tau/sides);', '\ta = abs(a - tau/sides/2.) ;', '\tp = r * vec2(cos(a), sin(a));', '\tvec4 color = texture2D(tDiffuse, p + 0.5);', '\tgl_FragColor = color;', '}'].join('\\n')\r\n};\r\n\r\nexport { KaleidoShader };\r\n", "/**\r\n * Mirror Shader\r\n * Copies half the input to the other half\r\n *\r\n * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)\r\n */\r\nconst MirrorShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    side: {\r\n      value: 1\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform int side;', 'varying vec2 vUv;', 'void main() {', '\tvec2 p = vUv;', '\tif (side == 0){', '\t\tif (p.x > 0.5) p.x = 1.0 - p.x;', '\t}else if (side == 1){', '\t\tif (p.x < 0.5) p.x = 1.0 - p.x;', '\t}else if (side == 2){', '\t\tif (p.y < 0.5) p.y = 1.0 - p.y;', '\t}else if (side == 3){', '\t\tif (p.y > 0.5) p.y = 1.0 - p.y;', '\t} ', '\tvec4 color = texture2D(tDiffuse, p);', '\tgl_FragColor = color;', '}'].join('\\n')\r\n};\r\n\r\nexport { MirrorShader };\r\n", "import { Vector2 } from 'three';\r\n\r\n/**\r\n * Normal map shader\r\n * - compute normals from heightmap\r\n */\r\n\r\nconst NormalMapShader = {\r\n  uniforms: {\r\n    heightMap: {\r\n      value: null\r\n    },\r\n    resolution: {\r\n      value: new Vector2(512, 512)\r\n    },\r\n    scale: {\r\n      value: new Vector2(1, 1)\r\n    },\r\n    height: {\r\n      value: 0.05\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform float height;', 'uniform vec2 resolution;', 'uniform sampler2D heightMap;', 'varying vec2 vUv;', 'void main() {', '\tfloat val = texture2D( heightMap, vUv ).x;', '\tfloat valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;', '\tfloat valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;', '\tgl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );', '}'].join('\\n')\r\n};\r\n\r\nexport { NormalMapShader };\r\n", "// Parallax Occlusion shaders from\r\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\r\n// No tangent-space transforms logic based on\r\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\r\nconst ParallaxShader = {\r\n  // Ordered from fastest to best quality.\r\n  modes: {\r\n    none: 'NO_PARALLAX',\r\n    basic: 'USE_BASIC_PARALLAX',\r\n    steep: 'USE_STEEP_PARALLAX',\r\n    occlusion: 'USE_OCLUSION_PARALLAX',\r\n    // a.k.a. POM\r\n    relief: 'USE_RELIEF_PARALLAX'\r\n  },\r\n  uniforms: {\r\n    bumpMap: {\r\n      value: null\r\n    },\r\n    map: {\r\n      value: null\r\n    },\r\n    parallaxScale: {\r\n      value: null\r\n    },\r\n    parallaxMinLayers: {\r\n      value: null\r\n    },\r\n    parallaxMaxLayers: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', 'void main() {', '\tvUv = uv;', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvViewPosition = -mvPosition.xyz;', '\tvNormal = normalize( normalMatrix * normal );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D bumpMap;', 'uniform sampler2D map;', 'uniform float parallaxScale;', 'uniform float parallaxMinLayers;', 'uniform float parallaxMaxLayers;', 'varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', '#ifdef USE_BASIC_PARALLAX', '\tvec2 parallaxMap( in vec3 V ) {', '\t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;', // No Offset Limitting: messy, floating output at grazing angles.\r\n  //\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\r\n  // Offset Limiting\r\n  '\t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;', '\t\treturn vUv - texCoordOffset;', '\t}', '#else', '\tvec2 parallaxMap( in vec3 V ) {', // Determine number of layers from angle between V and N\r\n  '\t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );', '\t\tfloat layerHeight = 1.0 / numLayers;', '\t\tfloat currentLayerHeight = 0.0;', // Shift of texture coordinates for each iteration\r\n  '\t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;', '\t\tvec2 currentTextureCoords = vUv;', '\t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // while ( heightFromTexture > currentLayerHeight )\r\n  // Infinite loops are not well supported. Do a \"large\" finite\r\n  // loop, but not too large, as it slows down some compilers.\r\n  '\t\tfor ( int i = 0; i < 30; i += 1 ) {', '\t\t\tif ( heightFromTexture <= currentLayerHeight ) {', '\t\t\t\tbreak;', '\t\t\t}', '\t\t\tcurrentLayerHeight += layerHeight;', // Shift texture coordinates along vector V\r\n  '\t\t\tcurrentTextureCoords -= dtex;', '\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', '\t\t}', '\t\t#ifdef USE_STEEP_PARALLAX', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_RELIEF_PARALLAX )', '\t\t\tvec2 deltaTexCoord = dtex / 2.0;', '\t\t\tfloat deltaHeight = layerHeight / 2.0;', // Return to the mid point of previous layer\r\n  '\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\tcurrentLayerHeight -= deltaHeight;', // Binary search to increase precision of Steep Parallax Mapping\r\n  '\t\t\tconst int numSearches = 5;', '\t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {', '\t\t\t\tdeltaTexCoord /= 2.0;', '\t\t\t\tdeltaHeight /= 2.0;', '\t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // Shift along or against vector V\r\n  '\t\t\t\tif( heightFromTexture > currentLayerHeight ) {', // Below the surface\r\n  '\t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight += deltaHeight;', '\t\t\t\t} else {', // above the surface\r\n  '\t\t\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight -= deltaHeight;', '\t\t\t\t}', '\t\t\t}', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_OCLUSION_PARALLAX )', '\t\t\tvec2 prevTCoords = currentTextureCoords + dtex;', // Heights for linear interpolation\r\n  '\t\t\tfloat nextH = heightFromTexture - currentLayerHeight;', '\t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;', // Proportions for linear interpolation\r\n  '\t\t\tfloat weight = nextH / ( nextH - prevH );', // Interpolation of texture coordinates\r\n  '\t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );', '\t\t#else', // NO_PARALLAX\r\n  '\t\t\treturn vUv;', '\t\t#endif', '\t}', '#endif', 'vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {', '\tvec2 texDx = dFdx( vUv );', '\tvec2 texDy = dFdy( vUv );', '\tvec3 vSigmaX = dFdx( surfPosition );', '\tvec3 vSigmaY = dFdy( surfPosition );', '\tvec3 vR1 = cross( vSigmaY, surfNormal );', '\tvec3 vR2 = cross( surfNormal, vSigmaX );', '\tfloat fDet = dot( vSigmaX, vR1 );', '\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );', '\tvec3 vProjVtex;', '\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;', '\tvProjVtex.z = dot( surfNormal, viewPosition );', '\treturn parallaxMap( vProjVtex );', '}', 'void main() {', '\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );', '\tgl_FragColor = texture2D( map, mapUv );', '}'].join('\\n')\r\n};\r\n\r\nexport { ParallaxShader };\r\n", "/**\r\n * Pixelation shader\r\n */\r\nconst PixelShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    resolution: {\r\n      value: null\r\n    },\r\n    pixelSize: {\r\n      value: 1\r\n    }\r\n  },\r\n  vertexShader: ['varying highp vec2 vUv;', 'void main() {', 'vUv = uv;', 'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float pixelSize;', 'uniform vec2 resolution;', 'varying highp vec2 vUv;', 'void main(){', 'vec2 dxy = pixelSize / resolution;', 'vec2 coord = dxy * floor( vUv / dxy );', 'gl_FragColor = texture2D(tDiffuse, coord);', '}'].join('\\n')\r\n};\r\n\r\nexport { PixelShader };\r\n", "/**\r\n * RGB Shift Shader\r\n * Shifts red and blue channels from center in opposite directions\r\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\r\n * by Tom Butterworth / http://kriss.cx/tom/\r\n *\r\n * amount: shift distance (1 is width of input)\r\n * angle: shift angle in radians\r\n */\r\nconst RGBShiftShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    amount: {\r\n      value: 0.005\r\n    },\r\n    angle: {\r\n      value: 0.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float amount;', 'uniform float angle;', 'varying vec2 vUv;', 'void main() {', '\tvec2 offset = amount * vec2( cos(angle), sin(angle));', '\tvec4 cr = texture2D(tDiffuse, vUv + offset);', '\tvec4 cga = texture2D(tDiffuse, vUv);', '\tvec4 cb = texture2D(tDiffuse, vUv - offset);', '\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);', '}'].join('\\n')\r\n};\r\n\r\nexport { RGBShiftShader };\r\n", "/**\r\n * Sepia tone shader\r\n * based on glfx.js sepia shader\r\n * https://github.com/evanw/glfx.js\r\n */\r\nconst SepiaShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    amount: {\r\n      value: 1.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform float amount;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 color = texture2D( tDiffuse, vUv );', '\tvec3 c = color.rgb;', '\tcolor.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );', '\tcolor.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );', '\tcolor.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );', '\tgl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );', '}'].join('\\n')\r\n};\r\n\r\nexport { SepiaShader };\r\n", "import { Vector2 } from 'three';\r\n\r\n/**\r\n * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\r\n *\r\n * As mentioned in the video the Sobel operator expects a grayscale image as input.\r\n *\r\n */\r\n\r\nconst SobelOperatorShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    resolution: {\r\n      value: new Vector2()\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );', // kernel definition (in glsl matrices are filled in column-major order)\r\n  '\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );', // x direction kernel\r\n  '\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );', // y direction kernel\r\n  // fetch the 3x3 neighbourhood of a fragment\r\n  // first column\r\n  '\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;', '\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;', '\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;', // second column\r\n  '\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;', '\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;', '\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;', // third column\r\n  '\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;', '\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;', '\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;', // gradient value in x direction\r\n  '\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ', '\t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ', '\t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ', // gradient value in y direction\r\n  '\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ', '\t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ', '\t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ', // magnitute of the total gradient\r\n  '\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );', '\tgl_FragColor = vec4( vec3( G ), 1 );', '}'].join('\\n')\r\n};\r\n\r\nexport { SobelOperatorShader };\r\n", "import { ShaderChunk, UniformsUtils, ShaderLib, Color } from 'three';\r\n\r\n/**\r\n * ------------------------------------------------------------------------------------------\r\n * Subsurface Scattering shader\r\n * Based on GDC 2011 – Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look\r\n * https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/\r\n *------------------------------------------------------------------------------------------\r\n */\r\n\r\nfunction replaceAll(string, find, replace) {\r\n  return string.split(find).join(replace);\r\n}\r\n\r\nconst meshphong_frag_head = ShaderChunk['meshphong_frag'].slice(0, ShaderChunk['meshphong_frag'].indexOf('void main() {'));\r\nconst meshphong_frag_body = ShaderChunk['meshphong_frag'].slice(ShaderChunk['meshphong_frag'].indexOf('void main() {'));\r\nconst SubsurfaceScatteringShader = {\r\n  uniforms: UniformsUtils.merge([ShaderLib['phong'].uniforms, {\r\n    thicknessMap: {\r\n      value: null\r\n    },\r\n    thicknessColor: {\r\n      value: new Color(0xffffff)\r\n    },\r\n    thicknessDistortion: {\r\n      value: 0.1\r\n    },\r\n    thicknessAmbient: {\r\n      value: 0.0\r\n    },\r\n    thicknessAttenuation: {\r\n      value: 0.1\r\n    },\r\n    thicknessPower: {\r\n      value: 2.0\r\n    },\r\n    thicknessScale: {\r\n      value: 10.0\r\n    }\r\n  }]),\r\n  vertexShader: ['#define USE_UV', ShaderChunk['meshphong_vert']].join('\\n'),\r\n  fragmentShader: ['#define USE_UV', '#define SUBSURFACE', meshphong_frag_head, 'uniform sampler2D thicknessMap;', 'uniform float thicknessPower;', 'uniform float thicknessScale;', 'uniform float thicknessDistortion;', 'uniform float thicknessAmbient;', 'uniform float thicknessAttenuation;', 'uniform vec3 thicknessColor;', 'void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {', '\tvec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;', '\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));', '\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;', '\tvec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;', '\treflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;', '}', meshphong_frag_body.replace('#include <lights_fragment_begin>', replaceAll(ShaderChunk['lights_fragment_begin'], 'RE_Direct( directLight, geometry, material, reflectedLight );', ['RE_Direct( directLight, geometry, material, reflectedLight );', '#if defined( SUBSURFACE ) && defined( USE_UV )', ' RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);', '#endif'].join('\\n')))].join('\\n')\r\n};\r\n\r\nexport { SubsurfaceScatteringShader };\r\n", "/**\r\n * Technicolor Shader\r\n * Simulates the look of the two-strip technicolor process popular in early 20th century films.\r\n * More historical info here: http://www.widescreenmuseum.com/oldcolor/technicolor1.htm\r\n * Demo here: http://charliehoey.com/technicolor_shader/shader_test.html\r\n */\r\nconst TechnicolorShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );', '\tvec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);', '\tgl_FragColor = newTex;', '}'].join('\\n')\r\n};\r\n\r\nexport { TechnicolorShader };\r\n", "import { Vector3, Color } from 'three';\r\n\r\n/**\r\n * Currently contains:\r\n *\r\n *\ttoon1\r\n *\ttoon2\r\n *\thatching\r\n *\tdotted\r\n */\r\n\r\nconst ToonShader1 = {\r\n  uniforms: {\r\n    uDirLightPos: {\r\n      value: new Vector3()\r\n    },\r\n    uDirLightColor: {\r\n      value: new Color(0xeeeeee)\r\n    },\r\n    uAmbientLightColor: {\r\n      value: new Color(0x050505)\r\n    },\r\n    uBaseColor: {\r\n      value: new Color(0xffffff)\r\n    }\r\n  },\r\n  vertexShader: ['varying vec3 vNormal;', 'varying vec3 vRefract;', 'void main() {', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );', '\tvNormal = normalize( normalMatrix * normal );', '\tvec3 I = worldPosition.xyz - cameraPosition;', '\tvRefract = refract( normalize( I ), worldNormal, 1.02 );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\r\n  fragmentShader: ['uniform vec3 uBaseColor;', 'uniform vec3 uDirLightPos;', 'uniform vec3 uDirLightColor;', 'uniform vec3 uAmbientLightColor;', 'varying vec3 vNormal;', 'varying vec3 vRefract;', 'void main() {', '\tfloat directionalLightWeighting = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);', '\tvec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;', '\tfloat intensity = smoothstep( - 0.5, 1.0, pow( length(lightWeighting), 20.0 ) );', '\tintensity += length(lightWeighting) * 0.2;', '\tfloat cameraWeighting = dot( normalize( vNormal ), vRefract );', '\tintensity += pow( 1.0 - length( cameraWeighting ), 6.0 );', '\tintensity = intensity * 0.2 + 0.3;', '\tif ( intensity < 0.50 ) {', '\t\tgl_FragColor = vec4( 2.0 * intensity * uBaseColor, 1.0 );', '\t} else {', '\t\tgl_FragColor = vec4( 1.0 - 2.0 * ( 1.0 - intensity ) * ( 1.0 - uBaseColor ), 1.0 );', '}', '}'].join('\\n')\r\n};\r\nconst ToonShader2 = {\r\n  uniforms: {\r\n    uDirLightPos: {\r\n      value: new Vector3()\r\n    },\r\n    uDirLightColor: {\r\n      value: new Color(0xeeeeee)\r\n    },\r\n    uAmbientLightColor: {\r\n      value: new Color(0x050505)\r\n    },\r\n    uBaseColor: {\r\n      value: new Color(0xeeeeee)\r\n    },\r\n    uLineColor1: {\r\n      value: new Color(0x808080)\r\n    },\r\n    uLineColor2: {\r\n      value: new Color(0x000000)\r\n    },\r\n    uLineColor3: {\r\n      value: new Color(0x000000)\r\n    },\r\n    uLineColor4: {\r\n      value: new Color(0x000000)\r\n    }\r\n  },\r\n  vertexShader: ['varying vec3 vNormal;', 'void main() {', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tvNormal = normalize( normalMatrix * normal );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform vec3 uBaseColor;', 'uniform vec3 uLineColor1;', 'uniform vec3 uLineColor2;', 'uniform vec3 uLineColor3;', 'uniform vec3 uLineColor4;', 'uniform vec3 uDirLightPos;', 'uniform vec3 uDirLightColor;', 'uniform vec3 uAmbientLightColor;', 'varying vec3 vNormal;', 'void main() {', '\tfloat camera = max( dot( normalize( vNormal ), vec3( 0.0, 0.0, 1.0 ) ), 0.4);', '\tfloat light = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);', '\tgl_FragColor = vec4( uBaseColor, 1.0 );', '\tif ( length(uAmbientLightColor + uDirLightColor * light) < 1.00 ) {', '\t\tgl_FragColor *= vec4( uLineColor1, 1.0 );', '\t}', '\tif ( length(uAmbientLightColor + uDirLightColor * camera) < 0.50 ) {', '\t\tgl_FragColor *= vec4( uLineColor2, 1.0 );', '\t}', '}'].join('\\n')\r\n};\r\nconst ToonShaderHatching = {\r\n  uniforms: {\r\n    uDirLightPos: {\r\n      value: new Vector3()\r\n    },\r\n    uDirLightColor: {\r\n      value: new Color(0xeeeeee)\r\n    },\r\n    uAmbientLightColor: {\r\n      value: new Color(0x050505)\r\n    },\r\n    uBaseColor: {\r\n      value: new Color(0xffffff)\r\n    },\r\n    uLineColor1: {\r\n      value: new Color(0x000000)\r\n    },\r\n    uLineColor2: {\r\n      value: new Color(0x000000)\r\n    },\r\n    uLineColor3: {\r\n      value: new Color(0x000000)\r\n    },\r\n    uLineColor4: {\r\n      value: new Color(0x000000)\r\n    }\r\n  },\r\n  vertexShader: ['varying vec3 vNormal;', 'void main() {', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tvNormal = normalize( normalMatrix * normal );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform vec3 uBaseColor;', 'uniform vec3 uLineColor1;', 'uniform vec3 uLineColor2;', 'uniform vec3 uLineColor3;', 'uniform vec3 uLineColor4;', 'uniform vec3 uDirLightPos;', 'uniform vec3 uDirLightColor;', 'uniform vec3 uAmbientLightColor;', 'varying vec3 vNormal;', 'void main() {', '\tfloat directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);', '\tvec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;', '\tgl_FragColor = vec4( uBaseColor, 1.0 );', '\tif ( length(lightWeighting) < 1.00 ) {', '\t\tif ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {', '\t\t\tgl_FragColor = vec4( uLineColor1, 1.0 );', '\t\t}', '\t}', '\tif ( length(lightWeighting) < 0.75 ) {', '\t\tif (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {', '\t\t\tgl_FragColor = vec4( uLineColor2, 1.0 );', '\t\t}', '\t}', '\tif ( length(lightWeighting) < 0.50 ) {', '\t\tif (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {', '\t\t\tgl_FragColor = vec4( uLineColor3, 1.0 );', '\t\t}', '\t}', '\tif ( length(lightWeighting) < 0.3465 ) {', '\t\tif (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {', '\t\t\tgl_FragColor = vec4( uLineColor4, 1.0 );', '\t}', '\t}', '}'].join('\\n')\r\n};\r\nconst ToonShaderDotted = {\r\n  uniforms: {\r\n    uDirLightPos: {\r\n      value: new Vector3()\r\n    },\r\n    uDirLightColor: {\r\n      value: new Color(0xeeeeee)\r\n    },\r\n    uAmbientLightColor: {\r\n      value: new Color(0x050505)\r\n    },\r\n    uBaseColor: {\r\n      value: new Color(0xffffff)\r\n    },\r\n    uLineColor1: {\r\n      value: new Color(0x000000)\r\n    }\r\n  },\r\n  vertexShader: ['varying vec3 vNormal;', 'void main() {', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tvNormal = normalize( normalMatrix * normal );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform vec3 uBaseColor;', 'uniform vec3 uLineColor1;', 'uniform vec3 uLineColor2;', 'uniform vec3 uLineColor3;', 'uniform vec3 uLineColor4;', 'uniform vec3 uDirLightPos;', 'uniform vec3 uDirLightColor;', 'uniform vec3 uAmbientLightColor;', 'varying vec3 vNormal;', 'void main() {', 'float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);', 'vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;', 'gl_FragColor = vec4( uBaseColor, 1.0 );', 'if ( length(lightWeighting) < 1.00 ) {', '\t\tif ( ( mod(gl_FragCoord.x, 4.001) + mod(gl_FragCoord.y, 4.0) ) > 6.00 ) {', '\t\t\tgl_FragColor = vec4( uLineColor1, 1.0 );', '\t\t}', '\t}', '\tif ( length(lightWeighting) < 0.50 ) {', '\t\tif ( ( mod(gl_FragCoord.x + 2.0, 4.001) + mod(gl_FragCoord.y + 2.0, 4.0) ) > 6.00 ) {', '\t\t\tgl_FragColor = vec4( uLineColor1, 1.0 );', '\t\t}', '\t}', '}'].join('\\n')\r\n};\r\n\r\nexport { ToonShader1, ToonShader2, ToonShaderDotted, ToonShaderHatching };\r\n", "import { Vector2 } from 'three';\r\n\r\n/**\r\n * Triangle blur shader\r\n * based on glfx.js triangle blur shader\r\n * https://github.com/evanw/glfx.js\r\n *\r\n * A basic blur filter, which convolves the image with a\r\n * pyramid filter. The pyramid filter is separable and is applied as two\r\n * perpendicular triangle filters.\r\n */\r\n\r\nconst TriangleBlurShader = {\r\n  uniforms: {\r\n    texture: {\r\n      value: null\r\n    },\r\n    delta: {\r\n      value: new Vector2(1, 1)\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['#include <common>', '#define ITERATIONS 10.0', 'uniform sampler2D texture;', 'uniform vec2 delta;', 'varying vec2 vUv;', 'void main() {', '\tvec4 color = vec4( 0.0 );', '\tfloat total = 0.0;', // randomize the lookup values to hide the fixed number of samples\r\n  '\tfloat offset = rand( vUv );', '\tfor ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {', '\t\tfloat percent = ( t + offset - 0.5 ) / ITERATIONS;', '\t\tfloat weight = 1.0 - abs( percent );', '\t\tcolor += texture2D( texture, vUv + delta * percent ) * weight;', '\t\ttotal += weight;', '\t}', '\tgl_FragColor = color / total;', '}'].join('\\n')\r\n};\r\n\r\nexport { TriangleBlurShader };\r\n", "/**\r\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\r\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\r\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\r\n *\r\n * - 9 samples per pass\r\n * - standard deviation 2.7\r\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\r\n */\r\nconst VerticalBlurShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    v: {\r\n      value: 1.0 / 512.0\r\n    }\r\n  },\r\n  vertexShader:\r\n  /* glsl */\r\n  `\r\n    varying vec2 vUv;\r\n\r\n    void main() {\r\n\r\n      vUv = uv;\r\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n    }\r\n  `,\r\n  fragmentShader:\r\n  /* glsl */\r\n  `\r\n\r\n  uniform sampler2D tDiffuse;\r\n  uniform float v;\r\n\r\n  varying vec2 vUv;\r\n\r\n  void main() {\r\n\r\n    vec4 sum = vec4( 0.0 );\r\n\r\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\r\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\r\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\r\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\r\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\r\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\r\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\r\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\r\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\r\n\r\n    gl_FragColor = sum;\r\n\r\n  }\r\n  `\r\n};\r\n\r\nexport { VerticalBlurShader };\r\n", "/**\r\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\r\n *\r\n * - 9 samples per pass\r\n * - standard deviation 2.7\r\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\r\n * - \"r\" parameter control where \"focused\" horizontal line lies\r\n */\r\nconst VerticalTiltShiftShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    v: {\r\n      value: 1.0 / 512.0\r\n    },\r\n    r: {\r\n      value: 0.35\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float v;', 'uniform float r;', 'varying vec2 vUv;', 'void main() {', '\tvec4 sum = vec4( 0.0 );', '\tfloat vv = v * abs( r - vUv.y );', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;', '\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;', '\tgl_FragColor = sum;', '}'].join('\\n')\r\n};\r\n\r\nexport { VerticalTiltShiftShader };\r\n", "/**\r\n * Vignette shader\r\n * based on PaintEffect postprocess from ro.me\r\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\r\n */\r\nconst VignetteShader = {\r\n  uniforms: {\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    offset: {\r\n      value: 1.0\r\n    },\r\n    darkness: {\r\n      value: 1.0\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform float offset;', 'uniform float darkness;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', // Eskil's vignette\r\n  '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tvec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );', '\tgl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );',\r\n  /*\r\n  // alternative version from glfx.js\r\n  // this one makes more \"dusty\" look (as opposed to \"burned\")\r\n  \"\tvec4 color = texture2D( tDiffuse, vUv );\",\r\n  \"\tfloat dist = distance( vUv, vec2( 0.5 ) );\",\r\n  \"\tcolor.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );\",\r\n  \"\tgl_FragColor = color;\",\r\n  */\r\n  '}'].join('\\n')\r\n};\r\n\r\nexport { VignetteShader };\r\n", "import { Vector3, Vector2 } from 'three';\r\n\r\n/**\r\n * Shaders to render 3D volumes using raycasting.\r\n * The applied techniques are based on similar implementations in the Visvis and Vispy projects.\r\n * This is not the only approach, therefore it's marked 1.\r\n */\r\n\r\nconst VolumeRenderShader1 = {\r\n  uniforms: {\r\n    u_size: {\r\n      value: new Vector3(1, 1, 1)\r\n    },\r\n    u_renderstyle: {\r\n      value: 0\r\n    },\r\n    u_renderthreshold: {\r\n      value: 0.5\r\n    },\r\n    u_clim: {\r\n      value: new Vector2(1, 1)\r\n    },\r\n    u_data: {\r\n      value: null\r\n    },\r\n    u_cmdata: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader: ['\t\tvarying vec4 v_nearpos;', '\t\tvarying vec4 v_farpos;', '\t\tvarying vec3 v_position;', '\t\tvoid main() {', // Prepare transforms to map to \"camera view\". See also:\r\n  // https://threejs.org/docs/#api/renderers/webgl/WebGLProgram\r\n  '\t\t\t\tmat4 viewtransformf = modelViewMatrix;', '\t\t\t\tmat4 viewtransformi = inverse(modelViewMatrix);', // Project local vertex coordinate to camera position. Then do a step\r\n  // backward (in cam coords) to the near clipping plane, and project back. Do\r\n  // the same for the far clipping plane. This gives us all the information we\r\n  // need to calculate the ray and truncate it to the viewing cone.\r\n  '\t\t\t\tvec4 position4 = vec4(position, 1.0);', '\t\t\t\tvec4 pos_in_cam = viewtransformf * position4;', // Intersection of ray and near clipping plane (z = -1 in clip coords)\r\n  '\t\t\t\tpos_in_cam.z = -pos_in_cam.w;', '\t\t\t\tv_nearpos = viewtransformi * pos_in_cam;', // Intersection of ray and far clipping plane (z = +1 in clip coords)\r\n  '\t\t\t\tpos_in_cam.z = pos_in_cam.w;', '\t\t\t\tv_farpos = viewtransformi * pos_in_cam;', // Set varyings and output pos\r\n  '\t\t\t\tv_position = position;', '\t\t\t\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;', '\t\t}'].join('\\n'),\r\n  fragmentShader: ['\t\tprecision highp float;', '\t\tprecision mediump sampler3D;', '\t\tuniform vec3 u_size;', '\t\tuniform int u_renderstyle;', '\t\tuniform float u_renderthreshold;', '\t\tuniform vec2 u_clim;', '\t\tuniform sampler3D u_data;', '\t\tuniform sampler2D u_cmdata;', '\t\tvarying vec3 v_position;', '\t\tvarying vec4 v_nearpos;', '\t\tvarying vec4 v_farpos;', // The maximum distance through our rendering volume is sqrt(3).\r\n  '\t\tconst int MAX_STEPS = 887;\t// 887 for 512^3, 1774 for 1024^3', '\t\tconst int REFINEMENT_STEPS = 4;', '\t\tconst float relative_step_size = 1.0;', '\t\tconst vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);', '\t\tconst vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);', '\t\tconst vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);', '\t\tconst float shininess = 40.0;', '\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);', '\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);', '\t\tfloat sample1(vec3 texcoords);', '\t\tvec4 apply_colormap(float val);', '\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);', '\t\tvoid main() {', // Normalize clipping plane info\r\n  '\t\t\t\tvec3 farpos = v_farpos.xyz / v_farpos.w;', '\t\t\t\tvec3 nearpos = v_nearpos.xyz / v_nearpos.w;', // Calculate unit vector pointing in the view direction through this fragment.\r\n  '\t\t\t\tvec3 view_ray = normalize(nearpos.xyz - farpos.xyz);', // Compute the (negative) distance to the front surface or near clipping plane.\r\n  // v_position is the back face of the cuboid, so the initial distance calculated in the dot\r\n  // product below is the distance from near clip plane to the back of the cuboid\r\n  '\t\t\t\tfloat distance = dot(nearpos - v_position, view_ray);', '\t\t\t\tdistance = max(distance, min((-0.5 - v_position.x) / view_ray.x,', '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.x - 0.5 - v_position.x) / view_ray.x));', '\t\t\t\tdistance = max(distance, min((-0.5 - v_position.y) / view_ray.y,', '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.y - 0.5 - v_position.y) / view_ray.y));', '\t\t\t\tdistance = max(distance, min((-0.5 - v_position.z) / view_ray.z,', '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.z - 0.5 - v_position.z) / view_ray.z));', // Now we have the starting position on the front surface\r\n  '\t\t\t\tvec3 front = v_position + view_ray * distance;', // Decide how many steps to take\r\n  '\t\t\t\tint nsteps = int(-distance / relative_step_size + 0.5);', '\t\t\t\tif ( nsteps < 1 )', '\t\t\t\t\t\tdiscard;', // Get starting location and step vector in texture coordinates\r\n  '\t\t\t\tvec3 step = ((v_position - front) / u_size) / float(nsteps);', '\t\t\t\tvec3 start_loc = front / u_size;', // For testing: show the number of steps. This helps to establish\r\n  // whether the rays are correctly oriented\r\n  //'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);',\r\n  //'return;',\r\n  '\t\t\t\tif (u_renderstyle == 0)', '\t\t\t\t\t\tcast_mip(start_loc, step, nsteps, view_ray);', '\t\t\t\telse if (u_renderstyle == 1)', '\t\t\t\t\t\tcast_iso(start_loc, step, nsteps, view_ray);', '\t\t\t\tif (gl_FragColor.a < 0.05)', '\t\t\t\t\t\tdiscard;', '\t\t}', '\t\tfloat sample1(vec3 texcoords) {', '\t\t\t\t/* Sample float value from a 3D texture. Assumes intensity data. */', '\t\t\t\treturn texture(u_data, texcoords.xyz).r;', '\t\t}', '\t\tvec4 apply_colormap(float val) {', '\t\t\t\tval = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);', '\t\t\t\treturn texture2D(u_cmdata, vec2(val, 0.5));', '\t\t}', '\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {', '\t\t\t\tfloat max_val = -1e6;', '\t\t\t\tint max_i = 100;', '\t\t\t\tvec3 loc = start_loc;', // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\r\n  // non-constant expression. So we use a hard-coded max, and an additional condition\r\n  // inside the loop.\r\n  '\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {', '\t\t\t\t\t\tif (iter >= nsteps)', '\t\t\t\t\t\t\t\tbreak;', // Sample from the 3D texture\r\n  '\t\t\t\t\t\tfloat val = sample1(loc);', // Apply MIP operation\r\n  '\t\t\t\t\t\tif (val > max_val) {', '\t\t\t\t\t\t\t\tmax_val = val;', '\t\t\t\t\t\t\t\tmax_i = iter;', '\t\t\t\t\t\t}', // Advance location deeper into the volume\r\n  '\t\t\t\t\t\tloc += step;', '\t\t\t\t}', // Refine location, gives crispier images\r\n  '\t\t\t\tvec3 iloc = start_loc + step * (float(max_i) - 0.5);', '\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);', '\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {', '\t\t\t\t\t\tmax_val = max(max_val, sample1(iloc));', '\t\t\t\t\t\tiloc += istep;', '\t\t\t\t}', // Resolve final color\r\n  '\t\t\t\tgl_FragColor = apply_colormap(max_val);', '\t\t}', '\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {', '\t\t\t\tgl_FragColor = vec4(0.0);\t// init transparent', '\t\t\t\tvec4 color3 = vec4(0.0);\t// final color', '\t\t\t\tvec3 dstep = 1.5 / u_size;\t// step to sample derivative', '\t\t\t\tvec3 loc = start_loc;', '\t\t\t\tfloat low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);', // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\r\n  // non-constant expression. So we use a hard-coded max, and an additional condition\r\n  // inside the loop.\r\n  '\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {', '\t\t\t\t\t\tif (iter >= nsteps)', '\t\t\t\t\t\t\t\tbreak;', // Sample from the 3D texture\r\n  '\t\t\t\t\t\tfloat val = sample1(loc);', '\t\t\t\t\t\tif (val > low_threshold) {', // Take the last interval in smaller steps\r\n  '\t\t\t\t\t\t\t\tvec3 iloc = loc - 0.5 * step;', '\t\t\t\t\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);', '\t\t\t\t\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {', '\t\t\t\t\t\t\t\t\t\tval = sample1(iloc);', '\t\t\t\t\t\t\t\t\t\tif (val > u_renderthreshold) {', '\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = add_lighting(val, iloc, dstep, view_ray);', '\t\t\t\t\t\t\t\t\t\t\t\treturn;', '\t\t\t\t\t\t\t\t\t\t}', '\t\t\t\t\t\t\t\t\t\tiloc += istep;', '\t\t\t\t\t\t\t\t}', '\t\t\t\t\t\t}', // Advance location deeper into the volume\r\n  '\t\t\t\t\t\tloc += step;', '\t\t\t\t}', '\t\t}', '\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)', '\t\t{', // Calculate color by incorporating lighting\r\n  // View direction\r\n  '\t\t\t\tvec3 V = normalize(view_ray);', // calculate normal vector from gradient\r\n  '\t\t\t\tvec3 N;', '\t\t\t\tfloat val1, val2;', '\t\t\t\tval1 = sample1(loc + vec3(-step[0], 0.0, 0.0));', '\t\t\t\tval2 = sample1(loc + vec3(+step[0], 0.0, 0.0));', '\t\t\t\tN[0] = val1 - val2;', '\t\t\t\tval = max(max(val1, val2), val);', '\t\t\t\tval1 = sample1(loc + vec3(0.0, -step[1], 0.0));', '\t\t\t\tval2 = sample1(loc + vec3(0.0, +step[1], 0.0));', '\t\t\t\tN[1] = val1 - val2;', '\t\t\t\tval = max(max(val1, val2), val);', '\t\t\t\tval1 = sample1(loc + vec3(0.0, 0.0, -step[2]));', '\t\t\t\tval2 = sample1(loc + vec3(0.0, 0.0, +step[2]));', '\t\t\t\tN[2] = val1 - val2;', '\t\t\t\tval = max(max(val1, val2), val);', '\t\t\t\tfloat gm = length(N); // gradient magnitude', '\t\t\t\tN = normalize(N);', // Flip normal so it points towards viewer\r\n  '\t\t\t\tfloat Nselect = float(dot(N, V) > 0.0);', '\t\t\t\tN = (2.0 * Nselect - 1.0) * N;\t// ==\tNselect * N - (1.0-Nselect)*N;', // Init colors\r\n  '\t\t\t\tvec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);', '\t\t\t\tvec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);', '\t\t\t\tvec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);', // note: could allow multiple lights\r\n  '\t\t\t\tfor (int i=0; i<1; i++)', '\t\t\t\t{', // Get light direction (make sure to prevent zero devision)\r\n  '\t\t\t\t\t\tvec3 L = normalize(view_ray);\t//lightDirs[i];', '\t\t\t\t\t\tfloat lightEnabled = float( length(L) > 0.0 );', '\t\t\t\t\t\tL = normalize(L + (1.0 - lightEnabled));', // Calculate lighting properties\r\n  '\t\t\t\t\t\tfloat lambertTerm = clamp(dot(N, L), 0.0, 1.0);', '\t\t\t\t\t\tvec3 H = normalize(L+V); // Halfway vector', '\t\t\t\t\t\tfloat specularTerm = pow(max(dot(H, N), 0.0), shininess);', // Calculate mask\r\n  '\t\t\t\t\t\tfloat mask1 = lightEnabled;', // Calculate colors\r\n  '\t\t\t\t\t\tambient_color +=\tmask1 * ambient_color;\t// * gl_LightSource[i].ambient;', '\t\t\t\t\t\tdiffuse_color +=\tmask1 * lambertTerm;', '\t\t\t\t\t\tspecular_color += mask1 * specularTerm * specular_color;', '\t\t\t\t}', // Calculate final color by componing different components\r\n  '\t\t\t\tvec4 final_color;', '\t\t\t\tvec4 color = apply_colormap(val);', '\t\t\t\tfinal_color = color * (ambient_color + diffuse_color) + specular_color;', '\t\t\t\tfinal_color.a = color.a;', '\t\t\t\treturn final_color;', '\t\t}'].join('\\n')\r\n};\r\n\r\nexport { VolumeRenderShader1 };\r\n", "const WaterRefractionShader = {\r\n  uniforms: {\r\n    color: {\r\n      value: null\r\n    },\r\n    time: {\r\n      value: 0\r\n    },\r\n    tDiffuse: {\r\n      value: null\r\n    },\r\n    tDudv: {\r\n      value: null\r\n    },\r\n    textureMatrix: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader: ['uniform mat4 textureMatrix;', 'varying vec2 vUv;', 'varying vec4 vUvRefraction;', 'void main() {', '\tvUv = uv;', '\tvUvRefraction = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['uniform vec3 color;', 'uniform float time;', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDudv;', 'varying vec2 vUv;', 'varying vec4 vUvRefraction;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );', '}', 'void main() {', ' float waveStrength = 0.1;', ' float waveSpeed = 0.03;', // simple distortion (ripple) via dudv map (see https://www.youtube.com/watch?v=6B7IF6GOu7s)\r\n  '\tvec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;', '\tdistortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );', '\tvec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;', // new uv coords\r\n  ' vec4 uv = vec4( vUvRefraction );', ' uv.xy += distortion;', '\tvec4 base = texture2DProj( tDiffuse, uv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\r\n};\r\n\r\nexport { WaterRefractionShader };\r\n", "import { Vector2, Group, Raycaster, Matrix4 } from 'three';\r\n\r\nconst _pointer = new Vector2();\r\n\r\nconst _event = {\r\n  type: '',\r\n  data: _pointer\r\n};\r\n\r\nclass InteractiveGroup extends Group {\r\n  constructor(renderer, camera) {\r\n    super();\r\n    const scope = this;\r\n    const raycaster = new Raycaster();\r\n    const tempMatrix = new Matrix4(); // Pointer Events\r\n\r\n    const element = renderer.domElement;\r\n\r\n    function onPointerEvent(event) {\r\n      event.stopPropagation();\r\n      _pointer.x = event.clientX / element.clientWidth * 2 - 1;\r\n      _pointer.y = -(event.clientY / element.clientHeight) * 2 + 1;\r\n      raycaster.setFromCamera(_pointer, camera);\r\n      const intersects = raycaster.intersectObjects(scope.children, false);\r\n\r\n      if (intersects.length > 0) {\r\n        const intersection = intersects[0];\r\n        const object = intersection.object;\r\n        const uv = intersection.uv;\r\n        _event.type = event.type;\r\n\r\n        _event.data.set(uv.x, 1 - uv.y);\r\n\r\n        object.dispatchEvent(_event);\r\n      }\r\n    }\r\n\r\n    element.addEventListener('pointerdown', onPointerEvent);\r\n    element.addEventListener('pointerup', onPointerEvent);\r\n    element.addEventListener('pointermove', onPointerEvent);\r\n    element.addEventListener('mousedown', onPointerEvent);\r\n    element.addEventListener('mouseup', onPointerEvent);\r\n    element.addEventListener('mousemove', onPointerEvent);\r\n    element.addEventListener('click', onPointerEvent); // WebXR Controller Events\r\n    // TODO: Dispatch pointerevents too\r\n\r\n    const events = {\r\n      move: 'mousemove',\r\n      select: 'click',\r\n      selectstart: 'mousedown',\r\n      selectend: 'mouseup'\r\n    };\r\n\r\n    function onXRControllerEvent(event) {\r\n      const controller = event.target;\r\n      tempMatrix.identity().extractRotation(controller.matrixWorld);\r\n      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);\r\n      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\r\n      const intersections = raycaster.intersectObjects(scope.children, false);\r\n\r\n      if (intersections.length > 0) {\r\n        const intersection = intersections[0];\r\n        const object = intersection.object;\r\n        const uv = intersection.uv;\r\n        _event.type = events[event.type];\r\n\r\n        _event.data.set(uv.x, 1 - uv.y);\r\n\r\n        object.dispatchEvent(_event);\r\n      }\r\n    }\r\n\r\n    const controller1 = renderer.xr.getController(0);\r\n    controller1.addEventListener('move', onXRControllerEvent);\r\n    controller1.addEventListener('select', onXRControllerEvent);\r\n    controller1.addEventListener('selectstart', onXRControllerEvent);\r\n    controller1.addEventListener('selectend', onXRControllerEvent);\r\n    const controller2 = renderer.xr.getController(1);\r\n    controller2.addEventListener('move', onXRControllerEvent);\r\n    controller2.addEventListener('select', onXRControllerEvent);\r\n    controller2.addEventListener('selectstart', onXRControllerEvent);\r\n    controller2.addEventListener('selectend', onXRControllerEvent);\r\n  }\r\n\r\n}\r\n\r\nexport { InteractiveGroup };\r\n", "import { Vector2 } from 'three';\r\n\r\nconst SelectionHelper = (() => {\r\n  class SelectionHelper {\r\n    constructor(selectionBox, renderer, cssClassName) {\r\n      this.element = document.createElement('div');\r\n      this.element.classList.add(cssClassName);\r\n      this.element.style.pointerEvents = 'none';\r\n      this.renderer = renderer;\r\n      this.startPoint = new Vector2();\r\n      this.pointTopLeft = new Vector2();\r\n      this.pointBottomRight = new Vector2();\r\n      this.isDown = false;\r\n      this.renderer.domElement.addEventListener('pointerdown', event => {\r\n        this.isDown = true;\r\n        this.onSelectStart(event);\r\n      });\r\n      this.renderer.domElement.addEventListener('pointermove', event => {\r\n        if (this.isDown) {\r\n          this.onSelectMove(event);\r\n        }\r\n      });\r\n      this.renderer.domElement.addEventListener('pointerup', event => {\r\n        this.isDown = false;\r\n        this.onSelectOver(event);\r\n      });\r\n    }\r\n\r\n    onSelectStart(event) {\r\n      this.renderer.domElement.parentElement.appendChild(this.element);\r\n      this.element.style.left = `${event.clientX}px`;\r\n      this.element.style.top = `${event.clientY}px`;\r\n      this.element.style.width = '0px';\r\n      this.element.style.height = '0px';\r\n      this.startPoint.x = event.clientX;\r\n      this.startPoint.y = event.clientY;\r\n    }\r\n\r\n    onSelectMove(event) {\r\n      this.pointBottomRight.x = Math.max(this.startPoint.x, event.clientX);\r\n      this.pointBottomRight.y = Math.max(this.startPoint.y, event.clientY);\r\n      this.pointTopLeft.x = Math.min(this.startPoint.x, event.clientX);\r\n      this.pointTopLeft.y = Math.min(this.startPoint.y, event.clientY);\r\n      this.element.style.left = `${this.pointTopLeft.x}px`;\r\n      this.element.style.top = `${this.pointTopLeft.y}px`;\r\n      this.element.style.width = `${this.pointBottomRight.x - this.pointTopLeft.x}px`;\r\n      this.element.style.height = `${this.pointBottomRight.y - this.pointTopLeft.y}px`;\r\n    }\r\n\r\n    onSelectOver() {\r\n      this.element.parentElement.removeChild(this.element);\r\n    }\r\n\r\n  }\r\n\r\n  return SelectionHelper;\r\n})();\r\n\r\nexport { SelectionHelper };\r\n", "import { Frustum, Vector3 } from 'three';\r\n\r\n/**\r\n * This is a class to check whether objects are in a selection area in 3D space\r\n */\r\n\r\nconst SelectionBox = (() => {\r\n  const frustum = new Frustum();\r\n  const center = new Vector3();\r\n  const tmpPoint = new Vector3();\r\n  const vecNear = new Vector3();\r\n  const vecTopLeft = new Vector3();\r\n  const vecTopRight = new Vector3();\r\n  const vecDownRight = new Vector3();\r\n  const vecDownLeft = new Vector3();\r\n  const vecFarTopLeft = new Vector3();\r\n  const vecFarTopRight = new Vector3();\r\n  const vecFarDownRight = new Vector3();\r\n  const vecFarDownLeft = new Vector3();\r\n  const vectemp1 = new Vector3();\r\n  const vectemp2 = new Vector3();\r\n  const vectemp3 = new Vector3();\r\n\r\n  class SelectionBox {\r\n    constructor(camera, scene, deep) {\r\n      this.camera = camera;\r\n      this.scene = scene;\r\n      this.startPoint = new Vector3();\r\n      this.endPoint = new Vector3();\r\n      this.collection = [];\r\n      this.deep = deep || Number.MAX_VALUE;\r\n    }\r\n\r\n    select(startPoint, endPoint) {\r\n      this.startPoint = startPoint || this.startPoint;\r\n      this.endPoint = endPoint || this.endPoint;\r\n      this.collection = [];\r\n      this.updateFrustum(this.startPoint, this.endPoint);\r\n      this.searchChildInFrustum(frustum, this.scene);\r\n      return this.collection;\r\n    }\r\n\r\n    updateFrustum(startPoint, endPoint) {\r\n      startPoint = startPoint || this.startPoint;\r\n      endPoint = endPoint || this.endPoint; // Avoid invalid frustum\r\n\r\n      if (startPoint.x === endPoint.x) {\r\n        endPoint.x += Number.EPSILON;\r\n      }\r\n\r\n      if (startPoint.y === endPoint.y) {\r\n        endPoint.y += Number.EPSILON;\r\n      }\r\n\r\n      this.camera.updateProjectionMatrix();\r\n      this.camera.updateMatrixWorld();\r\n\r\n      if (this.camera.isPerspectiveCamera) {\r\n        tmpPoint.copy(startPoint);\r\n        tmpPoint.x = Math.min(startPoint.x, endPoint.x);\r\n        tmpPoint.y = Math.max(startPoint.y, endPoint.y);\r\n        endPoint.x = Math.max(startPoint.x, endPoint.x);\r\n        endPoint.y = Math.min(startPoint.y, endPoint.y);\r\n        vecNear.setFromMatrixPosition(this.camera.matrixWorld);\r\n        vecTopLeft.copy(tmpPoint);\r\n        vecTopRight.set(endPoint.x, tmpPoint.y, 0);\r\n        vecDownRight.copy(endPoint);\r\n        vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\r\n        vecTopLeft.unproject(this.camera);\r\n        vecTopRight.unproject(this.camera);\r\n        vecDownRight.unproject(this.camera);\r\n        vecDownLeft.unproject(this.camera);\r\n        vectemp1.copy(vecTopLeft).sub(vecNear);\r\n        vectemp2.copy(vecTopRight).sub(vecNear);\r\n        vectemp3.copy(vecDownRight).sub(vecNear);\r\n        vectemp1.normalize();\r\n        vectemp2.normalize();\r\n        vectemp3.normalize();\r\n        vectemp1.multiplyScalar(this.deep);\r\n        vectemp2.multiplyScalar(this.deep);\r\n        vectemp3.multiplyScalar(this.deep);\r\n        vectemp1.add(vecNear);\r\n        vectemp2.add(vecNear);\r\n        vectemp3.add(vecNear);\r\n        var planes = frustum.planes;\r\n        planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\r\n        planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\r\n        planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\r\n        planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\r\n        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\r\n        planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\r\n        planes[5].normal.multiplyScalar(-1);\r\n      } else if (this.camera.isOrthographicCamera) {\r\n        const left = Math.min(startPoint.x, endPoint.x);\r\n        const top = Math.max(startPoint.y, endPoint.y);\r\n        const right = Math.max(startPoint.x, endPoint.x);\r\n        const down = Math.min(startPoint.y, endPoint.y);\r\n        vecTopLeft.set(left, top, -1);\r\n        vecTopRight.set(right, top, -1);\r\n        vecDownRight.set(right, down, -1);\r\n        vecDownLeft.set(left, down, -1);\r\n        vecFarTopLeft.set(left, top, 1);\r\n        vecFarTopRight.set(right, top, 1);\r\n        vecFarDownRight.set(right, down, 1);\r\n        vecFarDownLeft.set(left, down, 1);\r\n        vecTopLeft.unproject(this.camera);\r\n        vecTopRight.unproject(this.camera);\r\n        vecDownRight.unproject(this.camera);\r\n        vecDownLeft.unproject(this.camera);\r\n        vecFarTopLeft.unproject(this.camera);\r\n        vecFarTopRight.unproject(this.camera);\r\n        vecFarDownRight.unproject(this.camera);\r\n        vecFarDownLeft.unproject(this.camera);\r\n        var planes = frustum.planes;\r\n        planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\r\n        planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\r\n        planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\r\n        planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\r\n        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\r\n        planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\r\n        planes[5].normal.multiplyScalar(-1);\r\n      } else {\r\n        console.error('THREE.SelectionBox: Unsupported camera type.');\r\n      }\r\n    }\r\n\r\n    searchChildInFrustum(frustum, object) {\r\n      if (object.isMesh || object.isLine || object.isPoints) {\r\n        if (object.material !== undefined) {\r\n          if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();\r\n          center.copy(object.geometry.boundingSphere.center);\r\n          center.applyMatrix4(object.matrixWorld);\r\n\r\n          if (frustum.containsPoint(center)) {\r\n            this.collection.push(object);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (object.children.length > 0) {\r\n        for (let x = 0; x < object.children.length; x++) {\r\n          this.searchChildInFrustum(frustum, object.children[x]);\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  return SelectionBox;\r\n})();\r\n\r\nexport { SelectionBox };\r\n", "import { Loader, LoaderUtils, FileLoader, TextureLoader, RepeatWrapping, ClampToEdgeWrapping, Texture, MeshPhongMaterial, MeshLambertMaterial, Color, sRGBEncoding, EquirectangularReflectionMapping, Matrix4, Group, Bone, PropertyBinding, Object3D, OrthographicCamera, PerspectiveCamera, PointLight, MathUtils, SpotLight, DirectionalLight, SkinnedMesh, Mesh, LineBasicMaterial, Line, Vector3, Skeleton, AmbientLight, BufferGeometry, Float32BufferAttribute, Uint16BufferAttribute, Matrix3, Vector4, AnimationClip, Quaternion, Euler, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack } from 'three';\r\nimport { unzlibSync } from 'fflate';\r\nimport { NURBSCurve } from '../curves/NURBSCurve.js';\r\n\r\n/**\r\n * Loader loads FBX file and generates Group representing FBX scene.\r\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\r\n * Versions lower than this may load but will probably have errors\r\n *\r\n * Needs Support:\r\n *  Morph normals / blend shape normals\r\n *\r\n * FBX format references:\r\n * \thttps://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\r\n *\r\n * Binary format specification:\r\n *\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\r\n */\r\n\r\nlet fbxTree;\r\nlet connections;\r\nlet sceneGraph;\r\n\r\nclass FBXLoader extends Loader {\r\n  constructor(manager) {\r\n    super(manager);\r\n  }\r\n\r\n  load(url, onLoad, onProgress, onError) {\r\n    const scope = this;\r\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\r\n    const loader = new FileLoader(this.manager);\r\n    loader.setPath(scope.path);\r\n    loader.setResponseType('arraybuffer');\r\n    loader.setRequestHeader(scope.requestHeader);\r\n    loader.setWithCredentials(scope.withCredentials);\r\n    loader.load(url, function (buffer) {\r\n      try {\r\n        onLoad(scope.parse(buffer, path));\r\n      } catch (e) {\r\n        if (onError) {\r\n          onError(e);\r\n        } else {\r\n          console.error(e);\r\n        }\r\n\r\n        scope.manager.itemError(url);\r\n      }\r\n    }, onProgress, onError);\r\n  }\r\n\r\n  parse(FBXBuffer, path) {\r\n    if (isFbxFormatBinary(FBXBuffer)) {\r\n      fbxTree = new BinaryParser().parse(FBXBuffer);\r\n    } else {\r\n      const FBXText = convertArrayBufferToString(FBXBuffer);\r\n\r\n      if (!isFbxFormatASCII(FBXText)) {\r\n        throw new Error('THREE.FBXLoader: Unknown format.');\r\n      }\r\n\r\n      if (getFbxVersion(FBXText) < 7000) {\r\n        throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));\r\n      }\r\n\r\n      fbxTree = new TextParser().parse(FBXText);\r\n    } // console.log( fbxTree );\r\n\r\n\r\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\r\n    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);\r\n  }\r\n\r\n} // Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\r\n\r\n\r\nclass FBXTreeParser {\r\n  constructor(textureLoader, manager) {\r\n    this.textureLoader = textureLoader;\r\n    this.manager = manager;\r\n  }\r\n\r\n  parse() {\r\n    connections = this.parseConnections();\r\n    const images = this.parseImages();\r\n    const textures = this.parseTextures(images);\r\n    const materials = this.parseMaterials(textures);\r\n    const deformers = this.parseDeformers();\r\n    const geometryMap = new GeometryParser().parse(deformers);\r\n    this.parseScene(deformers, geometryMap, materials);\r\n    return sceneGraph;\r\n  } // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\r\n  // and details the connection type\r\n\r\n\r\n  parseConnections() {\r\n    const connectionMap = new Map();\r\n\r\n    if ('Connections' in fbxTree) {\r\n      const rawConnections = fbxTree.Connections.connections;\r\n      rawConnections.forEach(function (rawConnection) {\r\n        const fromID = rawConnection[0];\r\n        const toID = rawConnection[1];\r\n        const relationship = rawConnection[2];\r\n\r\n        if (!connectionMap.has(fromID)) {\r\n          connectionMap.set(fromID, {\r\n            parents: [],\r\n            children: []\r\n          });\r\n        }\r\n\r\n        const parentRelationship = {\r\n          ID: toID,\r\n          relationship: relationship\r\n        };\r\n        connectionMap.get(fromID).parents.push(parentRelationship);\r\n\r\n        if (!connectionMap.has(toID)) {\r\n          connectionMap.set(toID, {\r\n            parents: [],\r\n            children: []\r\n          });\r\n        }\r\n\r\n        const childRelationship = {\r\n          ID: fromID,\r\n          relationship: relationship\r\n        };\r\n        connectionMap.get(toID).children.push(childRelationship);\r\n      });\r\n    }\r\n\r\n    return connectionMap;\r\n  } // Parse FBXTree.Objects.Video for embedded image data\r\n  // These images are connected to textures in FBXTree.Objects.Textures\r\n  // via FBXTree.Connections.\r\n\r\n\r\n  parseImages() {\r\n    const images = {};\r\n    const blobs = {};\r\n\r\n    if ('Video' in fbxTree.Objects) {\r\n      const videoNodes = fbxTree.Objects.Video;\r\n\r\n      for (const nodeID in videoNodes) {\r\n        const videoNode = videoNodes[nodeID];\r\n        const id = parseInt(nodeID);\r\n        images[id] = videoNode.RelativeFilename || videoNode.Filename; // raw image data is in videoNode.Content\r\n\r\n        if ('Content' in videoNode) {\r\n          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;\r\n          const base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== '';\r\n\r\n          if (arrayBufferContent || base64Content) {\r\n            const image = this.parseImage(videoNodes[nodeID]);\r\n            blobs[videoNode.RelativeFilename || videoNode.Filename] = image;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const id in images) {\r\n      const filename = images[id];\r\n      if (blobs[filename] !== undefined) images[id] = blobs[filename];else images[id] = images[id].split('\\\\').pop();\r\n    }\r\n\r\n    return images;\r\n  } // Parse embedded image data in FBXTree.Video.Content\r\n\r\n\r\n  parseImage(videoNode) {\r\n    const content = videoNode.Content;\r\n    const fileName = videoNode.RelativeFilename || videoNode.Filename;\r\n    const extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();\r\n    let type;\r\n\r\n    switch (extension) {\r\n      case 'bmp':\r\n        type = 'image/bmp';\r\n        break;\r\n\r\n      case 'jpg':\r\n      case 'jpeg':\r\n        type = 'image/jpeg';\r\n        break;\r\n\r\n      case 'png':\r\n        type = 'image/png';\r\n        break;\r\n\r\n      case 'tif':\r\n        type = 'image/tiff';\r\n        break;\r\n\r\n      case 'tga':\r\n        if (this.manager.getHandler('.tga') === null) {\r\n          console.warn('FBXLoader: TGA loader not found, skipping ', fileName);\r\n        }\r\n\r\n        type = 'image/tga';\r\n        break;\r\n\r\n      default:\r\n        console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\r\n        return;\r\n    }\r\n\r\n    if (typeof content === 'string') {\r\n      // ASCII format\r\n      return 'data:' + type + ';base64,' + content;\r\n    } else {\r\n      // Binary Format\r\n      const array = new Uint8Array(content);\r\n      return window.URL.createObjectURL(new Blob([array], {\r\n        type: type\r\n      }));\r\n    }\r\n  } // Parse nodes in FBXTree.Objects.Texture\r\n  // These contain details such as UV scaling, cropping, rotation etc and are connected\r\n  // to images in FBXTree.Objects.Video\r\n\r\n\r\n  parseTextures(images) {\r\n    const textureMap = new Map();\r\n\r\n    if ('Texture' in fbxTree.Objects) {\r\n      const textureNodes = fbxTree.Objects.Texture;\r\n\r\n      for (const nodeID in textureNodes) {\r\n        const texture = this.parseTexture(textureNodes[nodeID], images);\r\n        textureMap.set(parseInt(nodeID), texture);\r\n      }\r\n    }\r\n\r\n    return textureMap;\r\n  } // Parse individual node in FBXTree.Objects.Texture\r\n\r\n\r\n  parseTexture(textureNode, images) {\r\n    const texture = this.loadTexture(textureNode, images);\r\n    texture.ID = textureNode.id;\r\n    texture.name = textureNode.attrName;\r\n    const wrapModeU = textureNode.WrapModeU;\r\n    const wrapModeV = textureNode.WrapModeV;\r\n    const valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\r\n    const valueV = wrapModeV !== undefined ? wrapModeV.value : 0; // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\r\n    // 0: repeat(default), 1: clamp\r\n\r\n    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;\r\n    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;\r\n\r\n    if ('Scaling' in textureNode) {\r\n      const values = textureNode.Scaling.value;\r\n      texture.repeat.x = values[0];\r\n      texture.repeat.y = values[1];\r\n    }\r\n\r\n    return texture;\r\n  } // load a texture specified as a blob or data URI, or via an external URL using TextureLoader\r\n\r\n\r\n  loadTexture(textureNode, images) {\r\n    let fileName;\r\n    const currentPath = this.textureLoader.path;\r\n    const children = connections.get(textureNode.id).children;\r\n\r\n    if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\r\n      fileName = images[children[0].ID];\r\n\r\n      if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\r\n        this.textureLoader.setPath(undefined);\r\n      }\r\n    }\r\n\r\n    let texture;\r\n    const extension = textureNode.FileName.slice(-3).toLowerCase();\r\n\r\n    if (extension === 'tga') {\r\n      const loader = this.manager.getHandler('.tga');\r\n\r\n      if (loader === null) {\r\n        console.warn('FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename);\r\n        texture = new Texture();\r\n      } else {\r\n        loader.setPath(this.textureLoader.path);\r\n        texture = loader.load(fileName);\r\n      }\r\n    } else if (extension === 'psd') {\r\n      console.warn('FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename);\r\n      texture = new Texture();\r\n    } else {\r\n      texture = this.textureLoader.load(fileName);\r\n    }\r\n\r\n    this.textureLoader.setPath(currentPath);\r\n    return texture;\r\n  } // Parse nodes in FBXTree.Objects.Material\r\n\r\n\r\n  parseMaterials(textureMap) {\r\n    const materialMap = new Map();\r\n\r\n    if ('Material' in fbxTree.Objects) {\r\n      const materialNodes = fbxTree.Objects.Material;\r\n\r\n      for (const nodeID in materialNodes) {\r\n        const material = this.parseMaterial(materialNodes[nodeID], textureMap);\r\n        if (material !== null) materialMap.set(parseInt(nodeID), material);\r\n      }\r\n    }\r\n\r\n    return materialMap;\r\n  } // Parse single node in FBXTree.Objects.Material\r\n  // Materials are connected to texture maps in FBXTree.Objects.Textures\r\n  // FBX format currently only supports Lambert and Phong shading models\r\n\r\n\r\n  parseMaterial(materialNode, textureMap) {\r\n    const ID = materialNode.id;\r\n    const name = materialNode.attrName;\r\n    let type = materialNode.ShadingModel; // Case where FBX wraps shading model in property object.\r\n\r\n    if (typeof type === 'object') {\r\n      type = type.value;\r\n    } // Ignore unused materials which don't have any connections.\r\n\r\n\r\n    if (!connections.has(ID)) return null;\r\n    const parameters = this.parseParameters(materialNode, textureMap, ID);\r\n    let material;\r\n\r\n    switch (type.toLowerCase()) {\r\n      case 'phong':\r\n        material = new MeshPhongMaterial();\r\n        break;\r\n\r\n      case 'lambert':\r\n        material = new MeshLambertMaterial();\r\n        break;\r\n\r\n      default:\r\n        console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\r\n        material = new MeshPhongMaterial();\r\n        break;\r\n    }\r\n\r\n    material.setValues(parameters);\r\n    material.name = name;\r\n    return material;\r\n  } // Parse FBX material and return parameters suitable for a three.js material\r\n  // Also parse the texture map and return any textures associated with the material\r\n\r\n\r\n  parseParameters(materialNode, textureMap, ID) {\r\n    const parameters = {};\r\n\r\n    if (materialNode.BumpFactor) {\r\n      parameters.bumpScale = materialNode.BumpFactor.value;\r\n    }\r\n\r\n    if (materialNode.Diffuse) {\r\n      parameters.color = new Color().fromArray(materialNode.Diffuse.value);\r\n    } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB')) {\r\n      // The blender exporter exports diffuse here instead of in materialNode.Diffuse\r\n      parameters.color = new Color().fromArray(materialNode.DiffuseColor.value);\r\n    }\r\n\r\n    if (materialNode.DisplacementFactor) {\r\n      parameters.displacementScale = materialNode.DisplacementFactor.value;\r\n    }\r\n\r\n    if (materialNode.Emissive) {\r\n      parameters.emissive = new Color().fromArray(materialNode.Emissive.value);\r\n    } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB')) {\r\n      // The blender exporter exports emissive color here instead of in materialNode.Emissive\r\n      parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value);\r\n    }\r\n\r\n    if (materialNode.EmissiveFactor) {\r\n      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);\r\n    }\r\n\r\n    if (materialNode.Opacity) {\r\n      parameters.opacity = parseFloat(materialNode.Opacity.value);\r\n    }\r\n\r\n    if (parameters.opacity < 1.0) {\r\n      parameters.transparent = true;\r\n    }\r\n\r\n    if (materialNode.ReflectionFactor) {\r\n      parameters.reflectivity = materialNode.ReflectionFactor.value;\r\n    }\r\n\r\n    if (materialNode.Shininess) {\r\n      parameters.shininess = materialNode.Shininess.value;\r\n    }\r\n\r\n    if (materialNode.Specular) {\r\n      parameters.specular = new Color().fromArray(materialNode.Specular.value);\r\n    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color') {\r\n      // The blender exporter exports specular color here instead of in materialNode.Specular\r\n      parameters.specular = new Color().fromArray(materialNode.SpecularColor.value);\r\n    }\r\n\r\n    const scope = this;\r\n    connections.get(ID).children.forEach(function (child) {\r\n      const type = child.relationship;\r\n\r\n      switch (type) {\r\n        case 'Bump':\r\n          parameters.bumpMap = scope.getTexture(textureMap, child.ID);\r\n          break;\r\n\r\n        case 'Maya|TEX_ao_map':\r\n          parameters.aoMap = scope.getTexture(textureMap, child.ID);\r\n          break;\r\n\r\n        case 'DiffuseColor':\r\n        case 'Maya|TEX_color_map':\r\n          parameters.map = scope.getTexture(textureMap, child.ID);\r\n\r\n          if (parameters.map !== undefined) {\r\n            parameters.map.encoding = sRGBEncoding;\r\n          }\r\n\r\n          break;\r\n\r\n        case 'DisplacementColor':\r\n          parameters.displacementMap = scope.getTexture(textureMap, child.ID);\r\n          break;\r\n\r\n        case 'EmissiveColor':\r\n          parameters.emissiveMap = scope.getTexture(textureMap, child.ID);\r\n\r\n          if (parameters.emissiveMap !== undefined) {\r\n            parameters.emissiveMap.encoding = sRGBEncoding;\r\n          }\r\n\r\n          break;\r\n\r\n        case 'NormalMap':\r\n        case 'Maya|TEX_normal_map':\r\n          parameters.normalMap = scope.getTexture(textureMap, child.ID);\r\n          break;\r\n\r\n        case 'ReflectionColor':\r\n          parameters.envMap = scope.getTexture(textureMap, child.ID);\r\n\r\n          if (parameters.envMap !== undefined) {\r\n            parameters.envMap.mapping = EquirectangularReflectionMapping;\r\n            parameters.envMap.encoding = sRGBEncoding;\r\n          }\r\n\r\n          break;\r\n\r\n        case 'SpecularColor':\r\n          parameters.specularMap = scope.getTexture(textureMap, child.ID);\r\n\r\n          if (parameters.specularMap !== undefined) {\r\n            parameters.specularMap.encoding = sRGBEncoding;\r\n          }\r\n\r\n          break;\r\n\r\n        case 'TransparentColor':\r\n        case 'TransparencyFactor':\r\n          parameters.alphaMap = scope.getTexture(textureMap, child.ID);\r\n          parameters.transparent = true;\r\n          break;\r\n\r\n        case 'AmbientColor':\r\n        case 'ShininessExponent': // AKA glossiness map\r\n\r\n        case 'SpecularFactor': // AKA specularLevel\r\n\r\n        case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\r\n\r\n        default:\r\n          console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);\r\n          break;\r\n      }\r\n    });\r\n    return parameters;\r\n  } // get a texture from the textureMap for use by a material.\r\n\r\n\r\n  getTexture(textureMap, id) {\r\n    // if the texture is a layered texture, just use the first layer and issue a warning\r\n    if ('LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {\r\n      console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.');\r\n      id = connections.get(id).children[0].ID;\r\n    }\r\n\r\n    return textureMap.get(id);\r\n  } // Parse nodes in FBXTree.Objects.Deformer\r\n  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\r\n  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\r\n\r\n\r\n  parseDeformers() {\r\n    const skeletons = {};\r\n    const morphTargets = {};\r\n\r\n    if ('Deformer' in fbxTree.Objects) {\r\n      const DeformerNodes = fbxTree.Objects.Deformer;\r\n\r\n      for (const nodeID in DeformerNodes) {\r\n        const deformerNode = DeformerNodes[nodeID];\r\n        const relationships = connections.get(parseInt(nodeID));\r\n\r\n        if (deformerNode.attrType === 'Skin') {\r\n          const skeleton = this.parseSkeleton(relationships, DeformerNodes);\r\n          skeleton.ID = nodeID;\r\n\r\n          if (relationships.parents.length > 1) {\r\n            console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.');\r\n          }\r\n\r\n          skeleton.geometryID = relationships.parents[0].ID;\r\n          skeletons[nodeID] = skeleton;\r\n        } else if (deformerNode.attrType === 'BlendShape') {\r\n          const morphTarget = {\r\n            id: nodeID\r\n          };\r\n          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);\r\n          morphTarget.id = nodeID;\r\n\r\n          if (relationships.parents.length > 1) {\r\n            console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.');\r\n          }\r\n\r\n          morphTargets[nodeID] = morphTarget;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      skeletons: skeletons,\r\n      morphTargets: morphTargets\r\n    };\r\n  } // Parse single nodes in FBXTree.Objects.Deformer\r\n  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\r\n  // Each skin node represents a skeleton and each cluster node represents a bone\r\n\r\n\r\n  parseSkeleton(relationships, deformerNodes) {\r\n    const rawBones = [];\r\n    relationships.children.forEach(function (child) {\r\n      const boneNode = deformerNodes[child.ID];\r\n      if (boneNode.attrType !== 'Cluster') return;\r\n      const rawBone = {\r\n        ID: child.ID,\r\n        indices: [],\r\n        weights: [],\r\n        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a) // transform: new Matrix4().fromArray( boneNode.Transform.a ),\r\n        // linkMode: boneNode.Mode,\r\n\r\n      };\r\n\r\n      if ('Indexes' in boneNode) {\r\n        rawBone.indices = boneNode.Indexes.a;\r\n        rawBone.weights = boneNode.Weights.a;\r\n      }\r\n\r\n      rawBones.push(rawBone);\r\n    });\r\n    return {\r\n      rawBones: rawBones,\r\n      bones: []\r\n    };\r\n  } // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\r\n\r\n\r\n  parseMorphTargets(relationships, deformerNodes) {\r\n    const rawMorphTargets = [];\r\n\r\n    for (let i = 0; i < relationships.children.length; i++) {\r\n      const child = relationships.children[i];\r\n      const morphTargetNode = deformerNodes[child.ID];\r\n      const rawMorphTarget = {\r\n        name: morphTargetNode.attrName,\r\n        initialWeight: morphTargetNode.DeformPercent,\r\n        id: morphTargetNode.id,\r\n        fullWeights: morphTargetNode.FullWeights.a\r\n      };\r\n      if (morphTargetNode.attrType !== 'BlendShapeChannel') return;\r\n      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function (child) {\r\n        return child.relationship === undefined;\r\n      })[0].ID;\r\n      rawMorphTargets.push(rawMorphTarget);\r\n    }\r\n\r\n    return rawMorphTargets;\r\n  } // create the main Group() to be returned by the loader\r\n\r\n\r\n  parseScene(deformers, geometryMap, materialMap) {\r\n    sceneGraph = new Group();\r\n    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);\r\n    const modelNodes = fbxTree.Objects.Model;\r\n    const scope = this;\r\n    modelMap.forEach(function (model) {\r\n      const modelNode = modelNodes[model.ID];\r\n      scope.setLookAtProperties(model, modelNode);\r\n      const parentConnections = connections.get(model.ID).parents;\r\n      parentConnections.forEach(function (connection) {\r\n        const parent = modelMap.get(connection.ID);\r\n        if (parent !== undefined) parent.add(model);\r\n      });\r\n\r\n      if (model.parent === null) {\r\n        sceneGraph.add(model);\r\n      }\r\n    });\r\n    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);\r\n    this.createAmbientLight();\r\n    sceneGraph.traverse(function (node) {\r\n      if (node.userData.transformData) {\r\n        if (node.parent) {\r\n          node.userData.transformData.parentMatrix = node.parent.matrix;\r\n          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;\r\n        }\r\n\r\n        const transform = generateTransform(node.userData.transformData);\r\n        node.applyMatrix4(transform);\r\n        node.updateWorldMatrix();\r\n      }\r\n    });\r\n    const animations = new AnimationParser().parse(); // if all the models where already combined in a single group, just return that\r\n\r\n    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {\r\n      sceneGraph.children[0].animations = animations;\r\n      sceneGraph = sceneGraph.children[0];\r\n    }\r\n\r\n    sceneGraph.animations = animations;\r\n  } // parse nodes in FBXTree.Objects.Model\r\n\r\n\r\n  parseModels(skeletons, geometryMap, materialMap) {\r\n    const modelMap = new Map();\r\n    const modelNodes = fbxTree.Objects.Model;\r\n\r\n    for (const nodeID in modelNodes) {\r\n      const id = parseInt(nodeID);\r\n      const node = modelNodes[nodeID];\r\n      const relationships = connections.get(id);\r\n      let model = this.buildSkeleton(relationships, skeletons, id, node.attrName);\r\n\r\n      if (!model) {\r\n        switch (node.attrType) {\r\n          case 'Camera':\r\n            model = this.createCamera(relationships);\r\n            break;\r\n\r\n          case 'Light':\r\n            model = this.createLight(relationships);\r\n            break;\r\n\r\n          case 'Mesh':\r\n            model = this.createMesh(relationships, geometryMap, materialMap);\r\n            break;\r\n\r\n          case 'NurbsCurve':\r\n            model = this.createCurve(relationships, geometryMap);\r\n            break;\r\n\r\n          case 'LimbNode':\r\n          case 'Root':\r\n            model = new Bone();\r\n            break;\r\n\r\n          case 'Null':\r\n          default:\r\n            model = new Group();\r\n            break;\r\n        }\r\n\r\n        model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : '';\r\n        model.ID = id;\r\n      }\r\n\r\n      this.getTransformData(model, node);\r\n      modelMap.set(id, model);\r\n    }\r\n\r\n    return modelMap;\r\n  }\r\n\r\n  buildSkeleton(relationships, skeletons, id, name) {\r\n    let bone = null;\r\n    relationships.parents.forEach(function (parent) {\r\n      for (const ID in skeletons) {\r\n        const skeleton = skeletons[ID];\r\n        skeleton.rawBones.forEach(function (rawBone, i) {\r\n          if (rawBone.ID === parent.ID) {\r\n            const subBone = bone;\r\n            bone = new Bone();\r\n            bone.matrixWorld.copy(rawBone.transformLink); // set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\r\n\r\n            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : '';\r\n            bone.ID = id;\r\n            skeleton.bones[i] = bone; // In cases where a bone is shared between multiple meshes\r\n            // duplicate the bone here and and it as a child of the first bone\r\n\r\n            if (subBone !== null) {\r\n              bone.add(subBone);\r\n            }\r\n          }\r\n        });\r\n      }\r\n    });\r\n    return bone;\r\n  } // create a PerspectiveCamera or OrthographicCamera\r\n\r\n\r\n  createCamera(relationships) {\r\n    let model;\r\n    let cameraAttribute;\r\n    relationships.children.forEach(function (child) {\r\n      const attr = fbxTree.Objects.NodeAttribute[child.ID];\r\n\r\n      if (attr !== undefined) {\r\n        cameraAttribute = attr;\r\n      }\r\n    });\r\n\r\n    if (cameraAttribute === undefined) {\r\n      model = new Object3D();\r\n    } else {\r\n      let type = 0;\r\n\r\n      if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\r\n        type = 1;\r\n      }\r\n\r\n      let nearClippingPlane = 1;\r\n\r\n      if (cameraAttribute.NearPlane !== undefined) {\r\n        nearClippingPlane = cameraAttribute.NearPlane.value / 1000;\r\n      }\r\n\r\n      let farClippingPlane = 1000;\r\n\r\n      if (cameraAttribute.FarPlane !== undefined) {\r\n        farClippingPlane = cameraAttribute.FarPlane.value / 1000;\r\n      }\r\n\r\n      let width = window.innerWidth;\r\n      let height = window.innerHeight;\r\n\r\n      if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\r\n        width = cameraAttribute.AspectWidth.value;\r\n        height = cameraAttribute.AspectHeight.value;\r\n      }\r\n\r\n      const aspect = width / height;\r\n      let fov = 45;\r\n\r\n      if (cameraAttribute.FieldOfView !== undefined) {\r\n        fov = cameraAttribute.FieldOfView.value;\r\n      }\r\n\r\n      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\r\n\r\n      switch (type) {\r\n        case 0:\r\n          // Perspective\r\n          model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);\r\n          if (focalLength !== null) model.setFocalLength(focalLength);\r\n          break;\r\n\r\n        case 1:\r\n          // Orthographic\r\n          model = new OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);\r\n          break;\r\n\r\n        default:\r\n          console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');\r\n          model = new Object3D();\r\n          break;\r\n      }\r\n    }\r\n\r\n    return model;\r\n  } // Create a DirectionalLight, PointLight or SpotLight\r\n\r\n\r\n  createLight(relationships) {\r\n    let model;\r\n    let lightAttribute;\r\n    relationships.children.forEach(function (child) {\r\n      const attr = fbxTree.Objects.NodeAttribute[child.ID];\r\n\r\n      if (attr !== undefined) {\r\n        lightAttribute = attr;\r\n      }\r\n    });\r\n\r\n    if (lightAttribute === undefined) {\r\n      model = new Object3D();\r\n    } else {\r\n      let type; // LightType can be undefined for Point lights\r\n\r\n      if (lightAttribute.LightType === undefined) {\r\n        type = 0;\r\n      } else {\r\n        type = lightAttribute.LightType.value;\r\n      }\r\n\r\n      let color = 0xffffff;\r\n\r\n      if (lightAttribute.Color !== undefined) {\r\n        color = new Color().fromArray(lightAttribute.Color.value);\r\n      }\r\n\r\n      let intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100; // light disabled\r\n\r\n      if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\r\n        intensity = 0;\r\n      }\r\n\r\n      let distance = 0;\r\n\r\n      if (lightAttribute.FarAttenuationEnd !== undefined) {\r\n        if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\r\n          distance = 0;\r\n        } else {\r\n          distance = lightAttribute.FarAttenuationEnd.value;\r\n        }\r\n      } // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\r\n\r\n\r\n      const decay = 1;\r\n\r\n      switch (type) {\r\n        case 0:\r\n          // Point\r\n          model = new PointLight(color, intensity, distance, decay);\r\n          break;\r\n\r\n        case 1:\r\n          // Directional\r\n          model = new DirectionalLight(color, intensity);\r\n          break;\r\n\r\n        case 2:\r\n          // Spot\r\n          let angle = Math.PI / 3;\r\n\r\n          if (lightAttribute.InnerAngle !== undefined) {\r\n            angle = MathUtils.degToRad(lightAttribute.InnerAngle.value);\r\n          }\r\n\r\n          let penumbra = 0;\r\n\r\n          if (lightAttribute.OuterAngle !== undefined) {\r\n            // TODO: this is not correct - FBX calculates outer and inner angle in degrees\r\n            // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\r\n            // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\r\n            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);\r\n            penumbra = Math.max(penumbra, 1);\r\n          }\r\n\r\n          model = new SpotLight(color, intensity, distance, angle, penumbra, decay);\r\n          break;\r\n\r\n        default:\r\n          console.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.');\r\n          model = new PointLight(color, intensity);\r\n          break;\r\n      }\r\n\r\n      if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\r\n        model.castShadow = true;\r\n      }\r\n    }\r\n\r\n    return model;\r\n  }\r\n\r\n  createMesh(relationships, geometryMap, materialMap) {\r\n    let model;\r\n    let geometry = null;\r\n    let material = null;\r\n    const materials = []; // get geometry and materials(s) from connections\r\n\r\n    relationships.children.forEach(function (child) {\r\n      if (geometryMap.has(child.ID)) {\r\n        geometry = geometryMap.get(child.ID);\r\n      }\r\n\r\n      if (materialMap.has(child.ID)) {\r\n        materials.push(materialMap.get(child.ID));\r\n      }\r\n    });\r\n\r\n    if (materials.length > 1) {\r\n      material = materials;\r\n    } else if (materials.length > 0) {\r\n      material = materials[0];\r\n    } else {\r\n      material = new MeshPhongMaterial({\r\n        color: 0xcccccc\r\n      });\r\n      materials.push(material);\r\n    }\r\n\r\n    if ('color' in geometry.attributes) {\r\n      materials.forEach(function (material) {\r\n        material.vertexColors = true;\r\n      });\r\n    }\r\n\r\n    if (geometry.FBX_Deformer) {\r\n      model = new SkinnedMesh(geometry, material);\r\n      model.normalizeSkinWeights();\r\n    } else {\r\n      model = new Mesh(geometry, material);\r\n    }\r\n\r\n    return model;\r\n  }\r\n\r\n  createCurve(relationships, geometryMap) {\r\n    const geometry = relationships.children.reduce(function (geo, child) {\r\n      if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);\r\n      return geo;\r\n    }, null); // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\r\n\r\n    const material = new LineBasicMaterial({\r\n      color: 0x3300ff,\r\n      linewidth: 1\r\n    });\r\n    return new Line(geometry, material);\r\n  } // parse the model node for transform data\r\n\r\n\r\n  getTransformData(model, modelNode) {\r\n    const transformData = {};\r\n    if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\r\n    if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);else transformData.eulerOrder = 'ZYX';\r\n    if ('Lcl_Translation' in modelNode) transformData.translation = modelNode.Lcl_Translation.value;\r\n    if ('PreRotation' in modelNode) transformData.preRotation = modelNode.PreRotation.value;\r\n    if ('Lcl_Rotation' in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;\r\n    if ('PostRotation' in modelNode) transformData.postRotation = modelNode.PostRotation.value;\r\n    if ('Lcl_Scaling' in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;\r\n    if ('ScalingOffset' in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;\r\n    if ('ScalingPivot' in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;\r\n    if ('RotationOffset' in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;\r\n    if ('RotationPivot' in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;\r\n    model.userData.transformData = transformData;\r\n  }\r\n\r\n  setLookAtProperties(model, modelNode) {\r\n    if ('LookAtProperty' in modelNode) {\r\n      const children = connections.get(model.ID).children;\r\n      children.forEach(function (child) {\r\n        if (child.relationship === 'LookAtProperty') {\r\n          const lookAtTarget = fbxTree.Objects.Model[child.ID];\r\n\r\n          if ('Lcl_Translation' in lookAtTarget) {\r\n            const pos = lookAtTarget.Lcl_Translation.value; // DirectionalLight, SpotLight\r\n\r\n            if (model.target !== undefined) {\r\n              model.target.position.fromArray(pos);\r\n              sceneGraph.add(model.target);\r\n            } else {\r\n              // Cameras and other Object3Ds\r\n              model.lookAt(new Vector3().fromArray(pos));\r\n            }\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  bindSkeleton(skeletons, geometryMap, modelMap) {\r\n    const bindMatrices = this.parsePoseNodes();\r\n\r\n    for (const ID in skeletons) {\r\n      const skeleton = skeletons[ID];\r\n      const parents = connections.get(parseInt(skeleton.ID)).parents;\r\n      parents.forEach(function (parent) {\r\n        if (geometryMap.has(parent.ID)) {\r\n          const geoID = parent.ID;\r\n          const geoRelationships = connections.get(geoID);\r\n          geoRelationships.parents.forEach(function (geoConnParent) {\r\n            if (modelMap.has(geoConnParent.ID)) {\r\n              const model = modelMap.get(geoConnParent.ID);\r\n              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  parsePoseNodes() {\r\n    const bindMatrices = {};\r\n\r\n    if ('Pose' in fbxTree.Objects) {\r\n      const BindPoseNode = fbxTree.Objects.Pose;\r\n\r\n      for (const nodeID in BindPoseNode) {\r\n        if (BindPoseNode[nodeID].attrType === 'BindPose' && BindPoseNode[nodeID].NbPoseNodes > 0) {\r\n          const poseNodes = BindPoseNode[nodeID].PoseNode;\r\n\r\n          if (Array.isArray(poseNodes)) {\r\n            poseNodes.forEach(function (poseNode) {\r\n              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);\r\n            });\r\n          } else {\r\n            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return bindMatrices;\r\n  } // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\r\n\r\n\r\n  createAmbientLight() {\r\n    if ('GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings) {\r\n      const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\r\n      const r = ambientColor[0];\r\n      const g = ambientColor[1];\r\n      const b = ambientColor[2];\r\n\r\n      if (r !== 0 || g !== 0 || b !== 0) {\r\n        const color = new Color(r, g, b);\r\n        sceneGraph.add(new AmbientLight(color, 1));\r\n      }\r\n    }\r\n  }\r\n\r\n} // parse Geometry data from FBXTree and return map of BufferGeometries\r\n\r\n\r\nclass GeometryParser {\r\n  // Parse nodes in FBXTree.Objects.Geometry\r\n  parse(deformers) {\r\n    const geometryMap = new Map();\r\n\r\n    if ('Geometry' in fbxTree.Objects) {\r\n      const geoNodes = fbxTree.Objects.Geometry;\r\n\r\n      for (const nodeID in geoNodes) {\r\n        const relationships = connections.get(parseInt(nodeID));\r\n        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);\r\n        geometryMap.set(parseInt(nodeID), geo);\r\n      }\r\n    }\r\n\r\n    return geometryMap;\r\n  } // Parse single node in FBXTree.Objects.Geometry\r\n\r\n\r\n  parseGeometry(relationships, geoNode, deformers) {\r\n    switch (geoNode.attrType) {\r\n      case 'Mesh':\r\n        return this.parseMeshGeometry(relationships, geoNode, deformers);\r\n\r\n      case 'NurbsCurve':\r\n        return this.parseNurbsGeometry(geoNode);\r\n    }\r\n  } // Parse single node mesh geometry in FBXTree.Objects.Geometry\r\n\r\n\r\n  parseMeshGeometry(relationships, geoNode, deformers) {\r\n    const skeletons = deformers.skeletons;\r\n    const morphTargets = [];\r\n    const modelNodes = relationships.parents.map(function (parent) {\r\n      return fbxTree.Objects.Model[parent.ID];\r\n    }); // don't create geometry if it is not associated with any models\r\n\r\n    if (modelNodes.length === 0) return;\r\n    const skeleton = relationships.children.reduce(function (skeleton, child) {\r\n      if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];\r\n      return skeleton;\r\n    }, null);\r\n    relationships.children.forEach(function (child) {\r\n      if (deformers.morphTargets[child.ID] !== undefined) {\r\n        morphTargets.push(deformers.morphTargets[child.ID]);\r\n      }\r\n    }); // Assume one model and get the preRotation from that\r\n    // if there is more than one model associated with the geometry this may cause problems\r\n\r\n    const modelNode = modelNodes[0];\r\n    const transformData = {};\r\n    if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);\r\n    if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\r\n    if ('GeometricTranslation' in modelNode) transformData.translation = modelNode.GeometricTranslation.value;\r\n    if ('GeometricRotation' in modelNode) transformData.rotation = modelNode.GeometricRotation.value;\r\n    if ('GeometricScaling' in modelNode) transformData.scale = modelNode.GeometricScaling.value;\r\n    const transform = generateTransform(transformData);\r\n    return this.genGeometry(geoNode, skeleton, morphTargets, transform);\r\n  } // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\r\n\r\n\r\n  genGeometry(geoNode, skeleton, morphTargets, preTransform) {\r\n    const geo = new BufferGeometry();\r\n    if (geoNode.attrName) geo.name = geoNode.attrName;\r\n    const geoInfo = this.parseGeoNode(geoNode, skeleton);\r\n    const buffers = this.genBuffers(geoInfo);\r\n    const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);\r\n    positionAttribute.applyMatrix4(preTransform);\r\n    geo.setAttribute('position', positionAttribute);\r\n\r\n    if (buffers.colors.length > 0) {\r\n      geo.setAttribute('color', new Float32BufferAttribute(buffers.colors, 3));\r\n    }\r\n\r\n    if (skeleton) {\r\n      geo.setAttribute('skinIndex', new Uint16BufferAttribute(buffers.weightsIndices, 4));\r\n      geo.setAttribute('skinWeight', new Float32BufferAttribute(buffers.vertexWeights, 4)); // used later to bind the skeleton to the model\r\n\r\n      geo.FBX_Deformer = skeleton;\r\n    }\r\n\r\n    if (buffers.normal.length > 0) {\r\n      const normalMatrix = new Matrix3().getNormalMatrix(preTransform);\r\n      const normalAttribute = new Float32BufferAttribute(buffers.normal, 3);\r\n      normalAttribute.applyNormalMatrix(normalMatrix);\r\n      geo.setAttribute('normal', normalAttribute);\r\n    }\r\n\r\n    buffers.uvs.forEach(function (uvBuffer, i) {\r\n      // subsequent uv buffers are called 'uv1', 'uv2', ...\r\n      let name = 'uv' + (i + 1).toString(); // the first uv buffer is just called 'uv'\r\n\r\n      if (i === 0) {\r\n        name = 'uv';\r\n      }\r\n\r\n      geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2));\r\n    });\r\n\r\n    if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\r\n      // Convert the material indices of each vertex into rendering groups on the geometry.\r\n      let prevMaterialIndex = buffers.materialIndex[0];\r\n      let startIndex = 0;\r\n      buffers.materialIndex.forEach(function (currentIndex, i) {\r\n        if (currentIndex !== prevMaterialIndex) {\r\n          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\r\n          prevMaterialIndex = currentIndex;\r\n          startIndex = i;\r\n        }\r\n      }); // the loop above doesn't add the last group, do that here.\r\n\r\n      if (geo.groups.length > 0) {\r\n        const lastGroup = geo.groups[geo.groups.length - 1];\r\n        const lastIndex = lastGroup.start + lastGroup.count;\r\n\r\n        if (lastIndex !== buffers.materialIndex.length) {\r\n          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);\r\n        }\r\n      } // case where there are multiple materials but the whole geometry is only\r\n      // using one of them\r\n\r\n\r\n      if (geo.groups.length === 0) {\r\n        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);\r\n      }\r\n    }\r\n\r\n    this.addMorphTargets(geo, geoNode, morphTargets, preTransform);\r\n    return geo;\r\n  }\r\n\r\n  parseGeoNode(geoNode, skeleton) {\r\n    const geoInfo = {};\r\n    geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];\r\n    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];\r\n\r\n    if (geoNode.LayerElementColor) {\r\n      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);\r\n    }\r\n\r\n    if (geoNode.LayerElementMaterial) {\r\n      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);\r\n    }\r\n\r\n    if (geoNode.LayerElementNormal) {\r\n      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);\r\n    }\r\n\r\n    if (geoNode.LayerElementUV) {\r\n      geoInfo.uv = [];\r\n      let i = 0;\r\n\r\n      while (geoNode.LayerElementUV[i]) {\r\n        if (geoNode.LayerElementUV[i].UV) {\r\n          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));\r\n        }\r\n\r\n        i++;\r\n      }\r\n    }\r\n\r\n    geoInfo.weightTable = {};\r\n\r\n    if (skeleton !== null) {\r\n      geoInfo.skeleton = skeleton;\r\n      skeleton.rawBones.forEach(function (rawBone, i) {\r\n        // loop over the bone's vertex indices and weights\r\n        rawBone.indices.forEach(function (index, j) {\r\n          if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];\r\n          geoInfo.weightTable[index].push({\r\n            id: i,\r\n            weight: rawBone.weights[j]\r\n          });\r\n        });\r\n      });\r\n    }\r\n\r\n    return geoInfo;\r\n  }\r\n\r\n  genBuffers(geoInfo) {\r\n    const buffers = {\r\n      vertex: [],\r\n      normal: [],\r\n      colors: [],\r\n      uvs: [],\r\n      materialIndex: [],\r\n      vertexWeights: [],\r\n      weightsIndices: []\r\n    };\r\n    let polygonIndex = 0;\r\n    let faceLength = 0;\r\n    let displayedWeightsWarning = false; // these will hold data for a single face\r\n\r\n    let facePositionIndexes = [];\r\n    let faceNormals = [];\r\n    let faceColors = [];\r\n    let faceUVs = [];\r\n    let faceWeights = [];\r\n    let faceWeightIndices = [];\r\n    const scope = this;\r\n    geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\r\n      let materialIndex;\r\n      let endOfFace = false; // Face index and vertex index arrays are combined in a single array\r\n      // A cube with quad faces looks like this:\r\n      // PolygonVertexIndex: *24 {\r\n      //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\r\n      //  }\r\n      // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\r\n      // to find index of last vertex bit shift the index: ^ - 1\r\n\r\n      if (vertexIndex < 0) {\r\n        vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\r\n\r\n        endOfFace = true;\r\n      }\r\n\r\n      let weightIndices = [];\r\n      let weights = [];\r\n      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\r\n\r\n      if (geoInfo.color) {\r\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);\r\n        faceColors.push(data[0], data[1], data[2]);\r\n      }\r\n\r\n      if (geoInfo.skeleton) {\r\n        if (geoInfo.weightTable[vertexIndex] !== undefined) {\r\n          geoInfo.weightTable[vertexIndex].forEach(function (wt) {\r\n            weights.push(wt.weight);\r\n            weightIndices.push(wt.id);\r\n          });\r\n        }\r\n\r\n        if (weights.length > 4) {\r\n          if (!displayedWeightsWarning) {\r\n            console.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');\r\n            displayedWeightsWarning = true;\r\n          }\r\n\r\n          const wIndex = [0, 0, 0, 0];\r\n          const Weight = [0, 0, 0, 0];\r\n          weights.forEach(function (weight, weightIndex) {\r\n            let currentWeight = weight;\r\n            let currentIndex = weightIndices[weightIndex];\r\n            Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\r\n              if (currentWeight > comparedWeight) {\r\n                comparedWeightArray[comparedWeightIndex] = currentWeight;\r\n                currentWeight = comparedWeight;\r\n                const tmp = wIndex[comparedWeightIndex];\r\n                wIndex[comparedWeightIndex] = currentIndex;\r\n                currentIndex = tmp;\r\n              }\r\n            });\r\n          });\r\n          weightIndices = wIndex;\r\n          weights = Weight;\r\n        } // if the weight array is shorter than 4 pad with 0s\r\n\r\n\r\n        while (weights.length < 4) {\r\n          weights.push(0);\r\n          weightIndices.push(0);\r\n        }\r\n\r\n        for (let i = 0; i < 4; ++i) {\r\n          faceWeights.push(weights[i]);\r\n          faceWeightIndices.push(weightIndices[i]);\r\n        }\r\n      }\r\n\r\n      if (geoInfo.normal) {\r\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);\r\n        faceNormals.push(data[0], data[1], data[2]);\r\n      }\r\n\r\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\r\n        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];\r\n      }\r\n\r\n      if (geoInfo.uv) {\r\n        geoInfo.uv.forEach(function (uv, i) {\r\n          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);\r\n\r\n          if (faceUVs[i] === undefined) {\r\n            faceUVs[i] = [];\r\n          }\r\n\r\n          faceUVs[i].push(data[0]);\r\n          faceUVs[i].push(data[1]);\r\n        });\r\n      }\r\n\r\n      faceLength++;\r\n\r\n      if (endOfFace) {\r\n        scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);\r\n        polygonIndex++;\r\n        faceLength = 0; // reset arrays for the next face\r\n\r\n        facePositionIndexes = [];\r\n        faceNormals = [];\r\n        faceColors = [];\r\n        faceUVs = [];\r\n        faceWeights = [];\r\n        faceWeightIndices = [];\r\n      }\r\n    });\r\n    return buffers;\r\n  } // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\r\n\r\n\r\n  genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {\r\n    for (let i = 2; i < faceLength; i++) {\r\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);\r\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);\r\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);\r\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);\r\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);\r\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);\r\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);\r\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);\r\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);\r\n\r\n      if (geoInfo.skeleton) {\r\n        buffers.vertexWeights.push(faceWeights[0]);\r\n        buffers.vertexWeights.push(faceWeights[1]);\r\n        buffers.vertexWeights.push(faceWeights[2]);\r\n        buffers.vertexWeights.push(faceWeights[3]);\r\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);\r\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);\r\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);\r\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);\r\n        buffers.vertexWeights.push(faceWeights[i * 4]);\r\n        buffers.vertexWeights.push(faceWeights[i * 4 + 1]);\r\n        buffers.vertexWeights.push(faceWeights[i * 4 + 2]);\r\n        buffers.vertexWeights.push(faceWeights[i * 4 + 3]);\r\n        buffers.weightsIndices.push(faceWeightIndices[0]);\r\n        buffers.weightsIndices.push(faceWeightIndices[1]);\r\n        buffers.weightsIndices.push(faceWeightIndices[2]);\r\n        buffers.weightsIndices.push(faceWeightIndices[3]);\r\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);\r\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);\r\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);\r\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);\r\n        buffers.weightsIndices.push(faceWeightIndices[i * 4]);\r\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);\r\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);\r\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);\r\n      }\r\n\r\n      if (geoInfo.color) {\r\n        buffers.colors.push(faceColors[0]);\r\n        buffers.colors.push(faceColors[1]);\r\n        buffers.colors.push(faceColors[2]);\r\n        buffers.colors.push(faceColors[(i - 1) * 3]);\r\n        buffers.colors.push(faceColors[(i - 1) * 3 + 1]);\r\n        buffers.colors.push(faceColors[(i - 1) * 3 + 2]);\r\n        buffers.colors.push(faceColors[i * 3]);\r\n        buffers.colors.push(faceColors[i * 3 + 1]);\r\n        buffers.colors.push(faceColors[i * 3 + 2]);\r\n      }\r\n\r\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\r\n        buffers.materialIndex.push(materialIndex);\r\n        buffers.materialIndex.push(materialIndex);\r\n        buffers.materialIndex.push(materialIndex);\r\n      }\r\n\r\n      if (geoInfo.normal) {\r\n        buffers.normal.push(faceNormals[0]);\r\n        buffers.normal.push(faceNormals[1]);\r\n        buffers.normal.push(faceNormals[2]);\r\n        buffers.normal.push(faceNormals[(i - 1) * 3]);\r\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);\r\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);\r\n        buffers.normal.push(faceNormals[i * 3]);\r\n        buffers.normal.push(faceNormals[i * 3 + 1]);\r\n        buffers.normal.push(faceNormals[i * 3 + 2]);\r\n      }\r\n\r\n      if (geoInfo.uv) {\r\n        geoInfo.uv.forEach(function (uv, j) {\r\n          if (buffers.uvs[j] === undefined) buffers.uvs[j] = [];\r\n          buffers.uvs[j].push(faceUVs[j][0]);\r\n          buffers.uvs[j].push(faceUVs[j][1]);\r\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);\r\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);\r\n          buffers.uvs[j].push(faceUVs[j][i * 2]);\r\n          buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {\r\n    if (morphTargets.length === 0) return;\r\n    parentGeo.morphTargetsRelative = true;\r\n    parentGeo.morphAttributes.position = []; // parentGeo.morphAttributes.normal = []; // not implemented\r\n\r\n    const scope = this;\r\n    morphTargets.forEach(function (morphTarget) {\r\n      morphTarget.rawTargets.forEach(function (rawTarget) {\r\n        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];\r\n\r\n        if (morphGeoNode !== undefined) {\r\n          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);\r\n        }\r\n      });\r\n    });\r\n  } // a morph geometry node is similar to a standard  node, and the node is also contained\r\n  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\r\n  // and a special attribute Index defining which vertices of the original geometry are affected\r\n  // Normal and position attributes only have data for the vertices that are affected by the morph\r\n\r\n\r\n  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {\r\n    const vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];\r\n    const morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];\r\n    const indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];\r\n    const length = parentGeo.attributes.position.count * 3;\r\n    const morphPositions = new Float32Array(length);\r\n\r\n    for (let i = 0; i < indices.length; i++) {\r\n      const morphIndex = indices[i] * 3;\r\n      morphPositions[morphIndex] = morphPositionsSparse[i * 3];\r\n      morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];\r\n      morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];\r\n    } // TODO: add morph normal support\r\n\r\n\r\n    const morphGeoInfo = {\r\n      vertexIndices: vertexIndices,\r\n      vertexPositions: morphPositions\r\n    };\r\n    const morphBuffers = this.genBuffers(morphGeoInfo);\r\n    const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);\r\n    positionAttribute.name = name || morphGeoNode.attrName;\r\n    positionAttribute.applyMatrix4(preTransform);\r\n    parentGeo.morphAttributes.position.push(positionAttribute);\r\n  } // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\r\n\r\n\r\n  parseNormals(NormalNode) {\r\n    const mappingType = NormalNode.MappingInformationType;\r\n    const referenceType = NormalNode.ReferenceInformationType;\r\n    const buffer = NormalNode.Normals.a;\r\n    let indexBuffer = [];\r\n\r\n    if (referenceType === 'IndexToDirect') {\r\n      if ('NormalIndex' in NormalNode) {\r\n        indexBuffer = NormalNode.NormalIndex.a;\r\n      } else if ('NormalsIndex' in NormalNode) {\r\n        indexBuffer = NormalNode.NormalsIndex.a;\r\n      }\r\n    }\r\n\r\n    return {\r\n      dataSize: 3,\r\n      buffer: buffer,\r\n      indices: indexBuffer,\r\n      mappingType: mappingType,\r\n      referenceType: referenceType\r\n    };\r\n  } // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\r\n\r\n\r\n  parseUVs(UVNode) {\r\n    const mappingType = UVNode.MappingInformationType;\r\n    const referenceType = UVNode.ReferenceInformationType;\r\n    const buffer = UVNode.UV.a;\r\n    let indexBuffer = [];\r\n\r\n    if (referenceType === 'IndexToDirect') {\r\n      indexBuffer = UVNode.UVIndex.a;\r\n    }\r\n\r\n    return {\r\n      dataSize: 2,\r\n      buffer: buffer,\r\n      indices: indexBuffer,\r\n      mappingType: mappingType,\r\n      referenceType: referenceType\r\n    };\r\n  } // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\r\n\r\n\r\n  parseVertexColors(ColorNode) {\r\n    const mappingType = ColorNode.MappingInformationType;\r\n    const referenceType = ColorNode.ReferenceInformationType;\r\n    const buffer = ColorNode.Colors.a;\r\n    let indexBuffer = [];\r\n\r\n    if (referenceType === 'IndexToDirect') {\r\n      indexBuffer = ColorNode.ColorIndex.a;\r\n    }\r\n\r\n    return {\r\n      dataSize: 4,\r\n      buffer: buffer,\r\n      indices: indexBuffer,\r\n      mappingType: mappingType,\r\n      referenceType: referenceType\r\n    };\r\n  } // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\r\n\r\n\r\n  parseMaterialIndices(MaterialNode) {\r\n    const mappingType = MaterialNode.MappingInformationType;\r\n    const referenceType = MaterialNode.ReferenceInformationType;\r\n\r\n    if (mappingType === 'NoMappingInformation') {\r\n      return {\r\n        dataSize: 1,\r\n        buffer: [0],\r\n        indices: [0],\r\n        mappingType: 'AllSame',\r\n        referenceType: referenceType\r\n      };\r\n    }\r\n\r\n    const materialIndexBuffer = MaterialNode.Materials.a; // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\r\n    // we expect.So we create an intermediate buffer that points to the index in the buffer,\r\n    // for conforming with the other functions we've written for other data.\r\n\r\n    const materialIndices = [];\r\n\r\n    for (let i = 0; i < materialIndexBuffer.length; ++i) {\r\n      materialIndices.push(i);\r\n    }\r\n\r\n    return {\r\n      dataSize: 1,\r\n      buffer: materialIndexBuffer,\r\n      indices: materialIndices,\r\n      mappingType: mappingType,\r\n      referenceType: referenceType\r\n    };\r\n  } // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\r\n\r\n\r\n  parseNurbsGeometry(geoNode) {\r\n    if (NURBSCurve === undefined) {\r\n      console.error('THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');\r\n      return new BufferGeometry();\r\n    }\r\n\r\n    const order = parseInt(geoNode.Order);\r\n\r\n    if (isNaN(order)) {\r\n      console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id);\r\n      return new BufferGeometry();\r\n    }\r\n\r\n    const degree = order - 1;\r\n    const knots = geoNode.KnotVector.a;\r\n    const controlPoints = [];\r\n    const pointsValues = geoNode.Points.a;\r\n\r\n    for (let i = 0, l = pointsValues.length; i < l; i += 4) {\r\n      controlPoints.push(new Vector4().fromArray(pointsValues, i));\r\n    }\r\n\r\n    let startKnot, endKnot;\r\n\r\n    if (geoNode.Form === 'Closed') {\r\n      controlPoints.push(controlPoints[0]);\r\n    } else if (geoNode.Form === 'Periodic') {\r\n      startKnot = degree;\r\n      endKnot = knots.length - 1 - startKnot;\r\n\r\n      for (let i = 0; i < degree; ++i) {\r\n        controlPoints.push(controlPoints[i]);\r\n      }\r\n    }\r\n\r\n    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\r\n    const points = curve.getPoints(controlPoints.length * 12);\r\n    return new BufferGeometry().setFromPoints(points);\r\n  }\r\n\r\n} // parse animation data from FBXTree\r\n\r\n\r\nclass AnimationParser {\r\n  // take raw animation clips and turn them into three.js animation clips\r\n  parse() {\r\n    const animationClips = [];\r\n    const rawClips = this.parseClips();\r\n\r\n    if (rawClips !== undefined) {\r\n      for (const key in rawClips) {\r\n        const rawClip = rawClips[key];\r\n        const clip = this.addClip(rawClip);\r\n        animationClips.push(clip);\r\n      }\r\n    }\r\n\r\n    return animationClips;\r\n  }\r\n\r\n  parseClips() {\r\n    // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\r\n    // if this is undefined we can safely assume there are no animations\r\n    if (fbxTree.Objects.AnimationCurve === undefined) return undefined;\r\n    const curveNodesMap = this.parseAnimationCurveNodes();\r\n    this.parseAnimationCurves(curveNodesMap);\r\n    const layersMap = this.parseAnimationLayers(curveNodesMap);\r\n    const rawClips = this.parseAnimStacks(layersMap);\r\n    return rawClips;\r\n  } // parse nodes in FBXTree.Objects.AnimationCurveNode\r\n  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\r\n  // and is referenced by an AnimationLayer\r\n\r\n\r\n  parseAnimationCurveNodes() {\r\n    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\r\n    const curveNodesMap = new Map();\r\n\r\n    for (const nodeID in rawCurveNodes) {\r\n      const rawCurveNode = rawCurveNodes[nodeID];\r\n\r\n      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {\r\n        const curveNode = {\r\n          id: rawCurveNode.id,\r\n          attr: rawCurveNode.attrName,\r\n          curves: {}\r\n        };\r\n        curveNodesMap.set(curveNode.id, curveNode);\r\n      }\r\n    }\r\n\r\n    return curveNodesMap;\r\n  } // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\r\n  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\r\n  // axis ( e.g. times and values of x rotation)\r\n\r\n\r\n  parseAnimationCurves(curveNodesMap) {\r\n    const rawCurves = fbxTree.Objects.AnimationCurve; // TODO: Many values are identical up to roundoff error, but won't be optimised\r\n    // e.g. position times: [0, 0.4, 0. 8]\r\n    // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\r\n    // clearly, this should be optimised to\r\n    // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\r\n    // this shows up in nearly every FBX file, and generally time array is length > 100\r\n\r\n    for (const nodeID in rawCurves) {\r\n      const animationCurve = {\r\n        id: rawCurves[nodeID].id,\r\n        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\r\n        values: rawCurves[nodeID].KeyValueFloat.a\r\n      };\r\n      const relationships = connections.get(animationCurve.id);\r\n\r\n      if (relationships !== undefined) {\r\n        const animationCurveID = relationships.parents[0].ID;\r\n        const animationCurveRelationship = relationships.parents[0].relationship;\r\n\r\n        if (animationCurveRelationship.match(/X/)) {\r\n          curveNodesMap.get(animationCurveID).curves['x'] = animationCurve;\r\n        } else if (animationCurveRelationship.match(/Y/)) {\r\n          curveNodesMap.get(animationCurveID).curves['y'] = animationCurve;\r\n        } else if (animationCurveRelationship.match(/Z/)) {\r\n          curveNodesMap.get(animationCurveID).curves['z'] = animationCurve;\r\n        } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {\r\n          curveNodesMap.get(animationCurveID).curves['morph'] = animationCurve;\r\n        }\r\n      }\r\n    }\r\n  } // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\r\n  // to various AnimationCurveNodes and is referenced by an AnimationStack node\r\n  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\r\n\r\n\r\n  parseAnimationLayers(curveNodesMap) {\r\n    const rawLayers = fbxTree.Objects.AnimationLayer;\r\n    const layersMap = new Map();\r\n\r\n    for (const nodeID in rawLayers) {\r\n      const layerCurveNodes = [];\r\n      const connection = connections.get(parseInt(nodeID));\r\n\r\n      if (connection !== undefined) {\r\n        // all the animationCurveNodes used in the layer\r\n        const children = connection.children;\r\n        children.forEach(function (child, i) {\r\n          if (curveNodesMap.has(child.ID)) {\r\n            const curveNode = curveNodesMap.get(child.ID); // check that the curves are defined for at least one axis, otherwise ignore the curveNode\r\n\r\n            if (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {\r\n              if (layerCurveNodes[i] === undefined) {\r\n                const modelID = connections.get(child.ID).parents.filter(function (parent) {\r\n                  return parent.relationship !== undefined;\r\n                })[0].ID;\r\n\r\n                if (modelID !== undefined) {\r\n                  const rawModel = fbxTree.Objects.Model[modelID.toString()];\r\n\r\n                  if (rawModel === undefined) {\r\n                    console.warn('THREE.FBXLoader: Encountered a unused curve.', child);\r\n                    return;\r\n                  }\r\n\r\n                  const node = {\r\n                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\r\n                    ID: rawModel.id,\r\n                    initialPosition: [0, 0, 0],\r\n                    initialRotation: [0, 0, 0],\r\n                    initialScale: [1, 1, 1]\r\n                  };\r\n                  sceneGraph.traverse(function (child) {\r\n                    if (child.ID === rawModel.id) {\r\n                      node.transform = child.matrix;\r\n                      if (child.userData.transformData) node.eulerOrder = child.userData.transformData.eulerOrder;\r\n                    }\r\n                  });\r\n                  if (!node.transform) node.transform = new Matrix4(); // if the animated model is pre rotated, we'll have to apply the pre rotations to every\r\n                  // animation value as well\r\n\r\n                  if ('PreRotation' in rawModel) node.preRotation = rawModel.PreRotation.value;\r\n                  if ('PostRotation' in rawModel) node.postRotation = rawModel.PostRotation.value;\r\n                  layerCurveNodes[i] = node;\r\n                }\r\n              }\r\n\r\n              if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode;\r\n            } else if (curveNode.curves.morph !== undefined) {\r\n              if (layerCurveNodes[i] === undefined) {\r\n                const deformerID = connections.get(child.ID).parents.filter(function (parent) {\r\n                  return parent.relationship !== undefined;\r\n                })[0].ID;\r\n                const morpherID = connections.get(deformerID).parents[0].ID;\r\n                const geoID = connections.get(morpherID).parents[0].ID; // assuming geometry is not used in more than one model\r\n\r\n                const modelID = connections.get(geoID).parents[0].ID;\r\n                const rawModel = fbxTree.Objects.Model[modelID];\r\n                const node = {\r\n                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\r\n                  morphName: fbxTree.Objects.Deformer[deformerID].attrName\r\n                };\r\n                layerCurveNodes[i] = node;\r\n              }\r\n\r\n              layerCurveNodes[i][curveNode.attr] = curveNode;\r\n            }\r\n          }\r\n        });\r\n        layersMap.set(parseInt(nodeID), layerCurveNodes);\r\n      }\r\n    }\r\n\r\n    return layersMap;\r\n  } // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\r\n  // hierarchy. Each Stack node will be used to create a AnimationClip\r\n\r\n\r\n  parseAnimStacks(layersMap) {\r\n    const rawStacks = fbxTree.Objects.AnimationStack; // connect the stacks (clips) up to the layers\r\n\r\n    const rawClips = {};\r\n\r\n    for (const nodeID in rawStacks) {\r\n      const children = connections.get(parseInt(nodeID)).children;\r\n\r\n      if (children.length > 1) {\r\n        // it seems like stacks will always be associated with a single layer. But just in case there are files\r\n        // where there are multiple layers per stack, we'll display a warning\r\n        console.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.');\r\n      }\r\n\r\n      const layer = layersMap.get(children[0].ID);\r\n      rawClips[nodeID] = {\r\n        name: rawStacks[nodeID].attrName,\r\n        layer: layer\r\n      };\r\n    }\r\n\r\n    return rawClips;\r\n  }\r\n\r\n  addClip(rawClip) {\r\n    let tracks = [];\r\n    const scope = this;\r\n    rawClip.layer.forEach(function (rawTracks) {\r\n      tracks = tracks.concat(scope.generateTracks(rawTracks));\r\n    });\r\n    return new AnimationClip(rawClip.name, -1, tracks);\r\n  }\r\n\r\n  generateTracks(rawTracks) {\r\n    const tracks = [];\r\n    let initialPosition = new Vector3();\r\n    let initialRotation = new Quaternion();\r\n    let initialScale = new Vector3();\r\n    if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);\r\n    initialPosition = initialPosition.toArray();\r\n    initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();\r\n    initialScale = initialScale.toArray();\r\n\r\n    if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\r\n      const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position');\r\n      if (positionTrack !== undefined) tracks.push(positionTrack);\r\n    }\r\n\r\n    if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\r\n      const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);\r\n      if (rotationTrack !== undefined) tracks.push(rotationTrack);\r\n    }\r\n\r\n    if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\r\n      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale');\r\n      if (scaleTrack !== undefined) tracks.push(scaleTrack);\r\n    }\r\n\r\n    if (rawTracks.DeformPercent !== undefined) {\r\n      const morphTrack = this.generateMorphTrack(rawTracks);\r\n      if (morphTrack !== undefined) tracks.push(morphTrack);\r\n    }\r\n\r\n    return tracks;\r\n  }\r\n\r\n  generateVectorTrack(modelName, curves, initialValue, type) {\r\n    const times = this.getTimesForAllAxes(curves);\r\n    const values = this.getKeyframeTrackValues(times, curves, initialValue);\r\n    return new VectorKeyframeTrack(modelName + '.' + type, times, values);\r\n  }\r\n\r\n  generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {\r\n    if (curves.x !== undefined) {\r\n      this.interpolateRotations(curves.x);\r\n      curves.x.values = curves.x.values.map(MathUtils.degToRad);\r\n    }\r\n\r\n    if (curves.y !== undefined) {\r\n      this.interpolateRotations(curves.y);\r\n      curves.y.values = curves.y.values.map(MathUtils.degToRad);\r\n    }\r\n\r\n    if (curves.z !== undefined) {\r\n      this.interpolateRotations(curves.z);\r\n      curves.z.values = curves.z.values.map(MathUtils.degToRad);\r\n    }\r\n\r\n    const times = this.getTimesForAllAxes(curves);\r\n    const values = this.getKeyframeTrackValues(times, curves, initialValue);\r\n\r\n    if (preRotation !== undefined) {\r\n      preRotation = preRotation.map(MathUtils.degToRad);\r\n      preRotation.push(eulerOrder);\r\n      preRotation = new Euler().fromArray(preRotation);\r\n      preRotation = new Quaternion().setFromEuler(preRotation);\r\n    }\r\n\r\n    if (postRotation !== undefined) {\r\n      postRotation = postRotation.map(MathUtils.degToRad);\r\n      postRotation.push(eulerOrder);\r\n      postRotation = new Euler().fromArray(postRotation);\r\n      postRotation = new Quaternion().setFromEuler(postRotation).invert();\r\n    }\r\n\r\n    const quaternion = new Quaternion();\r\n    const euler = new Euler();\r\n    const quaternionValues = [];\r\n\r\n    for (let i = 0; i < values.length; i += 3) {\r\n      euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);\r\n      quaternion.setFromEuler(euler);\r\n      if (preRotation !== undefined) quaternion.premultiply(preRotation);\r\n      if (postRotation !== undefined) quaternion.multiply(postRotation);\r\n      quaternion.toArray(quaternionValues, i / 3 * 4);\r\n    }\r\n\r\n    return new QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues);\r\n  }\r\n\r\n  generateMorphTrack(rawTracks) {\r\n    const curves = rawTracks.DeformPercent.curves.morph;\r\n    const values = curves.values.map(function (val) {\r\n      return val / 100;\r\n    });\r\n    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];\r\n    return new NumberKeyframeTrack(rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values);\r\n  } // For all animated objects, times are defined separately for each axis\r\n  // Here we'll combine the times into one sorted array without duplicates\r\n\r\n\r\n  getTimesForAllAxes(curves) {\r\n    let times = []; // first join together the times for each axis, if defined\r\n\r\n    if (curves.x !== undefined) times = times.concat(curves.x.times);\r\n    if (curves.y !== undefined) times = times.concat(curves.y.times);\r\n    if (curves.z !== undefined) times = times.concat(curves.z.times); // then sort them\r\n\r\n    times = times.sort(function (a, b) {\r\n      return a - b;\r\n    }); // and remove duplicates\r\n\r\n    if (times.length > 1) {\r\n      let targetIndex = 1;\r\n      let lastValue = times[0];\r\n\r\n      for (let i = 1; i < times.length; i++) {\r\n        const currentValue = times[i];\r\n\r\n        if (currentValue !== lastValue) {\r\n          times[targetIndex] = currentValue;\r\n          lastValue = currentValue;\r\n          targetIndex++;\r\n        }\r\n      }\r\n\r\n      times = times.slice(0, targetIndex);\r\n    }\r\n\r\n    return times;\r\n  }\r\n\r\n  getKeyframeTrackValues(times, curves, initialValue) {\r\n    const prevValue = initialValue;\r\n    const values = [];\r\n    let xIndex = -1;\r\n    let yIndex = -1;\r\n    let zIndex = -1;\r\n    times.forEach(function (time) {\r\n      if (curves.x) xIndex = curves.x.times.indexOf(time);\r\n      if (curves.y) yIndex = curves.y.times.indexOf(time);\r\n      if (curves.z) zIndex = curves.z.times.indexOf(time); // if there is an x value defined for this frame, use that\r\n\r\n      if (xIndex !== -1) {\r\n        const xValue = curves.x.values[xIndex];\r\n        values.push(xValue);\r\n        prevValue[0] = xValue;\r\n      } else {\r\n        // otherwise use the x value from the previous frame\r\n        values.push(prevValue[0]);\r\n      }\r\n\r\n      if (yIndex !== -1) {\r\n        const yValue = curves.y.values[yIndex];\r\n        values.push(yValue);\r\n        prevValue[1] = yValue;\r\n      } else {\r\n        values.push(prevValue[1]);\r\n      }\r\n\r\n      if (zIndex !== -1) {\r\n        const zValue = curves.z.values[zIndex];\r\n        values.push(zValue);\r\n        prevValue[2] = zValue;\r\n      } else {\r\n        values.push(prevValue[2]);\r\n      }\r\n    });\r\n    return values;\r\n  } // Rotations are defined as Euler angles which can have values  of any size\r\n  // These will be converted to quaternions which don't support values greater than\r\n  // PI, so we'll interpolate large rotations\r\n\r\n\r\n  interpolateRotations(curve) {\r\n    for (let i = 1; i < curve.values.length; i++) {\r\n      const initialValue = curve.values[i - 1];\r\n      const valuesSpan = curve.values[i] - initialValue;\r\n      const absoluteSpan = Math.abs(valuesSpan);\r\n\r\n      if (absoluteSpan >= 180) {\r\n        const numSubIntervals = absoluteSpan / 180;\r\n        const step = valuesSpan / numSubIntervals;\r\n        let nextValue = initialValue + step;\r\n        const initialTime = curve.times[i - 1];\r\n        const timeSpan = curve.times[i] - initialTime;\r\n        const interval = timeSpan / numSubIntervals;\r\n        let nextTime = initialTime + interval;\r\n        const interpolatedTimes = [];\r\n        const interpolatedValues = [];\r\n\r\n        while (nextTime < curve.times[i]) {\r\n          interpolatedTimes.push(nextTime);\r\n          nextTime += interval;\r\n          interpolatedValues.push(nextValue);\r\n          nextValue += step;\r\n        }\r\n\r\n        curve.times = inject(curve.times, i, interpolatedTimes);\r\n        curve.values = inject(curve.values, i, interpolatedValues);\r\n      }\r\n    }\r\n  }\r\n\r\n} // parse an FBX file in ASCII format\r\n\r\n\r\nclass TextParser {\r\n  getPrevNode() {\r\n    return this.nodeStack[this.currentIndent - 2];\r\n  }\r\n\r\n  getCurrentNode() {\r\n    return this.nodeStack[this.currentIndent - 1];\r\n  }\r\n\r\n  getCurrentProp() {\r\n    return this.currentProp;\r\n  }\r\n\r\n  pushStack(node) {\r\n    this.nodeStack.push(node);\r\n    this.currentIndent += 1;\r\n  }\r\n\r\n  popStack() {\r\n    this.nodeStack.pop();\r\n    this.currentIndent -= 1;\r\n  }\r\n\r\n  setCurrentProp(val, name) {\r\n    this.currentProp = val;\r\n    this.currentPropName = name;\r\n  }\r\n\r\n  parse(text) {\r\n    this.currentIndent = 0;\r\n    this.allNodes = new FBXTree();\r\n    this.nodeStack = [];\r\n    this.currentProp = [];\r\n    this.currentPropName = '';\r\n    const scope = this;\r\n    const split = text.split(/[\\r\\n]+/);\r\n    split.forEach(function (line, i) {\r\n      const matchComment = line.match(/^[\\s\\t]*;/);\r\n      const matchEmpty = line.match(/^[\\s\\t]*$/);\r\n      if (matchComment || matchEmpty) return;\r\n      const matchBeginning = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '');\r\n      const matchProperty = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)');\r\n      const matchEnd = line.match('^\\\\t{' + (scope.currentIndent - 1) + '}}');\r\n\r\n      if (matchBeginning) {\r\n        scope.parseNodeBegin(line, matchBeginning);\r\n      } else if (matchProperty) {\r\n        scope.parseNodeProperty(line, matchProperty, split[++i]);\r\n      } else if (matchEnd) {\r\n        scope.popStack();\r\n      } else if (line.match(/^[^\\s\\t}]/)) {\r\n        // large arrays are split over multiple lines terminated with a ',' character\r\n        // if this is encountered the line needs to be joined to the previous line\r\n        scope.parseNodePropertyContinued(line);\r\n      }\r\n    });\r\n    return this.allNodes;\r\n  }\r\n\r\n  parseNodeBegin(line, property) {\r\n    const nodeName = property[1].trim().replace(/^\"/, '').replace(/\"$/, '');\r\n    const nodeAttrs = property[2].split(',').map(function (attr) {\r\n      return attr.trim().replace(/^\"/, '').replace(/\"$/, '');\r\n    });\r\n    const node = {\r\n      name: nodeName\r\n    };\r\n    const attrs = this.parseNodeAttr(nodeAttrs);\r\n    const currentNode = this.getCurrentNode(); // a top node\r\n\r\n    if (this.currentIndent === 0) {\r\n      this.allNodes.add(nodeName, node);\r\n    } else {\r\n      // a subnode\r\n      // if the subnode already exists, append it\r\n      if (nodeName in currentNode) {\r\n        // special case Pose needs PoseNodes as an array\r\n        if (nodeName === 'PoseNode') {\r\n          currentNode.PoseNode.push(node);\r\n        } else if (currentNode[nodeName].id !== undefined) {\r\n          currentNode[nodeName] = {};\r\n          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];\r\n        }\r\n\r\n        if (attrs.id !== '') currentNode[nodeName][attrs.id] = node;\r\n      } else if (typeof attrs.id === 'number') {\r\n        currentNode[nodeName] = {};\r\n        currentNode[nodeName][attrs.id] = node;\r\n      } else if (nodeName !== 'Properties70') {\r\n        if (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;\r\n      }\r\n    }\r\n\r\n    if (typeof attrs.id === 'number') node.id = attrs.id;\r\n    if (attrs.name !== '') node.attrName = attrs.name;\r\n    if (attrs.type !== '') node.attrType = attrs.type;\r\n    this.pushStack(node);\r\n  }\r\n\r\n  parseNodeAttr(attrs) {\r\n    let id = attrs[0];\r\n\r\n    if (attrs[0] !== '') {\r\n      id = parseInt(attrs[0]);\r\n\r\n      if (isNaN(id)) {\r\n        id = attrs[0];\r\n      }\r\n    }\r\n\r\n    let name = '',\r\n        type = '';\r\n\r\n    if (attrs.length > 1) {\r\n      name = attrs[1].replace(/^(\\w+)::/, '');\r\n      type = attrs[2];\r\n    }\r\n\r\n    return {\r\n      id: id,\r\n      name: name,\r\n      type: type\r\n    };\r\n  }\r\n\r\n  parseNodeProperty(line, property, contentLine) {\r\n    let propName = property[1].replace(/^\"/, '').replace(/\"$/, '').trim();\r\n    let propValue = property[2].replace(/^\"/, '').replace(/\"$/, '').trim(); // for special case: base64 image data follows \"Content: ,\" line\r\n    //\tContent: ,\r\n    //\t \"/9j/4RDaRXhpZgAATU0A...\"\r\n\r\n    if (propName === 'Content' && propValue === ',') {\r\n      propValue = contentLine.replace(/\"/g, '').replace(/,$/, '').trim();\r\n    }\r\n\r\n    const currentNode = this.getCurrentNode();\r\n    const parentName = currentNode.name;\r\n\r\n    if (parentName === 'Properties70') {\r\n      this.parseNodeSpecialProperty(line, propName, propValue);\r\n      return;\r\n    } // Connections\r\n\r\n\r\n    if (propName === 'C') {\r\n      const connProps = propValue.split(',').slice(1);\r\n      const from = parseInt(connProps[0]);\r\n      const to = parseInt(connProps[1]);\r\n      let rest = propValue.split(',').slice(3);\r\n      rest = rest.map(function (elem) {\r\n        return elem.trim().replace(/^\"/, '');\r\n      });\r\n      propName = 'connections';\r\n      propValue = [from, to];\r\n      append(propValue, rest);\r\n\r\n      if (currentNode[propName] === undefined) {\r\n        currentNode[propName] = [];\r\n      }\r\n    } // Node\r\n\r\n\r\n    if (propName === 'Node') currentNode.id = propValue; // connections\r\n\r\n    if (propName in currentNode && Array.isArray(currentNode[propName])) {\r\n      currentNode[propName].push(propValue);\r\n    } else {\r\n      if (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;\r\n    }\r\n\r\n    this.setCurrentProp(currentNode, propName); // convert string to array, unless it ends in ',' in which case more will be added to it\r\n\r\n    if (propName === 'a' && propValue.slice(-1) !== ',') {\r\n      currentNode.a = parseNumberArray(propValue);\r\n    }\r\n  }\r\n\r\n  parseNodePropertyContinued(line) {\r\n    const currentNode = this.getCurrentNode();\r\n    currentNode.a += line; // if the line doesn't end in ',' we have reached the end of the property value\r\n    // so convert the string to an array\r\n\r\n    if (line.slice(-1) !== ',') {\r\n      currentNode.a = parseNumberArray(currentNode.a);\r\n    }\r\n  } // parse \"Property70\"\r\n\r\n\r\n  parseNodeSpecialProperty(line, propName, propValue) {\r\n    // split this\r\n    // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\r\n    // into array like below\r\n    // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\r\n    const props = propValue.split('\",').map(function (prop) {\r\n      return prop.trim().replace(/^\\\"/, '').replace(/\\s/, '_');\r\n    });\r\n    const innerPropName = props[0];\r\n    const innerPropType1 = props[1];\r\n    const innerPropType2 = props[2];\r\n    const innerPropFlag = props[3];\r\n    let innerPropValue = props[4]; // cast values where needed, otherwise leave as strings\r\n\r\n    switch (innerPropType1) {\r\n      case 'int':\r\n      case 'enum':\r\n      case 'bool':\r\n      case 'ULongLong':\r\n      case 'double':\r\n      case 'Number':\r\n      case 'FieldOfView':\r\n        innerPropValue = parseFloat(innerPropValue);\r\n        break;\r\n\r\n      case 'Color':\r\n      case 'ColorRGB':\r\n      case 'Vector3D':\r\n      case 'Lcl_Translation':\r\n      case 'Lcl_Rotation':\r\n      case 'Lcl_Scaling':\r\n        innerPropValue = parseNumberArray(innerPropValue);\r\n        break;\r\n    } // CAUTION: these props must append to parent's parent\r\n\r\n\r\n    this.getPrevNode()[innerPropName] = {\r\n      type: innerPropType1,\r\n      type2: innerPropType2,\r\n      flag: innerPropFlag,\r\n      value: innerPropValue\r\n    };\r\n    this.setCurrentProp(this.getPrevNode(), innerPropName);\r\n  }\r\n\r\n} // Parse an FBX file in Binary format\r\n\r\n\r\nclass BinaryParser {\r\n  parse(buffer) {\r\n    const reader = new BinaryReader(buffer);\r\n    reader.skip(23); // skip magic 23 bytes\r\n\r\n    const version = reader.getUint32();\r\n\r\n    if (version < 6400) {\r\n      throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + version);\r\n    }\r\n\r\n    const allNodes = new FBXTree();\r\n\r\n    while (!this.endOfContent(reader)) {\r\n      const node = this.parseNode(reader, version);\r\n      if (node !== null) allNodes.add(node.name, node);\r\n    }\r\n\r\n    return allNodes;\r\n  } // Check if reader has reached the end of content.\r\n\r\n\r\n  endOfContent(reader) {\r\n    // footer size: 160bytes + 16-byte alignment padding\r\n    // - 16bytes: magic\r\n    // - padding til 16-byte alignment (at least 1byte?)\r\n    //\t(seems like some exporters embed fixed 15 or 16bytes?)\r\n    // - 4bytes: magic\r\n    // - 4bytes: version\r\n    // - 120bytes: zero\r\n    // - 16bytes: magic\r\n    if (reader.size() % 16 === 0) {\r\n      return (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();\r\n    } else {\r\n      return reader.getOffset() + 160 + 16 >= reader.size();\r\n    }\r\n  } // recursively parse nodes until the end of the file is reached\r\n\r\n\r\n  parseNode(reader, version) {\r\n    const node = {}; // The first three data sizes depends on version.\r\n\r\n    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\r\n    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();\r\n    version >= 7500 ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used\r\n\r\n    const nameLen = reader.getUint8();\r\n    const name = reader.getString(nameLen); // Regards this node as NULL-record if endOffset is zero\r\n\r\n    if (endOffset === 0) return null;\r\n    const propertyList = [];\r\n\r\n    for (let i = 0; i < numProperties; i++) {\r\n      propertyList.push(this.parseProperty(reader));\r\n    } // Regards the first three elements in propertyList as id, attrName, and attrType\r\n\r\n\r\n    const id = propertyList.length > 0 ? propertyList[0] : '';\r\n    const attrName = propertyList.length > 1 ? propertyList[1] : '';\r\n    const attrType = propertyList.length > 2 ? propertyList[2] : ''; // check if this node represents just a single property\r\n    // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\r\n\r\n    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;\r\n\r\n    while (endOffset > reader.getOffset()) {\r\n      const subNode = this.parseNode(reader, version);\r\n      if (subNode !== null) this.parseSubNode(name, node, subNode);\r\n    }\r\n\r\n    node.propertyList = propertyList; // raw property list used by parent\r\n\r\n    if (typeof id === 'number') node.id = id;\r\n    if (attrName !== '') node.attrName = attrName;\r\n    if (attrType !== '') node.attrType = attrType;\r\n    if (name !== '') node.name = name;\r\n    return node;\r\n  }\r\n\r\n  parseSubNode(name, node, subNode) {\r\n    // special case: child node is single property\r\n    if (subNode.singleProperty === true) {\r\n      const value = subNode.propertyList[0];\r\n\r\n      if (Array.isArray(value)) {\r\n        node[subNode.name] = subNode;\r\n        subNode.a = value;\r\n      } else {\r\n        node[subNode.name] = value;\r\n      }\r\n    } else if (name === 'Connections' && subNode.name === 'C') {\r\n      const array = [];\r\n      subNode.propertyList.forEach(function (property, i) {\r\n        // first Connection is FBX type (OO, OP, etc.). We'll discard these\r\n        if (i !== 0) array.push(property);\r\n      });\r\n\r\n      if (node.connections === undefined) {\r\n        node.connections = [];\r\n      }\r\n\r\n      node.connections.push(array);\r\n    } else if (subNode.name === 'Properties70') {\r\n      const keys = Object.keys(subNode);\r\n      keys.forEach(function (key) {\r\n        node[key] = subNode[key];\r\n      });\r\n    } else if (name === 'Properties70' && subNode.name === 'P') {\r\n      let innerPropName = subNode.propertyList[0];\r\n      let innerPropType1 = subNode.propertyList[1];\r\n      const innerPropType2 = subNode.propertyList[2];\r\n      const innerPropFlag = subNode.propertyList[3];\r\n      let innerPropValue;\r\n      if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');\r\n      if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');\r\n\r\n      if (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {\r\n        innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];\r\n      } else {\r\n        innerPropValue = subNode.propertyList[4];\r\n      } // this will be copied to parent, see above\r\n\r\n\r\n      node[innerPropName] = {\r\n        type: innerPropType1,\r\n        type2: innerPropType2,\r\n        flag: innerPropFlag,\r\n        value: innerPropValue\r\n      };\r\n    } else if (node[subNode.name] === undefined) {\r\n      if (typeof subNode.id === 'number') {\r\n        node[subNode.name] = {};\r\n        node[subNode.name][subNode.id] = subNode;\r\n      } else {\r\n        node[subNode.name] = subNode;\r\n      }\r\n    } else {\r\n      if (subNode.name === 'PoseNode') {\r\n        if (!Array.isArray(node[subNode.name])) {\r\n          node[subNode.name] = [node[subNode.name]];\r\n        }\r\n\r\n        node[subNode.name].push(subNode);\r\n      } else if (node[subNode.name][subNode.id] === undefined) {\r\n        node[subNode.name][subNode.id] = subNode;\r\n      }\r\n    }\r\n  }\r\n\r\n  parseProperty(reader) {\r\n    const type = reader.getString(1);\r\n    let length;\r\n\r\n    switch (type) {\r\n      case 'C':\r\n        return reader.getBoolean();\r\n\r\n      case 'D':\r\n        return reader.getFloat64();\r\n\r\n      case 'F':\r\n        return reader.getFloat32();\r\n\r\n      case 'I':\r\n        return reader.getInt32();\r\n\r\n      case 'L':\r\n        return reader.getInt64();\r\n\r\n      case 'R':\r\n        length = reader.getUint32();\r\n        return reader.getArrayBuffer(length);\r\n\r\n      case 'S':\r\n        length = reader.getUint32();\r\n        return reader.getString(length);\r\n\r\n      case 'Y':\r\n        return reader.getInt16();\r\n\r\n      case 'b':\r\n      case 'c':\r\n      case 'd':\r\n      case 'f':\r\n      case 'i':\r\n      case 'l':\r\n        const arrayLength = reader.getUint32();\r\n        const encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\r\n\r\n        const compressedLength = reader.getUint32();\r\n\r\n        if (encoding === 0) {\r\n          switch (type) {\r\n            case 'b':\r\n            case 'c':\r\n              return reader.getBooleanArray(arrayLength);\r\n\r\n            case 'd':\r\n              return reader.getFloat64Array(arrayLength);\r\n\r\n            case 'f':\r\n              return reader.getFloat32Array(arrayLength);\r\n\r\n            case 'i':\r\n              return reader.getInt32Array(arrayLength);\r\n\r\n            case 'l':\r\n              return reader.getInt64Array(arrayLength);\r\n          }\r\n        }\r\n\r\n        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef\r\n\r\n        const reader2 = new BinaryReader(data.buffer);\r\n\r\n        switch (type) {\r\n          case 'b':\r\n          case 'c':\r\n            return reader2.getBooleanArray(arrayLength);\r\n\r\n          case 'd':\r\n            return reader2.getFloat64Array(arrayLength);\r\n\r\n          case 'f':\r\n            return reader2.getFloat32Array(arrayLength);\r\n\r\n          case 'i':\r\n            return reader2.getInt32Array(arrayLength);\r\n\r\n          case 'l':\r\n            return reader2.getInt64Array(arrayLength);\r\n        }\r\n\r\n      default:\r\n        throw new Error('THREE.FBXLoader: Unknown property type ' + type);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nclass BinaryReader {\r\n  constructor(buffer, littleEndian) {\r\n    this.dv = new DataView(buffer);\r\n    this.offset = 0;\r\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true;\r\n  }\r\n\r\n  getOffset() {\r\n    return this.offset;\r\n  }\r\n\r\n  size() {\r\n    return this.dv.buffer.byteLength;\r\n  }\r\n\r\n  skip(length) {\r\n    this.offset += length;\r\n  } // seems like true/false representation depends on exporter.\r\n  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\r\n  // then sees LSB.\r\n\r\n\r\n  getBoolean() {\r\n    return (this.getUint8() & 1) === 1;\r\n  }\r\n\r\n  getBooleanArray(size) {\r\n    const a = [];\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      a.push(this.getBoolean());\r\n    }\r\n\r\n    return a;\r\n  }\r\n\r\n  getUint8() {\r\n    const value = this.dv.getUint8(this.offset);\r\n    this.offset += 1;\r\n    return value;\r\n  }\r\n\r\n  getInt16() {\r\n    const value = this.dv.getInt16(this.offset, this.littleEndian);\r\n    this.offset += 2;\r\n    return value;\r\n  }\r\n\r\n  getInt32() {\r\n    const value = this.dv.getInt32(this.offset, this.littleEndian);\r\n    this.offset += 4;\r\n    return value;\r\n  }\r\n\r\n  getInt32Array(size) {\r\n    const a = [];\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      a.push(this.getInt32());\r\n    }\r\n\r\n    return a;\r\n  }\r\n\r\n  getUint32() {\r\n    const value = this.dv.getUint32(this.offset, this.littleEndian);\r\n    this.offset += 4;\r\n    return value;\r\n  } // JavaScript doesn't support 64-bit integer so calculate this here\r\n  // 1 << 32 will return 1 so using multiply operation instead here.\r\n  // There's a possibility that this method returns wrong value if the value\r\n  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\r\n  // TODO: safely handle 64-bit integer\r\n\r\n\r\n  getInt64() {\r\n    let low, high;\r\n\r\n    if (this.littleEndian) {\r\n      low = this.getUint32();\r\n      high = this.getUint32();\r\n    } else {\r\n      high = this.getUint32();\r\n      low = this.getUint32();\r\n    } // calculate negative value\r\n\r\n\r\n    if (high & 0x80000000) {\r\n      high = ~high & 0xffffffff;\r\n      low = ~low & 0xffffffff;\r\n      if (low === 0xffffffff) high = high + 1 & 0xffffffff;\r\n      low = low + 1 & 0xffffffff;\r\n      return -(high * 0x100000000 + low);\r\n    }\r\n\r\n    return high * 0x100000000 + low;\r\n  }\r\n\r\n  getInt64Array(size) {\r\n    const a = [];\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      a.push(this.getInt64());\r\n    }\r\n\r\n    return a;\r\n  } // Note: see getInt64() comment\r\n\r\n\r\n  getUint64() {\r\n    let low, high;\r\n\r\n    if (this.littleEndian) {\r\n      low = this.getUint32();\r\n      high = this.getUint32();\r\n    } else {\r\n      high = this.getUint32();\r\n      low = this.getUint32();\r\n    }\r\n\r\n    return high * 0x100000000 + low;\r\n  }\r\n\r\n  getFloat32() {\r\n    const value = this.dv.getFloat32(this.offset, this.littleEndian);\r\n    this.offset += 4;\r\n    return value;\r\n  }\r\n\r\n  getFloat32Array(size) {\r\n    const a = [];\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      a.push(this.getFloat32());\r\n    }\r\n\r\n    return a;\r\n  }\r\n\r\n  getFloat64() {\r\n    const value = this.dv.getFloat64(this.offset, this.littleEndian);\r\n    this.offset += 8;\r\n    return value;\r\n  }\r\n\r\n  getFloat64Array(size) {\r\n    const a = [];\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      a.push(this.getFloat64());\r\n    }\r\n\r\n    return a;\r\n  }\r\n\r\n  getArrayBuffer(size) {\r\n    const value = this.dv.buffer.slice(this.offset, this.offset + size);\r\n    this.offset += size;\r\n    return value;\r\n  }\r\n\r\n  getString(size) {\r\n    // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\r\n    let a = [];\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      a[i] = this.getUint8();\r\n    }\r\n\r\n    const nullByte = a.indexOf(0);\r\n    if (nullByte >= 0) a = a.slice(0, nullByte);\r\n    return LoaderUtils.decodeText(new Uint8Array(a));\r\n  }\r\n\r\n} // FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\r\n// and BinaryParser( FBX Binary format)\r\n\r\n\r\nclass FBXTree {\r\n  add(key, val) {\r\n    this[key] = val;\r\n  }\r\n\r\n} // ************** UTILITY FUNCTIONS **************\r\n\r\n\r\nfunction isFbxFormatBinary(buffer) {\r\n  const CORRECT = 'Kaydara\\u0020FBX\\u0020Binary\\u0020\\u0020\\0';\r\n  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\r\n}\r\n\r\nfunction isFbxFormatASCII(text) {\r\n  const CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\'];\r\n  let cursor = 0;\r\n\r\n  function read(offset) {\r\n    const result = text[offset - 1];\r\n    text = text.slice(cursor + offset);\r\n    cursor++;\r\n    return result;\r\n  }\r\n\r\n  for (let i = 0; i < CORRECT.length; ++i) {\r\n    const num = read(1);\r\n\r\n    if (num === CORRECT[i]) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction getFbxVersion(text) {\r\n  const versionRegExp = /FBXVersion: (\\d+)/;\r\n  const match = text.match(versionRegExp);\r\n\r\n  if (match) {\r\n    const version = parseInt(match[1]);\r\n    return version;\r\n  }\r\n\r\n  throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.');\r\n} // Converts FBX ticks into real time seconds.\r\n\r\n\r\nfunction convertFBXTimeToSeconds(time) {\r\n  return time / 46186158000;\r\n}\r\n\r\nconst dataArray = []; // extracts the data from the correct position in the FBX array based on indexing type\r\n\r\nfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\r\n  let index;\r\n\r\n  switch (infoObject.mappingType) {\r\n    case 'ByPolygonVertex':\r\n      index = polygonVertexIndex;\r\n      break;\r\n\r\n    case 'ByPolygon':\r\n      index = polygonIndex;\r\n      break;\r\n\r\n    case 'ByVertice':\r\n      index = vertexIndex;\r\n      break;\r\n\r\n    case 'AllSame':\r\n      index = infoObject.indices[0];\r\n      break;\r\n\r\n    default:\r\n      console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);\r\n  }\r\n\r\n  if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];\r\n  const from = index * infoObject.dataSize;\r\n  const to = from + infoObject.dataSize;\r\n  return slice(dataArray, infoObject.buffer, from, to);\r\n}\r\n\r\nconst tempEuler = new Euler();\r\nconst tempVec = new Vector3(); // generate transformation from FBX transform data\r\n// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\r\n// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\r\n\r\nfunction generateTransform(transformData) {\r\n  const lTranslationM = new Matrix4();\r\n  const lPreRotationM = new Matrix4();\r\n  const lRotationM = new Matrix4();\r\n  const lPostRotationM = new Matrix4();\r\n  const lScalingM = new Matrix4();\r\n  const lScalingPivotM = new Matrix4();\r\n  const lScalingOffsetM = new Matrix4();\r\n  const lRotationOffsetM = new Matrix4();\r\n  const lRotationPivotM = new Matrix4();\r\n  const lParentGX = new Matrix4();\r\n  const lParentLX = new Matrix4();\r\n  const lGlobalT = new Matrix4();\r\n  const inheritType = transformData.inheritType ? transformData.inheritType : 0;\r\n  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation));\r\n\r\n  if (transformData.preRotation) {\r\n    const array = transformData.preRotation.map(MathUtils.degToRad);\r\n    array.push(transformData.eulerOrder);\r\n    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\r\n  }\r\n\r\n  if (transformData.rotation) {\r\n    const array = transformData.rotation.map(MathUtils.degToRad);\r\n    array.push(transformData.eulerOrder);\r\n    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\r\n  }\r\n\r\n  if (transformData.postRotation) {\r\n    const array = transformData.postRotation.map(MathUtils.degToRad);\r\n    array.push(transformData.eulerOrder);\r\n    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\r\n    lPostRotationM.invert();\r\n  }\r\n\r\n  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale)); // Pivots and offsets\r\n\r\n  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));\r\n  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));\r\n  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));\r\n  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot)); // parent transform\r\n\r\n  if (transformData.parentMatrixWorld) {\r\n    lParentLX.copy(transformData.parentMatrix);\r\n    lParentGX.copy(transformData.parentMatrixWorld);\r\n  }\r\n\r\n  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM); // Global Rotation\r\n\r\n  const lParentGRM = new Matrix4();\r\n  lParentGRM.extractRotation(lParentGX); // Global Shear*Scaling\r\n\r\n  const lParentTM = new Matrix4();\r\n  lParentTM.copyPosition(lParentGX);\r\n  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);\r\n  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);\r\n  const lLSM = lScalingM;\r\n  const lGlobalRS = new Matrix4();\r\n\r\n  if (inheritType === 0) {\r\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);\r\n  } else if (inheritType === 1) {\r\n    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);\r\n  } else {\r\n    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX));\r\n    const lParentLSM_inv = lParentLSM.clone().invert();\r\n    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);\r\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);\r\n  }\r\n\r\n  const lRotationPivotM_inv = lRotationPivotM.clone().invert();\r\n  const lScalingPivotM_inv = lScalingPivotM.clone().invert(); // Calculate the local transform matrix\r\n\r\n  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);\r\n  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);\r\n  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);\r\n  lGlobalT.copyPosition(lGlobalTranslation);\r\n  lTransform = lGlobalT.clone().multiply(lGlobalRS); // from global to local\r\n\r\n  lTransform.premultiply(lParentGX.invert());\r\n  return lTransform;\r\n} // Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\r\n// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\r\n\r\n\r\nfunction getEulerOrder(order) {\r\n  order = order || 0;\r\n  const enums = ['ZYX', // -> XYZ extrinsic\r\n  'YZX', // -> XZY extrinsic\r\n  'XZY', // -> YZX extrinsic\r\n  'ZXY', // -> YXZ extrinsic\r\n  'YXZ', // -> ZXY extrinsic\r\n  'XYZ' // -> ZYX extrinsic\r\n  //'SphericXYZ', // not possible to support\r\n  ];\r\n\r\n  if (order === 6) {\r\n    console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');\r\n    return enums[0];\r\n  }\r\n\r\n  return enums[order];\r\n} // Parses comma separated list of numbers and returns them an array.\r\n// Used internally by the TextParser\r\n\r\n\r\nfunction parseNumberArray(value) {\r\n  const array = value.split(',').map(function (val) {\r\n    return parseFloat(val);\r\n  });\r\n  return array;\r\n}\r\n\r\nfunction convertArrayBufferToString(buffer, from, to) {\r\n  if (from === undefined) from = 0;\r\n  if (to === undefined) to = buffer.byteLength;\r\n  return LoaderUtils.decodeText(new Uint8Array(buffer, from, to));\r\n}\r\n\r\nfunction append(a, b) {\r\n  for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {\r\n    a[j] = b[i];\r\n  }\r\n}\r\n\r\nfunction slice(a, b, from, to) {\r\n  for (let i = from, j = 0; i < to; i++, j++) {\r\n    a[j] = b[i];\r\n  }\r\n\r\n  return a;\r\n} // inject array a2 into array a1 at index\r\n\r\n\r\nfunction inject(a1, index, a2) {\r\n  return a1.slice(0, index).concat(a2).concat(a1.slice(index));\r\n}\r\n\r\nexport { FBXLoader };\r\n", "import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { Loader, FileLoader, ShapePath } from 'three';\r\n\r\nclass FontLoader extends Loader {\r\n  constructor(manager) {\r\n    super(manager);\r\n  }\r\n\r\n  load(url, onLoad, onProgress, onError) {\r\n    const loader = new FileLoader(this.manager);\r\n    loader.setPath(this.path);\r\n    loader.setRequestHeader(this.requestHeader);\r\n    loader.setWithCredentials(this.withCredentials);\r\n    loader.load(url, response => {\r\n      if (typeof response !== 'string') throw new Error('unsupported data type');\r\n      const json = JSON.parse(response);\r\n      const font = this.parse(json);\r\n      if (onLoad) onLoad(font);\r\n    }, onProgress, onError);\r\n  }\r\n\r\n  parse(json) {\r\n    return new Font(json);\r\n  }\r\n\r\n}\r\nclass Font {\r\n  constructor(data) {\r\n    _defineProperty(this, \"data\", void 0);\r\n\r\n    this.data = data;\r\n  }\r\n\r\n  generateShapes(text, size = 100, _options) {\r\n    const shapes = [];\r\n    const options = {\r\n      letterSpacing: 0,\r\n      lineHeight: 1,\r\n      ..._options\r\n    };\r\n    const paths = createPaths(text, size, this.data, options);\r\n\r\n    for (let p = 0, pl = paths.length; p < pl; p++) {\r\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false));\r\n    }\r\n\r\n    return shapes;\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(Font, \"isFont\", void 0);\r\n\r\n_defineProperty(Font, \"type\", void 0);\r\n\r\nfunction createPaths(text, size, data, options) {\r\n  const chars = Array.from(text);\r\n  const scale = size / data.resolution;\r\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\r\n  const paths = [];\r\n  let offsetX = 0,\r\n      offsetY = 0;\r\n\r\n  for (let i = 0; i < chars.length; i++) {\r\n    const char = chars[i];\r\n\r\n    if (char === '\\n') {\r\n      offsetX = 0;\r\n      offsetY -= line_height * options.lineHeight;\r\n    } else {\r\n      const ret = createPath(char, scale, offsetX, offsetY, data);\r\n\r\n      if (ret) {\r\n        offsetX += ret.offsetX + options.letterSpacing;\r\n        paths.push(ret.path);\r\n      }\r\n    }\r\n  }\r\n\r\n  return paths;\r\n}\r\n\r\nfunction createPath(char, scale, offsetX, offsetY, data) {\r\n  const glyph = data.glyphs[char] || data.glyphs['?'];\r\n\r\n  if (!glyph) {\r\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.');\r\n    return;\r\n  }\r\n\r\n  const path = new ShapePath();\r\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\r\n\r\n  if (glyph.o) {\r\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\r\n\r\n    for (let i = 0, l = outline.length; i < l;) {\r\n      const action = outline[i++];\r\n\r\n      switch (action) {\r\n        case 'm':\r\n          // moveTo\r\n          x = parseInt(outline[i++]) * scale + offsetX;\r\n          y = parseInt(outline[i++]) * scale + offsetY;\r\n          path.moveTo(x, y);\r\n          break;\r\n\r\n        case 'l':\r\n          // lineTo\r\n          x = parseInt(outline[i++]) * scale + offsetX;\r\n          y = parseInt(outline[i++]) * scale + offsetY;\r\n          path.lineTo(x, y);\r\n          break;\r\n\r\n        case 'q':\r\n          // quadraticCurveTo\r\n          cpx = parseInt(outline[i++]) * scale + offsetX;\r\n          cpy = parseInt(outline[i++]) * scale + offsetY;\r\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\r\n          break;\r\n\r\n        case 'b':\r\n          // bezierCurveTo\r\n          cpx = parseInt(outline[i++]) * scale + offsetX;\r\n          cpy = parseInt(outline[i++]) * scale + offsetY;\r\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\r\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\r\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    offsetX: glyph.ha * scale,\r\n    path\r\n  };\r\n}\r\n\r\nexport { Font, FontLoader };\r\n", "import { Vector3, Quaternion, FileLoader, LoaderUtils, Matrix4, Bone, BufferGeometry, Float32BufferAttribute, Uint16BufferAttribute, MeshPhongMaterial, FrontSide, Vector2, SkinnedMesh, Mesh, Skeleton, AnimationClip, AnimationMixer, Loader, TextureLoader } from 'three';\r\n\r\nvar XLoader = function () {\r\n  var classCallCheck = function (instance, Constructor) {\r\n    if (!(instance instanceof Constructor)) {\r\n      throw new TypeError('Cannot call a class as a function');\r\n    }\r\n  };\r\n\r\n  var createClass = function () {\r\n    function defineProperties(target, props) {\r\n      for (let i = 0; i < props.length; i++) {\r\n        var descriptor = props[i];\r\n        descriptor.enumerable = descriptor.enumerable || false;\r\n        descriptor.configurable = true;\r\n        if ('value' in descriptor) descriptor.writable = true;\r\n        Object.defineProperty(target, descriptor.key, descriptor);\r\n      }\r\n    }\r\n\r\n    return function (Constructor, protoProps, staticProps) {\r\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\r\n      if (staticProps) defineProperties(Constructor, staticProps);\r\n      return Constructor;\r\n    };\r\n  }();\r\n\r\n  var XboneInf = function XboneInf() {\r\n    classCallCheck(this, XboneInf);\r\n    this.boneName = '';\r\n    this.BoneIndex = 0;\r\n    this.Indeces = [];\r\n    this.Weights = [];\r\n    this.initMatrix = null;\r\n    this.OffsetMatrix = null;\r\n  };\r\n\r\n  var XAnimationInfo = function XAnimationInfo() {\r\n    classCallCheck(this, XAnimationInfo);\r\n    this.animeName = '';\r\n    this.boneName = '';\r\n    this.targetBone = null;\r\n    this.keyType = 4;\r\n    this.frameStartLv = 0;\r\n    this.keyFrames = [];\r\n    this.InverseMx = null;\r\n  };\r\n\r\n  var XAnimationObj = function () {\r\n    function XAnimationObj(_flags) {\r\n      classCallCheck(this, XAnimationObj);\r\n      this.fps = 30;\r\n      this.name = 'xanimation';\r\n      this.length = 0;\r\n      this.hierarchy = [];\r\n      this.putFlags = _flags;\r\n\r\n      if (this.putFlags.putPos === undefined) {\r\n        this.putFlags.putPos = true;\r\n      }\r\n\r\n      if (this.putFlags.putRot === undefined) {\r\n        this.putFlags.putRot = true;\r\n      }\r\n\r\n      if (this.putFlags.putScl === undefined) {\r\n        this.putFlags.putScl = true;\r\n      }\r\n    }\r\n\r\n    createClass(XAnimationObj, [{\r\n      key: 'make',\r\n      value: function make(XAnimationInfoArray) {\r\n        for (let i = 0; i < XAnimationInfoArray.length; i++) {\r\n          this.hierarchy.push(this.makeBonekeys(XAnimationInfoArray[i]));\r\n        }\r\n\r\n        this.length = this.hierarchy[0].keys[this.hierarchy[0].keys.length - 1].time;\r\n      }\r\n    }, {\r\n      key: 'clone',\r\n      value: function clone() {\r\n        return Object.assign({}, this);\r\n      }\r\n    }, {\r\n      key: 'makeBonekeys',\r\n      value: function makeBonekeys(XAnimationInfo) {\r\n        var refObj = {};\r\n        refObj.name = XAnimationInfo.boneName;\r\n        refObj.parent = '';\r\n        refObj.keys = this.keyFrameRefactor(XAnimationInfo);\r\n\r\n        refObj.copy = function () {\r\n          return Object.assign({}, this);\r\n        };\r\n\r\n        return refObj;\r\n      }\r\n    }, {\r\n      key: 'keyFrameRefactor',\r\n      value: function keyFrameRefactor(XAnimationInfo) {\r\n        var keys = [];\r\n\r\n        for (let i = 0; i < XAnimationInfo.keyFrames.length; i++) {\r\n          var keyframe = {};\r\n          keyframe.time = XAnimationInfo.keyFrames[i].time * this.fps;\r\n\r\n          if (XAnimationInfo.keyFrames[i].pos && this.putFlags.putPos) {\r\n            keyframe.pos = XAnimationInfo.keyFrames[i].pos;\r\n          }\r\n\r\n          if (XAnimationInfo.keyFrames[i].rot && this.putFlags.putRot) {\r\n            keyframe.rot = XAnimationInfo.keyFrames[i].rot;\r\n          }\r\n\r\n          if (XAnimationInfo.keyFrames[i].scl && this.putFlags.putScl) {\r\n            keyframe.scl = XAnimationInfo.keyFrames[i].scl;\r\n          }\r\n\r\n          if (XAnimationInfo.keyFrames[i].matrix) {\r\n            keyframe.matrix = XAnimationInfo.keyFrames[i].matrix;\r\n\r\n            if (this.putFlags.putPos) {\r\n              keyframe.pos = new Vector3().setFromMatrixPosition(keyframe.matrix);\r\n            }\r\n\r\n            if (this.putFlags.putRot) {\r\n              keyframe.rot = new Quaternion().setFromRotationMatrix(keyframe.matrix);\r\n            }\r\n\r\n            if (this.putFlags.putScl) {\r\n              keyframe.scl = new Vector3().setFromMatrixScale(keyframe.matrix);\r\n            }\r\n          }\r\n\r\n          keys.push(keyframe);\r\n        }\r\n\r\n        return keys;\r\n      }\r\n    }]);\r\n    return XAnimationObj;\r\n  }();\r\n\r\n  var XKeyFrameInfo = function XKeyFrameInfo() {\r\n    classCallCheck(this, XKeyFrameInfo);\r\n    this.index = 0;\r\n    this.Frame = 0;\r\n    this.time = 0.0;\r\n    this.matrix = null;\r\n  };\r\n\r\n  var XLoader = function () {\r\n    function XLoader(manager) {\r\n      Loader.call(this, manager);\r\n      classCallCheck(this, XLoader);\r\n      this.debug = false;\r\n      this.texloader = new TextureLoader(this.manager);\r\n      this.url = '';\r\n      this._putMatLength = 0;\r\n      this._nowMat = null;\r\n      this._nowFrameName = '';\r\n      this.frameHierarchie = [];\r\n      this.Hierarchies = {};\r\n      this.HieStack = [];\r\n      this._currentObject = {};\r\n      this._currentFrame = {};\r\n      this._data = null;\r\n      this.onLoad = null;\r\n      this.IsUvYReverse = true;\r\n      this.Meshes = [];\r\n      this.animations = [];\r\n      this.animTicksPerSecond = 30;\r\n      this._currentGeo = null;\r\n      this._currentAnime = null;\r\n      this._currentAnimeFrames = null;\r\n    }\r\n\r\n    createClass(XLoader, [{\r\n      key: '_setArgOption',\r\n      value: function _setArgOption(_arg) {\r\n        var _start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\r\n\r\n        if (!_arg) {\r\n          return;\r\n        }\r\n\r\n        for (let i = _start; i < _arg.length; i++) {\r\n          switch (i) {\r\n            case 0:\r\n              this.url = _arg[i];\r\n              break;\r\n\r\n            case 1:\r\n              this.options = _arg[i];\r\n              break;\r\n          }\r\n        }\r\n\r\n        if (this.options === undefined) {\r\n          this.options = {};\r\n        }\r\n      }\r\n    }, {\r\n      key: 'load',\r\n      value: function load(_arg, onLoad, onProgress, onError) {\r\n        var _this = this;\r\n\r\n        this._setArgOption(_arg);\r\n\r\n        var loader = new FileLoader(this.manager);\r\n        loader.setPath(this.path);\r\n        loader.setResponseType('arraybuffer');\r\n        loader.setRequestHeader(this.requestHeader);\r\n        loader.setWithCredentials(this.withCredentials);\r\n        loader.load(this.url, function (response) {\r\n          try {\r\n            _this.parse(response, onLoad);\r\n          } catch (e) {\r\n            if (onError) {\r\n              onError(e);\r\n            } else {\r\n              console.error(e);\r\n            }\r\n\r\n            _this.manager.itemError(_this.url);\r\n          }\r\n        }, onProgress, onError);\r\n      }\r\n    }, {\r\n      key: '_readLine',\r\n      value: function _readLine(line) {\r\n        var readed = 0;\r\n\r\n        while (true) {\r\n          var find = -1;\r\n          find = line.indexOf('//', readed);\r\n\r\n          if (find === -1) {\r\n            find = line.indexOf('#', readed);\r\n          }\r\n\r\n          if (find > -1 && find < 2) {\r\n            var foundNewLine = -1;\r\n            foundNewLine = line.indexOf('\\r\\n', readed);\r\n\r\n            if (foundNewLine > 0) {\r\n              readed = foundNewLine + 2;\r\n            } else {\r\n              foundNewLine = line.indexOf('\\r', readed);\r\n\r\n              if (foundNewLine > 0) {\r\n                readed = foundNewLine + 1;\r\n              } else {\r\n                readed = line.indexOf('\\n', readed) + 1;\r\n              }\r\n            }\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n\r\n        return line.substr(readed);\r\n      }\r\n    }, {\r\n      key: '_readLine',\r\n      value: function _readLine(line) {\r\n        var readed = 0;\r\n\r\n        while (true) {\r\n          var find = -1;\r\n          find = line.indexOf('//', readed);\r\n\r\n          if (find === -1) {\r\n            find = line.indexOf('#', readed);\r\n          }\r\n\r\n          if (find > -1 && find < 2) {\r\n            var foundNewLine = -1;\r\n            foundNewLine = line.indexOf('\\r\\n', readed);\r\n\r\n            if (foundNewLine > 0) {\r\n              readed = foundNewLine + 2;\r\n            } else {\r\n              foundNewLine = line.indexOf('\\r', readed);\r\n\r\n              if (foundNewLine > 0) {\r\n                readed = foundNewLine + 1;\r\n              } else {\r\n                readed = line.indexOf('\\n', readed) + 1;\r\n              }\r\n            }\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n\r\n        return line.substr(readed);\r\n      }\r\n    }, {\r\n      key: '_isBinary',\r\n      value: function _isBinary(binData) {\r\n        var reader = new DataView(binData);\r\n        var face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\r\n        var n_faces = reader.getUint32(80, true);\r\n        var expect = 80 + 32 / 8 + n_faces * face_size;\r\n\r\n        if (expect === reader.byteLength) {\r\n          return true;\r\n        }\r\n\r\n        var fileLength = reader.byteLength;\r\n\r\n        for (let index = 0; index < fileLength; index++) {\r\n          if (reader.getUint8(index, false) > 127) {\r\n            return true;\r\n          }\r\n        }\r\n\r\n        return false;\r\n      }\r\n    }, {\r\n      key: '_ensureBinary',\r\n      value: function _ensureBinary(buf) {\r\n        if (typeof buf === 'string') {\r\n          var array_buffer = new Uint8Array(buf.length);\r\n\r\n          for (let i = 0; i < buf.length; i++) {\r\n            array_buffer[i] = buf.charCodeAt(i) & 0xff;\r\n          }\r\n\r\n          return array_buffer.buffer || array_buffer;\r\n        } else {\r\n          return buf;\r\n        }\r\n      }\r\n    }, {\r\n      key: '_ensureString',\r\n      value: function _ensureString(buf) {\r\n        if (typeof buf !== 'string') {\r\n          return LoaderUtils.decodeText(new Uint8Array(buf));\r\n        } else {\r\n          return buf;\r\n        }\r\n      }\r\n    }, {\r\n      key: 'parse',\r\n      value: function _parse(data, onLoad) {\r\n        var binData = this._ensureBinary(data);\r\n\r\n        this._data = this._ensureString(data);\r\n        this.onLoad = onLoad;\r\n        return this._isBinary(binData) ? this._parseBinary(binData) : this._parseASCII();\r\n      }\r\n    }, {\r\n      key: '_parseBinary',\r\n      value: function _parseBinary(data) {\r\n        return this._parseASCII(LoaderUtils.decodeText(new Uint8Array(data)));\r\n      }\r\n    }, {\r\n      key: '_parseASCII',\r\n      value: function _parseASCII() {\r\n        var path;\r\n\r\n        if (this.resourcePath !== '') {\r\n          path = this.resourcePath;\r\n        } else if (this.path !== '') {\r\n          path = this.path;\r\n        } else {\r\n          path = LoaderUtils.extractUrlBase(this.url);\r\n        }\r\n\r\n        this.texloader.setPath(path).setCrossOrigin(this.crossOrigin);\r\n        var endRead = 16;\r\n        this.Hierarchies.children = [];\r\n\r\n        this._hierarchieParse(this.Hierarchies, endRead);\r\n\r\n        this._changeRoot();\r\n\r\n        this._currentObject = this.Hierarchies.children.shift();\r\n\r\n        this._mainloop();\r\n      }\r\n    }, {\r\n      key: '_hierarchieParse',\r\n      value: function _hierarchieParse(_parent, _end) {\r\n        var endRead = _end;\r\n\r\n        while (true) {\r\n          var find1 = this._data.indexOf('{', endRead) + 1;\r\n\r\n          var findEnd = this._data.indexOf('}', endRead);\r\n\r\n          var findNext = this._data.indexOf('{', find1) + 1;\r\n\r\n          if (find1 > 0 && findEnd > find1) {\r\n            var _currentObject = {};\r\n            _currentObject.children = [];\r\n\r\n            var nameData = this._readLine(this._data.substr(endRead, find1 - endRead - 1)).trim();\r\n\r\n            var word = nameData.split(/ /g);\r\n\r\n            if (word.length > 0) {\r\n              _currentObject.type = word[0];\r\n\r\n              if (word.length >= 2) {\r\n                _currentObject.name = word[1];\r\n              } else {\r\n                _currentObject.name = word[0] + this.Hierarchies.children.length;\r\n              }\r\n            } else {\r\n              _currentObject.name = nameData;\r\n              _currentObject.type = '';\r\n            }\r\n\r\n            if (_currentObject.type === 'Animation') {\r\n              _currentObject.data = this._data.substr(findNext, findEnd - findNext).trim();\r\n\r\n              var refs = this._hierarchieParse(_currentObject, findEnd + 1);\r\n\r\n              endRead = refs.end;\r\n              _currentObject.children = refs.parent.children;\r\n            } else {\r\n              var DataEnder = this._data.lastIndexOf(';', findNext > 0 ? Math.min(findNext, findEnd) : findEnd);\r\n\r\n              _currentObject.data = this._data.substr(find1, DataEnder - find1).trim();\r\n\r\n              if (findNext <= 0 || findEnd < findNext) {\r\n                endRead = findEnd + 1;\r\n              } else {\r\n                var nextStart = Math.max(DataEnder + 1, find1);\r\n\r\n                var _refs = this._hierarchieParse(_currentObject, nextStart);\r\n\r\n                endRead = _refs.end;\r\n                _currentObject.children = _refs.parent.children;\r\n              }\r\n            }\r\n\r\n            _currentObject.parent = _parent;\r\n\r\n            if (_currentObject.type != 'template') {\r\n              _parent.children.push(_currentObject);\r\n            }\r\n          } else {\r\n            endRead = find1 === -1 ? this._data.length : findEnd + 1;\r\n            break;\r\n          }\r\n        }\r\n\r\n        return {\r\n          parent: _parent,\r\n          end: endRead\r\n        };\r\n      }\r\n    }, {\r\n      key: '_mainloop',\r\n      value: function _mainloop() {\r\n        var _this2 = this;\r\n\r\n        this._mainProc();\r\n\r\n        if (this._currentObject.parent || this._currentObject.children.length > 0 || !this._currentObject.worked) {\r\n          setTimeout(function () {\r\n            _this2._mainloop();\r\n          }, 1);\r\n        } else {\r\n          setTimeout(function () {\r\n            _this2.onLoad({\r\n              models: _this2.Meshes,\r\n              animations: _this2.animations\r\n            });\r\n          }, 1);\r\n        }\r\n      }\r\n    }, {\r\n      key: '_mainProc',\r\n      value: function _mainProc() {\r\n        var breakFlag = false;\r\n\r\n        while (true) {\r\n          if (!this._currentObject.worked) {\r\n            switch (this._currentObject.type) {\r\n              case 'template':\r\n                break;\r\n\r\n              case 'AnimTicksPerSecond':\r\n                this.animTicksPerSecond = parseInt(this._currentObject.data);\r\n                break;\r\n\r\n              case 'Frame':\r\n                this._setFrame();\r\n\r\n                break;\r\n\r\n              case 'FrameTransformMatrix':\r\n                this._setFrameTransformMatrix();\r\n\r\n                break;\r\n\r\n              case 'Mesh':\r\n                this._changeRoot();\r\n\r\n                this._currentGeo = {};\r\n                this._currentGeo.name = this._currentObject.name.trim();\r\n                this._currentGeo.parentName = this._getParentName(this._currentObject).trim();\r\n                this._currentGeo.VertexSetedBoneCount = [];\r\n                this._currentGeo.GeometryData = {\r\n                  vertices: [],\r\n                  normals: [],\r\n                  uvs: [],\r\n                  skinIndices: [],\r\n                  skinWeights: [],\r\n                  indices: [],\r\n                  materialIndices: []\r\n                };\r\n                this._currentGeo.Materials = [];\r\n                this._currentGeo.normalVectors = [];\r\n                this._currentGeo.BoneInfs = [];\r\n                this._currentGeo.baseFrame = this._currentFrame;\r\n\r\n                this._makeBoneFrom_CurrentFrame();\r\n\r\n                this._readVertexDatas();\r\n\r\n                breakFlag = true;\r\n                break;\r\n\r\n              case 'MeshNormals':\r\n                this._readVertexDatas();\r\n\r\n                break;\r\n\r\n              case 'MeshTextureCoords':\r\n                this._setMeshTextureCoords();\r\n\r\n                break;\r\n\r\n              case 'VertexDuplicationIndices':\r\n                break;\r\n\r\n              case 'MeshMaterialList':\r\n                this._setMeshMaterialList();\r\n\r\n                break;\r\n\r\n              case 'Material':\r\n                this._setMaterial();\r\n\r\n                break;\r\n\r\n              case 'SkinWeights':\r\n                this._setSkinWeights();\r\n\r\n                break;\r\n\r\n              case 'AnimationSet':\r\n                this._changeRoot();\r\n\r\n                this._currentAnime = {};\r\n                this._currentAnime.name = this._currentObject.name.trim();\r\n                this._currentAnime.AnimeFrames = [];\r\n                break;\r\n\r\n              case 'Animation':\r\n                if (this._currentAnimeFrames) {\r\n                  this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);\r\n                }\r\n\r\n                this._currentAnimeFrames = new XAnimationInfo();\r\n                this._currentAnimeFrames.boneName = this._currentObject.data.trim();\r\n                break;\r\n\r\n              case 'AnimationKey':\r\n                this._readAnimationKey();\r\n\r\n                breakFlag = true;\r\n                break;\r\n            }\r\n\r\n            this._currentObject.worked = true;\r\n          }\r\n\r\n          if (this._currentObject.children.length > 0) {\r\n            this._currentObject = this._currentObject.children.shift();\r\n\r\n            if (this.debug) {\r\n              console.log('processing ' + this._currentObject.name);\r\n            }\r\n\r\n            if (breakFlag) break;\r\n          } else {\r\n            if (this._currentObject.worked) {\r\n              if (this._currentObject.parent && !this._currentObject.parent.parent) {\r\n                this._changeRoot();\r\n              }\r\n            }\r\n\r\n            if (this._currentObject.parent) {\r\n              this._currentObject = this._currentObject.parent;\r\n            } else {\r\n              breakFlag = true;\r\n            }\r\n\r\n            if (breakFlag) break;\r\n          }\r\n        }\r\n\r\n        return;\r\n      }\r\n    }, {\r\n      key: '_changeRoot',\r\n      value: function _changeRoot() {\r\n        if (this._currentGeo != null && this._currentGeo.name) {\r\n          this._makeOutputGeometry();\r\n        }\r\n\r\n        this._currentGeo = {};\r\n\r\n        if (this._currentAnime != null && this._currentAnime.name) {\r\n          if (this._currentAnimeFrames) {\r\n            this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);\r\n\r\n            this._currentAnimeFrames = null;\r\n          }\r\n\r\n          this._makeOutputAnimation();\r\n        }\r\n\r\n        this._currentAnime = {};\r\n      }\r\n    }, {\r\n      key: '_getParentName',\r\n      value: function _getParentName(_obj) {\r\n        if (_obj.parent) {\r\n          if (_obj.parent.name) {\r\n            return _obj.parent.name;\r\n          } else {\r\n            return this._getParentName(_obj.parent);\r\n          }\r\n        } else {\r\n          return '';\r\n        }\r\n      }\r\n    }, {\r\n      key: '_setFrame',\r\n      value: function _setFrame() {\r\n        this._nowFrameName = this._currentObject.name.trim();\r\n        this._currentFrame = {};\r\n        this._currentFrame.name = this._nowFrameName;\r\n        this._currentFrame.children = [];\r\n\r\n        if (this._currentObject.parent && this._currentObject.parent.name) {\r\n          this._currentFrame.parentName = this._currentObject.parent.name;\r\n        }\r\n\r\n        this.frameHierarchie.push(this._nowFrameName);\r\n        this.HieStack[this._nowFrameName] = this._currentFrame;\r\n      }\r\n    }, {\r\n      key: '_setFrameTransformMatrix',\r\n      value: function _setFrameTransformMatrix() {\r\n        this._currentFrame.FrameTransformMatrix = new Matrix4();\r\n\r\n        var data = this._currentObject.data.split(',');\r\n\r\n        this._ParseMatrixData(this._currentFrame.FrameTransformMatrix, data);\r\n\r\n        this._makeBoneFrom_CurrentFrame();\r\n      }\r\n    }, {\r\n      key: '_makeBoneFrom_CurrentFrame',\r\n      value: function _makeBoneFrom_CurrentFrame() {\r\n        if (!this._currentFrame.FrameTransformMatrix) {\r\n          return;\r\n        }\r\n\r\n        var b = new Bone();\r\n        b.name = this._currentFrame.name;\r\n        b.applyMatrix4(this._currentFrame.FrameTransformMatrix);\r\n        b.matrixWorld = b.matrix;\r\n        b.FrameTransformMatrix = this._currentFrame.FrameTransformMatrix;\r\n        this._currentFrame.putBone = b;\r\n\r\n        if (this._currentFrame.parentName) {\r\n          for (let frame in this.HieStack) {\r\n            if (this.HieStack[frame].name === this._currentFrame.parentName) {\r\n              this.HieStack[frame].putBone.add(this._currentFrame.putBone);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }, {\r\n      key: '_readVertexDatas',\r\n      value: function _readVertexDatas() {\r\n        var endRead = 0;\r\n        var mode = 0;\r\n        var mode_local = 0;\r\n        var maxLength = 0;\r\n\r\n        while (true) {\r\n          var changeMode = false;\r\n\r\n          if (mode_local === 0) {\r\n            var refO = this._readInt1(endRead);\r\n\r\n            endRead = refO.endRead;\r\n            mode_local = 1;\r\n            maxLength = this._currentObject.data.indexOf(';;', endRead) + 1;\r\n\r\n            if (maxLength <= 0) {\r\n              maxLength = this._currentObject.data.length;\r\n            }\r\n          } else {\r\n            var find = 0;\r\n\r\n            switch (mode) {\r\n              case 0:\r\n                find = this._currentObject.data.indexOf(',', endRead) + 1;\r\n                break;\r\n\r\n              case 1:\r\n                find = this._currentObject.data.indexOf(';,', endRead) + 1;\r\n                break;\r\n            }\r\n\r\n            if (find === 0 || find > maxLength) {\r\n              find = maxLength;\r\n              mode_local = 0;\r\n              changeMode = true;\r\n            }\r\n\r\n            switch (this._currentObject.type) {\r\n              case 'Mesh':\r\n                switch (mode) {\r\n                  case 0:\r\n                    this._readVertex1(this._currentObject.data.substr(endRead, find - endRead));\r\n\r\n                    break;\r\n\r\n                  case 1:\r\n                    this._readFace1(this._currentObject.data.substr(endRead, find - endRead));\r\n\r\n                    break;\r\n                }\r\n\r\n                break;\r\n\r\n              case 'MeshNormals':\r\n                switch (mode) {\r\n                  case 0:\r\n                    this._readNormalVector1(this._currentObject.data.substr(endRead, find - endRead));\r\n\r\n                    break;\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            endRead = find + 1;\r\n\r\n            if (changeMode) {\r\n              mode++;\r\n            }\r\n          }\r\n\r\n          if (endRead >= this._currentObject.data.length) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }, {\r\n      key: '_readInt1',\r\n      value: function _readInt1(start) {\r\n        var find = this._currentObject.data.indexOf(';', start);\r\n\r\n        return {\r\n          refI: parseInt(this._currentObject.data.substr(start, find - start)),\r\n          endRead: find + 1\r\n        };\r\n      }\r\n    }, {\r\n      key: '_readVertex1',\r\n      value: function _readVertex1(line) {\r\n        var data = this._readLine(line.trim()).substr(0, line.length - 2).split(';');\r\n\r\n        this._currentGeo.GeometryData.vertices.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]));\r\n\r\n        this._currentGeo.GeometryData.skinIndices.push(0, 0, 0, 0);\r\n\r\n        this._currentGeo.GeometryData.skinWeights.push(1, 0, 0, 0);\r\n\r\n        this._currentGeo.VertexSetedBoneCount.push(0);\r\n      }\r\n    }, {\r\n      key: '_readFace1',\r\n      value: function _readFace1(line) {\r\n        var data = this._readLine(line.trim()).substr(2, line.length - 4).split(',');\r\n\r\n        this._currentGeo.GeometryData.indices.push(parseInt(data[0], 10), parseInt(data[1], 10), parseInt(data[2], 10));\r\n      }\r\n    }, {\r\n      key: '_readNormalVector1',\r\n      value: function _readNormalVector1(line) {\r\n        var data = this._readLine(line.trim()).substr(0, line.length - 2).split(';');\r\n\r\n        this._currentGeo.GeometryData.normals.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]));\r\n      }\r\n    }, {\r\n      key: '_buildGeometry',\r\n      value: function _buildGeometry() {\r\n        var bufferGeometry = new BufferGeometry();\r\n        var position = [];\r\n        var normals = [];\r\n        var uvs = [];\r\n        var skinIndices = [];\r\n        var skinWeights = []; //\r\n\r\n        var data = this._currentGeo.GeometryData;\r\n\r\n        for (let i = 0, l = data.indices.length; i < l; i++) {\r\n          var stride2 = data.indices[i] * 2;\r\n          var stride3 = data.indices[i] * 3;\r\n          var stride4 = data.indices[i] * 4;\r\n          position.push(data.vertices[stride3], data.vertices[stride3 + 1], data.vertices[stride3 + 2]);\r\n          normals.push(data.normals[stride3], data.normals[stride3 + 1], data.normals[stride3 + 2]);\r\n          skinIndices.push(data.skinIndices[stride4], data.skinIndices[stride4 + 1], data.skinIndices[stride4 + 2], data.skinIndices[stride4 + 3]);\r\n          skinWeights.push(data.skinWeights[stride4], data.skinWeights[stride4 + 1], data.skinWeights[stride4 + 2], data.skinWeights[stride4 + 3]);\r\n          uvs.push(data.uvs[stride2], data.uvs[stride2 + 1]);\r\n        } //\r\n\r\n\r\n        bufferGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\r\n        bufferGeometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n        bufferGeometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n        bufferGeometry.setAttribute('skinIndex', new Uint16BufferAttribute(skinIndices, 4));\r\n        bufferGeometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeights, 4));\r\n\r\n        this._computeGroups(bufferGeometry, data.materialIndices);\r\n\r\n        return bufferGeometry;\r\n      }\r\n    }, {\r\n      key: '_computeGroups',\r\n      value: function _computeGroups(bufferGeometry, materialIndices) {\r\n        var group;\r\n        var groups = [];\r\n        var materialIndex = undefined;\r\n\r\n        for (let i = 0; i < materialIndices.length; i++) {\r\n          var currentMaterialIndex = materialIndices[i];\r\n\r\n          if (currentMaterialIndex !== materialIndex) {\r\n            materialIndex = currentMaterialIndex;\r\n\r\n            if (group !== undefined) {\r\n              group.count = i * 3 - group.start;\r\n              groups.push(group);\r\n            }\r\n\r\n            group = {\r\n              start: i * 3,\r\n              materialIndex: materialIndex\r\n            };\r\n          }\r\n        }\r\n\r\n        if (group !== undefined) {\r\n          group.count = i * 3 - group.start;\r\n          groups.push(group);\r\n        }\r\n\r\n        bufferGeometry.groups = groups;\r\n      }\r\n    }, {\r\n      key: '_setMeshTextureCoords',\r\n      value: function _setMeshTextureCoords() {\r\n        var endRead = 0;\r\n        var mode = 0;\r\n        var mode_local = 0;\r\n\r\n        while (true) {\r\n          switch (mode) {\r\n            case 0:\r\n              if (mode_local === 0) {\r\n                var refO = this._readInt1(0);\r\n\r\n                endRead = refO.endRead;\r\n                mode_local = 1;\r\n              } else {\r\n                var find = this._currentObject.data.indexOf(',', endRead) + 1;\r\n\r\n                if (find === 0) {\r\n                  find = this._currentObject.data.length;\r\n                  mode = 2;\r\n                  mode_local = 0;\r\n                }\r\n\r\n                var line = this._currentObject.data.substr(endRead, find - endRead);\r\n\r\n                var data = this._readLine(line.trim()).split(';');\r\n\r\n                if (this.IsUvYReverse) {\r\n                  this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), 1 - parseFloat(data[1]));\r\n                } else {\r\n                  this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), parseFloat(data[1]));\r\n                }\r\n\r\n                endRead = find + 1;\r\n              }\r\n\r\n              break;\r\n          }\r\n\r\n          if (endRead >= this._currentObject.data.length) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }, {\r\n      key: '_setMeshMaterialList',\r\n      value: function _setMeshMaterialList() {\r\n        var endRead = 0;\r\n        var mode = 0;\r\n        var mode_local = 0;\r\n\r\n        while (true) {\r\n          if (mode_local < 2) {\r\n            var refO = this._readInt1(endRead);\r\n\r\n            endRead = refO.endRead;\r\n            mode_local++;\r\n          } else {\r\n            var find = this._currentObject.data.indexOf(';', endRead);\r\n\r\n            if (find === -1) {\r\n              find = this._currentObject.data.length;\r\n              mode = 3;\r\n              mode_local = 0;\r\n            }\r\n\r\n            var line = this._currentObject.data.substr(endRead, find - endRead);\r\n\r\n            var data = this._readLine(line.trim()).split(',');\r\n\r\n            for (let i = 0; i < data.length; i++) {\r\n              this._currentGeo.GeometryData.materialIndices[i] = parseInt(data[i]);\r\n            }\r\n\r\n            endRead = this._currentObject.data.length;\r\n          }\r\n\r\n          if (endRead >= this._currentObject.data.length || mode >= 3) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }, {\r\n      key: '_setMaterial',\r\n      value: function _setMaterial() {\r\n        var _nowMat = new MeshPhongMaterial({\r\n          color: Math.random() * 0xffffff\r\n        });\r\n\r\n        _nowMat.side = FrontSide;\r\n        _nowMat.name = this._currentObject.name;\r\n        var endRead = 0;\r\n\r\n        var find = this._currentObject.data.indexOf(';;', endRead);\r\n\r\n        var line = this._currentObject.data.substr(endRead, find - endRead);\r\n\r\n        var data = this._readLine(line.trim()).split(';');\r\n\r\n        _nowMat.color.r = parseFloat(data[0]);\r\n        _nowMat.color.g = parseFloat(data[1]);\r\n        _nowMat.color.b = parseFloat(data[2]);\r\n        endRead = find + 2;\r\n        find = this._currentObject.data.indexOf(';', endRead);\r\n        line = this._currentObject.data.substr(endRead, find - endRead);\r\n        _nowMat.shininess = parseFloat(this._readLine(line));\r\n        endRead = find + 1;\r\n        find = this._currentObject.data.indexOf(';;', endRead);\r\n        line = this._currentObject.data.substr(endRead, find - endRead);\r\n\r\n        var data2 = this._readLine(line.trim()).split(';');\r\n\r\n        _nowMat.specular.r = parseFloat(data2[0]);\r\n        _nowMat.specular.g = parseFloat(data2[1]);\r\n        _nowMat.specular.b = parseFloat(data2[2]);\r\n        endRead = find + 2;\r\n        find = this._currentObject.data.indexOf(';;', endRead);\r\n\r\n        if (find === -1) {\r\n          find = this._currentObject.data.length;\r\n        }\r\n\r\n        line = this._currentObject.data.substr(endRead, find - endRead);\r\n\r\n        var data3 = this._readLine(line.trim()).split(';');\r\n\r\n        _nowMat.emissive.r = parseFloat(data3[0]);\r\n        _nowMat.emissive.g = parseFloat(data3[1]);\r\n        _nowMat.emissive.b = parseFloat(data3[2]);\r\n        var localObject = null;\r\n\r\n        while (true) {\r\n          if (this._currentObject.children.length > 0) {\r\n            localObject = this._currentObject.children.shift();\r\n\r\n            if (this.debug) {\r\n              console.log('processing ' + localObject.name);\r\n            }\r\n\r\n            var fileName = localObject.data.substr(1, localObject.data.length - 2);\r\n\r\n            switch (localObject.type) {\r\n              case 'TextureFilename':\r\n                _nowMat.map = this.texloader.load(fileName);\r\n                break;\r\n\r\n              case 'BumpMapFilename':\r\n                _nowMat.bumpMap = this.texloader.load(fileName);\r\n                _nowMat.bumpScale = 0.05;\r\n                break;\r\n\r\n              case 'NormalMapFilename':\r\n                _nowMat.normalMap = this.texloader.load(fileName);\r\n                _nowMat.normalScale = new Vector2(2, 2);\r\n                break;\r\n\r\n              case 'EmissiveMapFilename':\r\n                _nowMat.emissiveMap = this.texloader.load(fileName);\r\n                break;\r\n\r\n              case 'LightMapFilename':\r\n                _nowMat.lightMap = this.texloader.load(fileName);\r\n                break;\r\n            }\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n\r\n        this._currentGeo.Materials.push(_nowMat);\r\n      }\r\n    }, {\r\n      key: '_setSkinWeights',\r\n      value: function _setSkinWeights() {\r\n        var boneInf = new XboneInf();\r\n        var endRead = 0;\r\n\r\n        var find = this._currentObject.data.indexOf(';', endRead);\r\n\r\n        var line = this._currentObject.data.substr(endRead, find - endRead);\r\n\r\n        endRead = find + 1;\r\n        boneInf.boneName = line.substr(1, line.length - 2);\r\n        boneInf.BoneIndex = this._currentGeo.BoneInfs.length;\r\n        find = this._currentObject.data.indexOf(';', endRead);\r\n        endRead = find + 1;\r\n        find = this._currentObject.data.indexOf(';', endRead);\r\n        line = this._currentObject.data.substr(endRead, find - endRead);\r\n\r\n        var data = this._readLine(line.trim()).split(',');\r\n\r\n        for (let i = 0; i < data.length; i++) {\r\n          boneInf.Indeces.push(parseInt(data[i]));\r\n        }\r\n\r\n        endRead = find + 1;\r\n        find = this._currentObject.data.indexOf(';', endRead);\r\n        line = this._currentObject.data.substr(endRead, find - endRead);\r\n\r\n        var data2 = this._readLine(line.trim()).split(',');\r\n\r\n        for (let _i = 0; _i < data2.length; _i++) {\r\n          boneInf.Weights.push(parseFloat(data2[_i]));\r\n        }\r\n\r\n        endRead = find + 1;\r\n        find = this._currentObject.data.indexOf(';', endRead);\r\n\r\n        if (find <= 0) {\r\n          find = this._currentObject.data.length;\r\n        }\r\n\r\n        line = this._currentObject.data.substr(endRead, find - endRead);\r\n\r\n        var data3 = this._readLine(line.trim()).split(',');\r\n\r\n        boneInf.OffsetMatrix = new Matrix4();\r\n\r\n        this._ParseMatrixData(boneInf.OffsetMatrix, data3);\r\n\r\n        this._currentGeo.BoneInfs.push(boneInf);\r\n      }\r\n    }, {\r\n      key: '_makePutBoneList',\r\n      value: function _makePutBoneList(_RootName, _bones) {\r\n        var putting = false;\r\n\r\n        for (let frame in this.HieStack) {\r\n          if (this.HieStack[frame].name === _RootName || putting) {\r\n            putting = true;\r\n            var b = new Bone();\r\n            b.name = this.HieStack[frame].name;\r\n            b.applyMatrix4(this.HieStack[frame].FrameTransformMatrix);\r\n            b.matrixWorld = b.matrix;\r\n            b.FrameTransformMatrix = this.HieStack[frame].FrameTransformMatrix;\r\n            b.pos = new Vector3().setFromMatrixPosition(b.FrameTransformMatrix).toArray();\r\n            b.rotq = new Quaternion().setFromRotationMatrix(b.FrameTransformMatrix).toArray();\r\n            b.scl = new Vector3().setFromMatrixScale(b.FrameTransformMatrix).toArray();\r\n\r\n            if (this.HieStack[frame].parentName && this.HieStack[frame].parentName.length > 0) {\r\n              for (let i = 0; i < _bones.length; i++) {\r\n                if (this.HieStack[frame].parentName === _bones[i].name) {\r\n                  _bones[i].add(b);\r\n\r\n                  b.parent = i;\r\n                  break;\r\n                }\r\n              }\r\n            }\r\n\r\n            _bones.push(b);\r\n          }\r\n        }\r\n      }\r\n    }, {\r\n      key: '_makeOutputGeometry',\r\n      value: function _makeOutputGeometry() {\r\n        var mesh = null;\r\n\r\n        if (this._currentGeo.BoneInfs.length > 0) {\r\n          var putBones = [];\r\n\r\n          this._makePutBoneList(this._currentGeo.baseFrame.parentName, putBones);\r\n\r\n          for (let bi = 0; bi < this._currentGeo.BoneInfs.length; bi++) {\r\n            var boneIndex = 0;\r\n\r\n            for (let bb = 0; bb < putBones.length; bb++) {\r\n              if (putBones[bb].name === this._currentGeo.BoneInfs[bi].boneName) {\r\n                boneIndex = bb;\r\n                putBones[bb].OffsetMatrix = new Matrix4();\r\n                putBones[bb].OffsetMatrix.copy(this._currentGeo.BoneInfs[bi].OffsetMatrix);\r\n                break;\r\n              }\r\n            }\r\n\r\n            for (let vi = 0; vi < this._currentGeo.BoneInfs[bi].Indeces.length; vi++) {\r\n              var nowVertexID = this._currentGeo.BoneInfs[bi].Indeces[vi];\r\n              var nowVal = this._currentGeo.BoneInfs[bi].Weights[vi];\r\n              var stride = nowVertexID * 4;\r\n\r\n              switch (this._currentGeo.VertexSetedBoneCount[nowVertexID]) {\r\n                case 0:\r\n                  this._currentGeo.GeometryData.skinIndices[stride] = boneIndex;\r\n                  this._currentGeo.GeometryData.skinWeights[stride] = nowVal;\r\n                  break;\r\n\r\n                case 1:\r\n                  this._currentGeo.GeometryData.skinIndices[stride + 1] = boneIndex;\r\n                  this._currentGeo.GeometryData.skinWeights[stride + 1] = nowVal;\r\n                  break;\r\n\r\n                case 2:\r\n                  this._currentGeo.GeometryData.skinIndices[stride + 2] = boneIndex;\r\n                  this._currentGeo.GeometryData.skinWeights[stride + 2] = nowVal;\r\n                  break;\r\n\r\n                case 3:\r\n                  this._currentGeo.GeometryData.skinIndices[stride + 3] = boneIndex;\r\n                  this._currentGeo.GeometryData.skinWeights[stride + 3] = nowVal;\r\n                  break;\r\n              }\r\n\r\n              this._currentGeo.VertexSetedBoneCount[nowVertexID]++;\r\n\r\n              if (this._currentGeo.VertexSetedBoneCount[nowVertexID] > 4) {\r\n                console.log('warn! over 4 bone weight! :' + nowVertexID);\r\n              }\r\n            }\r\n          }\r\n\r\n          for (let sk = 0; sk < this._currentGeo.Materials.length; sk++) {\r\n            this._currentGeo.Materials[sk].skinning = true;\r\n          }\r\n\r\n          var offsetList = [];\r\n\r\n          for (let _bi = 0; _bi < putBones.length; _bi++) {\r\n            if (putBones[_bi].OffsetMatrix) {\r\n              offsetList.push(putBones[_bi].OffsetMatrix);\r\n            } else {\r\n              offsetList.push(new Matrix4());\r\n            }\r\n          }\r\n\r\n          var bufferGeometry = this._buildGeometry();\r\n\r\n          mesh = new SkinnedMesh(bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);\r\n\r\n          this._initSkeleton(mesh, putBones, offsetList);\r\n        } else {\r\n          var _bufferGeometry = this._buildGeometry();\r\n\r\n          mesh = new Mesh(_bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);\r\n        }\r\n\r\n        mesh.name = this._currentGeo.name;\r\n        var worldBaseMx = new Matrix4();\r\n        var currentMxFrame = this._currentGeo.baseFrame.putBone;\r\n\r\n        if (currentMxFrame && currentMxFrame.parent) {\r\n          while (true) {\r\n            currentMxFrame = currentMxFrame.parent;\r\n\r\n            if (currentMxFrame) {\r\n              worldBaseMx.multiply(currentMxFrame.FrameTransformMatrix);\r\n            } else {\r\n              break;\r\n            }\r\n          }\r\n\r\n          mesh.applyMatrix4(worldBaseMx);\r\n        }\r\n\r\n        this.Meshes.push(mesh);\r\n      }\r\n    }, {\r\n      key: '_initSkeleton',\r\n      value: function _initSkeleton(mesh, boneList, boneInverses) {\r\n        var bones = [],\r\n            bone,\r\n            gbone;\r\n        var i, il;\r\n\r\n        for (i = 0, il = boneList.length; i < il; i++) {\r\n          gbone = boneList[i];\r\n          bone = new Bone();\r\n          bones.push(bone);\r\n          bone.name = gbone.name;\r\n          bone.position.fromArray(gbone.pos);\r\n          bone.quaternion.fromArray(gbone.rotq);\r\n          if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl);\r\n        }\r\n\r\n        for (i = 0, il = boneList.length; i < il; i++) {\r\n          gbone = boneList[i];\r\n\r\n          if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {\r\n            bones[gbone.parent].add(bones[i]);\r\n          } else {\r\n            mesh.add(bones[i]);\r\n          }\r\n        }\r\n\r\n        mesh.updateMatrixWorld(true);\r\n        var skeleton = new Skeleton(bones, boneInverses);\r\n        mesh.bind(skeleton, mesh.matrixWorld);\r\n      }\r\n    }, {\r\n      key: '_readAnimationKey',\r\n      value: function _readAnimationKey() {\r\n        var endRead = 0;\r\n\r\n        var find = this._currentObject.data.indexOf(';', endRead);\r\n\r\n        var line = this._currentObject.data.substr(endRead, find - endRead);\r\n\r\n        endRead = find + 1;\r\n        var nowKeyType = parseInt(this._readLine(line));\r\n        find = this._currentObject.data.indexOf(';', endRead);\r\n        endRead = find + 1;\r\n        line = this._currentObject.data.substr(endRead);\r\n\r\n        var data = this._readLine(line.trim()).split(';;,');\r\n\r\n        for (let i = 0; i < data.length; i++) {\r\n          var data2 = data[i].split(';');\r\n          var keyInfo = new XKeyFrameInfo();\r\n          keyInfo.type = nowKeyType;\r\n          keyInfo.Frame = parseInt(data2[0]);\r\n          keyInfo.index = this._currentAnimeFrames.keyFrames.length;\r\n          keyInfo.time = keyInfo.Frame;\r\n\r\n          if (nowKeyType != 4) {\r\n            var frameFound = false;\r\n\r\n            for (let mm = 0; mm < this._currentAnimeFrames.keyFrames.length; mm++) {\r\n              if (this._currentAnimeFrames.keyFrames[mm].Frame === keyInfo.Frame) {\r\n                keyInfo = this._currentAnimeFrames.keyFrames[mm];\r\n                frameFound = true;\r\n                break;\r\n              }\r\n            }\r\n\r\n            var frameValue = data2[2].split(',');\r\n\r\n            switch (nowKeyType) {\r\n              case 0:\r\n                keyInfo.rot = new Quaternion(parseFloat(frameValue[1]), parseFloat(frameValue[2]), parseFloat(frameValue[3]), parseFloat(frameValue[0]) * -1);\r\n                break;\r\n\r\n              case 1:\r\n                keyInfo.scl = new Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));\r\n                break;\r\n\r\n              case 2:\r\n                keyInfo.pos = new Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));\r\n                break;\r\n            }\r\n\r\n            if (!frameFound) {\r\n              this._currentAnimeFrames.keyFrames.push(keyInfo);\r\n            }\r\n          } else {\r\n            keyInfo.matrix = new Matrix4();\r\n\r\n            this._ParseMatrixData(keyInfo.matrix, data2[2].split(','));\r\n\r\n            this._currentAnimeFrames.keyFrames.push(keyInfo);\r\n          }\r\n        }\r\n      }\r\n    }, {\r\n      key: '_makeOutputAnimation',\r\n      value: function _makeOutputAnimation() {\r\n        var animationObj = new XAnimationObj(this.options);\r\n        animationObj.fps = this.animTicksPerSecond;\r\n        animationObj.name = this._currentAnime.name;\r\n        animationObj.make(this._currentAnime.AnimeFrames);\r\n        this.animations.push(animationObj);\r\n      }\r\n    }, {\r\n      key: 'assignAnimation',\r\n      value: function assignAnimation(_model, _animation) {\r\n        var model = _model;\r\n        var animation = _animation;\r\n\r\n        if (!model) {\r\n          model = this.Meshes[0];\r\n        }\r\n\r\n        if (!animation) {\r\n          animation = this.animations[0];\r\n        }\r\n\r\n        if (!model || !animation) {\r\n          return null;\r\n        }\r\n\r\n        var put = {};\r\n        put.fps = animation.fps;\r\n        put.name = animation.name;\r\n        put.length = animation.length;\r\n        put.hierarchy = [];\r\n\r\n        for (let b = 0; b < model.skeleton.bones.length; b++) {\r\n          var findAnimation = false;\r\n\r\n          for (let i = 0; i < animation.hierarchy.length; i++) {\r\n            if (model.skeleton.bones[b].name === animation.hierarchy[i].name) {\r\n              findAnimation = true;\r\n              var c_key = animation.hierarchy[i].copy();\r\n              c_key.parent = -1;\r\n\r\n              if (model.skeleton.bones[b].parent && model.skeleton.bones[b].parent.type === 'Bone') {\r\n                for (let bb = 0; bb < put.hierarchy.length; bb++) {\r\n                  if (put.hierarchy[bb].name === model.skeleton.bones[b].parent.name) {\r\n                    c_key.parent = bb;\r\n                    c_key.parentName = model.skeleton.bones[b].parent.name;\r\n                  }\r\n                }\r\n              }\r\n\r\n              put.hierarchy.push(c_key);\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (!findAnimation) {\r\n            var _c_key = animation.hierarchy[0].copy();\r\n\r\n            _c_key.name = model.skeleton.bones[b].name;\r\n            _c_key.parent = -1;\r\n\r\n            for (let k = 0; k < _c_key.keys.length; k++) {\r\n              if (_c_key.keys[k].pos) {\r\n                _c_key.keys[k].pos.set(0, 0, 0);\r\n              }\r\n\r\n              if (_c_key.keys[k].scl) {\r\n                _c_key.keys[k].scl.set(1, 1, 1);\r\n              }\r\n\r\n              if (_c_key.keys[k].rot) {\r\n                _c_key.keys[k].rot.set(0, 0, 0, 1);\r\n              }\r\n            }\r\n\r\n            put.hierarchy.push(_c_key);\r\n          }\r\n        }\r\n\r\n        if (!model.geometry.animations) {\r\n          model.geometry.animations = [];\r\n        }\r\n\r\n        model.geometry.animations.push(AnimationClip.parseAnimation(put, model.skeleton.bones));\r\n\r\n        if (!model.animationMixer) {\r\n          model.animationMixer = new AnimationMixer(model);\r\n        }\r\n\r\n        return put;\r\n      }\r\n    }, {\r\n      key: '_ParseMatrixData',\r\n      value: function _ParseMatrixData(targetMatrix, data) {\r\n        targetMatrix.set(parseFloat(data[0]), parseFloat(data[4]), parseFloat(data[8]), parseFloat(data[12]), parseFloat(data[1]), parseFloat(data[5]), parseFloat(data[9]), parseFloat(data[13]), parseFloat(data[2]), parseFloat(data[6]), parseFloat(data[10]), parseFloat(data[14]), parseFloat(data[3]), parseFloat(data[7]), parseFloat(data[11]), parseFloat(data[15]));\r\n      }\r\n    }]);\r\n    return XLoader;\r\n  }();\r\n\r\n  return XLoader;\r\n}();\r\n\r\nexport { XLoader };\r\n", "/**\r\n * @author Deepkolos / https://github.com/deepkolos\r\n */\r\nclass WorkerPool {\r\n  constructor(pool = 4) {\r\n    this.pool = pool;\r\n    this.queue = [];\r\n    this.workers = [];\r\n    this.workersResolve = [];\r\n    this.workerStatus = 0;\r\n  }\r\n\r\n  _initWorker(workerId) {\r\n    if (!this.workers[workerId]) {\r\n      const worker = this.workerCreator();\r\n      worker.addEventListener('message', this._onMessage.bind(this, workerId));\r\n      this.workers[workerId] = worker;\r\n    }\r\n  }\r\n\r\n  _getIdleWorker() {\r\n    for (let i = 0; i < this.pool; i++) if (!(this.workerStatus & 1 << i)) return i;\r\n\r\n    return -1;\r\n  }\r\n\r\n  _onMessage(workerId, msg) {\r\n    const resolve = this.workersResolve[workerId];\r\n    resolve && resolve(msg);\r\n\r\n    if (this.queue.length) {\r\n      const {\r\n        resolve,\r\n        msg,\r\n        transfer\r\n      } = this.queue.shift();\r\n      this.workersResolve[workerId] = resolve;\r\n      this.workers[workerId].postMessage(msg, transfer);\r\n    } else {\r\n      this.workerStatus ^= 1 << workerId;\r\n    }\r\n  }\r\n\r\n  setWorkerCreator(workerCreator) {\r\n    this.workerCreator = workerCreator;\r\n  }\r\n\r\n  setWorkerLimit(pool) {\r\n    this.pool = pool;\r\n  }\r\n\r\n  postMessage(msg, transfer) {\r\n    return new Promise(resolve => {\r\n      const workerId = this._getIdleWorker();\r\n\r\n      if (workerId !== -1) {\r\n        this._initWorker(workerId);\r\n\r\n        this.workerStatus |= 1 << workerId;\r\n        this.workersResolve[workerId] = resolve;\r\n        this.workers[workerId].postMessage(msg, transfer);\r\n      } else {\r\n        this.queue.push({\r\n          resolve,\r\n          msg,\r\n          transfer\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  dispose() {\r\n    this.workers.forEach(worker => worker.terminate());\r\n    this.workersResolve.length = 0;\r\n    this.workers.length = 0;\r\n    this.queue.length = 0;\r\n    this.workerStatus = 0;\r\n  }\r\n\r\n}\r\n\r\nexport { WorkerPool };\r\n", "import { Loader, FileLoader, CompressedTexture, UnsignedByteType, LinearFilter, LinearMipmapLinearFilter, sRGBEncoding, LinearEncoding, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, FloatType, HalfFloatType, DataTexture, Data3DTexture, RGFormat, RedFormat } from 'three';\r\nimport { WorkerPool } from '../utils/WorkerPool.js';\r\nimport { KHR_DF_TRANSFER_SRGB, KHR_DF_FLAG_ALPHA_PREMULTIPLIED, read, VK_FORMAT_UNDEFINED, KHR_SUPERCOMPRESSION_NONE, KHR_SUPERCOMPRESSION_ZSTD, VK_FORMAT_R32G32B32A32_SFLOAT, VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_R8G8B8A8_SRGB, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R8G8_UNORM, VK_FORMAT_R8G8_SRGB, VK_FORMAT_R32_SFLOAT, VK_FORMAT_R16_SFLOAT, VK_FORMAT_R8_SRGB, VK_FORMAT_R8_UNORM } from 'ktx-parse';\r\nimport { ZSTDDecoder } from 'zstddec';\r\n\r\n/**\r\n * Loader for KTX 2.0 GPU Texture containers.\r\n *\r\n * KTX 2.0 is a container format for various GPU texture formats. The loader\r\n * supports Basis Universal GPU textures, which can be quickly transcoded to\r\n * a wide variety of GPU texture compression formats, as well as some\r\n * uncompressed DataTexture and Data3DTexture formats.\r\n *\r\n * References:\r\n * - KTX: http://github.khronos.org/KTX-Specification/\r\n * - DFD: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#basicdescriptor\r\n */\r\n\r\nconst _taskCache = new WeakMap();\r\n\r\nlet _activeLoaders = 0;\r\n\r\nlet _zstd;\r\n\r\nclass KTX2Loader extends Loader {\r\n  constructor(manager) {\r\n    super(manager);\r\n    this.transcoderPath = '';\r\n    this.transcoderBinary = null;\r\n    this.transcoderPending = null;\r\n    this.workerPool = new WorkerPool();\r\n    this.workerSourceURL = '';\r\n    this.workerConfig = null;\r\n\r\n    if (typeof MSC_TRANSCODER !== 'undefined') {\r\n      console.warn('THREE.KTX2Loader: Please update to latest \"basis_transcoder\".' + ' \"msc_basis_transcoder\" is no longer supported in three.js r125+.');\r\n    }\r\n  }\r\n\r\n  setTranscoderPath(path) {\r\n    this.transcoderPath = path;\r\n    return this;\r\n  }\r\n\r\n  setWorkerLimit(num) {\r\n    this.workerPool.setWorkerLimit(num);\r\n    return this;\r\n  }\r\n\r\n  detectSupport(renderer) {\r\n    this.workerConfig = {\r\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\r\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\r\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\r\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\r\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\r\n      pvrtcSupported: renderer.extensions.has('WEBGL_compressed_texture_pvrtc') || renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc')\r\n    };\r\n\r\n    if (renderer.capabilities.isWebGL2) {\r\n      // https://github.com/mrdoob/three.js/pull/22928\r\n      this.workerConfig.etc1Supported = false;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  init() {\r\n    if (!this.transcoderPending) {\r\n      // Load transcoder wrapper.\r\n      const jsLoader = new FileLoader(this.manager);\r\n      jsLoader.setPath(this.transcoderPath);\r\n      jsLoader.setWithCredentials(this.withCredentials);\r\n      const jsContent = jsLoader.loadAsync('basis_transcoder.js'); // Load transcoder WASM binary.\r\n\r\n      const binaryLoader = new FileLoader(this.manager);\r\n      binaryLoader.setPath(this.transcoderPath);\r\n      binaryLoader.setResponseType('arraybuffer');\r\n      binaryLoader.setWithCredentials(this.withCredentials);\r\n      const binaryContent = binaryLoader.loadAsync('basis_transcoder.wasm');\r\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\r\n        const fn = KTX2Loader.BasisWorker.toString();\r\n        const body = ['/* constants */', 'let _EngineFormat = ' + JSON.stringify(KTX2Loader.EngineFormat), 'let _TranscoderFormat = ' + JSON.stringify(KTX2Loader.TranscoderFormat), 'let _BasisFormat = ' + JSON.stringify(KTX2Loader.BasisFormat), '/* basis_transcoder.js */', jsContent, '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\r\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]));\r\n        this.transcoderBinary = binaryContent;\r\n        this.workerPool.setWorkerCreator(() => {\r\n          const worker = new Worker(this.workerSourceURL);\r\n          const transcoderBinary = this.transcoderBinary.slice(0);\r\n          worker.postMessage({\r\n            type: 'init',\r\n            config: this.workerConfig,\r\n            transcoderBinary\r\n          }, [transcoderBinary]);\r\n          return worker;\r\n        });\r\n      });\r\n\r\n      if (_activeLoaders > 0) {\r\n        // Each instance loads a transcoder and allocates workers, increasing network and memory cost.\r\n        console.warn('THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues.' + ' Use a single KTX2Loader instance, or call .dispose() on old instances.');\r\n      }\r\n\r\n      _activeLoaders++;\r\n    }\r\n\r\n    return this.transcoderPending;\r\n  }\r\n\r\n  load(url, onLoad, onProgress, onError) {\r\n    if (this.workerConfig === null) {\r\n      throw new Error('THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.');\r\n    }\r\n\r\n    const loader = new FileLoader(this.manager);\r\n    loader.setResponseType('arraybuffer');\r\n    loader.setWithCredentials(this.withCredentials);\r\n    loader.load(url, buffer => {\r\n      // Check for an existing task using this buffer. A transferred buffer cannot be transferred\r\n      // again from this thread.\r\n      if (_taskCache.has(buffer)) {\r\n        const cachedTask = _taskCache.get(buffer);\r\n\r\n        return cachedTask.promise.then(onLoad).catch(onError);\r\n      }\r\n\r\n      this._createTexture(buffer).then(texture => onLoad ? onLoad(texture) : null).catch(onError);\r\n    }, onProgress, onError);\r\n  }\r\n\r\n  _createTextureFrom(transcodeResult) {\r\n    const {\r\n      mipmaps,\r\n      width,\r\n      height,\r\n      format,\r\n      type,\r\n      error,\r\n      dfdTransferFn,\r\n      dfdFlags\r\n    } = transcodeResult;\r\n    if (type === 'error') return Promise.reject(error);\r\n    const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\r\n    texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\r\n    texture.magFilter = LinearFilter;\r\n    texture.generateMipmaps = false;\r\n    texture.needsUpdate = true;\r\n    texture.encoding = dfdTransferFn === KHR_DF_TRANSFER_SRGB ? sRGBEncoding : LinearEncoding;\r\n    texture.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED);\r\n    return texture;\r\n  }\r\n  /**\r\n   * @param {ArrayBuffer} buffer\r\n   * @param {object?} config\r\n   * @return {Promise<CompressedTexture|DataTexture|Data3DTexture>}\r\n   */\r\n\r\n\r\n  _createTexture(buffer, config = {}) {\r\n    const container = read(new Uint8Array(buffer));\r\n\r\n    if (container.vkFormat !== VK_FORMAT_UNDEFINED) {\r\n      return createDataTexture(container);\r\n    } //\r\n\r\n\r\n    const taskConfig = config;\r\n    const texturePending = this.init().then(() => {\r\n      return this.workerPool.postMessage({\r\n        type: 'transcode',\r\n        buffer,\r\n        taskConfig: taskConfig\r\n      }, [buffer]);\r\n    }).then(e => this._createTextureFrom(e.data)); // Cache the task result.\r\n\r\n    _taskCache.set(buffer, {\r\n      promise: texturePending\r\n    });\r\n\r\n    return texturePending;\r\n  }\r\n\r\n  dispose() {\r\n    this.workerPool.dispose();\r\n    if (this.workerSourceURL) URL.revokeObjectURL(this.workerSourceURL);\r\n    _activeLoaders--;\r\n    return this;\r\n  }\r\n\r\n}\r\n/* CONSTANTS */\r\n\r\n\r\nKTX2Loader.BasisFormat = {\r\n  ETC1S: 0,\r\n  UASTC_4x4: 1\r\n};\r\nKTX2Loader.TranscoderFormat = {\r\n  ETC1: 0,\r\n  ETC2: 1,\r\n  BC1: 2,\r\n  BC3: 3,\r\n  BC4: 4,\r\n  BC5: 5,\r\n  BC7_M6_OPAQUE_ONLY: 6,\r\n  BC7_M5: 7,\r\n  PVRTC1_4_RGB: 8,\r\n  PVRTC1_4_RGBA: 9,\r\n  ASTC_4x4: 10,\r\n  ATC_RGB: 11,\r\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\r\n  RGBA32: 13,\r\n  RGB565: 14,\r\n  BGR565: 15,\r\n  RGBA4444: 16\r\n};\r\nKTX2Loader.EngineFormat = {\r\n  RGBAFormat: RGBAFormat,\r\n  RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\r\n  RGBA_BPTC_Format: RGBA_BPTC_Format,\r\n  RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\r\n  RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\r\n  RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\r\n  RGB_ETC1_Format: RGB_ETC1_Format,\r\n  RGB_ETC2_Format: RGB_ETC2_Format,\r\n  RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\r\n  RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format\r\n};\r\n/* WEB WORKER */\r\n\r\nKTX2Loader.BasisWorker = function () {\r\n  let config;\r\n  let transcoderPending;\r\n  let BasisModule;\r\n  const EngineFormat = _EngineFormat; // eslint-disable-line no-undef\r\n\r\n  const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef\r\n\r\n  const BasisFormat = _BasisFormat; // eslint-disable-line no-undef\r\n\r\n  self.addEventListener('message', function (e) {\r\n    const message = e.data;\r\n\r\n    switch (message.type) {\r\n      case 'init':\r\n        config = message.config;\r\n        init(message.transcoderBinary);\r\n        break;\r\n\r\n      case 'transcode':\r\n        transcoderPending.then(() => {\r\n          try {\r\n            const {\r\n              width,\r\n              height,\r\n              hasAlpha,\r\n              mipmaps,\r\n              format,\r\n              dfdTransferFn,\r\n              dfdFlags\r\n            } = transcode(message.buffer);\r\n            const buffers = [];\r\n\r\n            for (let i = 0; i < mipmaps.length; ++i) {\r\n              buffers.push(mipmaps[i].data.buffer);\r\n            }\r\n\r\n            self.postMessage({\r\n              type: 'transcode',\r\n              id: message.id,\r\n              width,\r\n              height,\r\n              hasAlpha,\r\n              mipmaps,\r\n              format,\r\n              dfdTransferFn,\r\n              dfdFlags\r\n            }, buffers);\r\n          } catch (error) {\r\n            console.error(error);\r\n            self.postMessage({\r\n              type: 'error',\r\n              id: message.id,\r\n              error: error.message\r\n            });\r\n          }\r\n        });\r\n        break;\r\n    }\r\n  });\r\n\r\n  function init(wasmBinary) {\r\n    transcoderPending = new Promise(resolve => {\r\n      BasisModule = {\r\n        wasmBinary,\r\n        onRuntimeInitialized: resolve\r\n      };\r\n      BASIS(BasisModule); // eslint-disable-line no-undef\r\n    }).then(() => {\r\n      BasisModule.initializeBasis();\r\n\r\n      if (BasisModule.KTX2File === undefined) {\r\n        console.warn('THREE.KTX2Loader: Please update Basis Universal transcoder.');\r\n      }\r\n    });\r\n  }\r\n\r\n  function transcode(buffer) {\r\n    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));\r\n\r\n    function cleanup() {\r\n      ktx2File.close();\r\n      ktx2File.delete();\r\n    }\r\n\r\n    if (!ktx2File.isValid()) {\r\n      cleanup();\r\n      throw new Error('THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file');\r\n    }\r\n\r\n    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\r\n    const width = ktx2File.getWidth();\r\n    const height = ktx2File.getHeight();\r\n    const levels = ktx2File.getLevels();\r\n    const hasAlpha = ktx2File.getHasAlpha();\r\n    const dfdTransferFn = ktx2File.getDFDTransferFunc();\r\n    const dfdFlags = ktx2File.getDFDFlags();\r\n    const {\r\n      transcoderFormat,\r\n      engineFormat\r\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\r\n\r\n    if (!width || !height || !levels) {\r\n      cleanup();\r\n      throw new Error('THREE.KTX2Loader:\tInvalid texture');\r\n    }\r\n\r\n    if (!ktx2File.startTranscoding()) {\r\n      cleanup();\r\n      throw new Error('THREE.KTX2Loader: .startTranscoding failed');\r\n    }\r\n\r\n    const mipmaps = [];\r\n\r\n    for (let mip = 0; mip < levels; mip++) {\r\n      const levelInfo = ktx2File.getImageLevelInfo(mip, 0, 0);\r\n      const mipWidth = levelInfo.origWidth;\r\n      const mipHeight = levelInfo.origHeight;\r\n      const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, 0, 0, transcoderFormat));\r\n      const status = ktx2File.transcodeImage(dst, mip, 0, 0, transcoderFormat, 0, -1, -1);\r\n\r\n      if (!status) {\r\n        cleanup();\r\n        throw new Error('THREE.KTX2Loader: .transcodeImage failed.');\r\n      }\r\n\r\n      mipmaps.push({\r\n        data: dst,\r\n        width: mipWidth,\r\n        height: mipHeight\r\n      });\r\n    }\r\n\r\n    cleanup();\r\n    return {\r\n      width,\r\n      height,\r\n      hasAlpha,\r\n      mipmaps,\r\n      format: engineFormat,\r\n      dfdTransferFn,\r\n      dfdFlags\r\n    };\r\n  } //\r\n  // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\r\n  // device capabilities, and texture dimensions. The list below ranks the formats separately\r\n  // for ETC1S and UASTC.\r\n  //\r\n  // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\r\n  // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\r\n  // chooses RGBA32 only as a last resort and does not expose that option to the caller.\r\n\r\n\r\n  const FORMAT_OPTIONS = [{\r\n    if: 'astcSupported',\r\n    basisFormat: [BasisFormat.UASTC_4x4],\r\n    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\r\n    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\r\n    priorityETC1S: Infinity,\r\n    priorityUASTC: 1,\r\n    needsPowerOfTwo: false\r\n  }, {\r\n    if: 'bptcSupported',\r\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\r\n    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\r\n    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\r\n    priorityETC1S: 3,\r\n    priorityUASTC: 2,\r\n    needsPowerOfTwo: false\r\n  }, {\r\n    if: 'dxtSupported',\r\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\r\n    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\r\n    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\r\n    priorityETC1S: 4,\r\n    priorityUASTC: 5,\r\n    needsPowerOfTwo: false\r\n  }, {\r\n    if: 'etc2Supported',\r\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\r\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\r\n    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\r\n    priorityETC1S: 1,\r\n    priorityUASTC: 3,\r\n    needsPowerOfTwo: false\r\n  }, {\r\n    if: 'etc1Supported',\r\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\r\n    transcoderFormat: [TranscoderFormat.ETC1],\r\n    engineFormat: [EngineFormat.RGB_ETC1_Format],\r\n    priorityETC1S: 2,\r\n    priorityUASTC: 4,\r\n    needsPowerOfTwo: false\r\n  }, {\r\n    if: 'pvrtcSupported',\r\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\r\n    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\r\n    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\r\n    priorityETC1S: 5,\r\n    priorityUASTC: 6,\r\n    needsPowerOfTwo: true\r\n  }];\r\n  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\r\n    return a.priorityETC1S - b.priorityETC1S;\r\n  });\r\n  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\r\n    return a.priorityUASTC - b.priorityUASTC;\r\n  });\r\n\r\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\r\n    let transcoderFormat;\r\n    let engineFormat;\r\n    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\r\n\r\n    for (let i = 0; i < options.length; i++) {\r\n      const opt = options[i];\r\n      if (!config[opt.if]) continue;\r\n      if (!opt.basisFormat.includes(basisFormat)) continue;\r\n      if (hasAlpha && opt.transcoderFormat.length < 2) continue;\r\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\r\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\r\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\r\n      return {\r\n        transcoderFormat,\r\n        engineFormat\r\n      };\r\n    }\r\n\r\n    console.warn('THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.');\r\n    transcoderFormat = TranscoderFormat.RGBA32;\r\n    engineFormat = EngineFormat.RGBAFormat;\r\n    return {\r\n      transcoderFormat,\r\n      engineFormat\r\n    };\r\n  }\r\n\r\n  function isPowerOfTwo(value) {\r\n    if (value <= 2) return true;\r\n    return (value & value - 1) === 0 && value !== 0;\r\n  }\r\n}; //\r\n// DataTexture and Data3DTexture parsing.\r\n\r\n\r\nconst FORMAT_MAP = {\r\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,\r\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,\r\n  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,\r\n  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,\r\n  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,\r\n  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,\r\n  [VK_FORMAT_R8G8_UNORM]: RGFormat,\r\n  [VK_FORMAT_R8G8_SRGB]: RGFormat,\r\n  [VK_FORMAT_R32_SFLOAT]: RedFormat,\r\n  [VK_FORMAT_R16_SFLOAT]: RedFormat,\r\n  [VK_FORMAT_R8_SRGB]: RedFormat,\r\n  [VK_FORMAT_R8_UNORM]: RedFormat\r\n};\r\nconst TYPE_MAP = {\r\n  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,\r\n  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,\r\n  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,\r\n  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,\r\n  [VK_FORMAT_R32G32_SFLOAT]: FloatType,\r\n  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,\r\n  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,\r\n  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,\r\n  [VK_FORMAT_R32_SFLOAT]: FloatType,\r\n  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,\r\n  [VK_FORMAT_R8_SRGB]: UnsignedByteType,\r\n  [VK_FORMAT_R8_UNORM]: UnsignedByteType\r\n};\r\nconst ENCODING_MAP = {\r\n  [VK_FORMAT_R8G8B8A8_SRGB]: sRGBEncoding,\r\n  [VK_FORMAT_R8G8_SRGB]: sRGBEncoding,\r\n  [VK_FORMAT_R8_SRGB]: sRGBEncoding\r\n};\r\n\r\nasync function createDataTexture(container) {\r\n  const {\r\n    vkFormat,\r\n    pixelWidth,\r\n    pixelHeight,\r\n    pixelDepth\r\n  } = container;\r\n\r\n  if (FORMAT_MAP[vkFormat] === undefined) {\r\n    throw new Error('THREE.KTX2Loader: Unsupported vkFormat.');\r\n  } //\r\n\r\n\r\n  const level = container.levels[0];\r\n  let levelData;\r\n  let view;\r\n\r\n  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\r\n    levelData = level.levelData;\r\n  } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {\r\n    if (!_zstd) {\r\n      _zstd = new Promise(async resolve => {\r\n        const zstd = new ZSTDDecoder();\r\n        await zstd.init();\r\n        resolve(zstd);\r\n      });\r\n    }\r\n\r\n    levelData = (await _zstd).decode(level.levelData, level.uncompressedByteLength);\r\n  } else {\r\n    throw new Error('THREE.KTX2Loader: Unsupported supercompressionScheme.');\r\n  }\r\n\r\n  if (TYPE_MAP[vkFormat] === FloatType) {\r\n    view = new Float32Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT);\r\n  } else if (TYPE_MAP[vkFormat] === HalfFloatType) {\r\n    view = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT);\r\n  } else {\r\n    view = levelData;\r\n  } //\r\n\r\n\r\n  const texture = pixelDepth === 0 ? new DataTexture(view, pixelWidth, pixelHeight) : new Data3DTexture(view, pixelWidth, pixelHeight, pixelDepth);\r\n  texture.type = TYPE_MAP[vkFormat];\r\n  texture.format = FORMAT_MAP[vkFormat];\r\n  texture.encoding = ENCODING_MAP[vkFormat] || LinearEncoding;\r\n  texture.needsUpdate = true; //\r\n\r\n  return Promise.resolve(texture);\r\n}\r\n\r\nexport { KTX2Loader };\r\n", "import { Loader, LoaderUtils, FileLoader, TextureLoader, Vector3, Quaternion, Matrix4, Skeleton, BufferGeometry, MeshLambertMaterial, BufferAttribute, Mesh, SkinnedMesh, Object3D, MeshPhongMaterial, Bone, Color } from 'three';\r\n\r\nvar AssimpLoader = function (manager) {\r\n  Loader.call(this, manager);\r\n};\r\n\r\nAssimpLoader.prototype = Object.assign(Object.create(Loader.prototype), {\r\n  constructor: AssimpLoader,\r\n  load: function (url, onLoad, onProgress, onError) {\r\n    var scope = this;\r\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\r\n    var loader = new FileLoader(scope.manager);\r\n    loader.setPath(scope.path);\r\n    loader.setResponseType('arraybuffer');\r\n    loader.setRequestHeader(scope.requestHeader);\r\n    loader.setWithCredentials(scope.withCredentials);\r\n    loader.load(url, function (buffer) {\r\n      try {\r\n        onLoad(scope.parse(buffer, path));\r\n      } catch (e) {\r\n        if (onError) {\r\n          onError(e);\r\n        } else {\r\n          console.error(e);\r\n        }\r\n\r\n        scope.manager.itemError(url);\r\n      }\r\n    }, onProgress, onError);\r\n  },\r\n  parse: function (buffer, path) {\r\n    var textureLoader = new TextureLoader(this.manager);\r\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\r\n    var Virtulous = {};\r\n\r\n    Virtulous.KeyFrame = function (time, matrix) {\r\n      this.time = time;\r\n      this.matrix = matrix.clone();\r\n      this.position = new Vector3();\r\n      this.quaternion = new Quaternion();\r\n      this.scale = new Vector3(1, 1, 1);\r\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\r\n\r\n      this.clone = function () {\r\n        var n = new Virtulous.KeyFrame(this.time, this.matrix);\r\n        return n;\r\n      };\r\n\r\n      this.lerp = function (nextKey, time) {\r\n        time -= this.time;\r\n        var dist = nextKey.time - this.time;\r\n        var l = time / dist;\r\n        var l2 = 1 - l;\r\n        var keypos = this.position;\r\n        var keyrot = this.quaternion; //      var keyscl =  key.parentspaceScl || key.scl;\r\n\r\n        var key2pos = nextKey.position;\r\n        var key2rot = nextKey.quaternion; //  var key2scl =  key2.parentspaceScl || key2.scl;\r\n\r\n        Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\r\n        Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\r\n        Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l; //     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\r\n        //     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\r\n        //     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\r\n\r\n        Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\r\n        Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\r\n        return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\r\n      };\r\n    };\r\n\r\n    Virtulous.KeyFrame.tempAniPos = new Vector3();\r\n    Virtulous.KeyFrame.tempAniQuat = new Quaternion();\r\n    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);\r\n    Virtulous.KeyFrame.tempAniMatrix = new Matrix4();\r\n\r\n    Virtulous.KeyFrameTrack = function () {\r\n      this.keys = [];\r\n      this.target = null;\r\n      this.time = 0;\r\n      this.length = 0;\r\n      this._accelTable = {};\r\n      this.fps = 20;\r\n\r\n      this.addKey = function (key) {\r\n        this.keys.push(key);\r\n      };\r\n\r\n      this.init = function () {\r\n        this.sortKeys();\r\n        if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\r\n        if (!this.fps) return;\r\n\r\n        for (let j = 0; j < this.length * this.fps; j++) {\r\n          for (let i = 0; i < this.keys.length; i++) {\r\n            if (this.keys[i].time == j) {\r\n              this._accelTable[j] = i;\r\n              break;\r\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\r\n              this._accelTable[j] = i;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      this.parseFromThree = function (data) {\r\n        var fps = data.fps;\r\n        this.target = data.node;\r\n        var track = data.hierarchy[0].keys;\r\n\r\n        for (let i = 0; i < track.length; i++) {\r\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\r\n        }\r\n\r\n        this.init();\r\n      };\r\n\r\n      this.parseFromCollada = function (data) {\r\n        var track = data.keys;\r\n        var fps = this.fps;\r\n\r\n        for (let i = 0; i < track.length; i++) {\r\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\r\n        }\r\n\r\n        this.init();\r\n      };\r\n\r\n      this.sortKeys = function () {\r\n        this.keys.sort(this.keySortFunc);\r\n      };\r\n\r\n      this.keySortFunc = function (a, b) {\r\n        return a.time - b.time;\r\n      };\r\n\r\n      this.clone = function () {\r\n        var t = new Virtulous.KeyFrameTrack();\r\n        t.target = this.target;\r\n        t.time = this.time;\r\n        t.length = this.length;\r\n\r\n        for (let i = 0; i < this.keys.length; i++) {\r\n          t.addKey(this.keys[i].clone());\r\n        }\r\n\r\n        t.init();\r\n        return t;\r\n      };\r\n\r\n      this.reTarget = function (root, compareitor) {\r\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\r\n        this.target = compareitor(root, this.target);\r\n      };\r\n\r\n      this.keySearchAccel = function (time) {\r\n        time *= this.fps;\r\n        time = Math.floor(time);\r\n        return this._accelTable[time] || 0;\r\n      };\r\n\r\n      this.setTime = function (time) {\r\n        time = Math.abs(time);\r\n        if (this.length) time = time % this.length + 0.05;\r\n        var key0 = null;\r\n        var key1 = null;\r\n\r\n        for (let i = this.keySearchAccel(time); i < this.keys.length; i++) {\r\n          if (this.keys[i].time == time) {\r\n            key0 = this.keys[i];\r\n            key1 = this.keys[i];\r\n            break;\r\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\r\n            key0 = this.keys[i];\r\n            key1 = this.keys[i + 1];\r\n            break;\r\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\r\n            key0 = this.keys[i];\r\n            key1 = this.keys[0].clone();\r\n            key1.time += this.length + 0.05;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (key0 && key1 && key0 !== key1) {\r\n          this.target.matrixAutoUpdate = false;\r\n          this.target.matrix.copy(key0.lerp(key1, time));\r\n          this.target.matrixWorldNeedsUpdate = true;\r\n          return;\r\n        }\r\n\r\n        if (key0 && key1 && key0 == key1) {\r\n          this.target.matrixAutoUpdate = false;\r\n          this.target.matrix.copy(key0.matrix);\r\n          this.target.matrixWorldNeedsUpdate = true;\r\n          return;\r\n        }\r\n      };\r\n    };\r\n\r\n    Virtulous.TrackTargetNodeNameCompare = function (root, target) {\r\n      function find(node, name) {\r\n        if (node.name == name) return node;\r\n\r\n        for (let i = 0; i < node.children.length; i++) {\r\n          var r = find(node.children[i], name);\r\n          if (r) return r;\r\n        }\r\n\r\n        return null;\r\n      }\r\n\r\n      return find(root, target.name);\r\n    };\r\n\r\n    Virtulous.Animation = function () {\r\n      this.tracks = [];\r\n      this.length = 0;\r\n\r\n      this.addTrack = function (track) {\r\n        this.tracks.push(track);\r\n        this.length = Math.max(track.length, this.length);\r\n      };\r\n\r\n      this.setTime = function (time) {\r\n        this.time = time;\r\n\r\n        for (let i = 0; i < this.tracks.length; i++) this.tracks[i].setTime(time);\r\n      };\r\n\r\n      this.clone = function (target, compareitor) {\r\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\r\n        var n = new Virtulous.Animation();\r\n        n.target = target;\r\n\r\n        for (let i = 0; i < this.tracks.length; i++) {\r\n          var track = this.tracks[i].clone();\r\n          track.reTarget(target, compareitor);\r\n          n.addTrack(track);\r\n        }\r\n\r\n        return n;\r\n      };\r\n    };\r\n\r\n    var ASSBIN_CHUNK_AICAMERA = 0x1234;\r\n    var ASSBIN_CHUNK_AILIGHT = 0x1235;\r\n    var ASSBIN_CHUNK_AITEXTURE = 0x1236;\r\n    var ASSBIN_CHUNK_AIMESH = 0x1237;\r\n    var ASSBIN_CHUNK_AINODEANIM = 0x1238;\r\n    var ASSBIN_CHUNK_AISCENE = 0x1239;\r\n    var ASSBIN_CHUNK_AIBONE = 0x123a;\r\n    var ASSBIN_CHUNK_AIANIMATION = 0x123b;\r\n    var ASSBIN_CHUNK_AINODE = 0x123c;\r\n    var ASSBIN_CHUNK_AIMATERIAL = 0x123d;\r\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\r\n    var ASSBIN_MESH_HAS_POSITIONS = 0x1;\r\n    var ASSBIN_MESH_HAS_NORMALS = 0x2;\r\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\r\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\r\n    var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\r\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;\r\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4; //var aiLightSource_UNDEFINED = 0x0;\r\n    //! A directional light source has a well-defined direction\r\n    //! but is infinitely far away. That's quite a good\r\n    //! approximation for sun light.\r\n\r\n    var aiLightSource_DIRECTIONAL = 0x1; //! A point light source has a well-defined position\r\n    //! in space but no direction - it emits light in all\r\n    //! directions. A normal bulb is a point light.\r\n    //var aiLightSource_POINT = 0x2;\r\n    //! A spot light source emits light in a specific\r\n    //! angle. It has a position and a direction it is pointing to.\r\n    //! A good example for a spot light is a light spot in\r\n    //! sport arenas.\r\n\r\n    var aiLightSource_SPOT = 0x3; //! The generic light level of the world, including the bounces\r\n    //! of all other lightsources.\r\n    //! Typically, there's at most one ambient light in a scene.\r\n    //! This light type doesn't have a valid position, direction, or\r\n    //! other properties, just a color.\r\n    //var aiLightSource_AMBIENT = 0x4;\r\n\r\n    /** Flat shading. Shading is done on per-face base,\r\n     *  diffuse only. Also known as 'faceted shading'.\r\n     */\r\n    //var aiShadingMode_Flat = 0x1;\r\n\r\n    /** Simple Gouraud shading.\r\n     */\r\n    //var aiShadingMode_Gouraud = 0x2;\r\n\r\n    /** Phong-Shading -\r\n     */\r\n    //var aiShadingMode_Phong = 0x3;\r\n\r\n    /** Phong-Blinn-Shading\r\n     */\r\n    //var aiShadingMode_Blinn = 0x4;\r\n\r\n    /** Toon-Shading per pixel\r\n     *\r\n     *  Also known as 'comic' shader.\r\n     */\r\n    //var aiShadingMode_Toon = 0x5;\r\n\r\n    /** OrenNayar-Shading per pixel\r\n     *\r\n     *  Extension to standard Lambertian shading, taking the\r\n     *  roughness of the material into account\r\n     */\r\n    //var aiShadingMode_OrenNayar = 0x6;\r\n\r\n    /** Minnaert-Shading per pixel\r\n     *\r\n     *  Extension to standard Lambertian shading, taking the\r\n     *  \"darkness\" of the material into account\r\n     */\r\n    //var aiShadingMode_Minnaert = 0x7;\r\n\r\n    /** CookTorrance-Shading per pixel\r\n     *\r\n     *  Special shader for metallic surfaces.\r\n     */\r\n    //var aiShadingMode_CookTorrance = 0x8;\r\n\r\n    /** No shading at all. Constant light influence of 1.0.\r\n     */\r\n    //var aiShadingMode_NoShading = 0x9;\r\n\r\n    /** Fresnel shading\r\n     */\r\n    //var aiShadingMode_Fresnel = 0xa;\r\n    //var aiTextureType_NONE = 0x0;\r\n\r\n    /** The texture is combined with the result of the diffuse\r\n     *  lighting equation.\r\n     */\r\n\r\n    var aiTextureType_DIFFUSE = 0x1;\r\n    /** The texture is combined with the result of the specular\r\n     *  lighting equation.\r\n     */\r\n    //var aiTextureType_SPECULAR = 0x2;\r\n\r\n    /** The texture is combined with the result of the ambient\r\n     *  lighting equation.\r\n     */\r\n    //var aiTextureType_AMBIENT = 0x3;\r\n\r\n    /** The texture is added to the result of the lighting\r\n     *  calculation. It isn't influenced by incoming light.\r\n     */\r\n    //var aiTextureType_EMISSIVE = 0x4;\r\n\r\n    /** The texture is a height map.\r\n     *\r\n     *  By convention, higher gray-scale values stand for\r\n     *  higher elevations from the base height.\r\n     */\r\n    //var aiTextureType_HEIGHT = 0x5;\r\n\r\n    /** The texture is a (tangent space) normal-map.\r\n     *\r\n     *  Again, there are several conventions for tangent-space\r\n     *  normal maps. Assimp does (intentionally) not\r\n     *  distinguish here.\r\n     */\r\n\r\n    var aiTextureType_NORMALS = 0x6;\r\n    /** The texture defines the glossiness of the material.\r\n     *\r\n     *  The glossiness is in fact the exponent of the specular\r\n     *  (phong) lighting equation. Usually there is a conversion\r\n     *  function defined to map the linear color values in the\r\n     *  texture to a suitable exponent. Have fun.\r\n     */\r\n    //var aiTextureType_SHININESS = 0x7;\r\n\r\n    /** The texture defines per-pixel opacity.\r\n     *\r\n     *  Usually 'white' means opaque and 'black' means\r\n     *  'transparency'. Or quite the opposite. Have fun.\r\n     */\r\n\r\n    var aiTextureType_OPACITY = 0x8;\r\n    /** Displacement texture\r\n     *\r\n     *  The exact purpose and format is application-dependent.\r\n     *  Higher color values stand for higher vertex displacements.\r\n     */\r\n    //var aiTextureType_DISPLACEMENT = 0x9;\r\n\r\n    /** Lightmap texture (aka Ambient Occlusion)\r\n     *\r\n     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\r\n     *  covered by this material property. The texture contains a\r\n     *  scaling value for the final color value of a pixel. Its\r\n     *  intensity is not affected by incoming light.\r\n     */\r\n\r\n    var aiTextureType_LIGHTMAP = 0xa;\r\n    /** Reflection texture\r\n     *\r\n     * Contains the color of a perfect mirror reflection.\r\n     * Rarely used, almost never for real-time applications.\r\n     */\r\n    //var aiTextureType_REFLECTION = 0xB;\r\n\r\n    /** Unknown texture\r\n     *\r\n     *  A texture reference that does not match any of the definitions\r\n     *  above is considered to be 'unknown'. It is still imported,\r\n     *  but is excluded from any further postprocessing.\r\n     */\r\n    //var aiTextureType_UNKNOWN = 0xC;\r\n\r\n    var BONESPERVERT = 4;\r\n\r\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\r\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\r\n    }\r\n\r\n    function ASSBIN_MESH_HAS_COLOR(n) {\r\n      return ASSBIN_MESH_HAS_COLOR_BASE << n;\r\n    }\r\n\r\n    function markBones(scene) {\r\n      for (let i in scene.mMeshes) {\r\n        var mesh = scene.mMeshes[i];\r\n\r\n        for (let k in mesh.mBones) {\r\n          var boneNode = scene.findNode(mesh.mBones[k].mName);\r\n          if (boneNode) boneNode.isBone = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    function cloneTreeToBones(root, scene) {\r\n      var rootBone = new Bone();\r\n      rootBone.matrix.copy(root.matrix);\r\n      rootBone.matrixWorld.copy(root.matrixWorld);\r\n      rootBone.position.copy(root.position);\r\n      rootBone.quaternion.copy(root.quaternion);\r\n      rootBone.scale.copy(root.scale);\r\n      scene.nodeCount++;\r\n      rootBone.name = 'bone_' + root.name + scene.nodeCount.toString();\r\n      if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\r\n      scene.nodeToBoneMap[root.name].push(rootBone);\r\n\r\n      for (let i in root.children) {\r\n        var child = cloneTreeToBones(root.children[i], scene);\r\n        rootBone.add(child);\r\n      }\r\n\r\n      return rootBone;\r\n    }\r\n\r\n    function sortWeights(indexes, weights) {\r\n      var pairs = [];\r\n\r\n      for (let i = 0; i < indexes.length; i++) {\r\n        pairs.push({\r\n          i: indexes[i],\r\n          w: weights[i]\r\n        });\r\n      }\r\n\r\n      pairs.sort(function (a, b) {\r\n        return b.w - a.w;\r\n      });\r\n\r\n      while (pairs.length < 4) {\r\n        pairs.push({\r\n          i: 0,\r\n          w: 0\r\n        });\r\n      }\r\n\r\n      if (pairs.length > 4) pairs.length = 4;\r\n      var sum = 0;\r\n\r\n      for (let i = 0; i < 4; i++) {\r\n        sum += pairs[i].w * pairs[i].w;\r\n      }\r\n\r\n      sum = Math.sqrt(sum);\r\n\r\n      for (let i = 0; i < 4; i++) {\r\n        pairs[i].w = pairs[i].w / sum;\r\n        indexes[i] = pairs[i].i;\r\n        weights[i] = pairs[i].w;\r\n      }\r\n    }\r\n\r\n    function findMatchingBone(root, name) {\r\n      if (root.name.indexOf('bone_' + name) == 0) return root;\r\n\r\n      for (let i in root.children) {\r\n        var ret = findMatchingBone(root.children[i], name);\r\n        if (ret) return ret;\r\n      }\r\n\r\n      return undefined;\r\n    }\r\n\r\n    function aiMesh() {\r\n      this.mPrimitiveTypes = 0;\r\n      this.mNumVertices = 0;\r\n      this.mNumFaces = 0;\r\n      this.mNumBones = 0;\r\n      this.mMaterialIndex = 0;\r\n      this.mVertices = [];\r\n      this.mNormals = [];\r\n      this.mTangents = [];\r\n      this.mBitangents = [];\r\n      this.mColors = [[]];\r\n      this.mTextureCoords = [[]];\r\n      this.mFaces = [];\r\n      this.mBones = [];\r\n\r\n      this.hookupSkeletons = function (scene) {\r\n        if (this.mBones.length == 0) return;\r\n        var allBones = [];\r\n        var offsetMatrix = [];\r\n        var skeletonRoot = scene.findNode(this.mBones[0].mName);\r\n\r\n        while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\r\n          skeletonRoot = skeletonRoot.mParent;\r\n        }\r\n\r\n        var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\r\n        var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\r\n        this.threeNode.add(threeSkeletonRootBone);\r\n\r\n        for (let i = 0; i < this.mBones.length; i++) {\r\n          var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\r\n\r\n          if (bone) {\r\n            var tbone = bone;\r\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\r\n\r\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\r\n          } else {\r\n            var skeletonRoot = scene.findNode(this.mBones[i].mName);\r\n            if (!skeletonRoot) return;\r\n            var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\r\n            var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\r\n            this.threeNode.add(threeSkeletonRootBone);\r\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\r\n            var tbone = bone;\r\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\r\n\r\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\r\n          }\r\n        }\r\n\r\n        var skeleton = new Skeleton(allBones, offsetMatrix);\r\n        this.threeNode.bind(skeleton, new Matrix4());\r\n        this.threeNode.material.skinning = true;\r\n      };\r\n\r\n      this.toTHREE = function (scene) {\r\n        if (this.threeNode) return this.threeNode;\r\n        var geometry = new BufferGeometry();\r\n        var mat;\r\n        if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new MeshLambertMaterial();\r\n        geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));\r\n        geometry.setAttribute('position', new BufferAttribute(this.mVertexBuffer, 3));\r\n\r\n        if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\r\n          geometry.setAttribute('normal', new BufferAttribute(this.mNormalBuffer, 3));\r\n        }\r\n\r\n        if (this.mColorBuffer && this.mColorBuffer.length > 0) {\r\n          geometry.setAttribute('color', new BufferAttribute(this.mColorBuffer, 4));\r\n        }\r\n\r\n        if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\r\n          geometry.setAttribute('uv', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\r\n        }\r\n\r\n        if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\r\n          geometry.setAttribute('uv1', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\r\n        }\r\n\r\n        if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\r\n          geometry.setAttribute('tangents', new BufferAttribute(this.mTangentBuffer, 3));\r\n        }\r\n\r\n        if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\r\n          geometry.setAttribute('bitangents', new BufferAttribute(this.mBitangentBuffer, 3));\r\n        }\r\n\r\n        if (this.mBones.length > 0) {\r\n          var weights = [];\r\n          var bones = [];\r\n\r\n          for (let i = 0; i < this.mBones.length; i++) {\r\n            for (let j = 0; j < this.mBones[i].mWeights.length; j++) {\r\n              var weight = this.mBones[i].mWeights[j];\r\n\r\n              if (weight) {\r\n                if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\r\n                if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\r\n                weights[weight.mVertexId].push(weight.mWeight);\r\n                bones[weight.mVertexId].push(parseInt(i));\r\n              }\r\n            }\r\n          }\r\n\r\n          for (let i in bones) {\r\n            sortWeights(bones[i], weights[i]);\r\n          }\r\n\r\n          var _weights = [];\r\n          var _bones = [];\r\n\r\n          for (let i = 0; i < weights.length; i++) {\r\n            for (let j = 0; j < 4; j++) {\r\n              if (weights[i] && bones[i]) {\r\n                _weights.push(weights[i][j]);\r\n\r\n                _bones.push(bones[i][j]);\r\n              } else {\r\n                _weights.push(0);\r\n\r\n                _bones.push(0);\r\n              }\r\n            }\r\n          }\r\n\r\n          geometry.setAttribute('skinWeight', new BufferAttribute(new Float32Array(_weights), BONESPERVERT));\r\n          geometry.setAttribute('skinIndex', new BufferAttribute(new Float32Array(_bones), BONESPERVERT));\r\n        }\r\n\r\n        var mesh;\r\n        if (this.mBones.length == 0) mesh = new Mesh(geometry, mat);\r\n\r\n        if (this.mBones.length > 0) {\r\n          mesh = new SkinnedMesh(geometry, mat);\r\n          mesh.normalizeSkinWeights();\r\n        }\r\n\r\n        this.threeNode = mesh; //mesh.matrixAutoUpdate = false;\r\n\r\n        return mesh;\r\n      };\r\n    }\r\n\r\n    function aiFace() {\r\n      this.mNumIndices = 0;\r\n      this.mIndices = [];\r\n    }\r\n\r\n    function aiVector3D() {\r\n      this.x = 0;\r\n      this.y = 0;\r\n      this.z = 0;\r\n\r\n      this.toTHREE = function () {\r\n        return new Vector3(this.x, this.y, this.z);\r\n      };\r\n    }\r\n\r\n    function aiColor3D() {\r\n      this.r = 0;\r\n      this.g = 0;\r\n      this.b = 0;\r\n      this.a = 0;\r\n\r\n      this.toTHREE = function () {\r\n        return new Color(this.r, this.g, this.b);\r\n      };\r\n    }\r\n\r\n    function aiQuaternion() {\r\n      this.x = 0;\r\n      this.y = 0;\r\n      this.z = 0;\r\n      this.w = 0;\r\n\r\n      this.toTHREE = function () {\r\n        return new Quaternion(this.x, this.y, this.z, this.w);\r\n      };\r\n    }\r\n\r\n    function aiVertexWeight() {\r\n      this.mVertexId = 0;\r\n      this.mWeight = 0;\r\n    }\r\n\r\n    function aiString() {\r\n      this.data = [];\r\n\r\n      this.toString = function () {\r\n        var str = '';\r\n        this.data.forEach(function (i) {\r\n          str += String.fromCharCode(i);\r\n        });\r\n        return str.replace(/[^\\x20-\\x7E]+/g, '');\r\n      };\r\n    }\r\n\r\n    function aiVectorKey() {\r\n      this.mTime = 0;\r\n      this.mValue = null;\r\n    }\r\n\r\n    function aiQuatKey() {\r\n      this.mTime = 0;\r\n      this.mValue = null;\r\n    }\r\n\r\n    function aiNode() {\r\n      this.mName = '';\r\n      this.mTransformation = [];\r\n      this.mNumChildren = 0;\r\n      this.mNumMeshes = 0;\r\n      this.mMeshes = [];\r\n      this.mChildren = [];\r\n\r\n      this.toTHREE = function (scene) {\r\n        if (this.threeNode) return this.threeNode;\r\n        var o = new Object3D();\r\n        o.name = this.mName;\r\n        o.matrix = this.mTransformation.toTHREE();\r\n\r\n        for (let i = 0; i < this.mChildren.length; i++) {\r\n          o.add(this.mChildren[i].toTHREE(scene));\r\n        }\r\n\r\n        for (let i = 0; i < this.mMeshes.length; i++) {\r\n          o.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene));\r\n        }\r\n\r\n        this.threeNode = o; //o.matrixAutoUpdate = false;\r\n\r\n        o.matrix.decompose(o.position, o.quaternion, o.scale);\r\n        return o;\r\n      };\r\n    }\r\n\r\n    function aiBone() {\r\n      this.mName = '';\r\n      this.mNumWeights = 0;\r\n      this.mOffsetMatrix = 0;\r\n    }\r\n\r\n    function aiMaterialProperty() {\r\n      this.mKey = '';\r\n      this.mSemantic = 0;\r\n      this.mIndex = 0;\r\n      this.mData = [];\r\n      this.mDataLength = 0;\r\n      this.mType = 0;\r\n\r\n      this.dataAsColor = function () {\r\n        var array = new Uint8Array(this.mData).buffer;\r\n        var reader = new DataView(array);\r\n        var r = reader.getFloat32(0, true);\r\n        var g = reader.getFloat32(4, true);\r\n        var b = reader.getFloat32(8, true); //var a = reader.getFloat32(12, true);\r\n\r\n        return new Color(r, g, b);\r\n      };\r\n\r\n      this.dataAsFloat = function () {\r\n        var array = new Uint8Array(this.mData).buffer;\r\n        var reader = new DataView(array);\r\n        var r = reader.getFloat32(0, true);\r\n        return r;\r\n      };\r\n\r\n      this.dataAsBool = function () {\r\n        var array = new Uint8Array(this.mData).buffer;\r\n        var reader = new DataView(array);\r\n        var r = reader.getFloat32(0, true);\r\n        return !!r;\r\n      };\r\n\r\n      this.dataAsString = function () {\r\n        var s = new aiString();\r\n        s.data = this.mData;\r\n        return s.toString();\r\n      };\r\n\r\n      this.dataAsMap = function () {\r\n        var s = new aiString();\r\n        s.data = this.mData;\r\n        var path = s.toString();\r\n        path = path.replace(/\\\\/g, '/');\r\n\r\n        if (path.indexOf('/') != -1) {\r\n          path = path.substr(path.lastIndexOf('/') + 1);\r\n        }\r\n\r\n        return textureLoader.load(path);\r\n      };\r\n    }\r\n\r\n    var namePropMapping = {\r\n      '?mat.name': 'name',\r\n      '$mat.shadingm': 'shading',\r\n      '$mat.twosided': 'twoSided',\r\n      '$mat.wireframe': 'wireframe',\r\n      '$clr.ambient': 'ambient',\r\n      '$clr.diffuse': 'color',\r\n      '$clr.specular': 'specular',\r\n      '$clr.emissive': 'emissive',\r\n      '$clr.transparent': 'transparent',\r\n      '$clr.reflective': 'reflect',\r\n      '$mat.shininess': 'shininess',\r\n      '$mat.reflectivity': 'reflectivity',\r\n      '$mat.refracti': 'refraction',\r\n      '$tex.file': 'map'\r\n    };\r\n    var nameTypeMapping = {\r\n      '?mat.name': 'string',\r\n      '$mat.shadingm': 'bool',\r\n      '$mat.twosided': 'bool',\r\n      '$mat.wireframe': 'bool',\r\n      '$clr.ambient': 'color',\r\n      '$clr.diffuse': 'color',\r\n      '$clr.specular': 'color',\r\n      '$clr.emissive': 'color',\r\n      '$clr.transparent': 'color',\r\n      '$clr.reflective': 'color',\r\n      '$mat.shininess': 'float',\r\n      '$mat.reflectivity': 'float',\r\n      '$mat.refracti': 'float',\r\n      '$tex.file': 'map'\r\n    };\r\n\r\n    function aiMaterial() {\r\n      this.mNumAllocated = 0;\r\n      this.mNumProperties = 0;\r\n      this.mProperties = [];\r\n\r\n      this.toTHREE = function () {\r\n        var mat = new MeshPhongMaterial();\r\n\r\n        for (let i = 0; i < this.mProperties.length; i++) {\r\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'float') {\r\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\r\n          }\r\n\r\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'color') {\r\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\r\n          }\r\n\r\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'bool') {\r\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\r\n          }\r\n\r\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'string') {\r\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\r\n          }\r\n\r\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\r\n            var prop = this.mProperties[i];\r\n            if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\r\n            if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\r\n            if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\r\n            if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\r\n          }\r\n        }\r\n\r\n        mat.ambient.r = 0.53;\r\n        mat.ambient.g = 0.53;\r\n        mat.ambient.b = 0.53;\r\n        mat.color.r = 1;\r\n        mat.color.g = 1;\r\n        mat.color.b = 1;\r\n        return mat;\r\n      };\r\n    }\r\n\r\n    function veclerp(v1, v2, l) {\r\n      var v = new Vector3();\r\n      var lm1 = 1 - l;\r\n      v.x = v1.x * l + v2.x * lm1;\r\n      v.y = v1.y * l + v2.y * lm1;\r\n      v.z = v1.z * l + v2.z * lm1;\r\n      return v;\r\n    }\r\n\r\n    function quatlerp(q1, q2, l) {\r\n      return q1.clone().slerp(q2, 1 - l);\r\n    }\r\n\r\n    function sampleTrack(keys, time, lne, lerp) {\r\n      if (keys.length == 1) return keys[0].mValue.toTHREE();\r\n      var dist = Infinity;\r\n      var key = null;\r\n      var nextKey = null;\r\n\r\n      for (let i = 0; i < keys.length; i++) {\r\n        var timeDist = Math.abs(keys[i].mTime - time);\r\n\r\n        if (timeDist < dist && keys[i].mTime <= time) {\r\n          dist = timeDist;\r\n          key = keys[i];\r\n          nextKey = keys[i + 1];\r\n        }\r\n      }\r\n\r\n      if (!key) {\r\n        return null;\r\n      } else if (nextKey) {\r\n        var dT = nextKey.mTime - key.mTime;\r\n        var T = key.mTime - time;\r\n        var l = T / dT;\r\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\r\n      } else {\r\n        nextKey = keys[0].clone();\r\n        nextKey.mTime += lne;\r\n        var dT = nextKey.mTime - key.mTime;\r\n        var T = key.mTime - time;\r\n        var l = T / dT;\r\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\r\n      }\r\n    }\r\n\r\n    function aiNodeAnim() {\r\n      this.mNodeName = '';\r\n      this.mNumPositionKeys = 0;\r\n      this.mNumRotationKeys = 0;\r\n      this.mNumScalingKeys = 0;\r\n      this.mPositionKeys = [];\r\n      this.mRotationKeys = [];\r\n      this.mScalingKeys = [];\r\n      this.mPreState = '';\r\n      this.mPostState = '';\r\n\r\n      this.init = function (tps) {\r\n        if (!tps) tps = 1;\r\n\r\n        function t(t) {\r\n          t.mTime /= tps;\r\n        }\r\n\r\n        this.mPositionKeys.forEach(t);\r\n        this.mRotationKeys.forEach(t);\r\n        this.mScalingKeys.forEach(t);\r\n      };\r\n\r\n      this.sortKeys = function () {\r\n        function comp(a, b) {\r\n          return a.mTime - b.mTime;\r\n        }\r\n\r\n        this.mPositionKeys.sort(comp);\r\n        this.mRotationKeys.sort(comp);\r\n        this.mScalingKeys.sort(comp);\r\n      };\r\n\r\n      this.getLength = function () {\r\n        return Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\r\n          return a.mTime;\r\n        })), Math.max.apply(null, this.mRotationKeys.map(function (a) {\r\n          return a.mTime;\r\n        })), Math.max.apply(null, this.mScalingKeys.map(function (a) {\r\n          return a.mTime;\r\n        })));\r\n      };\r\n\r\n      this.toTHREE = function (o) {\r\n        this.sortKeys();\r\n        var length = this.getLength();\r\n        var track = new Virtulous.KeyFrameTrack();\r\n\r\n        for (let i = 0; i < length; i += 0.05) {\r\n          var matrix = new Matrix4();\r\n          var time = i;\r\n          var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\r\n          var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\r\n          var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\r\n          matrix.compose(pos, rotation, scale);\r\n          var key = new Virtulous.KeyFrame(time, matrix);\r\n          track.addKey(key);\r\n        }\r\n\r\n        track.target = o.findNode(this.mNodeName).toTHREE();\r\n        var tracks = [track];\r\n\r\n        if (o.nodeToBoneMap[this.mNodeName]) {\r\n          for (let i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++) {\r\n            var t2 = track.clone();\r\n            t2.target = o.nodeToBoneMap[this.mNodeName][i];\r\n            tracks.push(t2);\r\n          }\r\n        }\r\n\r\n        return tracks;\r\n      };\r\n    }\r\n\r\n    function aiAnimation() {\r\n      this.mName = '';\r\n      this.mDuration = 0;\r\n      this.mTicksPerSecond = 0;\r\n      this.mNumChannels = 0;\r\n      this.mChannels = [];\r\n\r\n      this.toTHREE = function (root) {\r\n        var animationHandle = new Virtulous.Animation();\r\n\r\n        for (let i in this.mChannels) {\r\n          this.mChannels[i].init(this.mTicksPerSecond);\r\n          var tracks = this.mChannels[i].toTHREE(root);\r\n\r\n          for (let j in tracks) {\r\n            tracks[j].init();\r\n            animationHandle.addTrack(tracks[j]);\r\n          }\r\n        }\r\n\r\n        animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\r\n          return e.length;\r\n        }));\r\n        return animationHandle;\r\n      };\r\n    }\r\n\r\n    function aiTexture() {\r\n      this.mWidth = 0;\r\n      this.mHeight = 0;\r\n      this.texAchFormatHint = [];\r\n      this.pcData = [];\r\n    }\r\n\r\n    function aiLight() {\r\n      this.mName = '';\r\n      this.mType = 0;\r\n      this.mAttenuationConstant = 0;\r\n      this.mAttenuationLinear = 0;\r\n      this.mAttenuationQuadratic = 0;\r\n      this.mAngleInnerCone = 0;\r\n      this.mAngleOuterCone = 0;\r\n      this.mColorDiffuse = null;\r\n      this.mColorSpecular = null;\r\n      this.mColorAmbient = null;\r\n    }\r\n\r\n    function aiCamera() {\r\n      this.mName = '';\r\n      this.mPosition = null;\r\n      this.mLookAt = null;\r\n      this.mUp = null;\r\n      this.mHorizontalFOV = 0;\r\n      this.mClipPlaneNear = 0;\r\n      this.mClipPlaneFar = 0;\r\n      this.mAspect = 0;\r\n    }\r\n\r\n    function aiScene() {\r\n      this.versionMajor = 0;\r\n      this.versionMinor = 0;\r\n      this.versionRevision = 0;\r\n      this.compileFlags = 0;\r\n      this.mFlags = 0;\r\n      this.mNumMeshes = 0;\r\n      this.mNumMaterials = 0;\r\n      this.mNumAnimations = 0;\r\n      this.mNumTextures = 0;\r\n      this.mNumLights = 0;\r\n      this.mNumCameras = 0;\r\n      this.mRootNode = null;\r\n      this.mMeshes = [];\r\n      this.mMaterials = [];\r\n      this.mAnimations = [];\r\n      this.mLights = [];\r\n      this.mCameras = [];\r\n      this.nodeToBoneMap = {};\r\n\r\n      this.findNode = function (name, root) {\r\n        if (!root) {\r\n          root = this.mRootNode;\r\n        }\r\n\r\n        if (root.mName == name) {\r\n          return root;\r\n        }\r\n\r\n        for (let i = 0; i < root.mChildren.length; i++) {\r\n          var ret = this.findNode(name, root.mChildren[i]);\r\n          if (ret) return ret;\r\n        }\r\n\r\n        return null;\r\n      };\r\n\r\n      this.toTHREE = function () {\r\n        this.nodeCount = 0;\r\n        markBones(this);\r\n        var o = this.mRootNode.toTHREE(this);\r\n\r\n        for (let i in this.mMeshes) this.mMeshes[i].hookupSkeletons(this);\r\n\r\n        if (this.mAnimations.length > 0) {\r\n          var a = this.mAnimations[0].toTHREE(this);\r\n        }\r\n\r\n        return {\r\n          object: o,\r\n          animation: a\r\n        };\r\n      };\r\n    }\r\n\r\n    function aiMatrix4() {\r\n      this.elements = [[], [], [], []];\r\n\r\n      this.toTHREE = function () {\r\n        var m = new Matrix4();\r\n\r\n        for (let i = 0; i < 4; ++i) {\r\n          for (let i2 = 0; i2 < 4; ++i2) {\r\n            m.elements[i * 4 + i2] = this.elements[i2][i];\r\n          }\r\n        }\r\n\r\n        return m;\r\n      };\r\n    }\r\n\r\n    var littleEndian = true;\r\n\r\n    function readFloat(dataview) {\r\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian);\r\n      dataview.readOffset += 4;\r\n      return val;\r\n    }\r\n\r\n    function Read_double(dataview) {\r\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian);\r\n      dataview.readOffset += 8;\r\n      return val;\r\n    }\r\n\r\n    function Read_uint8_t(dataview) {\r\n      var val = dataview.getUint8(dataview.readOffset);\r\n      dataview.readOffset += 1;\r\n      return val;\r\n    }\r\n\r\n    function Read_uint16_t(dataview) {\r\n      var val = dataview.getUint16(dataview.readOffset, littleEndian);\r\n      dataview.readOffset += 2;\r\n      return val;\r\n    }\r\n\r\n    function Read_unsigned_int(dataview) {\r\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\r\n      dataview.readOffset += 4;\r\n      return val;\r\n    }\r\n\r\n    function Read_uint32_t(dataview) {\r\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\r\n      dataview.readOffset += 4;\r\n      return val;\r\n    }\r\n\r\n    function Read_aiVector3D(stream) {\r\n      var v = new aiVector3D();\r\n      v.x = readFloat(stream);\r\n      v.y = readFloat(stream);\r\n      v.z = readFloat(stream);\r\n      return v;\r\n    }\r\n\r\n    function Read_aiColor3D(stream) {\r\n      var c = new aiColor3D();\r\n      c.r = readFloat(stream);\r\n      c.g = readFloat(stream);\r\n      c.b = readFloat(stream);\r\n      return c;\r\n    }\r\n\r\n    function Read_aiQuaternion(stream) {\r\n      var v = new aiQuaternion();\r\n      v.w = readFloat(stream);\r\n      v.x = readFloat(stream);\r\n      v.y = readFloat(stream);\r\n      v.z = readFloat(stream);\r\n      return v;\r\n    }\r\n\r\n    function Read_aiString(stream) {\r\n      var s = new aiString();\r\n      var stringlengthbytes = Read_unsigned_int(stream);\r\n      stream.ReadBytes(s.data, 1, stringlengthbytes);\r\n      return s.toString();\r\n    }\r\n\r\n    function Read_aiVertexWeight(stream) {\r\n      var w = new aiVertexWeight();\r\n      w.mVertexId = Read_unsigned_int(stream);\r\n      w.mWeight = readFloat(stream);\r\n      return w;\r\n    }\r\n\r\n    function Read_aiMatrix4x4(stream) {\r\n      var m = new aiMatrix4();\r\n\r\n      for (let i = 0; i < 4; ++i) {\r\n        for (let i2 = 0; i2 < 4; ++i2) {\r\n          m.elements[i][i2] = readFloat(stream);\r\n        }\r\n      }\r\n\r\n      return m;\r\n    }\r\n\r\n    function Read_aiVectorKey(stream) {\r\n      var v = new aiVectorKey();\r\n      v.mTime = Read_double(stream);\r\n      v.mValue = Read_aiVector3D(stream);\r\n      return v;\r\n    }\r\n\r\n    function Read_aiQuatKey(stream) {\r\n      var v = new aiQuatKey();\r\n      v.mTime = Read_double(stream);\r\n      v.mValue = Read_aiQuaternion(stream);\r\n      return v;\r\n    }\r\n\r\n    function ReadArray_aiVertexWeight(stream, data, size) {\r\n      for (let i = 0; i < size; i++) data[i] = Read_aiVertexWeight(stream);\r\n    }\r\n\r\n    function ReadArray_aiVectorKey(stream, data, size) {\r\n      for (let i = 0; i < size; i++) data[i] = Read_aiVectorKey(stream);\r\n    }\r\n\r\n    function ReadArray_aiQuatKey(stream, data, size) {\r\n      for (let i = 0; i < size; i++) data[i] = Read_aiQuatKey(stream);\r\n    }\r\n\r\n    function ReadBounds(stream, T\r\n    /*p*/\r\n    , n) {\r\n      // not sure what to do here, the data isn't really useful.\r\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR); // eslint-disable-line no-undef\r\n    }\r\n\r\n    function ai_assert(bool) {\r\n      if (!bool) throw 'asset failed';\r\n    }\r\n\r\n    function ReadBinaryNode(stream, parent, depth) {\r\n      var chunkID = Read_uint32_t(stream);\r\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);\r\n      /*uint32_t size =*/\r\n\r\n      Read_uint32_t(stream);\r\n      var node = new aiNode();\r\n      node.mParent = parent;\r\n      node.mDepth = depth;\r\n      node.mName = Read_aiString(stream);\r\n      node.mTransformation = Read_aiMatrix4x4(stream);\r\n      node.mNumChildren = Read_unsigned_int(stream);\r\n      node.mNumMeshes = Read_unsigned_int(stream);\r\n\r\n      if (node.mNumMeshes) {\r\n        node.mMeshes = [];\r\n\r\n        for (let i = 0; i < node.mNumMeshes; ++i) {\r\n          node.mMeshes[i] = Read_unsigned_int(stream);\r\n        }\r\n      }\r\n\r\n      if (node.mNumChildren) {\r\n        node.mChildren = [];\r\n\r\n        for (let i = 0; i < node.mNumChildren; ++i) {\r\n          var node2 = ReadBinaryNode(stream, node, depth++);\r\n          node.mChildren[i] = node2;\r\n        }\r\n      }\r\n\r\n      return node;\r\n    } // -----------------------------------------------------------------------------------\r\n\r\n\r\n    function ReadBinaryBone(stream, b) {\r\n      var chunkID = Read_uint32_t(stream);\r\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\r\n      /*uint32_t size =*/\r\n\r\n      Read_uint32_t(stream);\r\n      b.mName = Read_aiString(stream);\r\n      b.mNumWeights = Read_unsigned_int(stream);\r\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream); // for the moment we write dumb min/max values for the bones, too.\r\n      // maybe I'll add a better, hash-like solution later\r\n\r\n      if (shortened) {\r\n        ReadBounds(stream, b.mWeights, b.mNumWeights);\r\n      } else {\r\n        // else write as usual\r\n        b.mWeights = [];\r\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\r\n      }\r\n\r\n      return b;\r\n    }\r\n\r\n    function ReadBinaryMesh(stream, mesh) {\r\n      var chunkID = Read_uint32_t(stream);\r\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\r\n      /*uint32_t size =*/\r\n\r\n      Read_uint32_t(stream);\r\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream);\r\n      mesh.mNumVertices = Read_unsigned_int(stream);\r\n      mesh.mNumFaces = Read_unsigned_int(stream);\r\n      mesh.mNumBones = Read_unsigned_int(stream);\r\n      mesh.mMaterialIndex = Read_unsigned_int(stream);\r\n      mesh.mNumUVComponents = []; // first of all, write bits for all existent vertex components\r\n\r\n      var c = Read_unsigned_int(stream);\r\n\r\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\r\n        if (shortened) {\r\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\r\n        } else {\r\n          // else write as usual\r\n          mesh.mVertices = [];\r\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\r\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\r\n        }\r\n      }\r\n\r\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\r\n        if (shortened) {\r\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\r\n        } else {\r\n          // else write as usual\r\n          mesh.mNormals = [];\r\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\r\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\r\n        }\r\n      }\r\n\r\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\r\n        if (shortened) {\r\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\r\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\r\n        } else {\r\n          // else write as usual\r\n          mesh.mTangents = [];\r\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\r\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\r\n          mesh.mBitangents = [];\r\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\r\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\r\n        }\r\n      }\r\n\r\n      for (let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\r\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\r\n\r\n        if (shortened) {\r\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\r\n        } else {\r\n          // else write as usual\r\n          mesh.mColors[n] = [];\r\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\r\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\r\n        }\r\n      }\r\n\r\n      mesh.mTexCoordsBuffers = [];\r\n\r\n      for (let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {\r\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n))) break; // write number of UV components\r\n\r\n        mesh.mNumUVComponents[n] = Read_unsigned_int(stream);\r\n\r\n        if (shortened) {\r\n          ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);\r\n        } else {\r\n          // else write as usual\r\n          mesh.mTextureCoords[n] = []; //note that assbin always writes 3d texcoords\r\n\r\n          mesh.mTexCoordsBuffers[n] = [];\r\n\r\n          for (let uv = 0; uv < mesh.mNumVertices; uv++) {\r\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\r\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\r\n            readFloat(stream);\r\n          }\r\n        }\r\n      } // write faces. There are no floating-point calculations involved\r\n      // in these, so we can write a simple hash over the face data\r\n      // to the dump file. We generate a single 32 Bit hash for 512 faces\r\n      // using Assimp's standard hashing function.\r\n\r\n\r\n      if (shortened) {\r\n        Read_unsigned_int(stream);\r\n      } else {\r\n        // else write as usual\r\n        // if there are less than 2^16 vertices, we can simply use 16 bit integers ...\r\n        mesh.mFaces = [];\r\n        mesh.mIndexArray = [];\r\n\r\n        for (let i = 0; i < mesh.mNumFaces; ++i) {\r\n          var f = mesh.mFaces[i] = new aiFace(); // BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\r\n\r\n          f.mNumIndices = Read_uint16_t(stream);\r\n          f.mIndices = [];\r\n\r\n          for (let a = 0; a < f.mNumIndices; ++a) {\r\n            if (mesh.mNumVertices < 1 << 16) {\r\n              f.mIndices[a] = Read_uint16_t(stream);\r\n            } else {\r\n              f.mIndices[a] = Read_unsigned_int(stream);\r\n            }\r\n          }\r\n\r\n          if (f.mNumIndices === 3) {\r\n            mesh.mIndexArray.push(f.mIndices[0]);\r\n            mesh.mIndexArray.push(f.mIndices[1]);\r\n            mesh.mIndexArray.push(f.mIndices[2]);\r\n          } else if (f.mNumIndices === 4) {\r\n            mesh.mIndexArray.push(f.mIndices[0]);\r\n            mesh.mIndexArray.push(f.mIndices[1]);\r\n            mesh.mIndexArray.push(f.mIndices[2]);\r\n            mesh.mIndexArray.push(f.mIndices[2]);\r\n            mesh.mIndexArray.push(f.mIndices[3]);\r\n            mesh.mIndexArray.push(f.mIndices[0]);\r\n          } else {\r\n            throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\r\n          }\r\n        }\r\n      } // write bones\r\n\r\n\r\n      if (mesh.mNumBones) {\r\n        mesh.mBones = [];\r\n\r\n        for (let a = 0; a < mesh.mNumBones; ++a) {\r\n          mesh.mBones[a] = new aiBone();\r\n          ReadBinaryBone(stream, mesh.mBones[a]);\r\n        }\r\n      }\r\n    }\r\n\r\n    function ReadBinaryMaterialProperty(stream, prop) {\r\n      var chunkID = Read_uint32_t(stream);\r\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\r\n      /*uint32_t size =*/\r\n\r\n      Read_uint32_t(stream);\r\n      prop.mKey = Read_aiString(stream);\r\n      prop.mSemantic = Read_unsigned_int(stream);\r\n      prop.mIndex = Read_unsigned_int(stream);\r\n      prop.mDataLength = Read_unsigned_int(stream);\r\n      prop.mType = Read_unsigned_int(stream);\r\n      prop.mData = [];\r\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength);\r\n    } // -----------------------------------------------------------------------------------\r\n\r\n\r\n    function ReadBinaryMaterial(stream, mat) {\r\n      var chunkID = Read_uint32_t(stream);\r\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\r\n      /*uint32_t size =*/\r\n\r\n      Read_uint32_t(stream);\r\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\r\n\r\n      if (mat.mNumProperties) {\r\n        if (mat.mProperties) {\r\n          delete mat.mProperties;\r\n        }\r\n\r\n        mat.mProperties = [];\r\n\r\n        for (let i = 0; i < mat.mNumProperties; ++i) {\r\n          mat.mProperties[i] = new aiMaterialProperty();\r\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i]);\r\n        }\r\n      }\r\n    }\r\n\r\n    function ReadBinaryNodeAnim(stream, nd) {\r\n      var chunkID = Read_uint32_t(stream);\r\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\r\n      /*uint32_t size =*/\r\n\r\n      Read_uint32_t(stream);\r\n      nd.mNodeName = Read_aiString(stream);\r\n      nd.mNumPositionKeys = Read_unsigned_int(stream);\r\n      nd.mNumRotationKeys = Read_unsigned_int(stream);\r\n      nd.mNumScalingKeys = Read_unsigned_int(stream);\r\n      nd.mPreState = Read_unsigned_int(stream);\r\n      nd.mPostState = Read_unsigned_int(stream);\r\n\r\n      if (nd.mNumPositionKeys) {\r\n        if (shortened) {\r\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\r\n        } else {\r\n          // else write as usual\r\n          nd.mPositionKeys = [];\r\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\r\n        }\r\n      }\r\n\r\n      if (nd.mNumRotationKeys) {\r\n        if (shortened) {\r\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\r\n        } else {\r\n          // else write as usual\r\n          nd.mRotationKeys = [];\r\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\r\n        }\r\n      }\r\n\r\n      if (nd.mNumScalingKeys) {\r\n        if (shortened) {\r\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\r\n        } else {\r\n          // else write as usual\r\n          nd.mScalingKeys = [];\r\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\r\n        }\r\n      }\r\n    }\r\n\r\n    function ReadBinaryAnim(stream, anim) {\r\n      var chunkID = Read_uint32_t(stream);\r\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\r\n      /*uint32_t size =*/\r\n\r\n      Read_uint32_t(stream);\r\n      anim.mName = Read_aiString(stream);\r\n      anim.mDuration = Read_double(stream);\r\n      anim.mTicksPerSecond = Read_double(stream);\r\n      anim.mNumChannels = Read_unsigned_int(stream);\r\n\r\n      if (anim.mNumChannels) {\r\n        anim.mChannels = [];\r\n\r\n        for (let a = 0; a < anim.mNumChannels; ++a) {\r\n          anim.mChannels[a] = new aiNodeAnim();\r\n          ReadBinaryNodeAnim(stream, anim.mChannels[a]);\r\n        }\r\n      }\r\n    }\r\n\r\n    function ReadBinaryTexture(stream, tex) {\r\n      var chunkID = Read_uint32_t(stream);\r\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\r\n      /*uint32_t size =*/\r\n\r\n      Read_uint32_t(stream);\r\n      tex.mWidth = Read_unsigned_int(stream);\r\n      tex.mHeight = Read_unsigned_int(stream);\r\n      stream.ReadBytes(tex.achFormatHint, 1, 4);\r\n\r\n      if (!shortened) {\r\n        if (!tex.mHeight) {\r\n          tex.pcData = [];\r\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth);\r\n        } else {\r\n          tex.pcData = [];\r\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\r\n        }\r\n      }\r\n    }\r\n\r\n    function ReadBinaryLight(stream, l) {\r\n      var chunkID = Read_uint32_t(stream);\r\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\r\n      /*uint32_t size =*/\r\n\r\n      Read_uint32_t(stream);\r\n      l.mName = Read_aiString(stream);\r\n      l.mType = Read_unsigned_int(stream);\r\n\r\n      if (l.mType != aiLightSource_DIRECTIONAL) {\r\n        l.mAttenuationConstant = readFloat(stream);\r\n        l.mAttenuationLinear = readFloat(stream);\r\n        l.mAttenuationQuadratic = readFloat(stream);\r\n      }\r\n\r\n      l.mColorDiffuse = Read_aiColor3D(stream);\r\n      l.mColorSpecular = Read_aiColor3D(stream);\r\n      l.mColorAmbient = Read_aiColor3D(stream);\r\n\r\n      if (l.mType == aiLightSource_SPOT) {\r\n        l.mAngleInnerCone = readFloat(stream);\r\n        l.mAngleOuterCone = readFloat(stream);\r\n      }\r\n    }\r\n\r\n    function ReadBinaryCamera(stream, cam) {\r\n      var chunkID = Read_uint32_t(stream);\r\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\r\n      /*uint32_t size =*/\r\n\r\n      Read_uint32_t(stream);\r\n      cam.mName = Read_aiString(stream);\r\n      cam.mPosition = Read_aiVector3D(stream);\r\n      cam.mLookAt = Read_aiVector3D(stream);\r\n      cam.mUp = Read_aiVector3D(stream);\r\n      cam.mHorizontalFOV = readFloat(stream);\r\n      cam.mClipPlaneNear = readFloat(stream);\r\n      cam.mClipPlaneFar = readFloat(stream);\r\n      cam.mAspect = readFloat(stream);\r\n    }\r\n\r\n    function ReadBinaryScene(stream, scene) {\r\n      var chunkID = Read_uint32_t(stream);\r\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\r\n      /*uint32_t size =*/\r\n\r\n      Read_uint32_t(stream);\r\n      scene.mFlags = Read_unsigned_int(stream);\r\n      scene.mNumMeshes = Read_unsigned_int(stream);\r\n      scene.mNumMaterials = Read_unsigned_int(stream);\r\n      scene.mNumAnimations = Read_unsigned_int(stream);\r\n      scene.mNumTextures = Read_unsigned_int(stream);\r\n      scene.mNumLights = Read_unsigned_int(stream);\r\n      scene.mNumCameras = Read_unsigned_int(stream); // Read node graph\r\n\r\n      scene.mRootNode = new aiNode();\r\n      scene.mRootNode = ReadBinaryNode(stream, null, 0); // Read all meshes\r\n\r\n      if (scene.mNumMeshes) {\r\n        scene.mMeshes = [];\r\n\r\n        for (let i = 0; i < scene.mNumMeshes; ++i) {\r\n          scene.mMeshes[i] = new aiMesh();\r\n          ReadBinaryMesh(stream, scene.mMeshes[i]);\r\n        }\r\n      } // Read materials\r\n\r\n\r\n      if (scene.mNumMaterials) {\r\n        scene.mMaterials = [];\r\n\r\n        for (let i = 0; i < scene.mNumMaterials; ++i) {\r\n          scene.mMaterials[i] = new aiMaterial();\r\n          ReadBinaryMaterial(stream, scene.mMaterials[i]);\r\n        }\r\n      } // Read all animations\r\n\r\n\r\n      if (scene.mNumAnimations) {\r\n        scene.mAnimations = [];\r\n\r\n        for (let i = 0; i < scene.mNumAnimations; ++i) {\r\n          scene.mAnimations[i] = new aiAnimation();\r\n          ReadBinaryAnim(stream, scene.mAnimations[i]);\r\n        }\r\n      } // Read all textures\r\n\r\n\r\n      if (scene.mNumTextures) {\r\n        scene.mTextures = [];\r\n\r\n        for (let i = 0; i < scene.mNumTextures; ++i) {\r\n          scene.mTextures[i] = new aiTexture();\r\n          ReadBinaryTexture(stream, scene.mTextures[i]);\r\n        }\r\n      } // Read lights\r\n\r\n\r\n      if (scene.mNumLights) {\r\n        scene.mLights = [];\r\n\r\n        for (let i = 0; i < scene.mNumLights; ++i) {\r\n          scene.mLights[i] = new aiLight();\r\n          ReadBinaryLight(stream, scene.mLights[i]);\r\n        }\r\n      } // Read cameras\r\n\r\n\r\n      if (scene.mNumCameras) {\r\n        scene.mCameras = [];\r\n\r\n        for (let i = 0; i < scene.mNumCameras; ++i) {\r\n          scene.mCameras[i] = new aiCamera();\r\n          ReadBinaryCamera(stream, scene.mCameras[i]);\r\n        }\r\n      }\r\n    }\r\n\r\n    var aiOrigin_CUR = 0;\r\n    var aiOrigin_BEG = 1;\r\n\r\n    function extendStream(stream) {\r\n      stream.readOffset = 0;\r\n\r\n      stream.Seek = function (off, ori) {\r\n        if (ori == aiOrigin_CUR) {\r\n          stream.readOffset += off;\r\n        }\r\n\r\n        if (ori == aiOrigin_BEG) {\r\n          stream.readOffset = off;\r\n        }\r\n      };\r\n\r\n      stream.ReadBytes = function (buff, size, n) {\r\n        var bytes = size * n;\r\n\r\n        for (let i = 0; i < bytes; i++) buff[i] = Read_uint8_t(this);\r\n      };\r\n\r\n      stream.subArray32 = function (start, end) {\r\n        var buff = this.buffer;\r\n        var newbuff = buff.slice(start, end);\r\n        return new Float32Array(newbuff);\r\n      };\r\n\r\n      stream.subArrayUint16 = function (start, end) {\r\n        var buff = this.buffer;\r\n        var newbuff = buff.slice(start, end);\r\n        return new Uint16Array(newbuff);\r\n      };\r\n\r\n      stream.subArrayUint8 = function (start, end) {\r\n        var buff = this.buffer;\r\n        var newbuff = buff.slice(start, end);\r\n        return new Uint8Array(newbuff);\r\n      };\r\n\r\n      stream.subArrayUint32 = function (start, end) {\r\n        var buff = this.buffer;\r\n        var newbuff = buff.slice(start, end);\r\n        return new Uint32Array(newbuff);\r\n      };\r\n    }\r\n\r\n    var shortened, compressed;\r\n\r\n    function InternReadFile(pFiledata) {\r\n      var pScene = new aiScene();\r\n      var stream = new DataView(pFiledata);\r\n      extendStream(stream);\r\n      stream.Seek(44, aiOrigin_CUR); // signature\r\n\r\n      /*unsigned int versionMajor =*/\r\n\r\n      pScene.versionMajor = Read_unsigned_int(stream);\r\n      /*unsigned int versionMinor =*/\r\n\r\n      pScene.versionMinor = Read_unsigned_int(stream);\r\n      /*unsigned int versionRevision =*/\r\n\r\n      pScene.versionRevision = Read_unsigned_int(stream);\r\n      /*unsigned int compileFlags =*/\r\n\r\n      pScene.compileFlags = Read_unsigned_int(stream);\r\n      shortened = Read_uint16_t(stream) > 0;\r\n      compressed = Read_uint16_t(stream) > 0;\r\n      if (shortened) throw 'Shortened binaries are not supported!';\r\n      stream.Seek(256, aiOrigin_CUR); // original filename\r\n\r\n      stream.Seek(128, aiOrigin_CUR); // options\r\n\r\n      stream.Seek(64, aiOrigin_CUR); // padding\r\n\r\n      if (compressed) {\r\n        var uncompressedSize = Read_uint32_t(stream);\r\n        var compressedSize = stream.FileSize() - stream.Tell();\r\n        var compressedData = [];\r\n        stream.Read(compressedData, 1, compressedSize);\r\n        var uncompressedData = [];\r\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize); // eslint-disable-line no-undef\r\n\r\n        var buff = new ArrayBuffer(uncompressedData);\r\n        ReadBinaryScene(buff, pScene);\r\n      } else {\r\n        ReadBinaryScene(stream, pScene);\r\n      }\r\n\r\n      return pScene.toTHREE();\r\n    }\r\n\r\n    return InternReadFile(buffer);\r\n  }\r\n});\r\n\r\nexport { AssimpLoader };\r\n", "import { Loader, FileLoader, CompressedTexture, UnsignedByteType, LinearFilter, LinearMipmapLinearFilter, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format } from 'three';\r\n\r\n/**\r\n * Loader for Basis Universal GPU Texture Codec.\r\n *\r\n * Basis Universal is a \"supercompressed\" GPU texture and texture video\r\n * compression system that outputs a highly compressed intermediate file format\r\n * (.basis) that can be quickly transcoded to a wide variety of GPU texture\r\n * compression formats.\r\n *\r\n * This loader parallelizes the transcoding process across a configurable number\r\n * of web workers, before transferring the transcoded compressed texture back\r\n * to the main thread.\r\n */\r\n\r\nconst _taskCache = new WeakMap();\r\n\r\nclass BasisTextureLoader extends Loader {\r\n  constructor(manager) {\r\n    super(manager);\r\n    this.transcoderPath = '';\r\n    this.transcoderBinary = null;\r\n    this.transcoderPending = null;\r\n    this.workerLimit = 4;\r\n    this.workerPool = [];\r\n    this.workerNextTaskID = 1;\r\n    this.workerSourceURL = '';\r\n    this.workerConfig = null;\r\n  }\r\n\r\n  setTranscoderPath(path) {\r\n    this.transcoderPath = path;\r\n    return this;\r\n  }\r\n\r\n  setWorkerLimit(workerLimit) {\r\n    this.workerLimit = workerLimit;\r\n    return this;\r\n  }\r\n\r\n  detectSupport(renderer) {\r\n    this.workerConfig = {\r\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\r\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\r\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\r\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\r\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\r\n      pvrtcSupported: renderer.extensions.has('WEBGL_compressed_texture_pvrtc') || renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc')\r\n    };\r\n    return this;\r\n  }\r\n\r\n  load(url, onLoad, onProgress, onError) {\r\n    const loader = new FileLoader(this.manager);\r\n    loader.setResponseType('arraybuffer');\r\n    loader.setWithCredentials(this.withCredentials);\r\n    const texture = new CompressedTexture();\r\n    loader.load(url, buffer => {\r\n      // Check for an existing task using this buffer. A transferred buffer cannot be transferred\r\n      // again from this thread.\r\n      if (_taskCache.has(buffer)) {\r\n        const cachedTask = _taskCache.get(buffer);\r\n\r\n        return cachedTask.promise.then(onLoad).catch(onError);\r\n      }\r\n\r\n      this._createTexture([buffer]).then(function (_texture) {\r\n        texture.copy(_texture);\r\n        texture.needsUpdate = true;\r\n        if (onLoad) onLoad(texture);\r\n      }).catch(onError);\r\n    }, onProgress, onError);\r\n    return texture;\r\n  }\r\n  /** Low-level transcoding API, exposed for use by KTX2Loader. */\r\n\r\n\r\n  parseInternalAsync(options) {\r\n    const {\r\n      levels\r\n    } = options;\r\n    const buffers = new Set();\r\n\r\n    for (let i = 0; i < levels.length; i++) {\r\n      buffers.add(levels[i].data.buffer);\r\n    }\r\n\r\n    return this._createTexture(Array.from(buffers), { ...options,\r\n      lowLevel: true\r\n    });\r\n  }\r\n  /**\r\n   * @param {ArrayBuffer[]} buffers\r\n   * @param {object?} config\r\n   * @return {Promise<CompressedTexture>}\r\n   */\r\n\r\n\r\n  _createTexture(buffers, config = {}) {\r\n    let worker;\r\n    let taskID;\r\n    const taskConfig = config;\r\n    let taskCost = 0;\r\n\r\n    for (let i = 0; i < buffers.length; i++) {\r\n      taskCost += buffers[i].byteLength;\r\n    }\r\n\r\n    const texturePending = this._allocateWorker(taskCost).then(_worker => {\r\n      worker = _worker;\r\n      taskID = this.workerNextTaskID++;\r\n      return new Promise((resolve, reject) => {\r\n        worker._callbacks[taskID] = {\r\n          resolve,\r\n          reject\r\n        };\r\n        worker.postMessage({\r\n          type: 'transcode',\r\n          id: taskID,\r\n          buffers: buffers,\r\n          taskConfig: taskConfig\r\n        }, buffers);\r\n      });\r\n    }).then(message => {\r\n      const {\r\n        mipmaps,\r\n        width,\r\n        height,\r\n        format\r\n      } = message;\r\n      const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\r\n      texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\r\n      texture.magFilter = LinearFilter;\r\n      texture.generateMipmaps = false;\r\n      texture.needsUpdate = true;\r\n      return texture;\r\n    }); // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\r\n\r\n\r\n    texturePending.catch(() => true).then(() => {\r\n      if (worker && taskID) {\r\n        worker._taskLoad -= taskCost;\r\n        delete worker._callbacks[taskID];\r\n      }\r\n    }); // Cache the task result.\r\n\r\n    _taskCache.set(buffers[0], {\r\n      promise: texturePending\r\n    });\r\n\r\n    return texturePending;\r\n  }\r\n\r\n  _initTranscoder() {\r\n    if (!this.transcoderPending) {\r\n      // Load transcoder wrapper.\r\n      const jsLoader = new FileLoader(this.manager);\r\n      jsLoader.setPath(this.transcoderPath);\r\n      jsLoader.setWithCredentials(this.withCredentials);\r\n      const jsContent = new Promise((resolve, reject) => {\r\n        jsLoader.load('basis_transcoder.js', resolve, undefined, reject);\r\n      }); // Load transcoder WASM binary.\r\n\r\n      const binaryLoader = new FileLoader(this.manager);\r\n      binaryLoader.setPath(this.transcoderPath);\r\n      binaryLoader.setResponseType('arraybuffer');\r\n      binaryLoader.setWithCredentials(this.withCredentials);\r\n      const binaryContent = new Promise((resolve, reject) => {\r\n        binaryLoader.load('basis_transcoder.wasm', resolve, undefined, reject);\r\n      });\r\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\r\n        const fn = BasisTextureLoader.BasisWorker.toString();\r\n        const body = ['/* constants */', 'let _EngineFormat = ' + JSON.stringify(BasisTextureLoader.EngineFormat), 'let _TranscoderFormat = ' + JSON.stringify(BasisTextureLoader.TranscoderFormat), 'let _BasisFormat = ' + JSON.stringify(BasisTextureLoader.BasisFormat), '/* basis_transcoder.js */', jsContent, '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\r\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]));\r\n        this.transcoderBinary = binaryContent;\r\n      });\r\n    }\r\n\r\n    return this.transcoderPending;\r\n  }\r\n\r\n  _allocateWorker(taskCost) {\r\n    return this._initTranscoder().then(() => {\r\n      if (this.workerPool.length < this.workerLimit) {\r\n        const worker = new Worker(this.workerSourceURL);\r\n        worker._callbacks = {};\r\n        worker._taskLoad = 0;\r\n        worker.postMessage({\r\n          type: 'init',\r\n          config: this.workerConfig,\r\n          transcoderBinary: this.transcoderBinary\r\n        });\r\n\r\n        worker.onmessage = function (e) {\r\n          const message = e.data;\r\n\r\n          switch (message.type) {\r\n            case 'transcode':\r\n              worker._callbacks[message.id].resolve(message);\r\n\r\n              break;\r\n\r\n            case 'error':\r\n              worker._callbacks[message.id].reject(message);\r\n\r\n              break;\r\n\r\n            default:\r\n              console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"');\r\n          }\r\n        };\r\n\r\n        this.workerPool.push(worker);\r\n      } else {\r\n        this.workerPool.sort(function (a, b) {\r\n          return a._taskLoad > b._taskLoad ? -1 : 1;\r\n        });\r\n      }\r\n\r\n      const worker = this.workerPool[this.workerPool.length - 1];\r\n      worker._taskLoad += taskCost;\r\n      return worker;\r\n    });\r\n  }\r\n\r\n  dispose() {\r\n    for (let i = 0; i < this.workerPool.length; i++) {\r\n      this.workerPool[i].terminate();\r\n    }\r\n\r\n    this.workerPool.length = 0;\r\n    return this;\r\n  }\r\n\r\n}\r\n/* CONSTANTS */\r\n\r\n\r\nBasisTextureLoader.BasisFormat = {\r\n  ETC1S: 0,\r\n  UASTC_4x4: 1\r\n};\r\nBasisTextureLoader.TranscoderFormat = {\r\n  ETC1: 0,\r\n  ETC2: 1,\r\n  BC1: 2,\r\n  BC3: 3,\r\n  BC4: 4,\r\n  BC5: 5,\r\n  BC7_M6_OPAQUE_ONLY: 6,\r\n  BC7_M5: 7,\r\n  PVRTC1_4_RGB: 8,\r\n  PVRTC1_4_RGBA: 9,\r\n  ASTC_4x4: 10,\r\n  ATC_RGB: 11,\r\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\r\n  RGBA32: 13,\r\n  RGB565: 14,\r\n  BGR565: 15,\r\n  RGBA4444: 16\r\n};\r\nBasisTextureLoader.EngineFormat = {\r\n  RGBAFormat: RGBAFormat,\r\n  RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\r\n  RGBA_BPTC_Format: RGBA_BPTC_Format,\r\n  RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\r\n  RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\r\n  RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\r\n  RGB_ETC1_Format: RGB_ETC1_Format,\r\n  RGB_ETC2_Format: RGB_ETC2_Format,\r\n  RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\r\n  RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format\r\n};\r\n/* WEB WORKER */\r\n\r\nBasisTextureLoader.BasisWorker = function () {\r\n  let config;\r\n  let transcoderPending;\r\n  let BasisModule;\r\n  const EngineFormat = _EngineFormat; // eslint-disable-line no-undef\r\n\r\n  const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef\r\n\r\n  const BasisFormat = _BasisFormat; // eslint-disable-line no-undef\r\n\r\n  onmessage = function (e) {\r\n    const message = e.data;\r\n\r\n    switch (message.type) {\r\n      case 'init':\r\n        config = message.config;\r\n        init(message.transcoderBinary);\r\n        break;\r\n\r\n      case 'transcode':\r\n        transcoderPending.then(() => {\r\n          try {\r\n            const {\r\n              width,\r\n              height,\r\n              hasAlpha,\r\n              mipmaps,\r\n              format\r\n            } = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]);\r\n            const buffers = [];\r\n\r\n            for (let i = 0; i < mipmaps.length; ++i) {\r\n              buffers.push(mipmaps[i].data.buffer);\r\n            }\r\n\r\n            self.postMessage({\r\n              type: 'transcode',\r\n              id: message.id,\r\n              width,\r\n              height,\r\n              hasAlpha,\r\n              mipmaps,\r\n              format\r\n            }, buffers);\r\n          } catch (error) {\r\n            console.error(error);\r\n            self.postMessage({\r\n              type: 'error',\r\n              id: message.id,\r\n              error: error.message\r\n            });\r\n          }\r\n        });\r\n        break;\r\n    }\r\n  };\r\n\r\n  function init(wasmBinary) {\r\n    transcoderPending = new Promise(resolve => {\r\n      BasisModule = {\r\n        wasmBinary,\r\n        onRuntimeInitialized: resolve\r\n      };\r\n      BASIS(BasisModule); // eslint-disable-line no-undef\r\n    }).then(() => {\r\n      BasisModule.initializeBasis();\r\n    });\r\n  }\r\n\r\n  function transcodeLowLevel(taskConfig) {\r\n    const {\r\n      basisFormat,\r\n      width,\r\n      height,\r\n      hasAlpha\r\n    } = taskConfig;\r\n    const {\r\n      transcoderFormat,\r\n      engineFormat\r\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\r\n    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\r\n    assert(BasisModule.isFormatSupported(transcoderFormat), 'THREE.BasisTextureLoader: Unsupported format.');\r\n    const mipmaps = [];\r\n\r\n    if (basisFormat === BasisFormat.ETC1S) {\r\n      const transcoder = new BasisModule.LowLevelETC1SImageTranscoder();\r\n      const {\r\n        endpointCount,\r\n        endpointsData,\r\n        selectorCount,\r\n        selectorsData,\r\n        tablesData\r\n      } = taskConfig.globalData;\r\n\r\n      try {\r\n        let ok;\r\n        ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);\r\n        assert(ok, 'THREE.BasisTextureLoader: decodePalettes() failed.');\r\n        ok = transcoder.decodeTables(tablesData);\r\n        assert(ok, 'THREE.BasisTextureLoader: decodeTables() failed.');\r\n\r\n        for (let i = 0; i < taskConfig.levels.length; i++) {\r\n          const level = taskConfig.levels[i];\r\n          const imageDesc = taskConfig.globalData.imageDescs[i];\r\n          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\r\n          const dst = new Uint8Array(dstByteLength);\r\n          ok = transcoder.transcodeImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength, imageDesc.alphaSliceByteOffset, imageDesc.alphaSliceByteLength, imageDesc.imageFlags, hasAlpha, false, 0, 0);\r\n          assert(ok, 'THREE.BasisTextureLoader: transcodeImage() failed for level ' + level.index + '.');\r\n          mipmaps.push({\r\n            data: dst,\r\n            width: level.width,\r\n            height: level.height\r\n          });\r\n        }\r\n      } finally {\r\n        transcoder.delete();\r\n      }\r\n    } else {\r\n      for (let i = 0; i < taskConfig.levels.length; i++) {\r\n        const level = taskConfig.levels[i];\r\n        const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\r\n        const dst = new Uint8Array(dstByteLength);\r\n        const ok = BasisModule.transcodeUASTCImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, 0, level.data.byteLength, 0, hasAlpha, false, 0, 0, -1, -1);\r\n        assert(ok, 'THREE.BasisTextureLoader: transcodeUASTCImage() failed for level ' + level.index + '.');\r\n        mipmaps.push({\r\n          data: dst,\r\n          width: level.width,\r\n          height: level.height\r\n        });\r\n      }\r\n    }\r\n\r\n    return {\r\n      width,\r\n      height,\r\n      hasAlpha,\r\n      mipmaps,\r\n      format: engineFormat\r\n    };\r\n  }\r\n\r\n  function transcode(buffer) {\r\n    const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer));\r\n    const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\r\n    const width = basisFile.getImageWidth(0, 0);\r\n    const height = basisFile.getImageHeight(0, 0);\r\n    const levels = basisFile.getNumLevels(0);\r\n    const hasAlpha = basisFile.getHasAlpha();\r\n\r\n    function cleanup() {\r\n      basisFile.close();\r\n      basisFile.delete();\r\n    }\r\n\r\n    const {\r\n      transcoderFormat,\r\n      engineFormat\r\n    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);\r\n\r\n    if (!width || !height || !levels) {\r\n      cleanup();\r\n      throw new Error('THREE.BasisTextureLoader:\tInvalid texture');\r\n    }\r\n\r\n    if (!basisFile.startTranscoding()) {\r\n      cleanup();\r\n      throw new Error('THREE.BasisTextureLoader: .startTranscoding failed');\r\n    }\r\n\r\n    const mipmaps = [];\r\n\r\n    for (let mip = 0; mip < levels; mip++) {\r\n      const mipWidth = basisFile.getImageWidth(0, mip);\r\n      const mipHeight = basisFile.getImageHeight(0, mip);\r\n      const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));\r\n      const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);\r\n\r\n      if (!status) {\r\n        cleanup();\r\n        throw new Error('THREE.BasisTextureLoader: .transcodeImage failed.');\r\n      }\r\n\r\n      mipmaps.push({\r\n        data: dst,\r\n        width: mipWidth,\r\n        height: mipHeight\r\n      });\r\n    }\r\n\r\n    cleanup();\r\n    return {\r\n      width,\r\n      height,\r\n      hasAlpha,\r\n      mipmaps,\r\n      format: engineFormat\r\n    };\r\n  } //\r\n  // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\r\n  // device capabilities, and texture dimensions. The list below ranks the formats separately\r\n  // for ETC1S and UASTC.\r\n  //\r\n  // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\r\n  // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\r\n  // chooses RGBA32 only as a last resort and does not expose that option to the caller.\r\n\r\n\r\n  const FORMAT_OPTIONS = [{\r\n    if: 'astcSupported',\r\n    basisFormat: [BasisFormat.UASTC_4x4],\r\n    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\r\n    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\r\n    priorityETC1S: Infinity,\r\n    priorityUASTC: 1,\r\n    needsPowerOfTwo: false\r\n  }, {\r\n    if: 'bptcSupported',\r\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\r\n    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\r\n    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\r\n    priorityETC1S: 3,\r\n    priorityUASTC: 2,\r\n    needsPowerOfTwo: false\r\n  }, {\r\n    if: 'dxtSupported',\r\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\r\n    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\r\n    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\r\n    priorityETC1S: 4,\r\n    priorityUASTC: 5,\r\n    needsPowerOfTwo: false\r\n  }, {\r\n    if: 'etc2Supported',\r\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\r\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\r\n    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\r\n    priorityETC1S: 1,\r\n    priorityUASTC: 3,\r\n    needsPowerOfTwo: false\r\n  }, {\r\n    if: 'etc1Supported',\r\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\r\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\r\n    engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\r\n    priorityETC1S: 2,\r\n    priorityUASTC: 4,\r\n    needsPowerOfTwo: false\r\n  }, {\r\n    if: 'pvrtcSupported',\r\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\r\n    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\r\n    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\r\n    priorityETC1S: 5,\r\n    priorityUASTC: 6,\r\n    needsPowerOfTwo: true\r\n  }];\r\n  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\r\n    return a.priorityETC1S - b.priorityETC1S;\r\n  });\r\n  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\r\n    return a.priorityUASTC - b.priorityUASTC;\r\n  });\r\n\r\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\r\n    let transcoderFormat;\r\n    let engineFormat;\r\n    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\r\n\r\n    for (let i = 0; i < options.length; i++) {\r\n      const opt = options[i];\r\n      if (!config[opt.if]) continue;\r\n      if (!opt.basisFormat.includes(basisFormat)) continue;\r\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\r\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\r\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\r\n      return {\r\n        transcoderFormat,\r\n        engineFormat\r\n      };\r\n    }\r\n\r\n    console.warn('THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.');\r\n    transcoderFormat = TranscoderFormat.RGBA32;\r\n    engineFormat = EngineFormat.RGBAFormat;\r\n    return {\r\n      transcoderFormat,\r\n      engineFormat\r\n    };\r\n  }\r\n\r\n  function assert(ok, message) {\r\n    if (!ok) throw new Error(message);\r\n  }\r\n\r\n  function getWidthInBlocks(transcoderFormat, width) {\r\n    return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));\r\n  }\r\n\r\n  function getHeightInBlocks(transcoderFormat, height) {\r\n    return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));\r\n  }\r\n\r\n  function getTranscodedImageByteLength(transcoderFormat, width, height) {\r\n    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\r\n\r\n    if (BasisModule.formatIsUncompressed(transcoderFormat)) {\r\n      return width * height * blockByteLength;\r\n    }\r\n\r\n    if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\r\n      // GL requires extra padding for very small textures:\r\n      // https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt\r\n      const paddedWidth = width + 3 & ~3;\r\n      const paddedHeight = height + 3 & ~3;\r\n      return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;\r\n    }\r\n\r\n    return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;\r\n  }\r\n\r\n  function isPowerOfTwo(value) {\r\n    if (value <= 2) return true;\r\n    return (value & value - 1) === 0 && value !== 0;\r\n  }\r\n};\r\n\r\nexport { BasisTextureLoader };\r\n", "import { Vector3, Ray, Loader, FileLoader, MeshStandardMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Color, BufferGeometry, BufferAttribute, LineSegments, Mesh, Matrix4, Group } from 'three';\r\n\r\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\r\n\r\nconst FINISH_TYPE_DEFAULT = 0;\r\nconst FINISH_TYPE_CHROME = 1;\r\nconst FINISH_TYPE_PEARLESCENT = 2;\r\nconst FINISH_TYPE_RUBBER = 3;\r\nconst FINISH_TYPE_MATTE_METALLIC = 4;\r\nconst FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\r\n// The LDraw standard establishes these various possible subfolders.\r\n\r\nconst FILE_LOCATION_AS_IS = 0;\r\nconst FILE_LOCATION_TRY_PARTS = 1;\r\nconst FILE_LOCATION_TRY_P = 2;\r\nconst FILE_LOCATION_TRY_MODELS = 3;\r\nconst FILE_LOCATION_TRY_RELATIVE = 4;\r\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\r\nconst FILE_LOCATION_NOT_FOUND = 6;\r\nconst MAIN_COLOUR_CODE = '16';\r\nconst MAIN_EDGE_COLOUR_CODE = '24';\r\n\r\nconst _tempVec0 = new Vector3();\r\n\r\nconst _tempVec1 = new Vector3();\r\n\r\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\r\n  constructor(parameters) {\r\n    super({\r\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\r\n        diffuse: {\r\n          value: new Color()\r\n        },\r\n        opacity: {\r\n          value: 1.0\r\n        }\r\n      }]),\r\n      vertexShader:\r\n      /* glsl */\r\n      `\r\n        attribute vec3 control0;\r\n        attribute vec3 control1;\r\n        attribute vec3 direction;\r\n        varying float discardFlag;\r\n\r\n        #include <common>\r\n        #include <color_pars_vertex>\r\n        #include <fog_pars_vertex>\r\n        #include <logdepthbuf_pars_vertex>\r\n        #include <clipping_planes_pars_vertex>\r\n\r\n        void main() {\r\n          #include <color_vertex>\r\n\r\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n          gl_Position = projectionMatrix * mvPosition;\r\n\r\n          // Transform the line segment ends and control points into camera clip space\r\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\r\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\r\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\r\n\r\n          c0.xy /= c0.w;\r\n          c1.xy /= c1.w;\r\n          p0.xy /= p0.w;\r\n          p1.xy /= p1.w;\r\n\r\n          // Get the direction of the segment and an orthogonal vector\r\n          vec2 dir = p1.xy - p0.xy;\r\n          vec2 norm = vec2(-dir.y, dir.x);\r\n\r\n          // Get control point directions from the line\r\n          vec2 c0dir = c0.xy - p1.xy;\r\n          vec2 c1dir = c1.xy - p1.xy;\r\n\r\n          // If the vectors to the controls points are pointed in different directions away\r\n          // from the line segment then the line should not be drawn.\r\n          float d0 = dot(normalize(norm), normalize(c0dir));\r\n          float d1 = dot(normalize(norm), normalize(c1dir));\r\n          discardFlag = float(sign(d0) != sign(d1));\r\n\r\n          #include <logdepthbuf_vertex>\r\n          #include <clipping_planes_vertex>\r\n          #include <fog_vertex>\r\n        }\r\n      `,\r\n      fragmentShader:\r\n      /* glsl */\r\n      `\r\n        uniform vec3 diffuse;\r\n        uniform float opacity;\r\n        varying float discardFlag;\r\n\r\n        #include <common>\r\n        #include <color_pars_fragment>\r\n        #include <fog_pars_fragment>\r\n        #include <logdepthbuf_pars_fragment>\r\n        #include <clipping_planes_pars_fragment>\r\n\r\n        void main() {\r\n          if (discardFlag > 0.5) discard;\r\n\r\n          #include <clipping_planes_fragment>\r\n          vec3 outgoingLight = vec3(0.0);\r\n          vec4 diffuseColor = vec4(diffuse, opacity);\r\n          #include <logdepthbuf_fragment>\r\n          #include <color_fragment>\r\n          outgoingLight = diffuseColor.rgb; // simple shader\r\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\r\n          #include <tonemapping_fragment>\r\n          #include <encodings_fragment>\r\n          #include <fog_fragment>\r\n          #include <premultiplied_alpha_fragment>\r\n        }\r\n      `\r\n    });\r\n    Object.defineProperties(this, {\r\n      opacity: {\r\n        get: function () {\r\n          return this.uniforms.opacity.value;\r\n        },\r\n        set: function (value) {\r\n          this.uniforms.opacity.value = value;\r\n        }\r\n      },\r\n      color: {\r\n        get: function () {\r\n          return this.uniforms.diffuse.value;\r\n        }\r\n      }\r\n    });\r\n    this.setValues(parameters);\r\n    this.isLDrawConditionalLineMaterial = true;\r\n  }\r\n\r\n}\r\n\r\nclass ConditionalLineSegments extends LineSegments {\r\n  constructor(geometry, material) {\r\n    super(geometry, material);\r\n    this.isConditionalLine = true;\r\n  }\r\n\r\n}\r\n\r\nfunction generateFaceNormals(faces) {\r\n  for (let i = 0, l = faces.length; i < l; i++) {\r\n    const face = faces[i];\r\n    const vertices = face.vertices;\r\n    const v0 = vertices[0];\r\n    const v1 = vertices[1];\r\n    const v2 = vertices[2];\r\n\r\n    _tempVec0.subVectors(v1, v0);\r\n\r\n    _tempVec1.subVectors(v2, v1);\r\n\r\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\r\n  }\r\n}\r\n\r\nconst _ray = new Ray();\r\n\r\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\r\n  // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\r\n  // it allows edges to be smoothed as expected (see minifig arms).\r\n  // --\r\n  // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\r\n  // point errors on vertices along quantization boundaries. Ie after matrix multiplication\r\n  // vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\r\n  // get merged. This added epsilon attempts to push these error values to the same quantized\r\n  // value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\r\n  const hashMultiplier = (1 + 1e-10) * 1e2;\r\n\r\n  function hashVertex(v) {\r\n    const x = ~~(v.x * hashMultiplier);\r\n    const y = ~~(v.y * hashMultiplier);\r\n    const z = ~~(v.z * hashMultiplier);\r\n    return `${x},${y},${z}`;\r\n  }\r\n\r\n  function hashEdge(v0, v1) {\r\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\r\n  } // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\r\n  // onto the original line.\r\n\r\n\r\n  function toNormalizedRay(v0, v1, targetRay) {\r\n    targetRay.direction.subVectors(v1, v0).normalize();\r\n    const scalar = v0.dot(targetRay.direction);\r\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\r\n    return targetRay;\r\n  }\r\n\r\n  function hashRay(ray) {\r\n    return hashEdge(ray.origin, ray.direction);\r\n  }\r\n\r\n  const hardEdges = new Set();\r\n  const hardEdgeRays = new Map();\r\n  const halfEdgeList = {};\r\n  const normals = []; // Save the list of hard edges by hash\r\n\r\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\r\n    const ls = lineSegments[i];\r\n    const vertices = ls.vertices;\r\n    const v0 = vertices[0];\r\n    const v1 = vertices[1];\r\n    hardEdges.add(hashEdge(v0, v1));\r\n    hardEdges.add(hashEdge(v1, v0)); // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\r\n    // and requires more memory.\r\n\r\n    if (checkSubSegments) {\r\n      // add both ray directions to the map\r\n      const ray = toNormalizedRay(v0, v1, new Ray());\r\n      const rh1 = hashRay(ray);\r\n\r\n      if (!hardEdgeRays.has(rh1)) {\r\n        toNormalizedRay(v1, v0, ray);\r\n        const rh2 = hashRay(ray);\r\n        const info = {\r\n          ray,\r\n          distances: []\r\n        };\r\n        hardEdgeRays.set(rh1, info);\r\n        hardEdgeRays.set(rh2, info);\r\n      } // store both segments ends in min, max order in the distances array to check if a face edge is a\r\n      // subsegment later.\r\n\r\n\r\n      const info = hardEdgeRays.get(rh1);\r\n      let d0 = info.ray.direction.dot(v0);\r\n      let d1 = info.ray.direction.dot(v1);\r\n\r\n      if (d0 > d1) {\r\n        [d0, d1] = [d1, d0];\r\n      }\r\n\r\n      info.distances.push(d0, d1);\r\n    }\r\n  } // track the half edges associated with each triangle\r\n\r\n\r\n  for (let i = 0, l = faces.length; i < l; i++) {\r\n    const tri = faces[i];\r\n    const vertices = tri.vertices;\r\n    const vertCount = vertices.length;\r\n\r\n    for (let i2 = 0; i2 < vertCount; i2++) {\r\n      const index = i2;\r\n      const next = (i2 + 1) % vertCount;\r\n      const v0 = vertices[index];\r\n      const v1 = vertices[next];\r\n      const hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\r\n\r\n      if (hardEdges.has(hash)) {\r\n        continue;\r\n      } // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\r\n\r\n\r\n      if (checkSubSegments) {\r\n        toNormalizedRay(v0, v1, _ray);\r\n        const rayHash = hashRay(_ray);\r\n\r\n        if (hardEdgeRays.has(rayHash)) {\r\n          const info = hardEdgeRays.get(rayHash);\r\n          const {\r\n            ray,\r\n            distances\r\n          } = info;\r\n          let d0 = ray.direction.dot(v0);\r\n          let d1 = ray.direction.dot(v1);\r\n\r\n          if (d0 > d1) {\r\n            [d0, d1] = [d1, d0];\r\n          } // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\r\n\r\n\r\n          let found = false;\r\n\r\n          for (let i = 0, l = distances.length; i < l; i += 2) {\r\n            if (d0 >= distances[i] && d1 <= distances[i + 1]) {\r\n              found = true;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (found) {\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n\r\n      const info = {\r\n        index: index,\r\n        tri: tri\r\n      };\r\n      halfEdgeList[hash] = info;\r\n    }\r\n  } // Iterate until we've tried to connect all faces to share normals\r\n\r\n\r\n  while (true) {\r\n    // Stop if there are no more faces left\r\n    let halfEdge = null;\r\n\r\n    for (const key in halfEdgeList) {\r\n      halfEdge = halfEdgeList[key];\r\n      break;\r\n    }\r\n\r\n    if (halfEdge === null) {\r\n      break;\r\n    } // Exhaustively find all connected faces\r\n\r\n\r\n    const queue = [halfEdge];\r\n\r\n    while (queue.length > 0) {\r\n      // initialize all vertex normals in this triangle\r\n      const tri = queue.pop().tri;\r\n      const vertices = tri.vertices;\r\n      const vertNormals = tri.normals;\r\n      const faceNormal = tri.faceNormal; // Check if any edge is connected to another triangle edge\r\n\r\n      const vertCount = vertices.length;\r\n\r\n      for (let i2 = 0; i2 < vertCount; i2++) {\r\n        const index = i2;\r\n        const next = (i2 + 1) % vertCount;\r\n        const v0 = vertices[index];\r\n        const v1 = vertices[next]; // delete this triangle from the list so it won't be found again\r\n\r\n        const hash = hashEdge(v0, v1);\r\n        delete halfEdgeList[hash];\r\n        const reverseHash = hashEdge(v1, v0);\r\n        const otherInfo = halfEdgeList[reverseHash];\r\n\r\n        if (otherInfo) {\r\n          const otherTri = otherInfo.tri;\r\n          const otherIndex = otherInfo.index;\r\n          const otherNormals = otherTri.normals;\r\n          const otherVertCount = otherNormals.length;\r\n          const otherFaceNormal = otherTri.faceNormal; // NOTE: If the angle between faces is > 67.5 degrees then assume it's\r\n          // hard edge. There are some cases where the line segments do not line up exactly\r\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\r\n\r\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\r\n            continue;\r\n          } // if this triangle has already been traversed then it won't be in\r\n          // the halfEdgeList. If it has not then add it to the queue and delete\r\n          // it so it won't be found again.\r\n\r\n\r\n          if (reverseHash in halfEdgeList) {\r\n            queue.push(otherInfo);\r\n            delete halfEdgeList[reverseHash];\r\n          } // share the first normal\r\n\r\n\r\n          const otherNext = (otherIndex + 1) % otherVertCount;\r\n\r\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\r\n            otherNormals[otherNext].norm.add(vertNormals[index].norm);\r\n            vertNormals[index].norm = otherNormals[otherNext].norm;\r\n          }\r\n\r\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];\r\n\r\n          if (sharedNormal1 === null) {\r\n            // it's possible to encounter an edge of a triangle that has already been traversed meaning\r\n            // both edges already have different normals defined and shared. To work around this we create\r\n            // a wrapper object so when those edges are merged the normals can be updated everywhere.\r\n            sharedNormal1 = {\r\n              norm: new Vector3()\r\n            };\r\n            normals.push(sharedNormal1.norm);\r\n          }\r\n\r\n          if (vertNormals[index] === null) {\r\n            vertNormals[index] = sharedNormal1;\r\n            sharedNormal1.norm.add(faceNormal);\r\n          }\r\n\r\n          if (otherNormals[otherNext] === null) {\r\n            otherNormals[otherNext] = sharedNormal1;\r\n            sharedNormal1.norm.add(otherFaceNormal);\r\n          } // share the second normal\r\n\r\n\r\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\r\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm);\r\n            vertNormals[next].norm = otherNormals[otherIndex].norm;\r\n          }\r\n\r\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];\r\n\r\n          if (sharedNormal2 === null) {\r\n            sharedNormal2 = {\r\n              norm: new Vector3()\r\n            };\r\n            normals.push(sharedNormal2.norm);\r\n          }\r\n\r\n          if (vertNormals[next] === null) {\r\n            vertNormals[next] = sharedNormal2;\r\n            sharedNormal2.norm.add(faceNormal);\r\n          }\r\n\r\n          if (otherNormals[otherIndex] === null) {\r\n            otherNormals[otherIndex] = sharedNormal2;\r\n            sharedNormal2.norm.add(otherFaceNormal);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\r\n\r\n\r\n  for (let i = 0, l = normals.length; i < l; i++) {\r\n    normals[i].normalize();\r\n  }\r\n}\r\n\r\nfunction isPartType(type) {\r\n  return type === 'Part' || type === 'Unofficial_Part';\r\n}\r\n\r\nfunction isPrimitiveType(type) {\r\n  return /primitive/i.test(type) || type === 'Subpart';\r\n}\r\n\r\nclass LineParser {\r\n  constructor(line, lineNumber) {\r\n    this.line = line;\r\n    this.lineLength = line.length;\r\n    this.currentCharIndex = 0;\r\n    this.currentChar = ' ';\r\n    this.lineNumber = lineNumber;\r\n  }\r\n\r\n  seekNonSpace() {\r\n    while (this.currentCharIndex < this.lineLength) {\r\n      this.currentChar = this.line.charAt(this.currentCharIndex);\r\n\r\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\r\n        return;\r\n      }\r\n\r\n      this.currentCharIndex++;\r\n    }\r\n  }\r\n\r\n  getToken() {\r\n    const pos0 = this.currentCharIndex++; // Seek space\r\n\r\n    while (this.currentCharIndex < this.lineLength) {\r\n      this.currentChar = this.line.charAt(this.currentCharIndex);\r\n\r\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\r\n        break;\r\n      }\r\n\r\n      this.currentCharIndex++;\r\n    }\r\n\r\n    const pos1 = this.currentCharIndex;\r\n    this.seekNonSpace();\r\n    return this.line.substring(pos0, pos1);\r\n  }\r\n\r\n  getVector() {\r\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\r\n  }\r\n\r\n  getRemainingString() {\r\n    return this.line.substring(this.currentCharIndex, this.lineLength);\r\n  }\r\n\r\n  isAtTheEnd() {\r\n    return this.currentCharIndex >= this.lineLength;\r\n  }\r\n\r\n  setToEnd() {\r\n    this.currentCharIndex = this.lineLength;\r\n  }\r\n\r\n  getLineNumberString() {\r\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\r\n  }\r\n\r\n} // Fetches and parses an intermediate representation of LDraw parts files.\r\n\r\n\r\nclass LDrawParsedCache {\r\n  constructor(loader) {\r\n    this.loader = loader;\r\n    this._cache = {};\r\n  }\r\n\r\n  cloneResult(original) {\r\n    const result = {}; // vertices are transformed and normals computed before being converted to geometry\r\n    // so these pieces must be cloned.\r\n\r\n    result.faces = original.faces.map(face => {\r\n      return {\r\n        colorCode: face.colorCode,\r\n        material: face.material,\r\n        vertices: face.vertices.map(v => v.clone()),\r\n        normals: face.normals.map(() => null),\r\n        faceNormal: null\r\n      };\r\n    });\r\n    result.conditionalSegments = original.conditionalSegments.map(face => {\r\n      return {\r\n        colorCode: face.colorCode,\r\n        material: face.material,\r\n        vertices: face.vertices.map(v => v.clone()),\r\n        controlPoints: face.controlPoints.map(v => v.clone())\r\n      };\r\n    });\r\n    result.lineSegments = original.lineSegments.map(face => {\r\n      return {\r\n        colorCode: face.colorCode,\r\n        material: face.material,\r\n        vertices: face.vertices.map(v => v.clone())\r\n      };\r\n    }); // none if this is subsequently modified\r\n\r\n    result.type = original.type;\r\n    result.category = original.category;\r\n    result.keywords = original.keywords;\r\n    result.subobjects = original.subobjects;\r\n    result.totalFaces = original.totalFaces;\r\n    result.startingConstructionStep = original.startingConstructionStep;\r\n    result.materials = original.materials;\r\n    result.group = null;\r\n    return result;\r\n  }\r\n\r\n  async fetchData(fileName) {\r\n    let triedLowerCase = false;\r\n    let locationState = FILE_LOCATION_AS_IS;\r\n\r\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\r\n      let subobjectURL = fileName;\r\n\r\n      switch (locationState) {\r\n        case FILE_LOCATION_AS_IS:\r\n          locationState = locationState + 1;\r\n          break;\r\n\r\n        case FILE_LOCATION_TRY_PARTS:\r\n          subobjectURL = 'parts/' + subobjectURL;\r\n          locationState = locationState + 1;\r\n          break;\r\n\r\n        case FILE_LOCATION_TRY_P:\r\n          subobjectURL = 'p/' + subobjectURL;\r\n          locationState = locationState + 1;\r\n          break;\r\n\r\n        case FILE_LOCATION_TRY_MODELS:\r\n          subobjectURL = 'models/' + subobjectURL;\r\n          locationState = locationState + 1;\r\n          break;\r\n\r\n        case FILE_LOCATION_TRY_RELATIVE:\r\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf('/') + 1) + subobjectURL;\r\n          locationState = locationState + 1;\r\n          break;\r\n\r\n        case FILE_LOCATION_TRY_ABSOLUTE:\r\n          if (triedLowerCase) {\r\n            // Try absolute path\r\n            locationState = FILE_LOCATION_NOT_FOUND;\r\n          } else {\r\n            // Next attempt is lower case\r\n            fileName = fileName.toLowerCase();\r\n            subobjectURL = fileName;\r\n            triedLowerCase = true;\r\n            locationState = FILE_LOCATION_AS_IS;\r\n          }\r\n\r\n          break;\r\n      }\r\n\r\n      const loader = this.loader;\r\n      const fileLoader = new FileLoader(loader.manager);\r\n      fileLoader.setPath(loader.partsLibraryPath);\r\n      fileLoader.setRequestHeader(loader.requestHeader);\r\n      fileLoader.setWithCredentials(loader.withCredentials);\r\n\r\n      try {\r\n        const text = await fileLoader.loadAsync(subobjectURL);\r\n        return text;\r\n      } catch {\r\n        continue;\r\n      }\r\n    }\r\n\r\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\r\n  }\r\n\r\n  parse(text, fileName = null) {\r\n    const loader = this.loader; // final results\r\n\r\n    const faces = [];\r\n    const lineSegments = [];\r\n    const conditionalSegments = [];\r\n    const subobjects = [];\r\n    const materials = {};\r\n\r\n    const getLocalMaterial = colorCode => {\r\n      return materials[colorCode] || null;\r\n    };\r\n\r\n    let type = 'Model';\r\n    let category = null;\r\n    let keywords = null;\r\n    let totalFaces = 0; // split into lines\r\n\r\n    if (text.indexOf('\\r\\n') !== -1) {\r\n      // This is faster than String.split with regex that splits on both\r\n      text = text.replace(/\\r\\n/g, '\\n');\r\n    }\r\n\r\n    const lines = text.split('\\n');\r\n    const numLines = lines.length;\r\n    let parsingEmbeddedFiles = false;\r\n    let currentEmbeddedFileName = null;\r\n    let currentEmbeddedText = null;\r\n    let bfcCertified = false;\r\n    let bfcCCW = true;\r\n    let bfcInverted = false;\r\n    let bfcCull = true;\r\n    let startingConstructionStep = false; // Parse all line commands\r\n\r\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\r\n      const line = lines[lineIndex];\r\n      if (line.length === 0) continue;\r\n\r\n      if (parsingEmbeddedFiles) {\r\n        if (line.startsWith('0 FILE ')) {\r\n          // Save previous embedded file in the cache\r\n          this.setData(currentEmbeddedFileName, currentEmbeddedText); // New embedded text file\r\n\r\n          currentEmbeddedFileName = line.substring(7);\r\n          currentEmbeddedText = '';\r\n        } else {\r\n          currentEmbeddedText += line + '\\n';\r\n        }\r\n\r\n        continue;\r\n      }\r\n\r\n      const lp = new LineParser(line, lineIndex + 1);\r\n      lp.seekNonSpace();\r\n\r\n      if (lp.isAtTheEnd()) {\r\n        // Empty line\r\n        continue;\r\n      } // Parse the line type\r\n\r\n\r\n      const lineType = lp.getToken();\r\n      let material;\r\n      let colorCode;\r\n      let segment;\r\n      let ccw;\r\n      let doubleSided;\r\n      let v0, v1, v2, v3, c0, c1;\r\n\r\n      switch (lineType) {\r\n        // Line type 0: Comment or META\r\n        case '0':\r\n          // Parse meta directive\r\n          const meta = lp.getToken();\r\n\r\n          if (meta) {\r\n            switch (meta) {\r\n              case '!LDRAW_ORG':\r\n                type = lp.getToken();\r\n                break;\r\n\r\n              case '!COLOUR':\r\n                material = loader.parseColorMetaDirective(lp);\r\n\r\n                if (material) {\r\n                  materials[material.userData.code] = material;\r\n                } else {\r\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\r\n                }\r\n\r\n                break;\r\n\r\n              case '!CATEGORY':\r\n                category = lp.getToken();\r\n                break;\r\n\r\n              case '!KEYWORDS':\r\n                const newKeywords = lp.getRemainingString().split(',');\r\n\r\n                if (newKeywords.length > 0) {\r\n                  if (!keywords) {\r\n                    keywords = [];\r\n                  }\r\n\r\n                  newKeywords.forEach(function (keyword) {\r\n                    keywords.push(keyword.trim());\r\n                  });\r\n                }\r\n\r\n                break;\r\n\r\n              case 'FILE':\r\n                if (lineIndex > 0) {\r\n                  // Start embedded text files parsing\r\n                  parsingEmbeddedFiles = true;\r\n                  currentEmbeddedFileName = lp.getRemainingString();\r\n                  currentEmbeddedText = '';\r\n                  bfcCertified = false;\r\n                  bfcCCW = true;\r\n                }\r\n\r\n                break;\r\n\r\n              case 'BFC':\r\n                // Changes to the backface culling state\r\n                while (!lp.isAtTheEnd()) {\r\n                  const token = lp.getToken();\r\n\r\n                  switch (token) {\r\n                    case 'CERTIFY':\r\n                    case 'NOCERTIFY':\r\n                      bfcCertified = token === 'CERTIFY';\r\n                      bfcCCW = true;\r\n                      break;\r\n\r\n                    case 'CW':\r\n                    case 'CCW':\r\n                      bfcCCW = token === 'CCW';\r\n                      break;\r\n\r\n                    case 'INVERTNEXT':\r\n                      bfcInverted = true;\r\n                      break;\r\n\r\n                    case 'CLIP':\r\n                    case 'NOCLIP':\r\n                      bfcCull = token === 'CLIP';\r\n                      break;\r\n\r\n                    default:\r\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\r\n                      break;\r\n                  }\r\n                }\r\n\r\n                break;\r\n\r\n              case 'STEP':\r\n                startingConstructionStep = true;\r\n                break;\r\n            }\r\n          }\r\n\r\n          break;\r\n        // Line type 1: Sub-object file\r\n\r\n        case '1':\r\n          colorCode = lp.getToken();\r\n          material = getLocalMaterial(colorCode);\r\n          const posX = parseFloat(lp.getToken());\r\n          const posY = parseFloat(lp.getToken());\r\n          const posZ = parseFloat(lp.getToken());\r\n          const m0 = parseFloat(lp.getToken());\r\n          const m1 = parseFloat(lp.getToken());\r\n          const m2 = parseFloat(lp.getToken());\r\n          const m3 = parseFloat(lp.getToken());\r\n          const m4 = parseFloat(lp.getToken());\r\n          const m5 = parseFloat(lp.getToken());\r\n          const m6 = parseFloat(lp.getToken());\r\n          const m7 = parseFloat(lp.getToken());\r\n          const m8 = parseFloat(lp.getToken());\r\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\r\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\r\n\r\n          if (loader.fileMap[fileName]) {\r\n            // Found the subobject path in the preloaded file path map\r\n            fileName = loader.fileMap[fileName];\r\n          } else {\r\n            // Standardized subfolders\r\n            if (fileName.startsWith('s/')) {\r\n              fileName = 'parts/' + fileName;\r\n            } else if (fileName.startsWith('48/')) {\r\n              fileName = 'p/' + fileName;\r\n            }\r\n          }\r\n\r\n          subobjects.push({\r\n            material: material,\r\n            colorCode: colorCode,\r\n            matrix: matrix,\r\n            fileName: fileName,\r\n            inverted: bfcInverted,\r\n            startingConstructionStep: startingConstructionStep\r\n          });\r\n          bfcInverted = false;\r\n          break;\r\n        // Line type 2: Line segment\r\n\r\n        case '2':\r\n          colorCode = lp.getToken();\r\n          material = getLocalMaterial(colorCode);\r\n          v0 = lp.getVector();\r\n          v1 = lp.getVector();\r\n          segment = {\r\n            material: material,\r\n            colorCode: colorCode,\r\n            vertices: [v0, v1]\r\n          };\r\n          lineSegments.push(segment);\r\n          break;\r\n        // Line type 5: Conditional Line segment\r\n\r\n        case '5':\r\n          colorCode = lp.getToken();\r\n          material = getLocalMaterial(colorCode);\r\n          v0 = lp.getVector();\r\n          v1 = lp.getVector();\r\n          c0 = lp.getVector();\r\n          c1 = lp.getVector();\r\n          segment = {\r\n            material: material,\r\n            colorCode: colorCode,\r\n            vertices: [v0, v1],\r\n            controlPoints: [c0, c1]\r\n          };\r\n          conditionalSegments.push(segment);\r\n          break;\r\n        // Line type 3: Triangle\r\n\r\n        case '3':\r\n          colorCode = lp.getToken();\r\n          material = getLocalMaterial(colorCode);\r\n          ccw = bfcCCW;\r\n          doubleSided = !bfcCertified || !bfcCull;\r\n\r\n          if (ccw === true) {\r\n            v0 = lp.getVector();\r\n            v1 = lp.getVector();\r\n            v2 = lp.getVector();\r\n          } else {\r\n            v2 = lp.getVector();\r\n            v1 = lp.getVector();\r\n            v0 = lp.getVector();\r\n          }\r\n\r\n          faces.push({\r\n            material: material,\r\n            colorCode: colorCode,\r\n            faceNormal: null,\r\n            vertices: [v0, v1, v2],\r\n            normals: [null, null, null]\r\n          });\r\n          totalFaces++;\r\n\r\n          if (doubleSided === true) {\r\n            faces.push({\r\n              material: material,\r\n              colorCode: colorCode,\r\n              faceNormal: null,\r\n              vertices: [v2, v1, v0],\r\n              normals: [null, null, null]\r\n            });\r\n            totalFaces++;\r\n          }\r\n\r\n          break;\r\n        // Line type 4: Quadrilateral\r\n\r\n        case '4':\r\n          colorCode = lp.getToken();\r\n          material = getLocalMaterial(colorCode);\r\n          ccw = bfcCCW;\r\n          doubleSided = !bfcCertified || !bfcCull;\r\n\r\n          if (ccw === true) {\r\n            v0 = lp.getVector();\r\n            v1 = lp.getVector();\r\n            v2 = lp.getVector();\r\n            v3 = lp.getVector();\r\n          } else {\r\n            v3 = lp.getVector();\r\n            v2 = lp.getVector();\r\n            v1 = lp.getVector();\r\n            v0 = lp.getVector();\r\n          } // specifically place the triangle diagonal in the v0 and v1 slots so we can\r\n          // account for the doubling of vertices later when smoothing normals.\r\n\r\n\r\n          faces.push({\r\n            material: material,\r\n            colorCode: colorCode,\r\n            faceNormal: null,\r\n            vertices: [v0, v1, v2, v3],\r\n            normals: [null, null, null, null]\r\n          });\r\n          totalFaces += 2;\r\n\r\n          if (doubleSided === true) {\r\n            faces.push({\r\n              material: material,\r\n              colorCode: colorCode,\r\n              faceNormal: null,\r\n              vertices: [v3, v2, v1, v0],\r\n              normals: [null, null, null, null]\r\n            });\r\n            totalFaces += 2;\r\n          }\r\n\r\n          break;\r\n\r\n        default:\r\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.');\r\n      }\r\n    }\r\n\r\n    if (parsingEmbeddedFiles) {\r\n      this.setData(currentEmbeddedFileName, currentEmbeddedText);\r\n    }\r\n\r\n    return {\r\n      faces,\r\n      conditionalSegments,\r\n      lineSegments,\r\n      type,\r\n      category,\r\n      keywords,\r\n      subobjects,\r\n      totalFaces,\r\n      startingConstructionStep,\r\n      materials,\r\n      fileName,\r\n      group: null\r\n    };\r\n  } // returns an (optionally cloned) instance of the data\r\n\r\n\r\n  getData(fileName, clone = true) {\r\n    const key = fileName.toLowerCase();\r\n    const result = this._cache[key];\r\n\r\n    if (result === null || result instanceof Promise) {\r\n      return null;\r\n    }\r\n\r\n    if (clone) {\r\n      return this.cloneResult(result);\r\n    } else {\r\n      return result;\r\n    }\r\n  } // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\r\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\r\n\r\n\r\n  async ensureDataLoaded(fileName) {\r\n    const key = fileName.toLowerCase();\r\n\r\n    if (!(key in this._cache)) {\r\n      // replace the promise with a copy of the parsed data for immediate processing\r\n      this._cache[key] = this.fetchData(fileName).then(text => {\r\n        const info = this.parse(text, fileName);\r\n        this._cache[key] = info;\r\n        return info;\r\n      });\r\n    }\r\n\r\n    await this._cache[key];\r\n  } // sets the data in the cache from parsed data\r\n\r\n\r\n  setData(fileName, text) {\r\n    const key = fileName.toLowerCase();\r\n    this._cache[key] = this.parse(text, fileName);\r\n  }\r\n\r\n} // returns the material for an associated color code. If the color code is 16 for a face or 24 for\r\n// an edge then the passthroughColorCode is used.\r\n\r\n\r\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\r\n  const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\r\n\r\n  if (isPassthrough) {\r\n    colorCode = parentColorCode;\r\n  }\r\n\r\n  return materialHierarchy[colorCode] || null;\r\n} // Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\r\n\r\n\r\nclass LDrawPartsGeometryCache {\r\n  constructor(loader) {\r\n    this.loader = loader;\r\n    this.parseCache = new LDrawParsedCache(loader);\r\n    this._cache = {};\r\n  } // Convert the given file information into a mesh by processing subobjects.\r\n\r\n\r\n  async processIntoMesh(info) {\r\n    const loader = this.loader;\r\n    const parseCache = this.parseCache;\r\n    const faceMaterials = new Set(); // Processes the part subobject information to load child parts and merge geometry onto part\r\n    // piece object.\r\n\r\n    const processInfoSubobjects = async (info, subobject = null) => {\r\n      const subobjects = info.subobjects;\r\n      const promises = []; // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\r\n      // group which lets instruction steps apply correctly.\r\n\r\n      for (let i = 0, l = subobjects.length; i < l; i++) {\r\n        const subobject = subobjects[i];\r\n        const promise = parseCache.ensureDataLoaded(subobject.fileName).then(() => {\r\n          const subobjectInfo = parseCache.getData(subobject.fileName, false);\r\n\r\n          if (!isPrimitiveType(subobjectInfo.type)) {\r\n            return this.loadModel(subobject.fileName).catch(error => {\r\n              console.warn(error);\r\n              return null;\r\n            });\r\n          }\r\n\r\n          return processInfoSubobjects(parseCache.getData(subobject.fileName), subobject);\r\n        });\r\n        promises.push(promise);\r\n      }\r\n\r\n      const group = new Group();\r\n      group.userData.category = info.category;\r\n      group.userData.keywords = info.keywords;\r\n      info.group = group;\r\n      const subobjectInfos = await Promise.all(promises);\r\n\r\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\r\n        const subobject = info.subobjects[i];\r\n        const subobjectInfo = subobjectInfos[i];\r\n\r\n        if (subobjectInfo === null) {\r\n          // the subobject failed to load\r\n          continue;\r\n        } // if the subobject was loaded as a separate group then apply the parent scopes materials\r\n\r\n\r\n        if (subobjectInfo.isGroup) {\r\n          const subobjectGroup = subobjectInfo;\r\n          subobject.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\r\n          subobjectGroup.userData.startingConstructionStep = subobject.startingConstructionStep;\r\n          subobjectGroup.name = subobject.fileName;\r\n          loader.applyMaterialsToMesh(subobjectGroup, subobject.colorCode, info.materials);\r\n          group.add(subobjectGroup);\r\n          continue;\r\n        } // add the subobject group if it has children in case it has both children and primitives\r\n\r\n\r\n        if (subobjectInfo.group.children.length) {\r\n          group.add(subobjectInfo.group);\r\n        } // transform the primitives into the local space of the parent piece and append them to\r\n        // to the parent primitives list.\r\n\r\n\r\n        const parentLineSegments = info.lineSegments;\r\n        const parentConditionalSegments = info.conditionalSegments;\r\n        const parentFaces = info.faces;\r\n        const lineSegments = subobjectInfo.lineSegments;\r\n        const conditionalSegments = subobjectInfo.conditionalSegments;\r\n        const faces = subobjectInfo.faces;\r\n        const matrix = subobject.matrix;\r\n        const inverted = subobject.inverted;\r\n        const matrixScaleInverted = matrix.determinant() < 0;\r\n        const colorCode = subobject.colorCode;\r\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\r\n\r\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\r\n          const ls = lineSegments[i];\r\n          const vertices = ls.vertices;\r\n          vertices[0].applyMatrix4(matrix);\r\n          vertices[1].applyMatrix4(matrix);\r\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\r\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info.materials, true);\r\n          parentLineSegments.push(ls);\r\n        }\r\n\r\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\r\n          const os = conditionalSegments[i];\r\n          const vertices = os.vertices;\r\n          const controlPoints = os.controlPoints;\r\n          vertices[0].applyMatrix4(matrix);\r\n          vertices[1].applyMatrix4(matrix);\r\n          controlPoints[0].applyMatrix4(matrix);\r\n          controlPoints[1].applyMatrix4(matrix);\r\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\r\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info.materials, true);\r\n          parentConditionalSegments.push(os);\r\n        }\r\n\r\n        for (let i = 0, l = faces.length; i < l; i++) {\r\n          const tri = faces[i];\r\n          const vertices = tri.vertices;\r\n\r\n          for (let i = 0, l = vertices.length; i < l; i++) {\r\n            vertices[i].applyMatrix4(matrix);\r\n          }\r\n\r\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\r\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info.materials, false);\r\n          faceMaterials.add(tri.colorCode); // If the scale of the object is negated then the triangle winding order\r\n          // needs to be flipped.\r\n\r\n          if (matrixScaleInverted !== inverted) {\r\n            vertices.reverse();\r\n          }\r\n\r\n          parentFaces.push(tri);\r\n        }\r\n\r\n        info.totalFaces += subobjectInfo.totalFaces;\r\n      } // Apply the parent subobjects pass through material code to this object. This is done several times due\r\n      // to material scoping.\r\n\r\n\r\n      if (subobject) {\r\n        loader.applyMaterialsToMesh(group, subobject.colorCode, info.materials);\r\n      }\r\n\r\n      return info;\r\n    }; // Track material use to see if we need to use the normal smooth slow path for hard edges.\r\n\r\n\r\n    for (let i = 0, l = info.faces; i < l; i++) {\r\n      faceMaterials.add(info.faces[i].colorCode);\r\n    }\r\n\r\n    await processInfoSubobjects(info);\r\n\r\n    if (loader.smoothNormals) {\r\n      const checkSubSegments = faceMaterials.size > 1;\r\n      generateFaceNormals(info.faces);\r\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments);\r\n    } // Add the primitive objects and metadata.\r\n\r\n\r\n    const group = info.group;\r\n\r\n    if (info.faces.length > 0) {\r\n      group.add(createObject(info.faces, 3, false, info.totalFaces));\r\n    }\r\n\r\n    if (info.lineSegments.length > 0) {\r\n      group.add(createObject(info.lineSegments, 2));\r\n    }\r\n\r\n    if (info.conditionalSegments.length > 0) {\r\n      group.add(createObject(info.conditionalSegments, 2, true));\r\n    }\r\n\r\n    return group;\r\n  }\r\n\r\n  hasCachedModel(fileName) {\r\n    return fileName !== null && fileName.toLowerCase() in this._cache;\r\n  }\r\n\r\n  async getCachedModel(fileName) {\r\n    if (fileName !== null && this.hasCachedModel(fileName)) {\r\n      const key = fileName.toLowerCase();\r\n      const group = await this._cache[key];\r\n      return group.clone();\r\n    } else {\r\n      return null;\r\n    }\r\n  } // Loads and parses the model with the given file name. Returns a cached copy if available.\r\n\r\n\r\n  async loadModel(fileName) {\r\n    const parseCache = this.parseCache;\r\n    const key = fileName.toLowerCase();\r\n\r\n    if (this.hasCachedModel(fileName)) {\r\n      // Return cached model if available.\r\n      return this.getCachedModel(fileName);\r\n    } else {\r\n      // Otherwise parse a new model.\r\n      // Ensure the file data is loaded and pre parsed.\r\n      await parseCache.ensureDataLoaded(fileName);\r\n      const info = parseCache.getData(fileName);\r\n      const promise = this.processIntoMesh(info); // Now that the file has loaded it's possible that another part parse has been waiting in parallel\r\n      // so check the cache again to see if it's been added since the last async operation so we don't\r\n      // do unnecessary work.\r\n\r\n      if (this.hasCachedModel(fileName)) {\r\n        return this.getCachedModel(fileName);\r\n      } // Cache object if it's a part so it can be reused later.\r\n\r\n\r\n      if (isPartType(info.type)) {\r\n        this._cache[key] = promise;\r\n      } // return a copy\r\n\r\n\r\n      const group = await promise;\r\n      return group.clone();\r\n    }\r\n  } // parses the given model text into a renderable object. Returns cached copy if available.\r\n\r\n\r\n  async parseModel(text) {\r\n    const parseCache = this.parseCache;\r\n    const info = parseCache.parse(text);\r\n\r\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\r\n      return this.getCachedModel(info.fileName);\r\n    }\r\n\r\n    return this.processIntoMesh(info);\r\n  }\r\n\r\n}\r\n\r\nfunction sortByMaterial(a, b) {\r\n  if (a.colorCode === b.colorCode) {\r\n    return 0;\r\n  }\r\n\r\n  if (a.colorCode < b.colorCode) {\r\n    return -1;\r\n  }\r\n\r\n  return 1;\r\n}\r\n\r\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\r\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\r\n  // With per face / segment material, implemented with mesh groups and materials array\r\n  // Sort the faces or line segments by color code to make later the mesh groups\r\n  elements.sort(sortByMaterial);\r\n\r\n  if (totalElements === null) {\r\n    totalElements = elements.length;\r\n  }\r\n\r\n  const positions = new Float32Array(elementSize * totalElements * 3);\r\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\r\n  const materials = [];\r\n  const quadArray = new Array(6);\r\n  const bufferGeometry = new BufferGeometry();\r\n  let prevMaterial = null;\r\n  let index0 = 0;\r\n  let numGroupVerts = 0;\r\n  let offset = 0;\r\n\r\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\r\n    const elem = elements[iElem];\r\n    let vertices = elem.vertices;\r\n\r\n    if (vertices.length === 4) {\r\n      quadArray[0] = vertices[0];\r\n      quadArray[1] = vertices[1];\r\n      quadArray[2] = vertices[2];\r\n      quadArray[3] = vertices[0];\r\n      quadArray[4] = vertices[2];\r\n      quadArray[5] = vertices[3];\r\n      vertices = quadArray;\r\n    }\r\n\r\n    for (let j = 0, l = vertices.length; j < l; j++) {\r\n      const v = vertices[j];\r\n      const index = offset + j * 3;\r\n      positions[index + 0] = v.x;\r\n      positions[index + 1] = v.y;\r\n      positions[index + 2] = v.z;\r\n    } // create the normals array if this is a set of faces\r\n\r\n\r\n    if (elementSize === 3) {\r\n      if (!elem.faceNormal) {\r\n        const v0 = vertices[0];\r\n        const v1 = vertices[1];\r\n        const v2 = vertices[2];\r\n\r\n        _tempVec0.subVectors(v1, v0);\r\n\r\n        _tempVec1.subVectors(v2, v1);\r\n\r\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\r\n      }\r\n\r\n      let elemNormals = elem.normals;\r\n\r\n      if (elemNormals.length === 4) {\r\n        quadArray[0] = elemNormals[0];\r\n        quadArray[1] = elemNormals[1];\r\n        quadArray[2] = elemNormals[2];\r\n        quadArray[3] = elemNormals[0];\r\n        quadArray[4] = elemNormals[2];\r\n        quadArray[5] = elemNormals[3];\r\n        elemNormals = quadArray;\r\n      }\r\n\r\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\r\n        // use face normal if a vertex normal is not provided\r\n        let n = elem.faceNormal;\r\n\r\n        if (elemNormals[j]) {\r\n          n = elemNormals[j].norm;\r\n        }\r\n\r\n        const index = offset + j * 3;\r\n        normals[index + 0] = n.x;\r\n        normals[index + 1] = n.y;\r\n        normals[index + 2] = n.z;\r\n      }\r\n    }\r\n\r\n    if (prevMaterial !== elem.colorCode) {\r\n      if (prevMaterial !== null) {\r\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\r\n      }\r\n\r\n      const material = elem.material;\r\n\r\n      if (material !== null) {\r\n        if (elementSize === 3) {\r\n          materials.push(material);\r\n        } else if (elementSize === 2) {\r\n          if (material !== null) {\r\n            if (isConditionalSegments) {\r\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\r\n            } else {\r\n              materials.push(material.userData.edgeMaterial);\r\n            }\r\n          } else {\r\n            materials.push(null);\r\n          }\r\n        }\r\n      } else {\r\n        // If a material has not been made available yet then keep the color code string in the material array\r\n        // to save the spot for the material once a parent scopes materials are being applied to the object.\r\n        materials.push(elem.colorCode);\r\n      }\r\n\r\n      prevMaterial = elem.colorCode;\r\n      index0 = offset / 3;\r\n      numGroupVerts = vertices.length;\r\n    } else {\r\n      numGroupVerts += vertices.length;\r\n    }\r\n\r\n    offset += 3 * vertices.length;\r\n  }\r\n\r\n  if (numGroupVerts > 0) {\r\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\r\n  }\r\n\r\n  bufferGeometry.setAttribute('position', new BufferAttribute(positions, 3));\r\n\r\n  if (normals !== null) {\r\n    bufferGeometry.setAttribute('normal', new BufferAttribute(normals, 3));\r\n  }\r\n\r\n  let object3d = null;\r\n\r\n  if (elementSize === 2) {\r\n    if (isConditionalSegments) {\r\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\r\n    } else {\r\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\r\n    }\r\n  } else if (elementSize === 3) {\r\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\r\n  }\r\n\r\n  if (isConditionalSegments) {\r\n    object3d.isConditionalLine = true;\r\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\r\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\r\n    const directionArray = new Float32Array(elements.length * 3 * 2);\r\n\r\n    for (let i = 0, l = elements.length; i < l; i++) {\r\n      const os = elements[i];\r\n      const vertices = os.vertices;\r\n      const controlPoints = os.controlPoints;\r\n      const c0 = controlPoints[0];\r\n      const c1 = controlPoints[1];\r\n      const v0 = vertices[0];\r\n      const v1 = vertices[1];\r\n      const index = i * 3 * 2;\r\n      controlArray0[index + 0] = c0.x;\r\n      controlArray0[index + 1] = c0.y;\r\n      controlArray0[index + 2] = c0.z;\r\n      controlArray0[index + 3] = c0.x;\r\n      controlArray0[index + 4] = c0.y;\r\n      controlArray0[index + 5] = c0.z;\r\n      controlArray1[index + 0] = c1.x;\r\n      controlArray1[index + 1] = c1.y;\r\n      controlArray1[index + 2] = c1.z;\r\n      controlArray1[index + 3] = c1.x;\r\n      controlArray1[index + 4] = c1.y;\r\n      controlArray1[index + 5] = c1.z;\r\n      directionArray[index + 0] = v1.x - v0.x;\r\n      directionArray[index + 1] = v1.y - v0.y;\r\n      directionArray[index + 2] = v1.z - v0.z;\r\n      directionArray[index + 3] = v1.x - v0.x;\r\n      directionArray[index + 4] = v1.y - v0.y;\r\n      directionArray[index + 5] = v1.z - v0.z;\r\n    }\r\n\r\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\r\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\r\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\r\n  }\r\n\r\n  return object3d;\r\n} //\r\n\r\n\r\nclass LDrawLoader extends Loader {\r\n  constructor(manager) {\r\n    super(manager); // Array of THREE.Material\r\n\r\n    this.materials = [];\r\n    this.materialLibrary = {}; // This also allows to handle the embedded text files (\"0 FILE\" lines)\r\n\r\n    this.partsCache = new LDrawPartsGeometryCache(this); // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\r\n\r\n    this.fileMap = {}; // Initializes the materials library with default materials\r\n\r\n    this.setMaterials([]); // If this flag is set to true the vertex normals will be smoothed.\r\n\r\n    this.smoothNormals = true; // The path to load parts from the LDraw parts library from.\r\n\r\n    this.partsLibraryPath = '';\r\n  }\r\n\r\n  setPartsLibraryPath(path) {\r\n    this.partsLibraryPath = path;\r\n    return this;\r\n  }\r\n\r\n  async preloadMaterials(url) {\r\n    const fileLoader = new FileLoader(this.manager);\r\n    fileLoader.setPath(this.path);\r\n    fileLoader.setRequestHeader(this.requestHeader);\r\n    fileLoader.setWithCredentials(this.withCredentials);\r\n    const text = await fileLoader.loadAsync(url);\r\n    const colorLineRegex = /^0 !COLOUR/;\r\n    const lines = text.split(/[\\n\\r]/g);\r\n    const materials = [];\r\n\r\n    for (let i = 0, l = lines.length; i < l; i++) {\r\n      const line = lines[i];\r\n\r\n      if (colorLineRegex.test(line)) {\r\n        const directive = line.replace(colorLineRegex, '');\r\n        const material = this.parseColorMetaDirective(new LineParser(directive));\r\n        materials.push(material);\r\n      }\r\n    }\r\n\r\n    this.setMaterials(materials);\r\n  }\r\n\r\n  load(url, onLoad, onProgress, onError) {\r\n    const fileLoader = new FileLoader(this.manager);\r\n    fileLoader.setPath(this.path);\r\n    fileLoader.setRequestHeader(this.requestHeader);\r\n    fileLoader.setWithCredentials(this.withCredentials);\r\n    fileLoader.load(url, text => {\r\n      this.partsCache.parseModel(text, this.materialLibrary).then(group => {\r\n        this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);\r\n        this.computeConstructionSteps(group);\r\n        onLoad(group);\r\n      }).catch(onError);\r\n    }, onProgress, onError);\r\n  }\r\n\r\n  parse(text, onLoad) {\r\n    this.partsCache.parseModel(text, this.materialLibrary).then(group => {\r\n      this.computeConstructionSteps(group);\r\n      onLoad(group);\r\n    });\r\n  }\r\n\r\n  setMaterials(materials) {\r\n    this.materialLibrary = {};\r\n    this.materials = [];\r\n\r\n    for (let i = 0, l = materials.length; i < l; i++) {\r\n      this.addMaterial(materials[i]);\r\n    } // Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\r\n\r\n\r\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')));\r\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333')));\r\n    return this;\r\n  }\r\n\r\n  setFileMap(fileMap) {\r\n    this.fileMap = fileMap;\r\n    return this;\r\n  }\r\n\r\n  addMaterial(material) {\r\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\r\n    const matLib = this.materialLibrary;\r\n\r\n    if (!matLib[material.userData.code]) {\r\n      this.materials.push(material);\r\n      matLib[material.userData.code] = material;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  getMaterial(colorCode) {\r\n    if (colorCode.startsWith('0x2')) {\r\n      // Special 'direct' material value (RGB color)\r\n      const color = colorCode.substring(3);\r\n      return this.parseColorMetaDirective(new LineParser('Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + ''));\r\n    }\r\n\r\n    return this.materialLibrary[colorCode] || null;\r\n  } // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\r\n  // in the material array if they need to be filled in.\r\n\r\n\r\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\r\n    // find any missing materials as indicated by a color code string and replace it with a material from the current material lib\r\n    const loader = this;\r\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\r\n    group.traverse(c => {\r\n      if (c.isMesh || c.isLineSegments) {\r\n        if (Array.isArray(c.material)) {\r\n          for (let i = 0, l = c.material.length; i < l; i++) {\r\n            if (!c.material[i].isMaterial) {\r\n              c.material[i] = getMaterial(c, c.material[i]);\r\n            }\r\n          }\r\n        } else if (!c.material.isMaterial) {\r\n          c.material = getMaterial(c, c.material);\r\n        }\r\n      }\r\n    }); // Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\r\n    // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\r\n    // simply returned for the subsequent material application.\r\n\r\n    function getMaterial(c, colorCode) {\r\n      // if our parent is a passthrough color code and we don't have the current material color available then\r\n      // return early.\r\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\r\n        return colorCode;\r\n      }\r\n\r\n      const forEdge = c.isLineSegments || c.isConditionalLine;\r\n      const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\r\n\r\n      if (isPassthrough) {\r\n        colorCode = parentColorCode;\r\n      }\r\n\r\n      let material = null;\r\n\r\n      if (colorCode in materialHierarchy) {\r\n        material = materialHierarchy[colorCode];\r\n      } else if (finalMaterialPass) {\r\n        // see if we can get the final material from from the \"getMaterial\" function which will attempt to\r\n        // parse the \"direct\" colors\r\n        material = loader.getMaterial(colorCode);\r\n\r\n        if (material === null) {\r\n          // otherwise throw an error if this is final opportunity to set the material\r\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`);\r\n        }\r\n      } else {\r\n        return colorCode;\r\n      }\r\n\r\n      if (c.isLineSegments) {\r\n        material = material.userData.edgeMaterial;\r\n\r\n        if (c.isConditionalLine) {\r\n          material = material.userData.conditionalEdgeMaterial;\r\n        }\r\n      }\r\n\r\n      return material;\r\n    }\r\n  }\r\n\r\n  getMainMaterial() {\r\n    return this.getMaterial(MAIN_COLOUR_CODE);\r\n  }\r\n\r\n  getMainEdgeMaterial() {\r\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\r\n  }\r\n\r\n  parseColorMetaDirective(lineParser) {\r\n    // Parses a color definition and returns a THREE.Material\r\n    let code = null; // Triangle and line colors\r\n\r\n    let color = 0xff00ff;\r\n    let edgeColor = 0xff00ff; // Transparency\r\n\r\n    let alpha = 1;\r\n    let isTransparent = false; // Self-illumination:\r\n\r\n    let luminance = 0;\r\n    let finishType = FINISH_TYPE_DEFAULT;\r\n    let edgeMaterial = null;\r\n    const name = lineParser.getToken();\r\n\r\n    if (!name) {\r\n      throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.');\r\n    } // Parse tag tokens and their parameters\r\n\r\n\r\n    let token = null;\r\n\r\n    while (true) {\r\n      token = lineParser.getToken();\r\n\r\n      if (!token) {\r\n        break;\r\n      }\r\n\r\n      switch (token.toUpperCase()) {\r\n        case 'CODE':\r\n          code = lineParser.getToken();\r\n          break;\r\n\r\n        case 'VALUE':\r\n          color = lineParser.getToken();\r\n\r\n          if (color.startsWith('0x')) {\r\n            color = '#' + color.substring(2);\r\n          } else if (!color.startsWith('#')) {\r\n            throw new Error('LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.');\r\n          }\r\n\r\n          break;\r\n\r\n        case 'EDGE':\r\n          edgeColor = lineParser.getToken();\r\n\r\n          if (edgeColor.startsWith('0x')) {\r\n            edgeColor = '#' + edgeColor.substring(2);\r\n          } else if (!edgeColor.startsWith('#')) {\r\n            // Try to see if edge color is a color code\r\n            edgeMaterial = this.getMaterial(edgeColor);\r\n\r\n            if (!edgeMaterial) {\r\n              throw new Error('LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.');\r\n            } // Get the edge material for this triangle material\r\n\r\n\r\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\r\n          }\r\n\r\n          break;\r\n\r\n        case 'ALPHA':\r\n          alpha = parseInt(lineParser.getToken());\r\n\r\n          if (isNaN(alpha)) {\r\n            throw new Error('LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.');\r\n          }\r\n\r\n          alpha = Math.max(0, Math.min(1, alpha / 255));\r\n\r\n          if (alpha < 1) {\r\n            isTransparent = true;\r\n          }\r\n\r\n          break;\r\n\r\n        case 'LUMINANCE':\r\n          luminance = parseInt(lineParser.getToken());\r\n\r\n          if (isNaN(luminance)) {\r\n            throw new Error('LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.');\r\n          }\r\n\r\n          luminance = Math.max(0, Math.min(1, luminance / 255));\r\n          break;\r\n\r\n        case 'CHROME':\r\n          finishType = FINISH_TYPE_CHROME;\r\n          break;\r\n\r\n        case 'PEARLESCENT':\r\n          finishType = FINISH_TYPE_PEARLESCENT;\r\n          break;\r\n\r\n        case 'RUBBER':\r\n          finishType = FINISH_TYPE_RUBBER;\r\n          break;\r\n\r\n        case 'MATTE_METALLIC':\r\n          finishType = FINISH_TYPE_MATTE_METALLIC;\r\n          break;\r\n\r\n        case 'METAL':\r\n          finishType = FINISH_TYPE_METAL;\r\n          break;\r\n\r\n        case 'MATERIAL':\r\n          // Not implemented\r\n          lineParser.setToEnd();\r\n          break;\r\n\r\n        default:\r\n          throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.');\r\n      }\r\n    }\r\n\r\n    let material = null;\r\n\r\n    switch (finishType) {\r\n      case FINISH_TYPE_DEFAULT:\r\n        material = new MeshStandardMaterial({\r\n          color: color,\r\n          roughness: 0.3,\r\n          metalness: 0\r\n        });\r\n        break;\r\n\r\n      case FINISH_TYPE_PEARLESCENT:\r\n        // Try to imitate pearlescency by making the surface glossy\r\n        material = new MeshStandardMaterial({\r\n          color: color,\r\n          roughness: 0.3,\r\n          metalness: 0.25\r\n        });\r\n        break;\r\n\r\n      case FINISH_TYPE_CHROME:\r\n        // Mirror finish surface\r\n        material = new MeshStandardMaterial({\r\n          color: color,\r\n          roughness: 0,\r\n          metalness: 1\r\n        });\r\n        break;\r\n\r\n      case FINISH_TYPE_RUBBER:\r\n        // Rubber finish\r\n        material = new MeshStandardMaterial({\r\n          color: color,\r\n          roughness: 0.9,\r\n          metalness: 0\r\n        });\r\n        break;\r\n\r\n      case FINISH_TYPE_MATTE_METALLIC:\r\n        // Brushed metal finish\r\n        material = new MeshStandardMaterial({\r\n          color: color,\r\n          roughness: 0.8,\r\n          metalness: 0.4\r\n        });\r\n        break;\r\n\r\n      case FINISH_TYPE_METAL:\r\n        // Average metal finish\r\n        material = new MeshStandardMaterial({\r\n          color: color,\r\n          roughness: 0.2,\r\n          metalness: 0.85\r\n        });\r\n        break;\r\n    }\r\n\r\n    material.transparent = isTransparent;\r\n    material.premultipliedAlpha = true;\r\n    material.opacity = alpha;\r\n    material.depthWrite = !isTransparent;\r\n    material.polygonOffset = true;\r\n    material.polygonOffsetFactor = 1;\r\n\r\n    if (luminance !== 0) {\r\n      material.emissive.set(material.color).multiplyScalar(luminance);\r\n    }\r\n\r\n    if (!edgeMaterial) {\r\n      // This is the material used for edges\r\n      edgeMaterial = new LineBasicMaterial({\r\n        color: edgeColor,\r\n        transparent: isTransparent,\r\n        opacity: alpha,\r\n        depthWrite: !isTransparent\r\n      });\r\n      edgeMaterial.userData.code = code;\r\n      edgeMaterial.name = name + ' - Edge'; // This is the material used for conditional edges\r\n\r\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\r\n        fog: true,\r\n        transparent: isTransparent,\r\n        depthWrite: !isTransparent,\r\n        color: edgeColor,\r\n        opacity: alpha\r\n      });\r\n    }\r\n\r\n    material.userData.code = code;\r\n    material.name = name;\r\n    material.userData.edgeMaterial = edgeMaterial;\r\n    this.addMaterial(material);\r\n    return material;\r\n  }\r\n\r\n  computeConstructionSteps(model) {\r\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\r\n    let stepNumber = 0;\r\n    model.traverse(c => {\r\n      if (c.isGroup) {\r\n        if (c.userData.startingConstructionStep) {\r\n          stepNumber++;\r\n        }\r\n\r\n        c.userData.constructionStep = stepNumber;\r\n      }\r\n    });\r\n    model.userData.numConstructionSteps = stepNumber + 1;\r\n  }\r\n\r\n}\r\n\r\nexport { LDrawLoader };\r\n", "function LWO3Parser(IFFParser) {\r\n  this.IFF = IFFParser;\r\n}\r\n\r\nLWO3Parser.prototype = {\r\n  constructor: LWO3Parser,\r\n  parseBlock: function () {\r\n    this.IFF.debugger.offset = this.IFF.reader.offset;\r\n    this.IFF.debugger.closeForms();\r\n    var blockID = this.IFF.reader.getIDTag();\r\n    var length = this.IFF.reader.getUint32(); // size of data in bytes\r\n\r\n    this.IFF.debugger.dataOffset = this.IFF.reader.offset;\r\n    this.IFF.debugger.length = length; // Data types may be found in either LWO2 OR LWO3 spec\r\n\r\n    switch (blockID) {\r\n      case 'FORM':\r\n        // form blocks may consist of sub -chunks or sub-forms\r\n        this.IFF.parseForm(length);\r\n        break;\r\n      // SKIPPED CHUNKS\r\n      // MISC skipped\r\n\r\n      case 'ICON': // Thumbnail Icon Image\r\n\r\n      case 'VMPA': // Vertex Map Parameter\r\n\r\n      case 'BBOX': // bounding box\r\n      // case 'VMMD':\r\n      // case 'VTYP':\r\n      // normal maps can be specified, normally on models imported from other applications. Currently ignored\r\n\r\n      case 'NORM': // ENVL FORM skipped\r\n\r\n      case 'PRE ':\r\n      case 'POST':\r\n      case 'KEY ':\r\n      case 'SPAN': // CLIP FORM skipped\r\n\r\n      case 'TIME':\r\n      case 'CLRS':\r\n      case 'CLRA':\r\n      case 'FILT':\r\n      case 'DITH':\r\n      case 'CONT':\r\n      case 'BRIT':\r\n      case 'SATR':\r\n      case 'HUE ':\r\n      case 'GAMM':\r\n      case 'NEGA':\r\n      case 'IFLT':\r\n      case 'PFLT': // Image Map Layer skipped\r\n\r\n      case 'PROJ':\r\n      case 'AXIS':\r\n      case 'AAST':\r\n      case 'PIXB':\r\n      case 'STCK': // Procedural Textures skipped\r\n\r\n      case 'VALU': // Gradient Textures skipped\r\n\r\n      case 'PNAM':\r\n      case 'INAM':\r\n      case 'GRST':\r\n      case 'GREN':\r\n      case 'GRPT':\r\n      case 'FKEY':\r\n      case 'IKEY': // Texture Mapping Form skipped\r\n\r\n      case 'CSYS': // Surface CHUNKs skipped\r\n\r\n      case 'OPAQ': // top level 'opacity' checkbox\r\n\r\n      case 'CMAP': // clip map\r\n      // Surface node CHUNKS skipped\r\n      // These mainly specify the node editor setup in LW\r\n\r\n      case 'NLOC':\r\n      case 'NZOM':\r\n      case 'NVER':\r\n      case 'NSRV':\r\n      case 'NCRD':\r\n      case 'NMOD':\r\n      case 'NSEL':\r\n      case 'NPRW':\r\n      case 'NPLA':\r\n      case 'VERS':\r\n      case 'ENUM':\r\n      case 'TAG ': // Car Material CHUNKS\r\n\r\n      case 'CGMD':\r\n      case 'CGTY':\r\n      case 'CGST':\r\n      case 'CGEN':\r\n      case 'CGTS':\r\n      case 'CGTE':\r\n      case 'OSMP':\r\n      case 'OMDE':\r\n      case 'OUTR':\r\n      case 'FLAG':\r\n      case 'TRNL':\r\n      case 'SHRP':\r\n      case 'RFOP':\r\n      case 'RSAN':\r\n      case 'TROP':\r\n      case 'RBLR':\r\n      case 'TBLR':\r\n      case 'CLRH':\r\n      case 'CLRF':\r\n      case 'ADTR':\r\n      case 'GLOW':\r\n      case 'LINE':\r\n      case 'ALPH':\r\n      case 'VCOL':\r\n      case 'ENAB':\r\n        this.IFF.debugger.skipped = true;\r\n        this.IFF.reader.skip(length);\r\n        break;\r\n      // Texture node chunks (not in spec)\r\n\r\n      case 'IPIX': // usePixelBlending\r\n\r\n      case 'IMIP': // useMipMaps\r\n\r\n      case 'IMOD': // imageBlendingMode\r\n\r\n      case 'AMOD': // unknown\r\n\r\n      case 'IINV': // imageInvertAlpha\r\n\r\n      case 'INCR': // imageInvertColor\r\n\r\n      case 'IAXS': // imageAxis ( for non-UV maps)\r\n\r\n      case 'IFOT': // imageFallofType\r\n\r\n      case 'ITIM': // timing for animated textures\r\n\r\n      case 'IWRL':\r\n      case 'IUTI':\r\n      case 'IINX':\r\n      case 'IINY':\r\n      case 'IINZ':\r\n      case 'IREF':\r\n        // possibly a VX for reused texture nodes\r\n        if (length === 4) this.IFF.currentNode[blockID] = this.IFF.reader.getInt32();else this.IFF.reader.skip(length);\r\n        break;\r\n\r\n      case 'OTAG':\r\n        this.IFF.parseObjectTag();\r\n        break;\r\n\r\n      case 'LAYR':\r\n        this.IFF.parseLayer(length);\r\n        break;\r\n\r\n      case 'PNTS':\r\n        this.IFF.parsePoints(length);\r\n        break;\r\n\r\n      case 'VMAP':\r\n        this.IFF.parseVertexMapping(length);\r\n        break;\r\n\r\n      case 'POLS':\r\n        this.IFF.parsePolygonList(length);\r\n        break;\r\n\r\n      case 'TAGS':\r\n        this.IFF.parseTagStrings(length);\r\n        break;\r\n\r\n      case 'PTAG':\r\n        this.IFF.parsePolygonTagMapping(length);\r\n        break;\r\n\r\n      case 'VMAD':\r\n        this.IFF.parseVertexMapping(length, true);\r\n        break;\r\n      // Misc CHUNKS\r\n\r\n      case 'DESC':\r\n        // Description Line\r\n        this.IFF.currentForm.description = this.IFF.reader.getString();\r\n        break;\r\n\r\n      case 'TEXT':\r\n      case 'CMNT':\r\n      case 'NCOM':\r\n        this.IFF.currentForm.comment = this.IFF.reader.getString();\r\n        break;\r\n      // Envelope Form\r\n\r\n      case 'NAME':\r\n        this.IFF.currentForm.channelName = this.IFF.reader.getString();\r\n        break;\r\n      // Image Map Layer\r\n\r\n      case 'WRAP':\r\n        this.IFF.currentForm.wrap = {\r\n          w: this.IFF.reader.getUint16(),\r\n          h: this.IFF.reader.getUint16()\r\n        };\r\n        break;\r\n\r\n      case 'IMAG':\r\n        var index = this.IFF.reader.getVariableLengthIndex();\r\n        this.IFF.currentForm.imageIndex = index;\r\n        break;\r\n      // Texture Mapping Form\r\n\r\n      case 'OREF':\r\n        this.IFF.currentForm.referenceObject = this.IFF.reader.getString();\r\n        break;\r\n\r\n      case 'ROID':\r\n        this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();\r\n        break;\r\n      // Surface Blocks\r\n\r\n      case 'SSHN':\r\n        this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();\r\n        break;\r\n\r\n      case 'AOVN':\r\n        this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();\r\n        break;\r\n      // Nodal Blocks\r\n\r\n      case 'NSTA':\r\n        this.IFF.currentForm.disabled = this.IFF.reader.getUint16();\r\n        break;\r\n\r\n      case 'NRNM':\r\n        this.IFF.currentForm.realName = this.IFF.reader.getString();\r\n        break;\r\n\r\n      case 'NNME':\r\n        this.IFF.currentForm.refName = this.IFF.reader.getString();\r\n        this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm;\r\n        break;\r\n      // Nodal Blocks : connections\r\n\r\n      case 'INME':\r\n        if (!this.IFF.currentForm.nodeName) this.IFF.currentForm.nodeName = [];\r\n        this.IFF.currentForm.nodeName.push(this.IFF.reader.getString());\r\n        break;\r\n\r\n      case 'IINN':\r\n        if (!this.IFF.currentForm.inputNodeName) this.IFF.currentForm.inputNodeName = [];\r\n        this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString());\r\n        break;\r\n\r\n      case 'IINM':\r\n        if (!this.IFF.currentForm.inputName) this.IFF.currentForm.inputName = [];\r\n        this.IFF.currentForm.inputName.push(this.IFF.reader.getString());\r\n        break;\r\n\r\n      case 'IONM':\r\n        if (!this.IFF.currentForm.inputOutputName) this.IFF.currentForm.inputOutputName = [];\r\n        this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString());\r\n        break;\r\n\r\n      case 'FNAM':\r\n        this.IFF.currentForm.fileName = this.IFF.reader.getString();\r\n        break;\r\n\r\n      case 'CHAN':\r\n        // NOTE: ENVL Forms may also have CHAN chunk, however ENVL is currently ignored\r\n        if (length === 4) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();else this.IFF.reader.skip(length);\r\n        break;\r\n      // LWO2 Spec chunks: these are needed since the SURF FORMs are often in LWO2 format\r\n\r\n      case 'SMAN':\r\n        var maxSmoothingAngle = this.IFF.reader.getFloat32();\r\n        this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true;\r\n        break;\r\n      // LWO2: Basic Surface Parameters\r\n\r\n      case 'COLR':\r\n        this.IFF.currentSurface.attributes.Color = {\r\n          value: this.IFF.reader.getFloat32Array(3)\r\n        };\r\n        this.IFF.reader.skip(2); // VX: envelope\r\n\r\n        break;\r\n\r\n      case 'LUMI':\r\n        this.IFF.currentSurface.attributes.Luminosity = {\r\n          value: this.IFF.reader.getFloat32()\r\n        };\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'SPEC':\r\n        this.IFF.currentSurface.attributes.Specular = {\r\n          value: this.IFF.reader.getFloat32()\r\n        };\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'DIFF':\r\n        this.IFF.currentSurface.attributes.Diffuse = {\r\n          value: this.IFF.reader.getFloat32()\r\n        };\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'REFL':\r\n        this.IFF.currentSurface.attributes.Reflection = {\r\n          value: this.IFF.reader.getFloat32()\r\n        };\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'GLOS':\r\n        this.IFF.currentSurface.attributes.Glossiness = {\r\n          value: this.IFF.reader.getFloat32()\r\n        };\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'TRAN':\r\n        this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'BUMP':\r\n        this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'SIDE':\r\n        this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();\r\n        break;\r\n\r\n      case 'RIMG':\r\n        this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();\r\n        break;\r\n\r\n      case 'RIND':\r\n        this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'TIMG':\r\n        this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();\r\n        break;\r\n\r\n      case 'IMAP':\r\n        this.IFF.currentSurface.attributes.imageMapIndex = this.IFF.reader.getUint32();\r\n        break;\r\n\r\n      case 'IUVI':\r\n        // uv channel name\r\n        this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length);\r\n        break;\r\n\r\n      case 'IUTL':\r\n        // widthWrappingMode: 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\r\n        this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();\r\n        break;\r\n\r\n      case 'IVTL':\r\n        // heightWrappingMode\r\n        this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();\r\n        break;\r\n\r\n      default:\r\n        this.IFF.parseUnknownCHUNK(blockID, length);\r\n    }\r\n\r\n    if (blockID != 'FORM') {\r\n      this.IFF.debugger.node = 1;\r\n      this.IFF.debugger.nodeID = blockID;\r\n      this.IFF.debugger.log();\r\n    }\r\n\r\n    if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {\r\n      this.IFF.currentForm = this.IFF.parentForm;\r\n    }\r\n  }\r\n};\r\n\r\nexport { LWO3Parser };\r\n", "function LWO2Parser(IFFParser) {\r\n  this.IFF = IFFParser;\r\n}\r\n\r\nLWO2Parser.prototype = {\r\n  constructor: LWO2Parser,\r\n  parseBlock: function () {\r\n    this.IFF.debugger.offset = this.IFF.reader.offset;\r\n    this.IFF.debugger.closeForms();\r\n    var blockID = this.IFF.reader.getIDTag();\r\n    var length = this.IFF.reader.getUint32(); // size of data in bytes\r\n\r\n    if (length > this.IFF.reader.dv.byteLength - this.IFF.reader.offset) {\r\n      this.IFF.reader.offset -= 4;\r\n      length = this.IFF.reader.getUint16();\r\n    }\r\n\r\n    this.IFF.debugger.dataOffset = this.IFF.reader.offset;\r\n    this.IFF.debugger.length = length; // Data types may be found in either LWO2 OR LWO3 spec\r\n\r\n    switch (blockID) {\r\n      case 'FORM':\r\n        // form blocks may consist of sub -chunks or sub-forms\r\n        this.IFF.parseForm(length);\r\n        break;\r\n      // SKIPPED CHUNKS\r\n      // if break; is called directly, the position in the lwoTree is not created\r\n      // any sub chunks and forms are added to the parent form instead\r\n      // MISC skipped\r\n\r\n      case 'ICON': // Thumbnail Icon Image\r\n\r\n      case 'VMPA': // Vertex Map Parameter\r\n\r\n      case 'BBOX': // bounding box\r\n      // case 'VMMD':\r\n      // case 'VTYP':\r\n      // normal maps can be specified, normally on models imported from other applications. Currently ignored\r\n\r\n      case 'NORM': // ENVL FORM skipped\r\n\r\n      case 'PRE ':\r\n      case 'POST':\r\n      case 'KEY ':\r\n      case 'SPAN': // CLIP FORM skipped\r\n\r\n      case 'TIME':\r\n      case 'CLRS':\r\n      case 'CLRA':\r\n      case 'FILT':\r\n      case 'DITH':\r\n      case 'CONT':\r\n      case 'BRIT':\r\n      case 'SATR':\r\n      case 'HUE ':\r\n      case 'GAMM':\r\n      case 'NEGA':\r\n      case 'IFLT':\r\n      case 'PFLT': // Image Map Layer skipped\r\n\r\n      case 'PROJ':\r\n      case 'AXIS':\r\n      case 'AAST':\r\n      case 'PIXB':\r\n      case 'AUVO':\r\n      case 'STCK': // Procedural Textures skipped\r\n\r\n      case 'PROC':\r\n      case 'VALU':\r\n      case 'FUNC': // Gradient Textures skipped\r\n\r\n      case 'PNAM':\r\n      case 'INAM':\r\n      case 'GRST':\r\n      case 'GREN':\r\n      case 'GRPT':\r\n      case 'FKEY':\r\n      case 'IKEY': // Texture Mapping Form skipped\r\n\r\n      case 'CSYS': // Surface CHUNKs skipped\r\n\r\n      case 'OPAQ': // top level 'opacity' checkbox\r\n\r\n      case 'CMAP': // clip map\r\n      // Surface node CHUNKS skipped\r\n      // These mainly specify the node editor setup in LW\r\n\r\n      case 'NLOC':\r\n      case 'NZOM':\r\n      case 'NVER':\r\n      case 'NSRV':\r\n      case 'NVSK': // unknown\r\n\r\n      case 'NCRD':\r\n      case 'WRPW': // image wrap w ( for cylindrical and spherical projections)\r\n\r\n      case 'WRPH': // image wrap h\r\n\r\n      case 'NMOD':\r\n      case 'NPRW':\r\n      case 'NPLA':\r\n      case 'NODS':\r\n      case 'VERS':\r\n      case 'ENUM':\r\n      case 'TAG ':\r\n      case 'OPAC': // Car Material CHUNKS\r\n\r\n      case 'CGMD':\r\n      case 'CGTY':\r\n      case 'CGST':\r\n      case 'CGEN':\r\n      case 'CGTS':\r\n      case 'CGTE':\r\n      case 'OSMP':\r\n      case 'OMDE':\r\n      case 'OUTR':\r\n      case 'FLAG':\r\n      case 'TRNL':\r\n      case 'GLOW':\r\n      case 'GVAL': // glow intensity\r\n\r\n      case 'SHRP':\r\n      case 'RFOP':\r\n      case 'RSAN':\r\n      case 'TROP':\r\n      case 'RBLR':\r\n      case 'TBLR':\r\n      case 'CLRH':\r\n      case 'CLRF':\r\n      case 'ADTR':\r\n      case 'LINE':\r\n      case 'ALPH':\r\n      case 'VCOL':\r\n      case 'ENAB':\r\n        this.IFF.debugger.skipped = true;\r\n        this.IFF.reader.skip(length);\r\n        break;\r\n\r\n      case 'SURF':\r\n        this.IFF.parseSurfaceLwo2(length);\r\n        break;\r\n\r\n      case 'CLIP':\r\n        this.IFF.parseClipLwo2(length);\r\n        break;\r\n      // Texture node chunks (not in spec)\r\n\r\n      case 'IPIX': // usePixelBlending\r\n\r\n      case 'IMIP': // useMipMaps\r\n\r\n      case 'IMOD': // imageBlendingMode\r\n\r\n      case 'AMOD': // unknown\r\n\r\n      case 'IINV': // imageInvertAlpha\r\n\r\n      case 'INCR': // imageInvertColor\r\n\r\n      case 'IAXS': // imageAxis ( for non-UV maps)\r\n\r\n      case 'IFOT': // imageFallofType\r\n\r\n      case 'ITIM': // timing for animated textures\r\n\r\n      case 'IWRL':\r\n      case 'IUTI':\r\n      case 'IINX':\r\n      case 'IINY':\r\n      case 'IINZ':\r\n      case 'IREF':\r\n        // possibly a VX for reused texture nodes\r\n        if (length === 4) this.IFF.currentNode[blockID] = this.IFF.reader.getInt32();else this.IFF.reader.skip(length);\r\n        break;\r\n\r\n      case 'OTAG':\r\n        this.IFF.parseObjectTag();\r\n        break;\r\n\r\n      case 'LAYR':\r\n        this.IFF.parseLayer(length);\r\n        break;\r\n\r\n      case 'PNTS':\r\n        this.IFF.parsePoints(length);\r\n        break;\r\n\r\n      case 'VMAP':\r\n        this.IFF.parseVertexMapping(length);\r\n        break;\r\n\r\n      case 'AUVU':\r\n      case 'AUVN':\r\n        this.IFF.reader.skip(length - 1);\r\n        this.IFF.reader.getVariableLengthIndex(); // VX\r\n\r\n        break;\r\n\r\n      case 'POLS':\r\n        this.IFF.parsePolygonList(length);\r\n        break;\r\n\r\n      case 'TAGS':\r\n        this.IFF.parseTagStrings(length);\r\n        break;\r\n\r\n      case 'PTAG':\r\n        this.IFF.parsePolygonTagMapping(length);\r\n        break;\r\n\r\n      case 'VMAD':\r\n        this.IFF.parseVertexMapping(length, true);\r\n        break;\r\n      // Misc CHUNKS\r\n\r\n      case 'DESC':\r\n        // Description Line\r\n        this.IFF.currentForm.description = this.IFF.reader.getString();\r\n        break;\r\n\r\n      case 'TEXT':\r\n      case 'CMNT':\r\n      case 'NCOM':\r\n        this.IFF.currentForm.comment = this.IFF.reader.getString();\r\n        break;\r\n      // Envelope Form\r\n\r\n      case 'NAME':\r\n        this.IFF.currentForm.channelName = this.IFF.reader.getString();\r\n        break;\r\n      // Image Map Layer\r\n\r\n      case 'WRAP':\r\n        this.IFF.currentForm.wrap = {\r\n          w: this.IFF.reader.getUint16(),\r\n          h: this.IFF.reader.getUint16()\r\n        };\r\n        break;\r\n\r\n      case 'IMAG':\r\n        var index = this.IFF.reader.getVariableLengthIndex();\r\n        this.IFF.currentForm.imageIndex = index;\r\n        break;\r\n      // Texture Mapping Form\r\n\r\n      case 'OREF':\r\n        this.IFF.currentForm.referenceObject = this.IFF.reader.getString();\r\n        break;\r\n\r\n      case 'ROID':\r\n        this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();\r\n        break;\r\n      // Surface Blocks\r\n\r\n      case 'SSHN':\r\n        this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();\r\n        break;\r\n\r\n      case 'AOVN':\r\n        this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();\r\n        break;\r\n      // Nodal Blocks\r\n\r\n      case 'NSTA':\r\n        this.IFF.currentForm.disabled = this.IFF.reader.getUint16();\r\n        break;\r\n\r\n      case 'NRNM':\r\n        this.IFF.currentForm.realName = this.IFF.reader.getString();\r\n        break;\r\n\r\n      case 'NNME':\r\n        this.IFF.currentForm.refName = this.IFF.reader.getString();\r\n        this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm;\r\n        break;\r\n      // Nodal Blocks : connections\r\n\r\n      case 'INME':\r\n        if (!this.IFF.currentForm.nodeName) this.IFF.currentForm.nodeName = [];\r\n        this.IFF.currentForm.nodeName.push(this.IFF.reader.getString());\r\n        break;\r\n\r\n      case 'IINN':\r\n        if (!this.IFF.currentForm.inputNodeName) this.IFF.currentForm.inputNodeName = [];\r\n        this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString());\r\n        break;\r\n\r\n      case 'IINM':\r\n        if (!this.IFF.currentForm.inputName) this.IFF.currentForm.inputName = [];\r\n        this.IFF.currentForm.inputName.push(this.IFF.reader.getString());\r\n        break;\r\n\r\n      case 'IONM':\r\n        if (!this.IFF.currentForm.inputOutputName) this.IFF.currentForm.inputOutputName = [];\r\n        this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString());\r\n        break;\r\n\r\n      case 'FNAM':\r\n        this.IFF.currentForm.fileName = this.IFF.reader.getString();\r\n        break;\r\n\r\n      case 'CHAN':\r\n        // NOTE: ENVL Forms may also have CHAN chunk, however ENVL is currently ignored\r\n        if (length === 4) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();else this.IFF.reader.skip(length);\r\n        break;\r\n      // LWO2 Spec chunks: these are needed since the SURF FORMs are often in LWO2 format\r\n\r\n      case 'SMAN':\r\n        var maxSmoothingAngle = this.IFF.reader.getFloat32();\r\n        this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true;\r\n        break;\r\n      // LWO2: Basic Surface Parameters\r\n\r\n      case 'COLR':\r\n        this.IFF.currentSurface.attributes.Color = {\r\n          value: this.IFF.reader.getFloat32Array(3)\r\n        };\r\n        this.IFF.reader.skip(2); // VX: envelope\r\n\r\n        break;\r\n\r\n      case 'LUMI':\r\n        this.IFF.currentSurface.attributes.Luminosity = {\r\n          value: this.IFF.reader.getFloat32()\r\n        };\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'SPEC':\r\n        this.IFF.currentSurface.attributes.Specular = {\r\n          value: this.IFF.reader.getFloat32()\r\n        };\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'DIFF':\r\n        this.IFF.currentSurface.attributes.Diffuse = {\r\n          value: this.IFF.reader.getFloat32()\r\n        };\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'REFL':\r\n        this.IFF.currentSurface.attributes.Reflection = {\r\n          value: this.IFF.reader.getFloat32()\r\n        };\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'GLOS':\r\n        this.IFF.currentSurface.attributes.Glossiness = {\r\n          value: this.IFF.reader.getFloat32()\r\n        };\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'TRAN':\r\n        this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'BUMP':\r\n        this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'SIDE':\r\n        this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();\r\n        break;\r\n\r\n      case 'RIMG':\r\n        this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();\r\n        break;\r\n\r\n      case 'RIND':\r\n        this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'TIMG':\r\n        this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();\r\n        break;\r\n\r\n      case 'IMAP':\r\n        this.IFF.reader.skip(2);\r\n        break;\r\n\r\n      case 'TMAP':\r\n        this.IFF.debugger.skipped = true;\r\n        this.IFF.reader.skip(length); // needs implementing\r\n\r\n        break;\r\n\r\n      case 'IUVI':\r\n        // uv channel name\r\n        this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length);\r\n        break;\r\n\r\n      case 'IUTL':\r\n        // widthWrappingMode: 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\r\n        this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();\r\n        break;\r\n\r\n      case 'IVTL':\r\n        // heightWrappingMode\r\n        this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();\r\n        break;\r\n      // LWO2 USE\r\n\r\n      case 'BLOK':\r\n        // skip\r\n        break;\r\n\r\n      default:\r\n        this.IFF.parseUnknownCHUNK(blockID, length);\r\n    }\r\n\r\n    if (blockID != 'FORM') {\r\n      this.IFF.debugger.node = 1;\r\n      this.IFF.debugger.nodeID = blockID;\r\n      this.IFF.debugger.log();\r\n    }\r\n\r\n    if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {\r\n      this.IFF.currentForm = this.IFF.parentForm;\r\n    }\r\n  }\r\n};\r\n\r\nexport { LWO2Parser };\r\n", "import { LoaderUtils } from 'three';\r\nimport { LWO2Parser } from './LWO2Parser.js';\r\nimport { LWO3Parser } from './LWO3Parser.js';\r\n\r\n/**\r\n * === IFFParser ===\r\n * - Parses data from the IFF buffer.\r\n * - LWO3 files are in IFF format and can contain the following data types, referred to by shorthand codes\r\n *\r\n * ATOMIC DATA TYPES\r\n *  ID Tag - 4x 7 bit uppercase ASCII chars: ID4\r\n *  signed integer, 1, 2, or 4 byte length: I1, I2, I4\r\n *  unsigned integer, 1, 2, or 4 byte length: U1, U2, U4\r\n *  float, 4 byte length: F4\r\n *  string, series of ASCII chars followed by null byte (If the length of the string including the null terminating byte is odd, an extra null is added so that the data that follows will begin on an even byte boundary): S0\r\n *\r\n * COMPOUND DATA TYPES\r\n *  Variable-length Index (index into an array or collection): U2 or U4 : VX\r\n *  Color (RGB): F4 + F4 + F4: COL12\r\n *  Coordinate (x, y, z): F4 + F4 + F4: VEC12\r\n *  Percentage F4 data type from 0->1 with 1 = 100%: FP4\r\n *  Angle in radian F4: ANG4\r\n *  Filename (string) S0: FNAM0\r\n *  XValue F4 + index (VX) + optional envelope( ENVL ): XVAL\r\n *  XValue vector VEC12 + index (VX) + optional envelope( ENVL ): XVAL3\r\n *\r\n *  The IFF file is arranged in chunks:\r\n *  CHUNK = ID4 + length (U4) + length X bytes of data + optional 0 pad byte\r\n *  optional 0 pad byte is there to ensure chunk ends on even boundary, not counted in size\r\n *\r\n * COMPOUND DATA TYPES\r\n * - Chunks are combined in Forms (collections of chunks)\r\n * - FORM = string 'FORM' (ID4) + length (U4) + type (ID4) + optional ( CHUNK | FORM )\r\n * - CHUNKS and FORMS are collectively referred to as blocks\r\n * - The entire file is contained in one top level FORM\r\n *\r\n **/\r\n\r\nfunction IFFParser() {\r\n  this.debugger = new Debugger(); // this.debugger.enable(); // un-comment to log IFF hierarchy.\r\n}\r\n\r\nIFFParser.prototype = {\r\n  constructor: IFFParser,\r\n  parse: function (buffer) {\r\n    this.reader = new DataViewReader(buffer);\r\n    this.tree = {\r\n      materials: {},\r\n      layers: [],\r\n      tags: [],\r\n      textures: []\r\n    }; // start out at the top level to add any data before first layer is encountered\r\n\r\n    this.currentLayer = this.tree;\r\n    this.currentForm = this.tree;\r\n    this.parseTopForm();\r\n    if (this.tree.format === undefined) return;\r\n\r\n    if (this.tree.format === 'LWO2') {\r\n      this.parser = new LWO2Parser(this);\r\n\r\n      while (!this.reader.endOfFile()) this.parser.parseBlock();\r\n    } else if (this.tree.format === 'LWO3') {\r\n      this.parser = new LWO3Parser(this);\r\n\r\n      while (!this.reader.endOfFile()) this.parser.parseBlock();\r\n    }\r\n\r\n    this.debugger.offset = this.reader.offset;\r\n    this.debugger.closeForms();\r\n    return this.tree;\r\n  },\r\n\r\n  parseTopForm() {\r\n    this.debugger.offset = this.reader.offset;\r\n    var topForm = this.reader.getIDTag();\r\n\r\n    if (topForm !== 'FORM') {\r\n      console.warn('LWOLoader: Top-level FORM missing.');\r\n      return;\r\n    }\r\n\r\n    var length = this.reader.getUint32();\r\n    this.debugger.dataOffset = this.reader.offset;\r\n    this.debugger.length = length;\r\n    var type = this.reader.getIDTag();\r\n\r\n    if (type === 'LWO2') {\r\n      this.tree.format = type;\r\n    } else if (type === 'LWO3') {\r\n      this.tree.format = type;\r\n    }\r\n\r\n    this.debugger.node = 0;\r\n    this.debugger.nodeID = type;\r\n    this.debugger.log();\r\n    return;\r\n  },\r\n\r\n  ///\r\n  // FORM PARSING METHODS\r\n  ///\r\n  // Forms are organisational and can contain any number of sub chunks and sub forms\r\n  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\r\n  parseForm(length) {\r\n    var type = this.reader.getIDTag();\r\n\r\n    switch (type) {\r\n      // SKIPPED FORMS\r\n      // if skipForm( length ) is called, the entire form and any sub forms and chunks are skipped\r\n      case 'ISEQ': // Image sequence\r\n\r\n      case 'ANIM': // plug in animation\r\n\r\n      case 'STCC': // Color-cycling Still\r\n\r\n      case 'VPVL':\r\n      case 'VPRM':\r\n      case 'NROT':\r\n      case 'WRPW': // image wrap w ( for cylindrical and spherical projections)\r\n\r\n      case 'WRPH': // image wrap h\r\n\r\n      case 'FUNC':\r\n      case 'FALL':\r\n      case 'OPAC':\r\n      case 'GRAD': // gradient texture\r\n\r\n      case 'ENVS':\r\n      case 'VMOP':\r\n      case 'VMBG': // Car Material FORMS\r\n\r\n      case 'OMAX':\r\n      case 'STEX':\r\n      case 'CKBG':\r\n      case 'CKEY':\r\n      case 'VMLA':\r\n      case 'VMLB':\r\n        this.debugger.skipped = true;\r\n        this.skipForm(length); // not currently supported\r\n\r\n        break;\r\n      // if break; is called directly, the position in the lwoTree is not created\r\n      // any sub chunks and forms are added to the parent form instead\r\n\r\n      case 'META':\r\n      case 'NNDS':\r\n      case 'NODS':\r\n      case 'NDTA':\r\n      case 'ADAT':\r\n      case 'AOVS':\r\n      case 'BLOK': // used by texture nodes\r\n\r\n      case 'IBGC': // imageBackgroundColor\r\n\r\n      case 'IOPC': // imageOpacity\r\n\r\n      case 'IIMG': // hold reference to image path\r\n\r\n      case 'TXTR':\r\n        // this.setupForm( type, length );\r\n        this.debugger.length = 4;\r\n        this.debugger.skipped = true;\r\n        break;\r\n\r\n      case 'IFAL': // imageFallof\r\n\r\n      case 'ISCL': // imageScale\r\n\r\n      case 'IPOS': // imagePosition\r\n\r\n      case 'IROT': // imageRotation\r\n\r\n      case 'IBMP':\r\n      case 'IUTD':\r\n      case 'IVTD':\r\n        this.parseTextureNodeAttribute(type);\r\n        break;\r\n\r\n      case 'ENVL':\r\n        this.parseEnvelope(length);\r\n        break;\r\n      // CLIP FORM AND SUB FORMS\r\n\r\n      case 'CLIP':\r\n        if (this.tree.format === 'LWO2') {\r\n          this.parseForm(length);\r\n        } else {\r\n          this.parseClip(length);\r\n        }\r\n\r\n        break;\r\n\r\n      case 'STIL':\r\n        this.parseImage();\r\n        break;\r\n\r\n      case 'XREF':\r\n        // clone of another STIL\r\n        this.reader.skip(8); // unknown\r\n\r\n        this.currentForm.referenceTexture = {\r\n          index: this.reader.getUint32(),\r\n          refName: this.reader.getString() // internal unique ref\r\n\r\n        };\r\n        break;\r\n      // Not in spec, used by texture nodes\r\n\r\n      case 'IMST':\r\n        this.parseImageStateForm(length);\r\n        break;\r\n      // SURF FORM AND SUB FORMS\r\n\r\n      case 'SURF':\r\n        this.parseSurfaceForm(length);\r\n        break;\r\n\r\n      case 'VALU':\r\n        // Not in spec\r\n        this.parseValueForm(length);\r\n        break;\r\n\r\n      case 'NTAG':\r\n        this.parseSubNode(length);\r\n        break;\r\n\r\n      case 'ATTR': // BSDF Node Attributes\r\n\r\n      case 'SATR':\r\n        // Standard Node Attributes\r\n        this.setupForm('attributes', length);\r\n        break;\r\n\r\n      case 'NCON':\r\n        this.parseConnections(length);\r\n        break;\r\n\r\n      case 'SSHA':\r\n        this.parentForm = this.currentForm;\r\n        this.currentForm = this.currentSurface;\r\n        this.setupForm('surfaceShader', length);\r\n        break;\r\n\r\n      case 'SSHD':\r\n        this.setupForm('surfaceShaderData', length);\r\n        break;\r\n\r\n      case 'ENTR':\r\n        // Not in spec\r\n        this.parseEntryForm(length);\r\n        break;\r\n      // Image Map Layer\r\n\r\n      case 'IMAP':\r\n        this.parseImageMap(length);\r\n        break;\r\n\r\n      case 'TAMP':\r\n        this.parseXVAL('amplitude', length);\r\n        break;\r\n      //Texture Mapping Form\r\n\r\n      case 'TMAP':\r\n        this.setupForm('textureMap', length);\r\n        break;\r\n\r\n      case 'CNTR':\r\n        this.parseXVAL3('center', length);\r\n        break;\r\n\r\n      case 'SIZE':\r\n        this.parseXVAL3('scale', length);\r\n        break;\r\n\r\n      case 'ROTA':\r\n        this.parseXVAL3('rotation', length);\r\n        break;\r\n\r\n      default:\r\n        this.parseUnknownForm(type, length);\r\n    }\r\n\r\n    this.debugger.node = 0;\r\n    this.debugger.nodeID = type;\r\n    this.debugger.log();\r\n  },\r\n\r\n  setupForm(type, length) {\r\n    if (!this.currentForm) this.currentForm = this.currentNode;\r\n    this.currentFormEnd = this.reader.offset + length;\r\n    this.parentForm = this.currentForm;\r\n\r\n    if (!this.currentForm[type]) {\r\n      this.currentForm[type] = {};\r\n      this.currentForm = this.currentForm[type];\r\n    } else {\r\n      // should never see this unless there's a bug in the reader\r\n      console.warn('LWOLoader: form already exists on parent: ', type, this.currentForm);\r\n      this.currentForm = this.currentForm[type];\r\n    }\r\n  },\r\n\r\n  skipForm(length) {\r\n    this.reader.skip(length - 4);\r\n  },\r\n\r\n  parseUnknownForm(type, length) {\r\n    console.warn('LWOLoader: unknown FORM encountered: ' + type, length);\r\n    printBuffer(this.reader.dv.buffer, this.reader.offset, length - 4);\r\n    this.reader.skip(length - 4);\r\n  },\r\n\r\n  parseSurfaceForm(length) {\r\n    this.reader.skip(8); // unknown Uint32 x2\r\n\r\n    var name = this.reader.getString();\r\n    var surface = {\r\n      attributes: {},\r\n      // LWO2 style non-node attributes will go here\r\n      connections: {},\r\n      name: name,\r\n      inputName: name,\r\n      nodes: {},\r\n      source: this.reader.getString()\r\n    };\r\n    this.tree.materials[name] = surface;\r\n    this.currentSurface = surface;\r\n    this.parentForm = this.tree.materials;\r\n    this.currentForm = surface;\r\n    this.currentFormEnd = this.reader.offset + length;\r\n  },\r\n\r\n  parseSurfaceLwo2(length) {\r\n    var name = this.reader.getString();\r\n    var surface = {\r\n      attributes: {},\r\n      // LWO2 style non-node attributes will go here\r\n      connections: {},\r\n      name: name,\r\n      nodes: {},\r\n      source: this.reader.getString()\r\n    };\r\n    this.tree.materials[name] = surface;\r\n    this.currentSurface = surface;\r\n    this.parentForm = this.tree.materials;\r\n    this.currentForm = surface;\r\n    this.currentFormEnd = this.reader.offset + length;\r\n  },\r\n\r\n  parseSubNode(length) {\r\n    // parse the NRNM CHUNK of the subnode FORM to get\r\n    // a meaningful name for the subNode\r\n    // some subnodes can be renamed, but Input and Surface cannot\r\n    this.reader.skip(8); // NRNM + length\r\n\r\n    var name = this.reader.getString();\r\n    var node = {\r\n      name: name\r\n    };\r\n    this.currentForm = node;\r\n    this.currentNode = node;\r\n    this.currentFormEnd = this.reader.offset + length;\r\n  },\r\n\r\n  // collect attributes from all nodes at the top level of a surface\r\n  parseConnections(length) {\r\n    this.currentFormEnd = this.reader.offset + length;\r\n    this.parentForm = this.currentForm;\r\n    this.currentForm = this.currentSurface.connections;\r\n  },\r\n\r\n  // surface node attribute data, e.g. specular, roughness etc\r\n  parseEntryForm(length) {\r\n    this.reader.skip(8); // NAME + length\r\n\r\n    var name = this.reader.getString();\r\n    this.currentForm = this.currentNode.attributes;\r\n    this.setupForm(name, length);\r\n  },\r\n\r\n  // parse values from material - doesn't match up to other LWO3 data types\r\n  // sub form of entry form\r\n  parseValueForm() {\r\n    this.reader.skip(8); // unknown + length\r\n\r\n    var valueType = this.reader.getString();\r\n\r\n    if (valueType === 'double') {\r\n      this.currentForm.value = this.reader.getUint64();\r\n    } else if (valueType === 'int') {\r\n      this.currentForm.value = this.reader.getUint32();\r\n    } else if (valueType === 'vparam') {\r\n      this.reader.skip(24);\r\n      this.currentForm.value = this.reader.getFloat64();\r\n    } else if (valueType === 'vparam3') {\r\n      this.reader.skip(24);\r\n      this.currentForm.value = this.reader.getFloat64Array(3);\r\n    }\r\n  },\r\n\r\n  // holds various data about texture node image state\r\n  // Data other thanmipMapLevel unknown\r\n  parseImageStateForm() {\r\n    this.reader.skip(8); // unknown\r\n\r\n    this.currentForm.mipMapLevel = this.reader.getFloat32();\r\n  },\r\n\r\n  // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\r\n  parseImageMap(length) {\r\n    this.currentFormEnd = this.reader.offset + length;\r\n    this.parentForm = this.currentForm;\r\n    if (!this.currentForm.maps) this.currentForm.maps = [];\r\n    var map = {};\r\n    this.currentForm.maps.push(map);\r\n    this.currentForm = map;\r\n    this.reader.skip(10); // unknown, could be an issue if it contains a VX\r\n  },\r\n\r\n  parseTextureNodeAttribute(type) {\r\n    this.reader.skip(28); // FORM + length + VPRM + unknown + Uint32 x2 + float32\r\n\r\n    this.reader.skip(20); // FORM + length + VPVL + float32 + Uint32\r\n\r\n    switch (type) {\r\n      case 'ISCL':\r\n        this.currentNode.scale = this.reader.getFloat32Array(3);\r\n        break;\r\n\r\n      case 'IPOS':\r\n        this.currentNode.position = this.reader.getFloat32Array(3);\r\n        break;\r\n\r\n      case 'IROT':\r\n        this.currentNode.rotation = this.reader.getFloat32Array(3);\r\n        break;\r\n\r\n      case 'IFAL':\r\n        this.currentNode.falloff = this.reader.getFloat32Array(3);\r\n        break;\r\n\r\n      case 'IBMP':\r\n        this.currentNode.amplitude = this.reader.getFloat32();\r\n        break;\r\n\r\n      case 'IUTD':\r\n        this.currentNode.uTiles = this.reader.getFloat32();\r\n        break;\r\n\r\n      case 'IVTD':\r\n        this.currentNode.vTiles = this.reader.getFloat32();\r\n        break;\r\n    }\r\n\r\n    this.reader.skip(2); // unknown\r\n  },\r\n\r\n  // ENVL forms are currently ignored\r\n  parseEnvelope(length) {\r\n    this.reader.skip(length - 4); // skipping  entirely for now\r\n  },\r\n\r\n  ///\r\n  // CHUNK PARSING METHODS\r\n  ///\r\n  // clips can either be defined inside a surface node, or at the top\r\n  // level and they have a different format in each case\r\n  parseClip(length) {\r\n    var tag = this.reader.getIDTag(); // inside surface node\r\n\r\n    if (tag === 'FORM') {\r\n      this.reader.skip(16);\r\n      this.currentNode.fileName = this.reader.getString();\r\n      return;\r\n    } // otherwise top level\r\n\r\n\r\n    this.reader.setOffset(this.reader.offset - 4);\r\n    this.currentFormEnd = this.reader.offset + length;\r\n    this.parentForm = this.currentForm;\r\n    this.reader.skip(8); // unknown\r\n\r\n    var texture = {\r\n      index: this.reader.getUint32()\r\n    };\r\n    this.tree.textures.push(texture);\r\n    this.currentForm = texture;\r\n  },\r\n\r\n  parseClipLwo2(length) {\r\n    var texture = {\r\n      index: this.reader.getUint32(),\r\n      fileName: ''\r\n    }; // seach STIL block\r\n\r\n    while (true) {\r\n      var tag = this.reader.getIDTag();\r\n      var n_length = this.reader.getUint16();\r\n\r\n      if (tag === 'STIL') {\r\n        texture.fileName = this.reader.getString();\r\n        break;\r\n      }\r\n\r\n      if (n_length >= length) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.tree.textures.push(texture);\r\n    this.currentForm = texture;\r\n  },\r\n\r\n  parseImage() {\r\n    this.reader.skip(8); // unknown\r\n\r\n    this.currentForm.fileName = this.reader.getString();\r\n  },\r\n\r\n  parseXVAL(type, length) {\r\n    var endOffset = this.reader.offset + length - 4;\r\n    this.reader.skip(8);\r\n    this.currentForm[type] = this.reader.getFloat32();\r\n    this.reader.setOffset(endOffset); // set end offset directly to skip optional envelope\r\n  },\r\n\r\n  parseXVAL3(type, length) {\r\n    var endOffset = this.reader.offset + length - 4;\r\n    this.reader.skip(8);\r\n    this.currentForm[type] = {\r\n      x: this.reader.getFloat32(),\r\n      y: this.reader.getFloat32(),\r\n      z: this.reader.getFloat32()\r\n    };\r\n    this.reader.setOffset(endOffset);\r\n  },\r\n\r\n  // Tags associated with an object\r\n  // OTAG { type[ID4], tag-string[S0] }\r\n  parseObjectTag() {\r\n    if (!this.tree.objectTags) this.tree.objectTags = {};\r\n    this.tree.objectTags[this.reader.getIDTag()] = {\r\n      tagString: this.reader.getString()\r\n    };\r\n  },\r\n\r\n  // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\r\n  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\r\n  parseLayer(length) {\r\n    var layer = {\r\n      number: this.reader.getUint16(),\r\n      flags: this.reader.getUint16(),\r\n      // If the least significant bit of flags is set, the layer is hidden.\r\n      pivot: this.reader.getFloat32Array(3),\r\n      // Note: this seems to be superflous, as the geometry is translated when pivot is present\r\n      name: this.reader.getString()\r\n    };\r\n    this.tree.layers.push(layer);\r\n    this.currentLayer = layer;\r\n    var parsedLength = 16 + stringOffset(this.currentLayer.name); // index ( 2 ) + flags( 2 ) + pivot( 12 ) + stringlength\r\n    // if we have not reached then end of the layer block, there must be a parent defined\r\n\r\n    this.currentLayer.parent = parsedLength < length ? this.reader.getUint16() : -1; // omitted or -1 for no parent\r\n  },\r\n\r\n  // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\r\n  // Converting from left to right handed coordinate system:\r\n  // x -> -x and switch material FrontSide -> BackSide\r\n  parsePoints(length) {\r\n    this.currentPoints = [];\r\n\r\n    for (let i = 0; i < length / 4; i += 3) {\r\n      // z -> -z to match three.js right handed coords\r\n      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\r\n    }\r\n  },\r\n\r\n  // parse VMAP or VMAD\r\n  // Associates a set of floating-point vectors with a set of points.\r\n  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\r\n  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\r\n  // Similar to VMAP UVs, but associates with polygon vertices rather than points\r\n  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\r\n  // if they exist. The vector values in the VMAD will then replace those in the\r\n  // corresponding VMAP, but only for calculations involving the specified polygons.\r\n  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\r\n  parseVertexMapping(length, discontinuous) {\r\n    var finalOffset = this.reader.offset + length;\r\n    var channelName = this.reader.getString();\r\n\r\n    if (this.reader.offset === finalOffset) {\r\n      // then we are in a texture node and the VMAP chunk is just a reference to a UV channel name\r\n      this.currentForm.UVChannel = channelName;\r\n      return;\r\n    } // otherwise reset to initial length and parse normal VMAP CHUNK\r\n\r\n\r\n    this.reader.setOffset(this.reader.offset - stringOffset(channelName));\r\n    var type = this.reader.getIDTag();\r\n    this.reader.getUint16(); // dimension\r\n\r\n    var name = this.reader.getString();\r\n    var remainingLength = length - 6 - stringOffset(name);\r\n\r\n    switch (type) {\r\n      case 'TXUV':\r\n        this.parseUVMapping(name, finalOffset, discontinuous);\r\n        break;\r\n\r\n      case 'MORF':\r\n      case 'SPOT':\r\n        this.parseMorphTargets(name, finalOffset, type); // can't be discontinuous\r\n\r\n        break;\r\n      // unsupported VMAPs\r\n\r\n      case 'APSL':\r\n      case 'NORM':\r\n      case 'WGHT':\r\n      case 'MNVW':\r\n      case 'PICK':\r\n      case 'RGB ':\r\n      case 'RGBA':\r\n        this.reader.skip(remainingLength);\r\n        break;\r\n\r\n      default:\r\n        console.warn('LWOLoader: unknown vertex map type: ' + type);\r\n        this.reader.skip(remainingLength);\r\n    }\r\n  },\r\n\r\n  parseUVMapping(name, finalOffset, discontinuous) {\r\n    var uvIndices = [];\r\n    var polyIndices = [];\r\n    var uvs = [];\r\n\r\n    while (this.reader.offset < finalOffset) {\r\n      uvIndices.push(this.reader.getVariableLengthIndex());\r\n      if (discontinuous) polyIndices.push(this.reader.getVariableLengthIndex());\r\n      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());\r\n    }\r\n\r\n    if (discontinuous) {\r\n      if (!this.currentLayer.discontinuousUVs) this.currentLayer.discontinuousUVs = {};\r\n      this.currentLayer.discontinuousUVs[name] = {\r\n        uvIndices: uvIndices,\r\n        polyIndices: polyIndices,\r\n        uvs: uvs\r\n      };\r\n    } else {\r\n      if (!this.currentLayer.uvs) this.currentLayer.uvs = {};\r\n      this.currentLayer.uvs[name] = {\r\n        uvIndices: uvIndices,\r\n        uvs: uvs\r\n      };\r\n    }\r\n  },\r\n\r\n  parseMorphTargets(name, finalOffset, type) {\r\n    var indices = [];\r\n    var points = [];\r\n    type = type === 'MORF' ? 'relative' : 'absolute';\r\n\r\n    while (this.reader.offset < finalOffset) {\r\n      indices.push(this.reader.getVariableLengthIndex()); // z -> -z to match three.js right handed coords\r\n\r\n      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());\r\n    }\r\n\r\n    if (!this.currentLayer.morphTargets) this.currentLayer.morphTargets = {};\r\n    this.currentLayer.morphTargets[name] = {\r\n      indices: indices,\r\n      points: points,\r\n      type: type\r\n    };\r\n  },\r\n\r\n  // A list of polygons for the current layer.\r\n  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\r\n  parsePolygonList(length) {\r\n    var finalOffset = this.reader.offset + length;\r\n    var type = this.reader.getIDTag();\r\n    var indices = []; // hold a list of polygon sizes, to be split up later\r\n\r\n    var polygonDimensions = [];\r\n\r\n    while (this.reader.offset < finalOffset) {\r\n      var numverts = this.reader.getUint16(); //var flags = numverts & 64512; // 6 high order bits are flags - ignoring for now\r\n\r\n      numverts = numverts & 1023; // remaining ten low order bits are vertex num\r\n\r\n      polygonDimensions.push(numverts);\r\n\r\n      for (let j = 0; j < numverts; j++) indices.push(this.reader.getVariableLengthIndex());\r\n    }\r\n\r\n    var geometryData = {\r\n      type: type,\r\n      vertexIndices: indices,\r\n      polygonDimensions: polygonDimensions,\r\n      points: this.currentPoints\r\n    }; // Note: assuming that all polys will be lines or points if the first is\r\n\r\n    if (polygonDimensions[0] === 1) geometryData.type = 'points';else if (polygonDimensions[0] === 2) geometryData.type = 'lines';\r\n    this.currentLayer.geometry = geometryData;\r\n  },\r\n\r\n  // Lists the tag strings that can be associated with polygons by the PTAG chunk.\r\n  // TAGS { tag-string[S0] * }\r\n  parseTagStrings(length) {\r\n    this.tree.tags = this.reader.getStringArray(length);\r\n  },\r\n\r\n  // Associates tags of a given type with polygons in the most recent POLS chunk.\r\n  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\r\n  parsePolygonTagMapping(length) {\r\n    var finalOffset = this.reader.offset + length;\r\n    var type = this.reader.getIDTag();\r\n\r\n    if (type === 'SURF') {\r\n      this.parseMaterialIndices(finalOffset);\r\n    } else {\r\n      //PART, SMGP, COLR not supported\r\n      this.reader.skip(length - 4);\r\n    }\r\n  },\r\n\r\n  parseMaterialIndices(finalOffset) {\r\n    // array holds polygon index followed by material index\r\n    this.currentLayer.geometry.materialIndices = [];\r\n\r\n    while (this.reader.offset < finalOffset) {\r\n      var polygonIndex = this.reader.getVariableLengthIndex();\r\n      var materialIndex = this.reader.getUint16();\r\n      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);\r\n    }\r\n  },\r\n\r\n  parseUnknownCHUNK(blockID, length) {\r\n    console.warn('LWOLoader: unknown chunk type: ' + blockID + ' length: ' + length); // print the chunk plus some bytes padding either side\r\n    // printBuffer( this.reader.dv.buffer, this.reader.offset - 20, length + 40 );\r\n\r\n    var data = this.reader.getString(length);\r\n    this.currentForm[blockID] = data;\r\n  }\r\n\r\n};\r\n\r\nfunction DataViewReader(buffer) {\r\n  this.dv = new DataView(buffer);\r\n  this.offset = 0;\r\n}\r\n\r\nDataViewReader.prototype = {\r\n  constructor: DataViewReader,\r\n  size: function () {\r\n    return this.dv.buffer.byteLength;\r\n  },\r\n\r\n  setOffset(offset) {\r\n    if (offset > 0 && offset < this.dv.buffer.byteLength) {\r\n      this.offset = offset;\r\n    } else {\r\n      console.error('LWOLoader: invalid buffer offset');\r\n    }\r\n  },\r\n\r\n  endOfFile: function () {\r\n    if (this.offset >= this.size()) return true;\r\n    return false;\r\n  },\r\n  skip: function (length) {\r\n    this.offset += length;\r\n  },\r\n  getUint8: function () {\r\n    var value = this.dv.getUint8(this.offset);\r\n    this.offset += 1;\r\n    return value;\r\n  },\r\n  getUint16: function () {\r\n    var value = this.dv.getUint16(this.offset);\r\n    this.offset += 2;\r\n    return value;\r\n  },\r\n  getInt32: function () {\r\n    var value = this.dv.getInt32(this.offset, false);\r\n    this.offset += 4;\r\n    return value;\r\n  },\r\n  getUint32: function () {\r\n    var value = this.dv.getUint32(this.offset, false);\r\n    this.offset += 4;\r\n    return value;\r\n  },\r\n  getUint64: function () {\r\n    var low, high;\r\n    high = this.getUint32();\r\n    low = this.getUint32();\r\n    return high * 0x100000000 + low;\r\n  },\r\n  getFloat32: function () {\r\n    var value = this.dv.getFloat32(this.offset, false);\r\n    this.offset += 4;\r\n    return value;\r\n  },\r\n  getFloat32Array: function (size) {\r\n    var a = [];\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      a.push(this.getFloat32());\r\n    }\r\n\r\n    return a;\r\n  },\r\n  getFloat64: function () {\r\n    var value = this.dv.getFloat64(this.offset, this.littleEndian);\r\n    this.offset += 8;\r\n    return value;\r\n  },\r\n  getFloat64Array: function (size) {\r\n    var a = [];\r\n\r\n    for (let i = 0; i < size; i++) {\r\n      a.push(this.getFloat64());\r\n    }\r\n\r\n    return a;\r\n  },\r\n\r\n  // get variable-length index data type\r\n  // VX ::= index[U2] | (index + 0xFF000000)[U4]\r\n  // If the index value is less than 65,280 (0xFF00),then VX === U2\r\n  // otherwise VX === U4 with bits 24-31 set\r\n  // When reading an index, if the first byte encountered is 255 (0xFF), then\r\n  // the four-byte form is being used and the first byte should be discarded or masked out.\r\n  getVariableLengthIndex() {\r\n    var firstByte = this.getUint8();\r\n\r\n    if (firstByte === 255) {\r\n      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\r\n    }\r\n\r\n    return firstByte * 256 + this.getUint8();\r\n  },\r\n\r\n  // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\r\n  getIDTag() {\r\n    return this.getString(4);\r\n  },\r\n\r\n  getString: function (size) {\r\n    if (size === 0) return; // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\r\n\r\n    var a = [];\r\n\r\n    if (size) {\r\n      for (let i = 0; i < size; i++) {\r\n        a[i] = this.getUint8();\r\n      }\r\n    } else {\r\n      var currentChar;\r\n      var len = 0;\r\n\r\n      while (currentChar !== 0) {\r\n        currentChar = this.getUint8();\r\n        if (currentChar !== 0) a.push(currentChar);\r\n        len++;\r\n      }\r\n\r\n      if (!isEven(len + 1)) this.getUint8(); // if string with terminating nullbyte is uneven, extra nullbyte is added\r\n    }\r\n\r\n    return LoaderUtils.decodeText(new Uint8Array(a));\r\n  },\r\n  getStringArray: function (size) {\r\n    var a = this.getString(size);\r\n    a = a.split('\\0');\r\n    return a.filter(Boolean); // return array with any empty strings removed\r\n  }\r\n}; // ************** DEBUGGER  **************\r\n\r\nfunction Debugger() {\r\n  this.active = false;\r\n  this.depth = 0;\r\n  this.formList = [];\r\n}\r\n\r\nDebugger.prototype = {\r\n  constructor: Debugger,\r\n  enable: function () {\r\n    this.active = true;\r\n  },\r\n  log: function () {\r\n    if (!this.active) return;\r\n    var nodeType;\r\n\r\n    switch (this.node) {\r\n      case 0:\r\n        nodeType = 'FORM';\r\n        break;\r\n\r\n      case 1:\r\n        nodeType = 'CHK';\r\n        break;\r\n\r\n      case 2:\r\n        nodeType = 'S-CHK';\r\n        break;\r\n    }\r\n\r\n    console.log('| '.repeat(this.depth) + nodeType, this.nodeID, `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`, this.node == 0 ? ' {' : '', this.skipped ? 'SKIPPED' : '', this.node == 0 && this.skipped ? '}' : '');\r\n\r\n    if (this.node == 0 && !this.skipped) {\r\n      this.depth += 1;\r\n      this.formList.push(this.dataOffset + this.length);\r\n    }\r\n\r\n    this.skipped = false;\r\n  },\r\n  closeForms: function () {\r\n    if (!this.active) return;\r\n\r\n    for (let i = this.formList.length - 1; i >= 0; i--) {\r\n      if (this.offset >= this.formList[i]) {\r\n        this.depth -= 1;\r\n        console.log('| '.repeat(this.depth) + '}');\r\n        this.formList.splice(-1, 1);\r\n      }\r\n    }\r\n  }\r\n}; // ************** UTILITY FUNCTIONS **************\r\n\r\nfunction isEven(num) {\r\n  return num % 2;\r\n} // calculate the length of the string in the buffer\r\n// this will be string.length + nullbyte + optional padbyte to make the length even\r\n\r\n\r\nfunction stringOffset(string) {\r\n  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);\r\n} // for testing purposes, dump buffer to console\r\n// printBuffer( this.reader.dv.buffer, this.reader.offset, length );\r\n\r\n\r\nfunction printBuffer(buffer, from, to) {\r\n  console.log(LoaderUtils.decodeText(new Uint8Array(buffer, from, to)));\r\n}\r\n\r\nexport { IFFParser };\r\n", "import { Vector3, Loader, FileLoader, Group, BufferGeometry, Float32BufferAttribute, LineBasicMaterial, Material, PointsMaterial, MeshPhongMaterial, LineSegments, Points, Mesh } from 'three';\r\n\r\nconst _object_pattern = /^[og]\\s*(.+)?/; // mtllib file_reference\r\n\r\nconst _material_library_pattern = /^mtllib /; // usemtl material_name\r\n\r\nconst _material_use_pattern = /^usemtl /; // usemap map_name\r\n\r\nconst _map_use_pattern = /^usemap /;\r\n\r\nconst _vA = new Vector3();\r\n\r\nconst _vB = new Vector3();\r\n\r\nconst _vC = new Vector3();\r\n\r\nconst _ab = new Vector3();\r\n\r\nconst _cb = new Vector3();\r\n\r\nfunction ParserState() {\r\n  const state = {\r\n    objects: [],\r\n    object: {},\r\n    vertices: [],\r\n    normals: [],\r\n    colors: [],\r\n    uvs: [],\r\n    materials: {},\r\n    materialLibraries: [],\r\n    startObject: function (name, fromDeclaration) {\r\n      // If the current object (initial from reset) is not from a g/o declaration in the parsed\r\n      // file. We need to use it for the first parsed g/o to keep things in sync.\r\n      if (this.object && this.object.fromDeclaration === false) {\r\n        this.object.name = name;\r\n        this.object.fromDeclaration = fromDeclaration !== false;\r\n        return;\r\n      }\r\n\r\n      const previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\r\n\r\n      if (this.object && typeof this.object._finalize === 'function') {\r\n        this.object._finalize(true);\r\n      }\r\n\r\n      this.object = {\r\n        name: name || '',\r\n        fromDeclaration: fromDeclaration !== false,\r\n        geometry: {\r\n          vertices: [],\r\n          normals: [],\r\n          colors: [],\r\n          uvs: [],\r\n          hasUVIndices: false\r\n        },\r\n        materials: [],\r\n        smooth: true,\r\n        startMaterial: function (name, libraries) {\r\n          const previous = this._finalize(false); // New usemtl declaration overwrites an inherited material, except if faces were declared\r\n          // after the material, then it must be preserved for proper MultiMaterial continuation.\r\n\r\n\r\n          if (previous && (previous.inherited || previous.groupCount <= 0)) {\r\n            this.materials.splice(previous.index, 1);\r\n          }\r\n\r\n          const material = {\r\n            index: this.materials.length,\r\n            name: name || '',\r\n            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\r\n            smooth: previous !== undefined ? previous.smooth : this.smooth,\r\n            groupStart: previous !== undefined ? previous.groupEnd : 0,\r\n            groupEnd: -1,\r\n            groupCount: -1,\r\n            inherited: false,\r\n            clone: function (index) {\r\n              const cloned = {\r\n                index: typeof index === 'number' ? index : this.index,\r\n                name: this.name,\r\n                mtllib: this.mtllib,\r\n                smooth: this.smooth,\r\n                groupStart: 0,\r\n                groupEnd: -1,\r\n                groupCount: -1,\r\n                inherited: false\r\n              };\r\n              cloned.clone = this.clone.bind(cloned);\r\n              return cloned;\r\n            }\r\n          };\r\n          this.materials.push(material);\r\n          return material;\r\n        },\r\n        currentMaterial: function () {\r\n          if (this.materials.length > 0) {\r\n            return this.materials[this.materials.length - 1];\r\n          }\r\n\r\n          return undefined;\r\n        },\r\n        _finalize: function (end) {\r\n          const lastMultiMaterial = this.currentMaterial();\r\n\r\n          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\r\n            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\r\n            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\r\n            lastMultiMaterial.inherited = false;\r\n          } // Ignore objects tail materials if no face declarations followed them before a new o/g started.\r\n\r\n\r\n          if (end && this.materials.length > 1) {\r\n            for (let mi = this.materials.length - 1; mi >= 0; mi--) {\r\n              if (this.materials[mi].groupCount <= 0) {\r\n                this.materials.splice(mi, 1);\r\n              }\r\n            }\r\n          } // Guarantee at least one empty material, this makes the creation later more straight forward.\r\n\r\n\r\n          if (end && this.materials.length === 0) {\r\n            this.materials.push({\r\n              name: '',\r\n              smooth: this.smooth\r\n            });\r\n          }\r\n\r\n          return lastMultiMaterial;\r\n        }\r\n      }; // Inherit previous objects material.\r\n      // Spec tells us that a declared material must be set to all objects until a new material is declared.\r\n      // If a usemtl declaration is encountered while this new object is being parsed, it will\r\n      // overwrite the inherited material. Exception being that there was already face declarations\r\n      // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\r\n\r\n      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\r\n        const declared = previousMaterial.clone(0);\r\n        declared.inherited = true;\r\n        this.object.materials.push(declared);\r\n      }\r\n\r\n      this.objects.push(this.object);\r\n    },\r\n    finalize: function () {\r\n      if (this.object && typeof this.object._finalize === 'function') {\r\n        this.object._finalize(true);\r\n      }\r\n    },\r\n    parseVertexIndex: function (value, len) {\r\n      const index = parseInt(value, 10);\r\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\r\n    },\r\n    parseNormalIndex: function (value, len) {\r\n      const index = parseInt(value, 10);\r\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\r\n    },\r\n    parseUVIndex: function (value, len) {\r\n      const index = parseInt(value, 10);\r\n      return (index >= 0 ? index - 1 : index + len / 2) * 2;\r\n    },\r\n    addVertex: function (a, b, c) {\r\n      const src = this.vertices;\r\n      const dst = this.object.geometry.vertices;\r\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\r\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\r\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\r\n    },\r\n    addVertexPoint: function (a) {\r\n      const src = this.vertices;\r\n      const dst = this.object.geometry.vertices;\r\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\r\n    },\r\n    addVertexLine: function (a) {\r\n      const src = this.vertices;\r\n      const dst = this.object.geometry.vertices;\r\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\r\n    },\r\n    addNormal: function (a, b, c) {\r\n      const src = this.normals;\r\n      const dst = this.object.geometry.normals;\r\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\r\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\r\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\r\n    },\r\n    addFaceNormal: function (a, b, c) {\r\n      const src = this.vertices;\r\n      const dst = this.object.geometry.normals;\r\n\r\n      _vA.fromArray(src, a);\r\n\r\n      _vB.fromArray(src, b);\r\n\r\n      _vC.fromArray(src, c);\r\n\r\n      _cb.subVectors(_vC, _vB);\r\n\r\n      _ab.subVectors(_vA, _vB);\r\n\r\n      _cb.cross(_ab);\r\n\r\n      _cb.normalize();\r\n\r\n      dst.push(_cb.x, _cb.y, _cb.z);\r\n      dst.push(_cb.x, _cb.y, _cb.z);\r\n      dst.push(_cb.x, _cb.y, _cb.z);\r\n    },\r\n    addColor: function (a, b, c) {\r\n      const src = this.colors;\r\n      const dst = this.object.geometry.colors;\r\n      if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2]);\r\n      if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2]);\r\n      if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2]);\r\n    },\r\n    addUV: function (a, b, c) {\r\n      const src = this.uvs;\r\n      const dst = this.object.geometry.uvs;\r\n      dst.push(src[a + 0], src[a + 1]);\r\n      dst.push(src[b + 0], src[b + 1]);\r\n      dst.push(src[c + 0], src[c + 1]);\r\n    },\r\n    addDefaultUV: function () {\r\n      const dst = this.object.geometry.uvs;\r\n      dst.push(0, 0);\r\n      dst.push(0, 0);\r\n      dst.push(0, 0);\r\n    },\r\n    addUVLine: function (a) {\r\n      const src = this.uvs;\r\n      const dst = this.object.geometry.uvs;\r\n      dst.push(src[a + 0], src[a + 1]);\r\n    },\r\n    addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\r\n      const vLen = this.vertices.length;\r\n      let ia = this.parseVertexIndex(a, vLen);\r\n      let ib = this.parseVertexIndex(b, vLen);\r\n      let ic = this.parseVertexIndex(c, vLen);\r\n      this.addVertex(ia, ib, ic);\r\n      this.addColor(ia, ib, ic); // normals\r\n\r\n      if (na !== undefined && na !== '') {\r\n        const nLen = this.normals.length;\r\n        ia = this.parseNormalIndex(na, nLen);\r\n        ib = this.parseNormalIndex(nb, nLen);\r\n        ic = this.parseNormalIndex(nc, nLen);\r\n        this.addNormal(ia, ib, ic);\r\n      } else {\r\n        this.addFaceNormal(ia, ib, ic);\r\n      } // uvs\r\n\r\n\r\n      if (ua !== undefined && ua !== '') {\r\n        const uvLen = this.uvs.length;\r\n        ia = this.parseUVIndex(ua, uvLen);\r\n        ib = this.parseUVIndex(ub, uvLen);\r\n        ic = this.parseUVIndex(uc, uvLen);\r\n        this.addUV(ia, ib, ic);\r\n        this.object.geometry.hasUVIndices = true;\r\n      } else {\r\n        // add placeholder values (for inconsistent face definitions)\r\n        this.addDefaultUV();\r\n      }\r\n    },\r\n    addPointGeometry: function (vertices) {\r\n      this.object.geometry.type = 'Points';\r\n      const vLen = this.vertices.length;\r\n\r\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\r\n        const index = this.parseVertexIndex(vertices[vi], vLen);\r\n        this.addVertexPoint(index);\r\n        this.addColor(index);\r\n      }\r\n    },\r\n    addLineGeometry: function (vertices, uvs) {\r\n      this.object.geometry.type = 'Line';\r\n      const vLen = this.vertices.length;\r\n      const uvLen = this.uvs.length;\r\n\r\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\r\n        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\r\n      }\r\n\r\n      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {\r\n        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\r\n      }\r\n    }\r\n  };\r\n  state.startObject('', false);\r\n  return state;\r\n} //\r\n\r\n\r\nclass OBJLoader extends Loader {\r\n  constructor(manager) {\r\n    super(manager);\r\n    this.materials = null;\r\n  }\r\n\r\n  load(url, onLoad, onProgress, onError) {\r\n    const scope = this;\r\n    const loader = new FileLoader(this.manager);\r\n    loader.setPath(this.path);\r\n    loader.setRequestHeader(this.requestHeader);\r\n    loader.setWithCredentials(this.withCredentials);\r\n    loader.load(url, function (text) {\r\n      try {\r\n        onLoad(scope.parse(text));\r\n      } catch (e) {\r\n        if (onError) {\r\n          onError(e);\r\n        } else {\r\n          console.error(e);\r\n        }\r\n\r\n        scope.manager.itemError(url);\r\n      }\r\n    }, onProgress, onError);\r\n  }\r\n\r\n  setMaterials(materials) {\r\n    this.materials = materials;\r\n    return this;\r\n  }\r\n\r\n  parse(text) {\r\n    const state = new ParserState();\r\n\r\n    if (text.indexOf('\\r\\n') !== -1) {\r\n      // This is faster than String.split with regex that splits on both\r\n      text = text.replace(/\\r\\n/g, '\\n');\r\n    }\r\n\r\n    if (text.indexOf('\\\\\\n') !== -1) {\r\n      // join lines separated by a line continuation character (\\)\r\n      text = text.replace(/\\\\\\n/g, '');\r\n    }\r\n\r\n    const lines = text.split('\\n');\r\n    let line = '',\r\n        lineFirstChar = '';\r\n    let lineLength = 0;\r\n    let result = []; // Faster to just trim left side of the line. Use if available.\r\n\r\n    const trimLeft = typeof ''.trimLeft === 'function';\r\n\r\n    for (let i = 0, l = lines.length; i < l; i++) {\r\n      line = lines[i];\r\n      line = trimLeft ? line.trimLeft() : line.trim();\r\n      lineLength = line.length;\r\n      if (lineLength === 0) continue;\r\n      lineFirstChar = line.charAt(0); // @todo invoke passed in handler if any\r\n\r\n      if (lineFirstChar === '#') continue;\r\n\r\n      if (lineFirstChar === 'v') {\r\n        const data = line.split(/\\s+/);\r\n\r\n        switch (data[0]) {\r\n          case 'v':\r\n            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\r\n\r\n            if (data.length >= 7) {\r\n              state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\r\n            } else {\r\n              // if no colors are defined, add placeholders so color and vertex indices match\r\n              state.colors.push(undefined, undefined, undefined);\r\n            }\r\n\r\n            break;\r\n\r\n          case 'vn':\r\n            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\r\n            break;\r\n\r\n          case 'vt':\r\n            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\r\n            break;\r\n        }\r\n      } else if (lineFirstChar === 'f') {\r\n        const lineData = line.substr(1).trim();\r\n        const vertexData = lineData.split(/\\s+/);\r\n        const faceVertices = []; // Parse the face vertex data into an easy to work with format\r\n\r\n        for (let j = 0, jl = vertexData.length; j < jl; j++) {\r\n          const vertex = vertexData[j];\r\n\r\n          if (vertex.length > 0) {\r\n            const vertexParts = vertex.split('/');\r\n            faceVertices.push(vertexParts);\r\n          }\r\n        } // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\r\n\r\n\r\n        const v1 = faceVertices[0];\r\n\r\n        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\r\n          const v2 = faceVertices[j];\r\n          const v3 = faceVertices[j + 1];\r\n          state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\r\n        }\r\n      } else if (lineFirstChar === 'l') {\r\n        const lineParts = line.substring(1).trim().split(' ');\r\n        let lineVertices = [];\r\n        const lineUVs = [];\r\n\r\n        if (line.indexOf('/') === -1) {\r\n          lineVertices = lineParts;\r\n        } else {\r\n          for (let li = 0, llen = lineParts.length; li < llen; li++) {\r\n            const parts = lineParts[li].split('/');\r\n            if (parts[0] !== '') lineVertices.push(parts[0]);\r\n            if (parts[1] !== '') lineUVs.push(parts[1]);\r\n          }\r\n        }\r\n\r\n        state.addLineGeometry(lineVertices, lineUVs);\r\n      } else if (lineFirstChar === 'p') {\r\n        const lineData = line.substr(1).trim();\r\n        const pointData = lineData.split(' ');\r\n        state.addPointGeometry(pointData);\r\n      } else if ((result = _object_pattern.exec(line)) !== null) {\r\n        // o object_name\r\n        // or\r\n        // g group_name\r\n        // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\r\n        // let name = result[ 0 ].substr( 1 ).trim();\r\n        const name = (' ' + result[0].substr(1).trim()).substr(1);\r\n        state.startObject(name);\r\n      } else if (_material_use_pattern.test(line)) {\r\n        // material\r\n        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\r\n      } else if (_material_library_pattern.test(line)) {\r\n        // mtl file\r\n        state.materialLibraries.push(line.substring(7).trim());\r\n      } else if (_map_use_pattern.test(line)) {\r\n        // the line is parsed but ignored since the loader assumes textures are defined MTL files\r\n        // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\r\n        console.warn('THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.');\r\n      } else if (lineFirstChar === 's') {\r\n        result = line.split(' '); // smooth shading\r\n        // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\r\n        // but does not define a usemtl for each face set.\r\n        // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\r\n        // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\r\n        // where explicit usemtl defines geometry groups.\r\n        // Example asset: examples/models/obj/cerberus/Cerberus.obj\r\n\r\n        /*\r\n         * http://paulbourke.net/dataformats/obj/\r\n         * or\r\n         * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\r\n         *\r\n         * From chapter \"Grouping\" Syntax explanation \"s group_number\":\r\n         * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\r\n         * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\r\n         * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\r\n         * than 0.\"\r\n         */\r\n\r\n        if (result.length > 1) {\r\n          const value = result[1].trim().toLowerCase();\r\n          state.object.smooth = value !== '0' && value !== 'off';\r\n        } else {\r\n          // ZBrush can produce \"s\" lines #11707\r\n          state.object.smooth = true;\r\n        }\r\n\r\n        const material = state.object.currentMaterial();\r\n        if (material) material.smooth = state.object.smooth;\r\n      } else {\r\n        // Handle null terminated files without exception\r\n        if (line === '\\0') continue;\r\n        console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\r\n      }\r\n    }\r\n\r\n    state.finalize();\r\n    const container = new Group();\r\n    container.materialLibraries = [].concat(state.materialLibraries);\r\n    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);\r\n\r\n    if (hasPrimitives === true) {\r\n      for (let i = 0, l = state.objects.length; i < l; i++) {\r\n        const object = state.objects[i];\r\n        const geometry = object.geometry;\r\n        const materials = object.materials;\r\n        const isLine = geometry.type === 'Line';\r\n        const isPoints = geometry.type === 'Points';\r\n        let hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces\r\n\r\n        if (geometry.vertices.length === 0) continue;\r\n        const buffergeometry = new BufferGeometry();\r\n        buffergeometry.setAttribute('position', new Float32BufferAttribute(geometry.vertices, 3));\r\n\r\n        if (geometry.normals.length > 0) {\r\n          buffergeometry.setAttribute('normal', new Float32BufferAttribute(geometry.normals, 3));\r\n        }\r\n\r\n        if (geometry.colors.length > 0) {\r\n          hasVertexColors = true;\r\n          buffergeometry.setAttribute('color', new Float32BufferAttribute(geometry.colors, 3));\r\n        }\r\n\r\n        if (geometry.hasUVIndices === true) {\r\n          buffergeometry.setAttribute('uv', new Float32BufferAttribute(geometry.uvs, 2));\r\n        } // Create materials\r\n\r\n\r\n        const createdMaterials = [];\r\n\r\n        for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\r\n          const sourceMaterial = materials[mi];\r\n          const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\r\n          let material = state.materials[materialHash];\r\n\r\n          if (this.materials !== null) {\r\n            material = this.materials.create(sourceMaterial.name); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\r\n\r\n            if (isLine && material && !(material instanceof LineBasicMaterial)) {\r\n              const materialLine = new LineBasicMaterial();\r\n              Material.prototype.copy.call(materialLine, material);\r\n              materialLine.color.copy(material.color);\r\n              material = materialLine;\r\n            } else if (isPoints && material && !(material instanceof PointsMaterial)) {\r\n              const materialPoints = new PointsMaterial({\r\n                size: 10,\r\n                sizeAttenuation: false\r\n              });\r\n              Material.prototype.copy.call(materialPoints, material);\r\n              materialPoints.color.copy(material.color);\r\n              materialPoints.map = material.map;\r\n              material = materialPoints;\r\n            }\r\n          }\r\n\r\n          if (material === undefined) {\r\n            if (isLine) {\r\n              material = new LineBasicMaterial();\r\n            } else if (isPoints) {\r\n              material = new PointsMaterial({\r\n                size: 1,\r\n                sizeAttenuation: false\r\n              });\r\n            } else {\r\n              material = new MeshPhongMaterial();\r\n            }\r\n\r\n            material.name = sourceMaterial.name;\r\n            material.flatShading = sourceMaterial.smooth ? false : true;\r\n            material.vertexColors = hasVertexColors;\r\n            state.materials[materialHash] = material;\r\n          }\r\n\r\n          createdMaterials.push(material);\r\n        } // Create mesh\r\n\r\n\r\n        let mesh;\r\n\r\n        if (createdMaterials.length > 1) {\r\n          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\r\n            const sourceMaterial = materials[mi];\r\n            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\r\n          }\r\n\r\n          if (isLine) {\r\n            mesh = new LineSegments(buffergeometry, createdMaterials);\r\n          } else if (isPoints) {\r\n            mesh = new Points(buffergeometry, createdMaterials);\r\n          } else {\r\n            mesh = new Mesh(buffergeometry, createdMaterials);\r\n          }\r\n        } else {\r\n          if (isLine) {\r\n            mesh = new LineSegments(buffergeometry, createdMaterials[0]);\r\n          } else if (isPoints) {\r\n            mesh = new Points(buffergeometry, createdMaterials[0]);\r\n          } else {\r\n            mesh = new Mesh(buffergeometry, createdMaterials[0]);\r\n          }\r\n        }\r\n\r\n        mesh.name = object.name;\r\n        container.add(mesh);\r\n      }\r\n    } else {\r\n      // if there is only the default parser state object with no geometry data, interpret data as point cloud\r\n      if (state.vertices.length > 0) {\r\n        const material = new PointsMaterial({\r\n          size: 1,\r\n          sizeAttenuation: false\r\n        });\r\n        const buffergeometry = new BufferGeometry();\r\n        buffergeometry.setAttribute('position', new Float32BufferAttribute(state.vertices, 3));\r\n\r\n        if (state.colors.length > 0 && state.colors[0] !== undefined) {\r\n          buffergeometry.setAttribute('color', new Float32BufferAttribute(state.colors, 3));\r\n          material.vertexColors = true;\r\n        }\r\n\r\n        const points = new Points(buffergeometry, material);\r\n        container.add(points);\r\n      }\r\n    }\r\n\r\n    return container;\r\n  }\r\n\r\n}\r\n\r\nexport { OBJLoader };\r\n", "import { CompressedTextureLoader } from 'three';\r\n\r\n/**\r\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\r\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\r\n *\r\n * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts\r\n */\r\n\r\nclass KTXLoader extends CompressedTextureLoader {\r\n  constructor(manager) {\r\n    super(manager);\r\n  }\r\n\r\n  parse(buffer, loadMipmaps) {\r\n    const ktx = new KhronosTextureContainer(buffer, 1);\r\n    return {\r\n      mipmaps: ktx.mipmaps(loadMipmaps),\r\n      width: ktx.pixelWidth,\r\n      height: ktx.pixelHeight,\r\n      format: ktx.glInternalFormat,\r\n      isCubemap: ktx.numberOfFaces === 6,\r\n      mipmapCount: ktx.numberOfMipmapLevels\r\n    };\r\n  }\r\n\r\n}\r\n\r\nconst HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\r\n// load types\r\n\r\nconst COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\r\n//const COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\r\n//const TEX_2D = 2; // uses a gl.texImage2D()\r\n//const TEX_3D = 3; // uses a gl.texImage3D()\r\n\r\nclass KhronosTextureContainer {\r\n  /**\r\n   * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file\r\n   * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or\r\n   * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented\r\n   * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented\r\n   */\r\n  constructor(arrayBuffer, facesExpected\r\n  /*, threeDExpected, textureArrayExpected */\r\n  ) {\r\n    this.arrayBuffer = arrayBuffer; // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:\r\n    // '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\\r', '\\n', '\\x1A', '\\n'\r\n    // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\r\n\r\n    const identifier = new Uint8Array(this.arrayBuffer, 0, 12);\r\n\r\n    if (identifier[0] !== 0xab || identifier[1] !== 0x4b || identifier[2] !== 0x54 || identifier[3] !== 0x58 || identifier[4] !== 0x20 || identifier[5] !== 0x31 || identifier[6] !== 0x31 || identifier[7] !== 0xbb || identifier[8] !== 0x0d || identifier[9] !== 0x0a || identifier[10] !== 0x1a || identifier[11] !== 0x0a) {\r\n      console.error('texture missing KTX identifier');\r\n      return;\r\n    } // load the reset of the header in native 32 bit uint\r\n\r\n\r\n    const dataSize = Uint32Array.BYTES_PER_ELEMENT;\r\n    const headerDataView = new DataView(this.arrayBuffer, 12, 13 * dataSize);\r\n    const endianness = headerDataView.getUint32(0, true);\r\n    const littleEndian = endianness === 0x04030201;\r\n    this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures\r\n\r\n    this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures\r\n\r\n    this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures\r\n\r\n    this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\r\n\r\n    this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\r\n\r\n    this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\r\n\r\n    this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\r\n\r\n    this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\r\n\r\n    this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays\r\n\r\n    this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6\r\n\r\n    this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures\r\n\r\n    this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data\r\n    // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\r\n\r\n    if (this.glType !== 0) {\r\n      console.warn('only compressed formats currently supported');\r\n      return;\r\n    } else {\r\n      // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\r\n      this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);\r\n    }\r\n\r\n    if (this.pixelHeight === 0 || this.pixelDepth !== 0) {\r\n      console.warn('only 2D textures currently supported');\r\n      return;\r\n    }\r\n\r\n    if (this.numberOfArrayElements !== 0) {\r\n      console.warn('texture arrays not currently supported');\r\n      return;\r\n    }\r\n\r\n    if (this.numberOfFaces !== facesExpected) {\r\n      console.warn('number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces);\r\n      return;\r\n    } // we now have a completely validated file, so could use existence of loadType as success\r\n    // would need to make this more elaborate & adjust checks above to support more than one load type\r\n\r\n\r\n    this.loadType = COMPRESSED_2D;\r\n  }\r\n\r\n  mipmaps(loadMipmaps) {\r\n    const mipmaps = []; // initialize width & height for level 1\r\n\r\n    let dataOffset = HEADER_LEN + this.bytesOfKeyValueData;\r\n    let width = this.pixelWidth;\r\n    let height = this.pixelHeight;\r\n    const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\r\n\r\n    for (let level = 0; level < mipmapCount; level++) {\r\n      const imageSize = new Int32Array(this.arrayBuffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\r\n\r\n      dataOffset += 4; // size of the image + 4 for the imageSize field\r\n\r\n      for (let face = 0; face < this.numberOfFaces; face++) {\r\n        const byteArray = new Uint8Array(this.arrayBuffer, dataOffset, imageSize);\r\n        mipmaps.push({\r\n          data: byteArray,\r\n          width: width,\r\n          height: height\r\n        });\r\n        dataOffset += imageSize;\r\n        dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image\r\n      }\r\n\r\n      width = Math.max(1.0, width * 0.5);\r\n      height = Math.max(1.0, height * 0.5);\r\n    }\r\n\r\n    return mipmaps;\r\n  }\r\n\r\n}\r\n\r\nexport { KTXLoader };\r\n", "import { DataTextureLoader, HalfFloatType, CubeTexture, RGBAFormat, LinearFilter, DataUtils } from 'three';\r\n\r\nclass RGBMLoader extends DataTextureLoader {\r\n  constructor(manager) {\r\n    super(manager);\r\n    this.type = HalfFloatType;\r\n    this.maxRange = 7; // more information about this property at https://iwasbeingirony.blogspot.com/2010/06/difference-between-rgbm-and-rgbd.html\r\n  }\r\n\r\n  setDataType(value) {\r\n    this.type = value;\r\n    return this;\r\n  }\r\n\r\n  setMaxRange(value) {\r\n    this.maxRange = value;\r\n    return this;\r\n  }\r\n\r\n  loadCubemap(urls, onLoad, onProgress, onError) {\r\n    const texture = new CubeTexture();\r\n    let loaded = 0;\r\n    const scope = this;\r\n\r\n    function loadTexture(i) {\r\n      scope.load(urls[i], function (image) {\r\n        texture.images[i] = image;\r\n        loaded++;\r\n\r\n        if (loaded === 6) {\r\n          texture.needsUpdate = true;\r\n          if (onLoad) onLoad(texture);\r\n        }\r\n      }, undefined, onError);\r\n    }\r\n\r\n    for (let i = 0; i < urls.length; ++i) {\r\n      loadTexture(i);\r\n    }\r\n\r\n    texture.type = this.type;\r\n    texture.format = RGBAFormat;\r\n    texture.minFilter = LinearFilter;\r\n    texture.generateMipmaps = false;\r\n    return texture;\r\n  }\r\n\r\n  parse(buffer) {\r\n    const img = UPNG.decode(buffer);\r\n    const rgba = UPNG.toRGBA8(img)[0];\r\n    const data = new Uint8Array(rgba);\r\n    const size = img.width * img.height * 4;\r\n    const output = this.type === HalfFloatType ? new Uint16Array(size) : new Float32Array(size); // decode RGBM\r\n\r\n    for (let i = 0; i < data.length; i += 4) {\r\n      const r = data[i + 0] / 255;\r\n      const g = data[i + 1] / 255;\r\n      const b = data[i + 2] / 255;\r\n      const a = data[i + 3] / 255;\r\n\r\n      if (this.type === HalfFloatType) {\r\n        output[i + 0] = DataUtils.toHalfFloat(Math.min(r * a * this.maxRange, 65504));\r\n        output[i + 1] = DataUtils.toHalfFloat(Math.min(g * a * this.maxRange, 65504));\r\n        output[i + 2] = DataUtils.toHalfFloat(Math.min(b * a * this.maxRange, 65504));\r\n        output[i + 3] = DataUtils.toHalfFloat(1);\r\n      } else {\r\n        output[i + 0] = r * a * this.maxRange;\r\n        output[i + 1] = g * a * this.maxRange;\r\n        output[i + 2] = b * a * this.maxRange;\r\n        output[i + 3] = 1;\r\n      }\r\n    }\r\n\r\n    return {\r\n      width: img.width,\r\n      height: img.height,\r\n      data: output,\r\n      format: RGBAFormat,\r\n      type: this.type,\r\n      flipY: true\r\n    };\r\n  }\r\n\r\n} // from https://github.com/photopea/UPNG.js (MIT License)\r\n\r\n\r\nvar UPNG = {};\r\n\r\nUPNG.toRGBA8 = function (out) {\r\n  var w = out.width,\r\n      h = out.height;\r\n  if (out.tabs.acTL == null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];\r\n  var frms = [];\r\n  if (out.frames[0].data == null) out.frames[0].data = out.data;\r\n  var len = w * h * 4,\r\n      img = new Uint8Array(len),\r\n      empty = new Uint8Array(len),\r\n      prev = new Uint8Array(len);\r\n\r\n  for (var i = 0; i < out.frames.length; i++) {\r\n    var frm = out.frames[i];\r\n    var fx = frm.rect.x,\r\n        fy = frm.rect.y,\r\n        fw = frm.rect.width,\r\n        fh = frm.rect.height;\r\n    var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);\r\n    if (i != 0) for (var j = 0; j < len; j++) prev[j] = img[j];\r\n    if (frm.blend == 0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);else if (frm.blend == 1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\r\n    frms.push(img.buffer.slice(0));\r\n    if (frm.dispose == 1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);else if (frm.dispose == 2) for (var j = 0; j < len; j++) img[j] = prev[j];\r\n  }\r\n\r\n  return frms;\r\n};\r\n\r\nUPNG.toRGBA8.decodeImage = function (data, w, h, out) {\r\n  var area = w * h,\r\n      bpp = UPNG.decode._getBPP(out);\r\n\r\n  var bpl = Math.ceil(w * bpp / 8); // bytes per line\r\n\r\n  var bf = new Uint8Array(area * 4),\r\n      bf32 = new Uint32Array(bf.buffer);\r\n  var ctype = out.ctype,\r\n      depth = out.depth;\r\n  var rs = UPNG._bin.readUshort;\r\n\r\n  if (ctype == 6) {\r\n    // RGB + alpha\r\n    var qarea = area << 2;\r\n\r\n    if (depth == 8) {\r\n      for (var i = 0; i < qarea; i += 4) {\r\n        bf[i] = data[i];\r\n        bf[i + 1] = data[i + 1];\r\n        bf[i + 2] = data[i + 2];\r\n        bf[i + 3] = data[i + 3];\r\n      }\r\n    }\r\n\r\n    if (depth == 16) {\r\n      for (var i = 0; i < qarea; i++) {\r\n        bf[i] = data[i << 1];\r\n      }\r\n    }\r\n  } else if (ctype == 2) {\r\n    // RGB\r\n    var ts = out.tabs['tRNS'];\r\n\r\n    if (ts == null) {\r\n      if (depth == 8) {\r\n        for (var i = 0; i < area; i++) {\r\n          var ti = i * 3;\r\n          bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];\r\n        }\r\n      }\r\n\r\n      if (depth == 16) {\r\n        for (var i = 0; i < area; i++) {\r\n          var ti = i * 6;\r\n          bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];\r\n        }\r\n      }\r\n    } else {\r\n      var tr = ts[0],\r\n          tg = ts[1],\r\n          tb = ts[2];\r\n\r\n      if (depth == 8) {\r\n        for (var i = 0; i < area; i++) {\r\n          var qi = i << 2,\r\n              ti = i * 3;\r\n          bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];\r\n          if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb) bf[qi + 3] = 0;\r\n        }\r\n      }\r\n\r\n      if (depth == 16) {\r\n        for (var i = 0; i < area; i++) {\r\n          var qi = i << 2,\r\n              ti = i * 6;\r\n          bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];\r\n          if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb) bf[qi + 3] = 0;\r\n        }\r\n      }\r\n    }\r\n  } else if (ctype == 3) {\r\n    // palette\r\n    var p = out.tabs['PLTE'],\r\n        ap = out.tabs['tRNS'],\r\n        tl = ap ? ap.length : 0; //console.log(p, ap);\r\n\r\n    if (depth == 1) {\r\n      for (var y = 0; y < h; y++) {\r\n        var s0 = y * bpl,\r\n            t0 = y * w;\r\n\r\n        for (var i = 0; i < w; i++) {\r\n          var qi = t0 + i << 2,\r\n              j = data[s0 + (i >> 3)] >> 7 - ((i & 7) << 0) & 1,\r\n              cj = 3 * j;\r\n          bf[qi] = p[cj];\r\n          bf[qi + 1] = p[cj + 1];\r\n          bf[qi + 2] = p[cj + 2];\r\n          bf[qi + 3] = j < tl ? ap[j] : 255;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (depth == 2) {\r\n      for (var y = 0; y < h; y++) {\r\n        var s0 = y * bpl,\r\n            t0 = y * w;\r\n\r\n        for (var i = 0; i < w; i++) {\r\n          var qi = t0 + i << 2,\r\n              j = data[s0 + (i >> 2)] >> 6 - ((i & 3) << 1) & 3,\r\n              cj = 3 * j;\r\n          bf[qi] = p[cj];\r\n          bf[qi + 1] = p[cj + 1];\r\n          bf[qi + 2] = p[cj + 2];\r\n          bf[qi + 3] = j < tl ? ap[j] : 255;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (depth == 4) {\r\n      for (var y = 0; y < h; y++) {\r\n        var s0 = y * bpl,\r\n            t0 = y * w;\r\n\r\n        for (var i = 0; i < w; i++) {\r\n          var qi = t0 + i << 2,\r\n              j = data[s0 + (i >> 1)] >> 4 - ((i & 1) << 2) & 15,\r\n              cj = 3 * j;\r\n          bf[qi] = p[cj];\r\n          bf[qi + 1] = p[cj + 1];\r\n          bf[qi + 2] = p[cj + 2];\r\n          bf[qi + 3] = j < tl ? ap[j] : 255;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (depth == 8) {\r\n      for (var i = 0; i < area; i++) {\r\n        var qi = i << 2,\r\n            j = data[i],\r\n            cj = 3 * j;\r\n        bf[qi] = p[cj];\r\n        bf[qi + 1] = p[cj + 1];\r\n        bf[qi + 2] = p[cj + 2];\r\n        bf[qi + 3] = j < tl ? ap[j] : 255;\r\n      }\r\n    }\r\n  } else if (ctype == 4) {\r\n    // gray + alpha\r\n    if (depth == 8) {\r\n      for (var i = 0; i < area; i++) {\r\n        var qi = i << 2,\r\n            di = i << 1,\r\n            gr = data[di];\r\n        bf[qi] = gr;\r\n        bf[qi + 1] = gr;\r\n        bf[qi + 2] = gr;\r\n        bf[qi + 3] = data[di + 1];\r\n      }\r\n    }\r\n\r\n    if (depth == 16) {\r\n      for (var i = 0; i < area; i++) {\r\n        var qi = i << 2,\r\n            di = i << 2,\r\n            gr = data[di];\r\n        bf[qi] = gr;\r\n        bf[qi + 1] = gr;\r\n        bf[qi + 2] = gr;\r\n        bf[qi + 3] = data[di + 2];\r\n      }\r\n    }\r\n  } else if (ctype == 0) {\r\n    // gray\r\n    var tr = out.tabs['tRNS'] ? out.tabs['tRNS'] : -1;\r\n\r\n    for (var y = 0; y < h; y++) {\r\n      var off = y * bpl,\r\n          to = y * w;\r\n\r\n      if (depth == 1) {\r\n        for (var x = 0; x < w; x++) {\r\n          var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1),\r\n              al = gr == tr * 255 ? 0 : 255;\r\n          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\r\n        }\r\n      } else if (depth == 2) {\r\n        for (var x = 0; x < w; x++) {\r\n          var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3),\r\n              al = gr == tr * 85 ? 0 : 255;\r\n          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\r\n        }\r\n      } else if (depth == 4) {\r\n        for (var x = 0; x < w; x++) {\r\n          var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15),\r\n              al = gr == tr * 17 ? 0 : 255;\r\n          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\r\n        }\r\n      } else if (depth == 8) {\r\n        for (var x = 0; x < w; x++) {\r\n          var gr = data[off + x],\r\n              al = gr == tr ? 0 : 255;\r\n          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\r\n        }\r\n      } else if (depth == 16) {\r\n        for (var x = 0; x < w; x++) {\r\n          var gr = data[off + (x << 1)],\r\n              al = rs(data, off + (x << 1)) == tr ? 0 : 255;\r\n          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\r\n        }\r\n      }\r\n    }\r\n  } //console.log(Date.now()-time);\r\n\r\n\r\n  return bf;\r\n};\r\n\r\nUPNG.decode = function (buff) {\r\n  var data = new Uint8Array(buff),\r\n      offset = 8,\r\n      bin = UPNG._bin,\r\n      rUs = bin.readUshort,\r\n      rUi = bin.readUint;\r\n  var out = {\r\n    tabs: {},\r\n    frames: []\r\n  };\r\n  var dd = new Uint8Array(data.length),\r\n      doff = 0; // put all IDAT data into it\r\n\r\n  var fd,\r\n      foff = 0; // frames\r\n\r\n  var text, keyw, bfr;\r\n  var mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\r\n\r\n  for (var i = 0; i < 8; i++) if (data[i] != mgck[i]) throw new Error('The input is not a PNG file!');\r\n\r\n  while (offset < data.length) {\r\n    var len = bin.readUint(data, offset);\r\n    offset += 4;\r\n    var type = bin.readASCII(data, offset, 4);\r\n    offset += 4; //console.log(type,len);\r\n\r\n    if (type == 'IHDR') {\r\n      UPNG.decode._IHDR(data, offset, out);\r\n    } else if (type == 'CgBI') {\r\n      out.tabs[type] = data.slice(offset, offset + 4);\r\n    } else if (type == 'IDAT') {\r\n      for (var i = 0; i < len; i++) dd[doff + i] = data[offset + i];\r\n\r\n      doff += len;\r\n    } else if (type == 'acTL') {\r\n      out.tabs[type] = {\r\n        num_frames: rUi(data, offset),\r\n        num_plays: rUi(data, offset + 4)\r\n      };\r\n      fd = new Uint8Array(data.length);\r\n    } else if (type == 'fcTL') {\r\n      if (foff != 0) {\r\n        var fr = out.frames[out.frames.length - 1];\r\n        fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\r\n        foff = 0;\r\n      }\r\n\r\n      var rct = {\r\n        x: rUi(data, offset + 12),\r\n        y: rUi(data, offset + 16),\r\n        width: rUi(data, offset + 4),\r\n        height: rUi(data, offset + 8)\r\n      };\r\n      var del = rUs(data, offset + 22);\r\n      del = rUs(data, offset + 20) / (del == 0 ? 100 : del);\r\n      var frm = {\r\n        rect: rct,\r\n        delay: Math.round(del * 1000),\r\n        dispose: data[offset + 24],\r\n        blend: data[offset + 25]\r\n      }; //console.log(frm);\r\n\r\n      out.frames.push(frm);\r\n    } else if (type == 'fdAT') {\r\n      for (var i = 0; i < len - 4; i++) fd[foff + i] = data[offset + i + 4];\r\n\r\n      foff += len - 4;\r\n    } else if (type == 'pHYs') {\r\n      out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];\r\n    } else if (type == 'cHRM') {\r\n      out.tabs[type] = [];\r\n\r\n      for (var i = 0; i < 8; i++) out.tabs[type].push(bin.readUint(data, offset + i * 4));\r\n    } else if (type == 'tEXt' || type == 'zTXt') {\r\n      if (out.tabs[type] == null) out.tabs[type] = {};\r\n      var nz = bin.nextZero(data, offset);\r\n      keyw = bin.readASCII(data, offset, nz - offset);\r\n      var tl = offset + len - nz - 1;\r\n\r\n      if (type == 'tEXt') {\r\n        text = bin.readASCII(data, nz + 1, tl);\r\n      } else {\r\n        bfr = UPNG.decode._inflate(data.slice(nz + 2, nz + 2 + tl));\r\n        text = bin.readUTF8(bfr, 0, bfr.length);\r\n      }\r\n\r\n      out.tabs[type][keyw] = text;\r\n    } else if (type == 'iTXt') {\r\n      if (out.tabs[type] == null) out.tabs[type] = {};\r\n      var nz = 0,\r\n          off = offset;\r\n      nz = bin.nextZero(data, off);\r\n      keyw = bin.readASCII(data, off, nz - off);\r\n      off = nz + 1;\r\n      var cflag = data[off];\r\n      off += 2;\r\n      nz = bin.nextZero(data, off);\r\n      bin.readASCII(data, off, nz - off);\r\n      off = nz + 1;\r\n      nz = bin.nextZero(data, off);\r\n      bin.readUTF8(data, off, nz - off);\r\n      off = nz + 1;\r\n      var tl = len - (off - offset);\r\n\r\n      if (cflag == 0) {\r\n        text = bin.readUTF8(data, off, tl);\r\n      } else {\r\n        bfr = UPNG.decode._inflate(data.slice(off, off + tl));\r\n        text = bin.readUTF8(bfr, 0, bfr.length);\r\n      }\r\n\r\n      out.tabs[type][keyw] = text;\r\n    } else if (type == 'PLTE') {\r\n      out.tabs[type] = bin.readBytes(data, offset, len);\r\n    } else if (type == 'hIST') {\r\n      var pl = out.tabs['PLTE'].length / 3;\r\n      out.tabs[type] = [];\r\n\r\n      for (var i = 0; i < pl; i++) out.tabs[type].push(rUs(data, offset + i * 2));\r\n    } else if (type == 'tRNS') {\r\n      if (out.ctype == 3) out.tabs[type] = bin.readBytes(data, offset, len);else if (out.ctype == 0) out.tabs[type] = rUs(data, offset);else if (out.ctype == 2) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)]; //else console.log(\"tRNS for unsupported color type\",out.ctype, len);\r\n    } else if (type == 'gAMA') {\r\n      out.tabs[type] = bin.readUint(data, offset) / 100000;\r\n    } else if (type == 'sRGB') {\r\n      out.tabs[type] = data[offset];\r\n    } else if (type == 'bKGD') {\r\n      if (out.ctype == 0 || out.ctype == 4) {\r\n        out.tabs[type] = [rUs(data, offset)];\r\n      } else if (out.ctype == 2 || out.ctype == 6) {\r\n        out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];\r\n      } else if (out.ctype == 3) {\r\n        out.tabs[type] = data[offset];\r\n      }\r\n    } else if (type == 'IEND') {\r\n      break;\r\n    } //else {  console.log(\"unknown chunk type\", type, len);  out.tabs[type]=data.slice(offset,offset+len);  }\r\n\r\n\r\n    offset += len;\r\n    bin.readUint(data, offset);\r\n    offset += 4;\r\n  }\r\n\r\n  if (foff != 0) {\r\n    var fr = out.frames[out.frames.length - 1];\r\n    fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\r\n  }\r\n\r\n  out.data = UPNG.decode._decompress(out, dd, out.width, out.height);\r\n  delete out.compress;\r\n  delete out.interlace;\r\n  delete out.filter;\r\n  return out;\r\n};\r\n\r\nUPNG.decode._decompress = function (out, dd, w, h) {\r\n  var bpp = UPNG.decode._getBPP(out),\r\n      bpl = Math.ceil(w * bpp / 8),\r\n      buff = new Uint8Array((bpl + 1 + out.interlace) * h);\r\n\r\n  if (out.tabs['CgBI']) dd = UPNG.inflateRaw(dd, buff);else dd = UPNG.decode._inflate(dd, buff);\r\n  if (out.interlace == 0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);else if (out.interlace == 1) dd = UPNG.decode._readInterlace(dd, out);\r\n  return dd;\r\n};\r\n\r\nUPNG.decode._inflate = function (data, buff) {\r\n  var out = UPNG['inflateRaw'](new Uint8Array(data.buffer, 2, data.length - 6), buff);\r\n  return out;\r\n};\r\n\r\nUPNG.inflateRaw = function () {\r\n  var H = {};\r\n  H.H = {};\r\n\r\n  H.H.N = function (N, W) {\r\n    var R = Uint8Array,\r\n        i = 0,\r\n        m = 0,\r\n        J = 0,\r\n        h = 0,\r\n        Q = 0,\r\n        X = 0,\r\n        u = 0,\r\n        w = 0,\r\n        d = 0,\r\n        v,\r\n        C;\r\n    if (N[0] == 3 && N[1] == 0) return W ? W : new R(0);\r\n    var V = H.H,\r\n        n = V.b,\r\n        A = V.e,\r\n        l = V.R,\r\n        M = V.n,\r\n        I = V.A,\r\n        e = V.Z,\r\n        b = V.m,\r\n        Z = W == null;\r\n    if (Z) W = new R(N.length >>> 2 << 5);\r\n\r\n    while (i == 0) {\r\n      i = n(N, d, 1);\r\n      m = n(N, d + 1, 2);\r\n      d += 3;\r\n\r\n      if (m == 0) {\r\n        if ((d & 7) != 0) d += 8 - (d & 7);\r\n        var D = (d >>> 3) + 4,\r\n            q = N[D - 4] | N[D - 3] << 8;\r\n        if (Z) W = H.H.W(W, w + q);\r\n        W.set(new R(N.buffer, N.byteOffset + D, q), w);\r\n        d = D + q << 3;\r\n        w += q;\r\n        continue;\r\n      }\r\n\r\n      if (Z) W = H.H.W(W, w + (1 << 17));\r\n\r\n      if (m == 1) {\r\n        v = b.J;\r\n        C = b.h;\r\n        X = (1 << 9) - 1;\r\n        u = (1 << 5) - 1;\r\n      }\r\n\r\n      if (m == 2) {\r\n        J = A(N, d, 5) + 257;\r\n        h = A(N, d + 5, 5) + 1;\r\n        Q = A(N, d + 10, 4) + 4;\r\n        d += 14;\r\n        var j = 1;\r\n\r\n        for (var c = 0; c < 38; c += 2) {\r\n          b.Q[c] = 0;\r\n          b.Q[c + 1] = 0;\r\n        }\r\n\r\n        for (var c = 0; c < Q; c++) {\r\n          var K = A(N, d + c * 3, 3);\r\n          b.Q[(b.X[c] << 1) + 1] = K;\r\n          if (K > j) j = K;\r\n        }\r\n\r\n        d += 3 * Q;\r\n        M(b.Q, j);\r\n        I(b.Q, j, b.u);\r\n        v = b.w;\r\n        C = b.d;\r\n        d = l(b.u, (1 << j) - 1, J + h, N, d, b.v);\r\n        var r = V.V(b.v, 0, J, b.C);\r\n        X = (1 << r) - 1;\r\n        var S = V.V(b.v, J, h, b.D);\r\n        u = (1 << S) - 1;\r\n        M(b.C, r);\r\n        I(b.C, r, v);\r\n        M(b.D, S);\r\n        I(b.D, S, C);\r\n      }\r\n\r\n      while (!0) {\r\n        var T = v[e(N, d) & X];\r\n        d += T & 15;\r\n        var p = T >>> 4;\r\n\r\n        if (p >>> 8 == 0) {\r\n          W[w++] = p;\r\n        } else if (p == 256) {\r\n          break;\r\n        } else {\r\n          var z = w + p - 254;\r\n\r\n          if (p > 264) {\r\n            var _ = b.q[p - 257];\r\n            z = w + (_ >>> 3) + A(N, d, _ & 7);\r\n            d += _ & 7;\r\n          }\r\n\r\n          var $ = C[e(N, d) & u];\r\n          d += $ & 15;\r\n          var s = $ >>> 4,\r\n              Y = b.c[s],\r\n              a = (Y >>> 4) + n(N, d, Y & 15);\r\n          d += Y & 15;\r\n\r\n          while (w < z) {\r\n            W[w] = W[w++ - a];\r\n            W[w] = W[w++ - a];\r\n            W[w] = W[w++ - a];\r\n            W[w] = W[w++ - a];\r\n          }\r\n\r\n          w = z;\r\n        }\r\n      }\r\n    }\r\n\r\n    return W.length == w ? W : W.slice(0, w);\r\n  };\r\n\r\n  H.H.W = function (N, W) {\r\n    var R = N.length;\r\n    if (W <= R) return N;\r\n    var V = new Uint8Array(R << 1);\r\n    V.set(N, 0);\r\n    return V;\r\n  };\r\n\r\n  H.H.R = function (N, W, R, V, n, A) {\r\n    var l = H.H.e,\r\n        M = H.H.Z,\r\n        I = 0;\r\n\r\n    while (I < R) {\r\n      var e = N[M(V, n) & W];\r\n      n += e & 15;\r\n      var b = e >>> 4;\r\n\r\n      if (b <= 15) {\r\n        A[I] = b;\r\n        I++;\r\n      } else {\r\n        var Z = 0,\r\n            m = 0;\r\n\r\n        if (b == 16) {\r\n          m = 3 + l(V, n, 2);\r\n          n += 2;\r\n          Z = A[I - 1];\r\n        } else if (b == 17) {\r\n          m = 3 + l(V, n, 3);\r\n          n += 3;\r\n        } else if (b == 18) {\r\n          m = 11 + l(V, n, 7);\r\n          n += 7;\r\n        }\r\n\r\n        var J = I + m;\r\n\r\n        while (I < J) {\r\n          A[I] = Z;\r\n          I++;\r\n        }\r\n      }\r\n    }\r\n\r\n    return n;\r\n  };\r\n\r\n  H.H.V = function (N, W, R, V) {\r\n    var n = 0,\r\n        A = 0,\r\n        l = V.length >>> 1;\r\n\r\n    while (A < R) {\r\n      var M = N[A + W];\r\n      V[A << 1] = 0;\r\n      V[(A << 1) + 1] = M;\r\n      if (M > n) n = M;\r\n      A++;\r\n    }\r\n\r\n    while (A < l) {\r\n      V[A << 1] = 0;\r\n      V[(A << 1) + 1] = 0;\r\n      A++;\r\n    }\r\n\r\n    return n;\r\n  };\r\n\r\n  H.H.n = function (N, W) {\r\n    var R = H.H.m,\r\n        V = N.length,\r\n        n,\r\n        A,\r\n        l,\r\n        M,\r\n        I,\r\n        e = R.j;\r\n\r\n    for (var M = 0; M <= W; M++) e[M] = 0;\r\n\r\n    for (M = 1; M < V; M += 2) e[N[M]]++;\r\n\r\n    var b = R.K;\r\n    n = 0;\r\n    e[0] = 0;\r\n\r\n    for (A = 1; A <= W; A++) {\r\n      n = n + e[A - 1] << 1;\r\n      b[A] = n;\r\n    }\r\n\r\n    for (l = 0; l < V; l += 2) {\r\n      I = N[l + 1];\r\n\r\n      if (I != 0) {\r\n        N[l] = b[I];\r\n        b[I]++;\r\n      }\r\n    }\r\n  };\r\n\r\n  H.H.A = function (N, W, R) {\r\n    var V = N.length,\r\n        n = H.H.m,\r\n        A = n.r;\r\n\r\n    for (var l = 0; l < V; l += 2) {\r\n      if (N[l + 1] != 0) {\r\n        var M = l >> 1,\r\n            I = N[l + 1],\r\n            e = M << 4 | I,\r\n            b = W - I,\r\n            Z = N[l] << b,\r\n            m = Z + (1 << b);\r\n\r\n        while (Z != m) {\r\n          var J = A[Z] >>> 15 - W;\r\n          R[J] = e;\r\n          Z++;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  H.H.l = function (N, W) {\r\n    var R = H.H.m.r,\r\n        V = 15 - W;\r\n\r\n    for (var n = 0; n < N.length; n += 2) {\r\n      var A = N[n] << W - N[n + 1];\r\n      N[n] = R[A] >>> V;\r\n    }\r\n  };\r\n\r\n  H.H.M = function (N, W, R) {\r\n    R = R << (W & 7);\r\n    var V = W >>> 3;\r\n    N[V] |= R;\r\n    N[V + 1] |= R >>> 8;\r\n  };\r\n\r\n  H.H.I = function (N, W, R) {\r\n    R = R << (W & 7);\r\n    var V = W >>> 3;\r\n    N[V] |= R;\r\n    N[V + 1] |= R >>> 8;\r\n    N[V + 2] |= R >>> 16;\r\n  };\r\n\r\n  H.H.e = function (N, W, R) {\r\n    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1;\r\n  };\r\n\r\n  H.H.b = function (N, W, R) {\r\n    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1;\r\n  };\r\n\r\n  H.H.Z = function (N, W) {\r\n    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);\r\n  };\r\n\r\n  H.H.i = function (N, W) {\r\n    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);\r\n  };\r\n\r\n  H.H.m = function () {\r\n    var N = Uint16Array,\r\n        W = Uint32Array;\r\n    return {\r\n      K: new N(16),\r\n      j: new N(16),\r\n      X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\r\n      S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\r\n      T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\r\n      q: new N(32),\r\n      p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\r\n      z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\r\n      c: new W(32),\r\n      J: new N(512),\r\n      _: [],\r\n      h: new N(32),\r\n      $: [],\r\n      w: new N(32768),\r\n      C: [],\r\n      v: [],\r\n      d: new N(32768),\r\n      D: [],\r\n      u: new N(512),\r\n      Q: [],\r\n      r: new N(1 << 15),\r\n      s: new W(286),\r\n      Y: new W(30),\r\n      a: new W(19),\r\n      t: new W(15e3),\r\n      k: new N(1 << 16),\r\n      g: new N(1 << 15)\r\n    };\r\n  }();\r\n\r\n  (function () {\r\n    var N = H.H.m,\r\n        W = 1 << 15;\r\n\r\n    for (var R = 0; R < W; R++) {\r\n      var V = R;\r\n      V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;\r\n      V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;\r\n      V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;\r\n      V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;\r\n      N.r[R] = (V >>> 16 | V << 16) >>> 17;\r\n    }\r\n\r\n    function n(A, l, M) {\r\n      while (l-- != 0) A.push(0, M);\r\n    }\r\n\r\n    for (var R = 0; R < 32; R++) {\r\n      N.q[R] = N.S[R] << 3 | N.T[R];\r\n      N.c[R] = N.p[R] << 4 | N.z[R];\r\n    }\r\n\r\n    n(N._, 144, 8);\r\n    n(N._, 255 - 143, 9);\r\n    n(N._, 279 - 255, 7);\r\n    n(N._, 287 - 279, 8);\r\n    H.H.n(N._, 9);\r\n    H.H.A(N._, 9, N.J);\r\n    H.H.l(N._, 9);\r\n    n(N.$, 32, 5);\r\n    H.H.n(N.$, 5);\r\n    H.H.A(N.$, 5, N.h);\r\n    H.H.l(N.$, 5);\r\n    n(N.Q, 19, 0);\r\n    n(N.C, 286, 0);\r\n    n(N.D, 30, 0);\r\n    n(N.v, 320, 0);\r\n  })();\r\n\r\n  return H.H.N;\r\n}();\r\n\r\nUPNG.decode._readInterlace = function (data, out) {\r\n  var w = out.width,\r\n      h = out.height;\r\n\r\n  var bpp = UPNG.decode._getBPP(out),\r\n      cbpp = bpp >> 3,\r\n      bpl = Math.ceil(w * bpp / 8);\r\n\r\n  var img = new Uint8Array(h * bpl);\r\n  var di = 0;\r\n  var starting_row = [0, 0, 4, 0, 2, 0, 1];\r\n  var starting_col = [0, 4, 0, 2, 0, 1, 0];\r\n  var row_increment = [8, 8, 8, 4, 4, 2, 2];\r\n  var col_increment = [8, 8, 4, 4, 2, 2, 1];\r\n  var pass = 0;\r\n\r\n  while (pass < 7) {\r\n    var ri = row_increment[pass],\r\n        ci = col_increment[pass];\r\n    var sw = 0,\r\n        sh = 0;\r\n    var cr = starting_row[pass];\r\n\r\n    while (cr < h) {\r\n      cr += ri;\r\n      sh++;\r\n    }\r\n\r\n    var cc = starting_col[pass];\r\n\r\n    while (cc < w) {\r\n      cc += ci;\r\n      sw++;\r\n    }\r\n\r\n    var bpll = Math.ceil(sw * bpp / 8);\r\n\r\n    UPNG.decode._filterZero(data, out, di, sw, sh);\r\n\r\n    var y = 0,\r\n        row = starting_row[pass];\r\n    var val;\r\n\r\n    while (row < h) {\r\n      var col = starting_col[pass];\r\n      var cdi = di + y * bpll << 3;\r\n\r\n      while (col < w) {\r\n        if (bpp == 1) {\r\n          val = data[cdi >> 3];\r\n          val = val >> 7 - (cdi & 7) & 1;\r\n          img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);\r\n        }\r\n\r\n        if (bpp == 2) {\r\n          val = data[cdi >> 3];\r\n          val = val >> 6 - (cdi & 7) & 3;\r\n          img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);\r\n        }\r\n\r\n        if (bpp == 4) {\r\n          val = data[cdi >> 3];\r\n          val = val >> 4 - (cdi & 7) & 15;\r\n          img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);\r\n        }\r\n\r\n        if (bpp >= 8) {\r\n          var ii = row * bpl + col * cbpp;\r\n\r\n          for (var j = 0; j < cbpp; j++) img[ii + j] = data[(cdi >> 3) + j];\r\n        }\r\n\r\n        cdi += bpp;\r\n        col += ci;\r\n      }\r\n\r\n      y++;\r\n      row += ri;\r\n    }\r\n\r\n    if (sw * sh != 0) di += sh * (1 + bpll);\r\n    pass = pass + 1;\r\n  }\r\n\r\n  return img;\r\n};\r\n\r\nUPNG.decode._getBPP = function (out) {\r\n  var noc = [1, null, 3, 1, 2, null, 4][out.ctype];\r\n  return noc * out.depth;\r\n};\r\n\r\nUPNG.decode._filterZero = function (data, out, off, w, h) {\r\n  var bpp = UPNG.decode._getBPP(out),\r\n      bpl = Math.ceil(w * bpp / 8),\r\n      paeth = UPNG.decode._paeth;\r\n\r\n  bpp = Math.ceil(bpp / 8);\r\n  var i,\r\n      di,\r\n      type = data[off],\r\n      x = 0;\r\n  if (type > 1) data[off] = [0, 0, 1][type - 2];\r\n  if (type == 3) for (x = bpp; x < bpl; x++) data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;\r\n\r\n  for (var y = 0; y < h; y++) {\r\n    i = off + y * bpl;\r\n    di = i + y + 1;\r\n    type = data[di - 1];\r\n    x = 0;\r\n\r\n    if (type == 0) {\r\n      for (; x < bpl; x++) data[i + x] = data[di + x];\r\n    } else if (type == 1) {\r\n      for (; x < bpp; x++) data[i + x] = data[di + x];\r\n\r\n      for (; x < bpl; x++) data[i + x] = data[di + x] + data[i + x - bpp];\r\n    } else if (type == 2) {\r\n      for (; x < bpl; x++) data[i + x] = data[di + x] + data[i + x - bpl];\r\n    } else if (type == 3) {\r\n      for (; x < bpp; x++) data[i + x] = data[di + x] + (data[i + x - bpl] >>> 1);\r\n\r\n      for (; x < bpl; x++) data[i + x] = data[di + x] + (data[i + x - bpl] + data[i + x - bpp] >>> 1);\r\n    } else {\r\n      for (; x < bpp; x++) data[i + x] = data[di + x] + paeth(0, data[i + x - bpl], 0);\r\n\r\n      for (; x < bpl; x++) {\r\n        data[i + x] = data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]);\r\n      }\r\n    }\r\n  }\r\n\r\n  return data;\r\n};\r\n\r\nUPNG.decode._paeth = function (a, b, c) {\r\n  var p = a + b - c,\r\n      pa = p - a,\r\n      pb = p - b,\r\n      pc = p - c;\r\n  if (pa * pa <= pb * pb && pa * pa <= pc * pc) return a;else if (pb * pb <= pc * pc) return b;\r\n  return c;\r\n};\r\n\r\nUPNG.decode._IHDR = function (data, offset, out) {\r\n  var bin = UPNG._bin;\r\n  out.width = bin.readUint(data, offset);\r\n  offset += 4;\r\n  out.height = bin.readUint(data, offset);\r\n  offset += 4;\r\n  out.depth = data[offset];\r\n  offset++;\r\n  out.ctype = data[offset];\r\n  offset++;\r\n  out.compress = data[offset];\r\n  offset++;\r\n  out.filter = data[offset];\r\n  offset++;\r\n  out.interlace = data[offset];\r\n  offset++;\r\n};\r\n\r\nUPNG._bin = {\r\n  nextZero: function (data, p) {\r\n    while (data[p] != 0) p++;\r\n\r\n    return p;\r\n  },\r\n  readUshort: function (buff, p) {\r\n    return buff[p] << 8 | buff[p + 1];\r\n  },\r\n  writeUshort: function (buff, p, n) {\r\n    buff[p] = n >> 8 & 255;\r\n    buff[p + 1] = n & 255;\r\n  },\r\n  readUint: function (buff, p) {\r\n    return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);\r\n  },\r\n  writeUint: function (buff, p, n) {\r\n    buff[p] = n >> 24 & 255;\r\n    buff[p + 1] = n >> 16 & 255;\r\n    buff[p + 2] = n >> 8 & 255;\r\n    buff[p + 3] = n & 255;\r\n  },\r\n  readASCII: function (buff, p, l) {\r\n    var s = '';\r\n\r\n    for (var i = 0; i < l; i++) s += String.fromCharCode(buff[p + i]);\r\n\r\n    return s;\r\n  },\r\n  writeASCII: function (data, p, s) {\r\n    for (var i = 0; i < s.length; i++) data[p + i] = s.charCodeAt(i);\r\n  },\r\n  readBytes: function (buff, p, l) {\r\n    var arr = [];\r\n\r\n    for (var i = 0; i < l; i++) arr.push(buff[p + i]);\r\n\r\n    return arr;\r\n  },\r\n  pad: function (n) {\r\n    return n.length < 2 ? '0' + n : n;\r\n  },\r\n  readUTF8: function (buff, p, l) {\r\n    var s = '',\r\n        ns;\r\n\r\n    for (var i = 0; i < l; i++) s += '%' + UPNG._bin.pad(buff[p + i].toString(16));\r\n\r\n    try {\r\n      ns = decodeURIComponent(s);\r\n    } catch (e) {\r\n      return UPNG._bin.readASCII(buff, p, l);\r\n    }\r\n\r\n    return ns;\r\n  }\r\n};\r\n\r\nUPNG._copyTile = function (sb, sw, sh, tb, tw, th, xoff, yoff, mode) {\r\n  var w = Math.min(sw, tw),\r\n      h = Math.min(sh, th);\r\n  var si = 0,\r\n      ti = 0;\r\n\r\n  for (var y = 0; y < h; y++) {\r\n    for (var x = 0; x < w; x++) {\r\n      if (xoff >= 0 && yoff >= 0) {\r\n        si = y * sw + x << 2;\r\n        ti = (yoff + y) * tw + xoff + x << 2;\r\n      } else {\r\n        si = (-yoff + y) * sw - xoff + x << 2;\r\n        ti = y * tw + x << 2;\r\n      }\r\n\r\n      if (mode == 0) {\r\n        tb[ti] = sb[si];\r\n        tb[ti + 1] = sb[si + 1];\r\n        tb[ti + 2] = sb[si + 2];\r\n        tb[ti + 3] = sb[si + 3];\r\n      } else if (mode == 1) {\r\n        var fa = sb[si + 3] * (1 / 255),\r\n            fr = sb[si] * fa,\r\n            fg = sb[si + 1] * fa,\r\n            fb = sb[si + 2] * fa;\r\n        var ba = tb[ti + 3] * (1 / 255),\r\n            br = tb[ti] * ba,\r\n            bg = tb[ti + 1] * ba,\r\n            bb = tb[ti + 2] * ba;\r\n        var ifa = 1 - fa,\r\n            oa = fa + ba * ifa,\r\n            ioa = oa == 0 ? 0 : 1 / oa;\r\n        tb[ti + 3] = 255 * oa;\r\n        tb[ti + 0] = (fr + br * ifa) * ioa;\r\n        tb[ti + 1] = (fg + bg * ifa) * ioa;\r\n        tb[ti + 2] = (fb + bb * ifa) * ioa;\r\n      } else if (mode == 2) {\r\n        // copy only differences, otherwise zero\r\n        var fa = sb[si + 3],\r\n            fr = sb[si],\r\n            fg = sb[si + 1],\r\n            fb = sb[si + 2];\r\n        var ba = tb[ti + 3],\r\n            br = tb[ti],\r\n            bg = tb[ti + 1],\r\n            bb = tb[ti + 2];\r\n\r\n        if (fa == ba && fr == br && fg == bg && fb == bb) {\r\n          tb[ti] = 0;\r\n          tb[ti + 1] = 0;\r\n          tb[ti + 2] = 0;\r\n          tb[ti + 3] = 0;\r\n        } else {\r\n          tb[ti] = fr;\r\n          tb[ti + 1] = fg;\r\n          tb[ti + 2] = fb;\r\n          tb[ti + 3] = fa;\r\n        }\r\n      } else if (mode == 3) {\r\n        // check if can be blended\r\n        var fa = sb[si + 3],\r\n            fr = sb[si],\r\n            fg = sb[si + 1],\r\n            fb = sb[si + 2];\r\n        var ba = tb[ti + 3],\r\n            br = tb[ti],\r\n            bg = tb[ti + 1],\r\n            bb = tb[ti + 2];\r\n        if (fa == ba && fr == br && fg == bg && fb == bb) continue; //if(fa!=255 && ba!=0) return false;\r\n\r\n        if (fa < 220 && ba > 20) return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nexport { RGBMLoader };\r\n", "import { Box3, Vector3, InstancedBufferGeometry, Float32BufferAttribute, InstancedInterleavedBuffer, InterleavedBufferAttribute, WireframeGeometry, Sphere } from 'three';\r\n\r\nconst _box = new Box3();\r\n\r\nconst _vector = new Vector3();\r\n\r\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\r\n  constructor() {\r\n    super();\r\n    this.isLineSegmentsGeometry = true;\r\n    this.type = 'LineSegmentsGeometry';\r\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\r\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\r\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\r\n    this.setIndex(index);\r\n    this.setAttribute('position', new Float32BufferAttribute(positions, 3));\r\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\r\n  }\r\n\r\n  applyMatrix4(matrix) {\r\n    const start = this.attributes.instanceStart;\r\n    const end = this.attributes.instanceEnd;\r\n\r\n    if (start !== undefined) {\r\n      start.applyMatrix4(matrix);\r\n      end.applyMatrix4(matrix);\r\n      start.needsUpdate = true;\r\n    }\r\n\r\n    if (this.boundingBox !== null) {\r\n      this.computeBoundingBox();\r\n    }\r\n\r\n    if (this.boundingSphere !== null) {\r\n      this.computeBoundingSphere();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  setPositions(array) {\r\n    let lineSegments;\r\n\r\n    if (array instanceof Float32Array) {\r\n      lineSegments = array;\r\n    } else if (Array.isArray(array)) {\r\n      lineSegments = new Float32Array(array);\r\n    }\r\n\r\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz\r\n\r\n    this.setAttribute('instanceStart', new InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz\r\n\r\n    this.setAttribute('instanceEnd', new InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz\r\n    //\r\n\r\n    this.computeBoundingBox();\r\n    this.computeBoundingSphere();\r\n    return this;\r\n  }\r\n\r\n  setColors(array) {\r\n    let colors;\r\n\r\n    if (array instanceof Float32Array) {\r\n      colors = array;\r\n    } else if (Array.isArray(array)) {\r\n      colors = new Float32Array(array);\r\n    }\r\n\r\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb\r\n\r\n    this.setAttribute('instanceColorStart', new InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb\r\n\r\n    this.setAttribute('instanceColorEnd', new InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb\r\n\r\n    return this;\r\n  }\r\n\r\n  fromWireframeGeometry(geometry) {\r\n    this.setPositions(geometry.attributes.position.array);\r\n    return this;\r\n  }\r\n\r\n  fromEdgesGeometry(geometry) {\r\n    this.setPositions(geometry.attributes.position.array);\r\n    return this;\r\n  }\r\n\r\n  fromMesh(mesh) {\r\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry)); // set colors, maybe\r\n\r\n    return this;\r\n  }\r\n\r\n  fromLineSegments(lineSegments) {\r\n    const geometry = lineSegments.geometry;\r\n    this.setPositions(geometry.attributes.position.array); // assumes non-indexed\r\n    // set colors, maybe\r\n\r\n    return this;\r\n  }\r\n\r\n  computeBoundingBox() {\r\n    if (this.boundingBox === null) {\r\n      this.boundingBox = new Box3();\r\n    }\r\n\r\n    const start = this.attributes.instanceStart;\r\n    const end = this.attributes.instanceEnd;\r\n\r\n    if (start !== undefined && end !== undefined) {\r\n      this.boundingBox.setFromBufferAttribute(start);\r\n\r\n      _box.setFromBufferAttribute(end);\r\n\r\n      this.boundingBox.union(_box);\r\n    }\r\n  }\r\n\r\n  computeBoundingSphere() {\r\n    if (this.boundingSphere === null) {\r\n      this.boundingSphere = new Sphere();\r\n    }\r\n\r\n    if (this.boundingBox === null) {\r\n      this.computeBoundingBox();\r\n    }\r\n\r\n    const start = this.attributes.instanceStart;\r\n    const end = this.attributes.instanceEnd;\r\n\r\n    if (start !== undefined && end !== undefined) {\r\n      const center = this.boundingSphere.center;\r\n      this.boundingBox.getCenter(center);\r\n      let maxRadiusSq = 0;\r\n\r\n      for (let i = 0, il = start.count; i < il; i++) {\r\n        _vector.fromBufferAttribute(start, i);\r\n\r\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\r\n\r\n        _vector.fromBufferAttribute(end, i);\r\n\r\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\r\n      }\r\n\r\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\r\n\r\n      if (isNaN(this.boundingSphere.radius)) {\r\n        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\r\n      }\r\n    }\r\n  }\r\n\r\n  toJSON() {// todo\r\n  }\r\n\r\n  applyMatrix(matrix) {\r\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\r\n    return this.applyMatrix4(matrix);\r\n  }\r\n\r\n}\r\n\r\nexport { LineSegmentsGeometry };\r\n", "import { UniformsLib, Vector2, ShaderLib, UniformsUtils, ShaderMaterial } from 'three';\r\n\r\n/**\r\n * parameters = {\r\n *  color: <hex>,\r\n *  linewidth: <float>,\r\n *  dashed: <boolean>,\r\n *  dashScale: <float>,\r\n *  dashSize: <float>,\r\n *  dashOffset: <float>,\r\n *  gapSize: <float>,\r\n *  resolution: <Vector2>, // to be set by renderer\r\n * }\r\n */\r\nUniformsLib.line = {\r\n  worldUnits: {\r\n    value: 1\r\n  },\r\n  linewidth: {\r\n    value: 1\r\n  },\r\n  resolution: {\r\n    value: new Vector2(1, 1)\r\n  },\r\n  dashOffset: {\r\n    value: 0\r\n  },\r\n  dashScale: {\r\n    value: 1\r\n  },\r\n  dashSize: {\r\n    value: 1\r\n  },\r\n  gapSize: {\r\n    value: 1\r\n  } // todo FIX - maybe change to totalSize\r\n\r\n};\r\nShaderLib['line'] = {\r\n  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, UniformsLib.line]),\r\n  vertexShader:\r\n  /* glsl */\r\n  `\r\n\t\t#include <common>\r\n\t\t#include <color_pars_vertex>\r\n\t\t#include <fog_pars_vertex>\r\n\t\t#include <logdepthbuf_pars_vertex>\r\n\t\t#include <clipping_planes_pars_vertex>\r\n\r\n\t\tuniform float linewidth;\r\n\t\tuniform vec2 resolution;\r\n\r\n\t\tattribute vec3 instanceStart;\r\n\t\tattribute vec3 instanceEnd;\r\n\r\n\t\tattribute vec3 instanceColorStart;\r\n\t\tattribute vec3 instanceColorEnd;\r\n\r\n\t\t#ifdef WORLD_UNITS\r\n\r\n\t\t\tvarying vec4 worldPos;\r\n\t\t\tvarying vec3 worldStart;\r\n\t\t\tvarying vec3 worldEnd;\r\n\r\n\t\t\t#ifdef USE_DASH\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t#else\r\n\r\n\t\t\tvarying vec2 vUv;\r\n\r\n\t\t#endif\r\n\r\n\t\t#ifdef USE_DASH\r\n\r\n\t\t\tuniform float dashScale;\r\n\t\t\tattribute float instanceDistanceStart;\r\n\t\t\tattribute float instanceDistanceEnd;\r\n\t\t\tvarying float vLineDistance;\r\n\r\n\t\t#endif\r\n\r\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\r\n\r\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\r\n\r\n\t\t\t// conservative estimate of the near plane\r\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\r\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\r\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\r\n\r\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\r\n\r\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#ifdef USE_COLOR\r\n\r\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t#ifdef USE_DASH\r\n\r\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\r\n\t\t\t\tvUv = uv;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tfloat aspect = resolution.x / resolution.y;\r\n\r\n\t\t\t// camera space\r\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\r\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\r\n\r\n\t\t\t#ifdef WORLD_UNITS\r\n\r\n\t\t\t\tworldStart = start.xyz;\r\n\t\t\t\tworldEnd = end.xyz;\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\tvUv = uv;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\r\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\r\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\r\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\r\n\r\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\r\n\r\n\t\t\tif ( perspective ) {\r\n\r\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\r\n\r\n\t\t\t\t\ttrimSegment( start, end );\r\n\r\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\r\n\r\n\t\t\t\t\ttrimSegment( end, start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// clip space\r\n\t\t\tvec4 clipStart = projectionMatrix * start;\r\n\t\t\tvec4 clipEnd = projectionMatrix * end;\r\n\r\n\t\t\t// ndc space\r\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\r\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\r\n\r\n\t\t\t// direction\r\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\r\n\r\n\t\t\t// account for clip-space aspect ratio\r\n\t\t\tdir.x *= aspect;\r\n\t\t\tdir = normalize( dir );\r\n\r\n\t\t\t#ifdef WORLD_UNITS\r\n\r\n\t\t\t\t// get the offset direction as perpendicular to the view vector\r\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\r\n\t\t\t\tvec3 offset;\r\n\t\t\t\tif ( position.y < 0.5 ) {\r\n\r\n\t\t\t\t\toffset = normalize( cross( start.xyz, worldDir ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\toffset = normalize( cross( end.xyz, worldDir ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// sign flip\r\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\r\n\r\n\t\t\t\tfloat forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );\r\n\r\n\t\t\t\t// don't extend the line if we're rendering dashes because we\r\n\t\t\t\t// won't be rendering the endcaps\r\n\t\t\t\t#ifndef USE_DASH\r\n\r\n\t\t\t\t\t// extend the line bounds to encompass  endcaps\r\n\t\t\t\t\tstart.xyz += - worldDir * linewidth * 0.5;\r\n\t\t\t\t\tend.xyz += worldDir * linewidth * 0.5;\r\n\r\n\t\t\t\t\t// shift the position of the quad so it hugs the forward edge of the line\r\n\t\t\t\t\toffset.xy -= dir * forwardOffset;\r\n\t\t\t\t\toffset.z += 0.5;\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// endcaps\r\n\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\r\n\r\n\t\t\t\t\toffset.xy += dir * 2.0 * forwardOffset;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// adjust for linewidth\r\n\t\t\t\toffset *= linewidth * 0.5;\r\n\r\n\t\t\t\t// set the world position\r\n\t\t\t\tworldPos = ( position.y < 0.5 ) ? start : end;\r\n\t\t\t\tworldPos.xyz += offset;\r\n\r\n\t\t\t\t// project the worldpos\r\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\r\n\r\n\t\t\t\t// shift the depth of the projected points so the line\r\n\t\t\t\t// segments overlap neatly\r\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\r\n\t\t\t\tclip.z = clipPose.z * clip.w;\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\r\n\t\t\t\t// undo aspect ratio adjustment\r\n\t\t\t\tdir.x /= aspect;\r\n\t\t\t\toffset.x /= aspect;\r\n\r\n\t\t\t\t// sign flip\r\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\r\n\r\n\t\t\t\t// endcaps\r\n\t\t\t\tif ( position.y < 0.0 ) {\r\n\r\n\t\t\t\t\toffset += - dir;\r\n\r\n\t\t\t\t} else if ( position.y > 1.0 ) {\r\n\r\n\t\t\t\t\toffset += dir;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// adjust for linewidth\r\n\t\t\t\toffset *= linewidth;\r\n\r\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\r\n\t\t\t\toffset /= resolution.y;\r\n\r\n\t\t\t\t// select end\r\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\r\n\r\n\t\t\t\t// back to clip space\r\n\t\t\t\toffset *= clip.w;\r\n\r\n\t\t\t\tclip.xy += offset;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tgl_Position = clip;\r\n\r\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\r\n\r\n\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t#include <clipping_planes_vertex>\r\n\t\t\t#include <fog_vertex>\r\n\r\n\t\t}\r\n\t\t`,\r\n  fragmentShader:\r\n  /* glsl */\r\n  `\r\n\t\tuniform vec3 diffuse;\r\n\t\tuniform float opacity;\r\n\t\tuniform float linewidth;\r\n\r\n\t\t#ifdef USE_DASH\r\n\r\n\t\t\tuniform float dashOffset;\r\n\t\t\tuniform float dashSize;\r\n\t\t\tuniform float gapSize;\r\n\r\n\t\t#endif\r\n\r\n\t\tvarying float vLineDistance;\r\n\r\n\t\t#ifdef WORLD_UNITS\r\n\r\n\t\t\tvarying vec4 worldPos;\r\n\t\t\tvarying vec3 worldStart;\r\n\t\t\tvarying vec3 worldEnd;\r\n\r\n\t\t\t#ifdef USE_DASH\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t#else\r\n\r\n\t\t\tvarying vec2 vUv;\r\n\r\n\t\t#endif\r\n\r\n\t\t#include <common>\r\n\t\t#include <color_pars_fragment>\r\n\t\t#include <fog_pars_fragment>\r\n\t\t#include <logdepthbuf_pars_fragment>\r\n\t\t#include <clipping_planes_pars_fragment>\r\n\r\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\r\n\r\n\t\t\tfloat mua;\r\n\t\t\tfloat mub;\r\n\r\n\t\t\tvec3 p13 = p1 - p3;\r\n\t\t\tvec3 p43 = p4 - p3;\r\n\r\n\t\t\tvec3 p21 = p2 - p1;\r\n\r\n\t\t\tfloat d1343 = dot( p13, p43 );\r\n\t\t\tfloat d4321 = dot( p43, p21 );\r\n\t\t\tfloat d1321 = dot( p13, p21 );\r\n\t\t\tfloat d4343 = dot( p43, p43 );\r\n\t\t\tfloat d2121 = dot( p21, p21 );\r\n\r\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\r\n\r\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\r\n\r\n\t\t\tmua = numer / denom;\r\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\r\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\r\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\r\n\r\n\t\t\treturn vec2( mua, mub );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <clipping_planes_fragment>\r\n\r\n\t\t\t#ifdef USE_DASH\r\n\r\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\r\n\r\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tfloat alpha = opacity;\r\n\r\n\t\t\t#ifdef WORLD_UNITS\r\n\r\n\t\t\t\t// Find the closest points on the view ray and the line segment\r\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\r\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\r\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\r\n\r\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\r\n\t\t\t\tvec3 p2 = rayEnd * params.y;\r\n\t\t\t\tvec3 delta = p1 - p2;\r\n\t\t\t\tfloat len = length( delta );\r\n\t\t\t\tfloat norm = len / linewidth;\r\n\r\n\t\t\t\t#ifndef USE_DASH\r\n\r\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\r\n\r\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\r\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\r\n\r\n\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\tif ( norm > 0.5 ) {\r\n\r\n\t\t\t\t\t\t\tdiscard;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\r\n\r\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\r\n\t\t\t\t\tfloat a = vUv.x;\r\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\r\n\t\t\t\t\tfloat len2 = a * a + b * b;\r\n\t\t\t\t\tfloat dlen = fwidth( len2 );\r\n\r\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\r\n\r\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t#else\r\n\r\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\r\n\r\n\t\t\t\t\t\tfloat a = vUv.x;\r\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\r\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\r\n\r\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\r\n\r\n\t\t\t#include <logdepthbuf_fragment>\r\n\t\t\t#include <color_fragment>\r\n\r\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <encodings_fragment>\r\n\t\t\t#include <fog_fragment>\r\n\t\t\t#include <premultiplied_alpha_fragment>\r\n\r\n\t\t}\r\n\t\t`\r\n};\r\n\r\nclass LineMaterial extends ShaderMaterial {\r\n  constructor(parameters) {\r\n    super({\r\n      type: 'LineMaterial',\r\n      uniforms: UniformsUtils.clone(ShaderLib['line'].uniforms),\r\n      vertexShader: ShaderLib['line'].vertexShader,\r\n      fragmentShader: ShaderLib['line'].fragmentShader,\r\n      clipping: true // required for clipping support\r\n\r\n    });\r\n    this.isLineMaterial = true;\r\n    Object.defineProperties(this, {\r\n      color: {\r\n        enumerable: true,\r\n        get: function () {\r\n          return this.uniforms.diffuse.value;\r\n        },\r\n        set: function (value) {\r\n          this.uniforms.diffuse.value = value;\r\n        }\r\n      },\r\n      worldUnits: {\r\n        enumerable: true,\r\n        get: function () {\r\n          return 'WORLD_UNITS' in this.defines;\r\n        },\r\n        set: function (value) {\r\n          if (value === true) {\r\n            this.defines.WORLD_UNITS = '';\r\n          } else {\r\n            delete this.defines.WORLD_UNITS;\r\n          }\r\n        }\r\n      },\r\n      linewidth: {\r\n        enumerable: true,\r\n        get: function () {\r\n          return this.uniforms.linewidth.value;\r\n        },\r\n        set: function (value) {\r\n          this.uniforms.linewidth.value = value;\r\n        }\r\n      },\r\n      dashed: {\r\n        enumerable: true,\r\n        get: function () {\r\n          return Boolean('USE_DASH' in this.defines);\r\n        },\r\n\r\n        set(value) {\r\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\r\n            this.needsUpdate = true;\r\n          }\r\n\r\n          if (value === true) {\r\n            this.defines.USE_DASH = '';\r\n          } else {\r\n            delete this.defines.USE_DASH;\r\n          }\r\n        }\r\n\r\n      },\r\n      dashScale: {\r\n        enumerable: true,\r\n        get: function () {\r\n          return this.uniforms.dashScale.value;\r\n        },\r\n        set: function (value) {\r\n          this.uniforms.dashScale.value = value;\r\n        }\r\n      },\r\n      dashSize: {\r\n        enumerable: true,\r\n        get: function () {\r\n          return this.uniforms.dashSize.value;\r\n        },\r\n        set: function (value) {\r\n          this.uniforms.dashSize.value = value;\r\n        }\r\n      },\r\n      dashOffset: {\r\n        enumerable: true,\r\n        get: function () {\r\n          return this.uniforms.dashOffset.value;\r\n        },\r\n        set: function (value) {\r\n          this.uniforms.dashOffset.value = value;\r\n        }\r\n      },\r\n      gapSize: {\r\n        enumerable: true,\r\n        get: function () {\r\n          return this.uniforms.gapSize.value;\r\n        },\r\n        set: function (value) {\r\n          this.uniforms.gapSize.value = value;\r\n        }\r\n      },\r\n      opacity: {\r\n        enumerable: true,\r\n        get: function () {\r\n          return this.uniforms.opacity.value;\r\n        },\r\n        set: function (value) {\r\n          this.uniforms.opacity.value = value;\r\n        }\r\n      },\r\n      resolution: {\r\n        enumerable: true,\r\n        get: function () {\r\n          return this.uniforms.resolution.value;\r\n        },\r\n        set: function (value) {\r\n          this.uniforms.resolution.value.copy(value);\r\n        }\r\n      },\r\n      alphaToCoverage: {\r\n        enumerable: true,\r\n        get: function () {\r\n          return Boolean('USE_ALPHA_TO_COVERAGE' in this.defines);\r\n        },\r\n        set: function (value) {\r\n          if (Boolean(value) !== Boolean('USE_ALPHA_TO_COVERAGE' in this.defines)) {\r\n            this.needsUpdate = true;\r\n          }\r\n\r\n          if (value === true) {\r\n            this.defines.USE_ALPHA_TO_COVERAGE = '';\r\n            this.extensions.derivatives = true;\r\n          } else {\r\n            delete this.defines.USE_ALPHA_TO_COVERAGE;\r\n            this.extensions.derivatives = false;\r\n          }\r\n        }\r\n      }\r\n    });\r\n    this.setValues(parameters);\r\n  }\r\n\r\n}\r\n\r\nexport { LineMaterial };\r\n", "import { Vector3, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute } from 'three';\r\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\r\nimport { LineMaterial } from './LineMaterial.js';\r\n\r\nconst _start = new Vector3();\r\n\r\nconst _end = new Vector3();\r\n\r\nclass Wireframe extends Mesh {\r\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\r\n    color: Math.random() * 0xffffff\r\n  })) {\r\n    super(geometry, material);\r\n    this.isWireframe = true;\r\n    this.type = 'Wireframe';\r\n  } // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\r\n\r\n\r\n  computeLineDistances() {\r\n    const geometry = this.geometry;\r\n    const instanceStart = geometry.attributes.instanceStart;\r\n    const instanceEnd = geometry.attributes.instanceEnd;\r\n    const lineDistances = new Float32Array(2 * instanceStart.count);\r\n\r\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\r\n      _start.fromBufferAttribute(instanceStart, i);\r\n\r\n      _end.fromBufferAttribute(instanceEnd, i);\r\n\r\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\r\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\r\n    }\r\n\r\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\r\n\r\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\r\n\r\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\r\n\r\n    return this;\r\n  }\r\n\r\n}\r\n\r\nexport { Wireframe };\r\n", "import { Vector3, Vector4, Matrix4, Line3, Box3, Sphere, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute, MathUtils } from 'three';\r\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\r\nimport { LineMaterial } from './LineMaterial.js';\r\n\r\nconst _start = new Vector3();\r\n\r\nconst _end = new Vector3();\r\n\r\nconst _start4 = new Vector4();\r\n\r\nconst _end4 = new Vector4();\r\n\r\nconst _ssOrigin = new Vector4();\r\n\r\nconst _ssOrigin3 = new Vector3();\r\n\r\nconst _mvMatrix = new Matrix4();\r\n\r\nconst _line = new Line3();\r\n\r\nconst _closestPoint = new Vector3();\r\n\r\nconst _box = new Box3();\r\n\r\nconst _sphere = new Sphere();\r\n\r\nconst _clipToWorldVector = new Vector4();\r\n\r\nlet _ray, _instanceStart, _instanceEnd, _lineWidth; // Returns the margin required to expand by in world space given the distance from the camera,\r\n// line width, resolution, and camera projection\r\n\r\n\r\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\r\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\r\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\r\n  // width does not need to be halved.\r\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix);\r\n\r\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\r\n\r\n  _clipToWorldVector.x = _lineWidth / resolution.width;\r\n  _clipToWorldVector.y = _lineWidth / resolution.height;\r\n\r\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\r\n\r\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\r\n\r\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\r\n}\r\n\r\nfunction raycastWorldUnits(lineSegments, intersects) {\r\n  for (let i = 0, l = _instanceStart.count; i < l; i++) {\r\n    _line.start.fromBufferAttribute(_instanceStart, i);\r\n\r\n    _line.end.fromBufferAttribute(_instanceEnd, i);\r\n\r\n    const pointOnLine = new Vector3();\r\n    const point = new Vector3();\r\n\r\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\r\n\r\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\r\n\r\n    if (isInside) {\r\n      intersects.push({\r\n        point,\r\n        pointOnLine,\r\n        distance: _ray.origin.distanceTo(point),\r\n        object: lineSegments,\r\n        face: null,\r\n        faceIndex: i,\r\n        uv: null,\r\n        uv2: null\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\r\n  const projectionMatrix = camera.projectionMatrix;\r\n  const material = lineSegments.material;\r\n  const resolution = material.resolution;\r\n  const matrixWorld = lineSegments.matrixWorld;\r\n  const geometry = lineSegments.geometry;\r\n  const instanceStart = geometry.attributes.instanceStart;\r\n  const instanceEnd = geometry.attributes.instanceEnd;\r\n  const near = -camera.near; //\r\n  // pick a point 1 unit out along the ray to avoid the ray origin\r\n  // sitting at the camera origin which will cause \"w\" to be 0 when\r\n  // applying the projection matrix.\r\n\r\n  _ray.at(1, _ssOrigin); // ndc space [ - 1.0, 1.0 ]\r\n\r\n\r\n  _ssOrigin.w = 1;\r\n\r\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\r\n\r\n  _ssOrigin.applyMatrix4(projectionMatrix);\r\n\r\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w); // screen space\r\n\r\n\r\n  _ssOrigin.x *= resolution.x / 2;\r\n  _ssOrigin.y *= resolution.y / 2;\r\n  _ssOrigin.z = 0;\r\n\r\n  _ssOrigin3.copy(_ssOrigin);\r\n\r\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\r\n\r\n  for (let i = 0, l = instanceStart.count; i < l; i++) {\r\n    _start4.fromBufferAttribute(instanceStart, i);\r\n\r\n    _end4.fromBufferAttribute(instanceEnd, i);\r\n\r\n    _start4.w = 1;\r\n    _end4.w = 1; // camera space\r\n\r\n    _start4.applyMatrix4(_mvMatrix);\r\n\r\n    _end4.applyMatrix4(_mvMatrix); // skip the segment if it's entirely behind the camera\r\n\r\n\r\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\r\n\r\n    if (isBehindCameraNear) {\r\n      continue;\r\n    } // trim the segment if it extends behind camera near\r\n\r\n\r\n    if (_start4.z > near) {\r\n      const deltaDist = _start4.z - _end4.z;\r\n      const t = (_start4.z - near) / deltaDist;\r\n\r\n      _start4.lerp(_end4, t);\r\n    } else if (_end4.z > near) {\r\n      const deltaDist = _end4.z - _start4.z;\r\n      const t = (_end4.z - near) / deltaDist;\r\n\r\n      _end4.lerp(_start4, t);\r\n    } // clip space\r\n\r\n\r\n    _start4.applyMatrix4(projectionMatrix);\r\n\r\n    _end4.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]\r\n\r\n\r\n    _start4.multiplyScalar(1 / _start4.w);\r\n\r\n    _end4.multiplyScalar(1 / _end4.w); // screen space\r\n\r\n\r\n    _start4.x *= resolution.x / 2;\r\n    _start4.y *= resolution.y / 2;\r\n    _end4.x *= resolution.x / 2;\r\n    _end4.y *= resolution.y / 2; // create 2d segment\r\n\r\n    _line.start.copy(_start4);\r\n\r\n    _line.start.z = 0;\r\n\r\n    _line.end.copy(_end4);\r\n\r\n    _line.end.z = 0; // get closest point on ray to segment\r\n\r\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\r\n\r\n    _line.at(param, _closestPoint); // check if the intersection point is within clip space\r\n\r\n\r\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);\r\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\r\n\r\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\r\n\r\n    if (isInClipSpace && isInside) {\r\n      _line.start.fromBufferAttribute(instanceStart, i);\r\n\r\n      _line.end.fromBufferAttribute(instanceEnd, i);\r\n\r\n      _line.start.applyMatrix4(matrixWorld);\r\n\r\n      _line.end.applyMatrix4(matrixWorld);\r\n\r\n      const pointOnLine = new Vector3();\r\n      const point = new Vector3();\r\n\r\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\r\n\r\n      intersects.push({\r\n        point: point,\r\n        pointOnLine: pointOnLine,\r\n        distance: _ray.origin.distanceTo(point),\r\n        object: lineSegments,\r\n        face: null,\r\n        faceIndex: i,\r\n        uv: null,\r\n        uv2: null\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nclass LineSegments2 extends Mesh {\r\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({\r\n    color: Math.random() * 0xffffff\r\n  })) {\r\n    super(geometry, material);\r\n    this.isLineSegments2 = true;\r\n    this.type = 'LineSegments2';\r\n  } // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\r\n\r\n\r\n  computeLineDistances() {\r\n    const geometry = this.geometry;\r\n    const instanceStart = geometry.attributes.instanceStart;\r\n    const instanceEnd = geometry.attributes.instanceEnd;\r\n    const lineDistances = new Float32Array(2 * instanceStart.count);\r\n\r\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\r\n      _start.fromBufferAttribute(instanceStart, i);\r\n\r\n      _end.fromBufferAttribute(instanceEnd, i);\r\n\r\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\r\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\r\n    }\r\n\r\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\r\n\r\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\r\n\r\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\r\n\r\n    return this;\r\n  }\r\n\r\n  raycast(raycaster, intersects) {\r\n    const worldUnits = this.material.worldUnits;\r\n    const camera = raycaster.camera;\r\n\r\n    if (camera === null && !worldUnits) {\r\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\r\n    }\r\n\r\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\r\n    _ray = raycaster.ray;\r\n    const matrixWorld = this.matrixWorld;\r\n    const geometry = this.geometry;\r\n    const material = this.material;\r\n    _lineWidth = material.linewidth + threshold;\r\n    _instanceStart = geometry.attributes.instanceStart;\r\n    _instanceEnd = geometry.attributes.instanceEnd; // check if we intersect the sphere bounds\r\n\r\n    if (geometry.boundingSphere === null) {\r\n      geometry.computeBoundingSphere();\r\n    }\r\n\r\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld); // increase the sphere bounds by the worst case line screen space width\r\n\r\n\r\n    let sphereMargin;\r\n\r\n    if (worldUnits) {\r\n      sphereMargin = _lineWidth * 0.5;\r\n    } else {\r\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\r\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\r\n    }\r\n\r\n    _sphere.radius += sphereMargin;\r\n\r\n    if (_ray.intersectsSphere(_sphere) === false) {\r\n      return;\r\n    } // check if we intersect the box bounds\r\n\r\n\r\n    if (geometry.boundingBox === null) {\r\n      geometry.computeBoundingBox();\r\n    }\r\n\r\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld); // increase the box bounds by the worst case line width\r\n\r\n\r\n    let boxMargin;\r\n\r\n    if (worldUnits) {\r\n      boxMargin = _lineWidth * 0.5;\r\n    } else {\r\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\r\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\r\n    }\r\n\r\n    _box.expandByScalar(boxMargin);\r\n\r\n    if (_ray.intersectsBox(_box) === false) {\r\n      return;\r\n    }\r\n\r\n    if (worldUnits) {\r\n      raycastWorldUnits(this, intersects);\r\n    } else {\r\n      raycastScreenSpace(this, camera, intersects);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport { LineSegments2 };\r\n", "import { Vector3, LineSegments, BufferGeometry, Float32BufferAttribute, LineBasicMaterial } from 'three';\r\n\r\nconst _v1 = new Vector3();\r\n\r\nconst _v2 = new Vector3();\r\n\r\nclass VertexTangentsHelper extends LineSegments {\r\n  constructor(object, size, hex) {\r\n    const color = hex !== undefined ? hex : 0x00ffff; //\r\n\r\n    const objGeometry = object.geometry;\r\n\r\n    if (!(objGeometry && objGeometry.isBufferGeometry)) {\r\n      console.error('THREE.VertexTangentsHelper: geometry not an instance of THREE.BufferGeometry.', objGeometry);\r\n      return;\r\n    }\r\n\r\n    const nTangents = objGeometry.attributes.tangent.count; //\r\n\r\n    const geometry = new BufferGeometry();\r\n    const positions = new Float32BufferAttribute(nTangents * 2 * 3, 3);\r\n    geometry.setAttribute('position', positions);\r\n    super(geometry, new LineBasicMaterial({\r\n      color,\r\n      toneMapped: false\r\n    }));\r\n    this.type = 'VertexTangentsHelper';\r\n    this.object = object;\r\n    this.size = size !== undefined ? size : 1; //\r\n\r\n    this.matrixAutoUpdate = false;\r\n    this.update();\r\n  }\r\n\r\n  update() {\r\n    this.object.updateMatrixWorld(true);\r\n    const matrixWorld = this.object.matrixWorld;\r\n    const position = this.geometry.attributes.position; //\r\n\r\n    const objGeometry = this.object.geometry;\r\n    const objPos = objGeometry.attributes.position;\r\n    const objTan = objGeometry.attributes.tangent;\r\n    let idx = 0; // for simplicity, ignore index and drawcalls, and render every tangent\r\n\r\n    for (let j = 0, jl = objPos.count; j < jl; j++) {\r\n      _v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);\r\n\r\n      _v2.set(objTan.getX(j), objTan.getY(j), objTan.getZ(j));\r\n\r\n      _v2.transformDirection(matrixWorld).multiplyScalar(this.size).add(_v1);\r\n\r\n      position.setXYZ(idx, _v1.x, _v1.y, _v1.z);\r\n      idx = idx + 1;\r\n      position.setXYZ(idx, _v2.x, _v2.y, _v2.z);\r\n      idx = idx + 1;\r\n    }\r\n\r\n    position.needsUpdate = true;\r\n  }\r\n\r\n}\r\n\r\nexport { VertexTangentsHelper };\r\n", "import { Vector3, Matrix3, LineSegments, BufferGeometry, LineBasicMaterial, Float32BufferAttribute } from 'three';\r\n\r\nconst _v1 = new Vector3();\r\n\r\nconst _v2 = new Vector3();\r\n\r\nconst _normalMatrix = new Matrix3();\r\n\r\nclass VertexNormalsHelper extends LineSegments {\r\n  constructor(object, size, hex) {\r\n    const geometry = new BufferGeometry();\r\n    const color = hex !== undefined ? hex : 0xff0000;\r\n    super(geometry, new LineBasicMaterial({\r\n      color,\r\n      toneMapped: false\r\n    }));\r\n    this.object = object;\r\n    this.size = size !== undefined ? size : 0.1;\r\n    let nNormals = 0;\r\n    const objGeometry = this.object.geometry;\r\n\r\n    if (objGeometry && objGeometry.isGeometry) {\r\n      console.error('THREE.VertexNormalsHelper no longer supports Geometry. Use BufferGeometry instead.');\r\n      return;\r\n    } else if (objGeometry && objGeometry.isBufferGeometry) {\r\n      nNormals = objGeometry.attributes.normal.count;\r\n    } //\r\n\r\n\r\n    const positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);\r\n    geometry.setAttribute('position', positions);\r\n    this.type = 'VertexNormalsHelper'; //\r\n\r\n    this.matrixAutoUpdate = false;\r\n    this.update();\r\n  }\r\n\r\n  update() {\r\n    this.object.updateMatrixWorld(true);\r\n\r\n    _normalMatrix.getNormalMatrix(this.object.matrixWorld);\r\n\r\n    const matrixWorld = this.object.matrixWorld;\r\n    const position = this.geometry.attributes.position; //\r\n\r\n    const objGeometry = this.object.geometry;\r\n\r\n    if (objGeometry && objGeometry.isGeometry) {\r\n      console.error('THREE.VertexNormalsHelper no longer supports Geometry. Use BufferGeometry instead.');\r\n      return;\r\n    } else if (objGeometry && objGeometry.isBufferGeometry) {\r\n      const objPos = objGeometry.attributes.position;\r\n      const objNorm = objGeometry.attributes.normal;\r\n      let idx = 0; // for simplicity, ignore index and drawcalls, and render every normal\r\n\r\n      for (let j = 0, jl = objPos.count; j < jl; j++) {\r\n        _v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);\r\n\r\n        _v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));\r\n\r\n        _v2.applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1);\r\n\r\n        position.setXYZ(idx, _v1.x, _v1.y, _v1.z);\r\n        idx = idx + 1;\r\n        position.setXYZ(idx, _v2.x, _v2.y, _v2.z);\r\n        idx = idx + 1;\r\n      }\r\n    }\r\n\r\n    position.needsUpdate = true;\r\n  }\r\n\r\n}\r\n\r\nexport { VertexNormalsHelper };\r\n", "import { Matrix4, Object3D, Vector3, EventDispatcher, MathUtils, Matrix3, Color, Box3, Sphere, BufferGeometry, BufferAttribute, Float32BufferAttribute, Vector2 } from 'three';\r\n\r\nconst _m1 = new Matrix4();\r\n\r\nconst _obj = new Object3D();\r\n\r\nconst _offset = new Vector3();\r\n\r\nclass Geometry extends EventDispatcher {\r\n  constructor() {\r\n    super();\r\n    this.isGeometry = true;\r\n    this.uuid = MathUtils.generateUUID();\r\n    this.name = '';\r\n    this.type = 'Geometry';\r\n    this.vertices = [];\r\n    this.colors = [];\r\n    this.faces = [];\r\n    this.faceVertexUvs = [[]];\r\n    this.morphTargets = [];\r\n    this.morphNormals = [];\r\n    this.skinWeights = [];\r\n    this.skinIndices = [];\r\n    this.lineDistances = [];\r\n    this.boundingBox = null;\r\n    this.boundingSphere = null; // update flags\r\n\r\n    this.elementsNeedUpdate = false;\r\n    this.verticesNeedUpdate = false;\r\n    this.uvsNeedUpdate = false;\r\n    this.normalsNeedUpdate = false;\r\n    this.colorsNeedUpdate = false;\r\n    this.lineDistancesNeedUpdate = false;\r\n    this.groupsNeedUpdate = false;\r\n  }\r\n\r\n  applyMatrix4(matrix) {\r\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\r\n\r\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\r\n      const vertex = this.vertices[i];\r\n      vertex.applyMatrix4(matrix);\r\n    }\r\n\r\n    for (let i = 0, il = this.faces.length; i < il; i++) {\r\n      const face = this.faces[i];\r\n      face.normal.applyMatrix3(normalMatrix).normalize();\r\n\r\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\r\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\r\n      }\r\n    }\r\n\r\n    if (this.boundingBox !== null) {\r\n      this.computeBoundingBox();\r\n    }\r\n\r\n    if (this.boundingSphere !== null) {\r\n      this.computeBoundingSphere();\r\n    }\r\n\r\n    this.verticesNeedUpdate = true;\r\n    this.normalsNeedUpdate = true;\r\n    return this;\r\n  }\r\n\r\n  rotateX(angle) {\r\n    // rotate geometry around world x-axis\r\n    _m1.makeRotationX(angle);\r\n\r\n    this.applyMatrix4(_m1);\r\n    return this;\r\n  }\r\n\r\n  rotateY(angle) {\r\n    // rotate geometry around world y-axis\r\n    _m1.makeRotationY(angle);\r\n\r\n    this.applyMatrix4(_m1);\r\n    return this;\r\n  }\r\n\r\n  rotateZ(angle) {\r\n    // rotate geometry around world z-axis\r\n    _m1.makeRotationZ(angle);\r\n\r\n    this.applyMatrix4(_m1);\r\n    return this;\r\n  }\r\n\r\n  translate(x, y, z) {\r\n    // translate geometry\r\n    _m1.makeTranslation(x, y, z);\r\n\r\n    this.applyMatrix4(_m1);\r\n    return this;\r\n  }\r\n\r\n  scale(x, y, z) {\r\n    // scale geometry\r\n    _m1.makeScale(x, y, z);\r\n\r\n    this.applyMatrix4(_m1);\r\n    return this;\r\n  }\r\n\r\n  lookAt(vector) {\r\n    _obj.lookAt(vector);\r\n\r\n    _obj.updateMatrix();\r\n\r\n    this.applyMatrix4(_obj.matrix);\r\n    return this;\r\n  }\r\n\r\n  fromBufferGeometry(geometry) {\r\n    const scope = this;\r\n    const index = geometry.index !== null ? geometry.index : undefined;\r\n    const attributes = geometry.attributes;\r\n\r\n    if (attributes.position === undefined) {\r\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\r\n      return this;\r\n    }\r\n\r\n    const position = attributes.position;\r\n    const normal = attributes.normal;\r\n    const color = attributes.color;\r\n    const uv = attributes.uv;\r\n    const uv2 = attributes.uv2;\r\n    if (uv2 !== undefined) this.faceVertexUvs[1] = [];\r\n\r\n    for (let i = 0; i < position.count; i++) {\r\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\r\n\r\n      if (color !== undefined) {\r\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\r\n      }\r\n    }\r\n\r\n    function addFace(a, b, c, materialIndex) {\r\n      const vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\r\n      const vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\r\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\r\n      scope.faces.push(face);\r\n\r\n      if (uv !== undefined) {\r\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\r\n      }\r\n\r\n      if (uv2 !== undefined) {\r\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\r\n      }\r\n    }\r\n\r\n    const groups = geometry.groups;\r\n\r\n    if (groups.length > 0) {\r\n      for (let i = 0; i < groups.length; i++) {\r\n        const group = groups[i];\r\n        const start = group.start;\r\n        const count = group.count;\r\n\r\n        for (let j = start, jl = start + count; j < jl; j += 3) {\r\n          if (index !== undefined) {\r\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\r\n          } else {\r\n            addFace(j, j + 1, j + 2, group.materialIndex);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      if (index !== undefined) {\r\n        for (let i = 0; i < index.count; i += 3) {\r\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\r\n        }\r\n      } else {\r\n        for (let i = 0; i < position.count; i += 3) {\r\n          addFace(i, i + 1, i + 2);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.computeFaceNormals();\r\n\r\n    if (geometry.boundingBox !== null) {\r\n      this.boundingBox = geometry.boundingBox.clone();\r\n    }\r\n\r\n    if (geometry.boundingSphere !== null) {\r\n      this.boundingSphere = geometry.boundingSphere.clone();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  center() {\r\n    this.computeBoundingBox();\r\n    this.boundingBox.getCenter(_offset).negate();\r\n    this.translate(_offset.x, _offset.y, _offset.z);\r\n    return this;\r\n  }\r\n\r\n  normalize() {\r\n    this.computeBoundingSphere();\r\n    const center = this.boundingSphere.center;\r\n    const radius = this.boundingSphere.radius;\r\n    const s = radius === 0 ? 1 : 1.0 / radius;\r\n    const matrix = new Matrix4();\r\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\r\n    this.applyMatrix4(matrix);\r\n    return this;\r\n  }\r\n\r\n  computeFaceNormals() {\r\n    const cb = new Vector3(),\r\n          ab = new Vector3();\r\n\r\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n      const face = this.faces[f];\r\n      const vA = this.vertices[face.a];\r\n      const vB = this.vertices[face.b];\r\n      const vC = this.vertices[face.c];\r\n      cb.subVectors(vC, vB);\r\n      ab.subVectors(vA, vB);\r\n      cb.cross(ab);\r\n      cb.normalize();\r\n      face.normal.copy(cb);\r\n    }\r\n  }\r\n\r\n  computeVertexNormals(areaWeighted = true) {\r\n    const vertices = new Array(this.vertices.length);\r\n\r\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\r\n      vertices[v] = new Vector3();\r\n    }\r\n\r\n    if (areaWeighted) {\r\n      // vertex normals weighted by triangle areas\r\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\r\n      const cb = new Vector3(),\r\n            ab = new Vector3();\r\n\r\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n        const face = this.faces[f];\r\n        const vA = this.vertices[face.a];\r\n        const vB = this.vertices[face.b];\r\n        const vC = this.vertices[face.c];\r\n        cb.subVectors(vC, vB);\r\n        ab.subVectors(vA, vB);\r\n        cb.cross(ab);\r\n        vertices[face.a].add(cb);\r\n        vertices[face.b].add(cb);\r\n        vertices[face.c].add(cb);\r\n      }\r\n    } else {\r\n      this.computeFaceNormals();\r\n\r\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n        const face = this.faces[f];\r\n        vertices[face.a].add(face.normal);\r\n        vertices[face.b].add(face.normal);\r\n        vertices[face.c].add(face.normal);\r\n      }\r\n    }\r\n\r\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\r\n      vertices[v].normalize();\r\n    }\r\n\r\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n      const face = this.faces[f];\r\n      const vertexNormals = face.vertexNormals;\r\n\r\n      if (vertexNormals.length === 3) {\r\n        vertexNormals[0].copy(vertices[face.a]);\r\n        vertexNormals[1].copy(vertices[face.b]);\r\n        vertexNormals[2].copy(vertices[face.c]);\r\n      } else {\r\n        vertexNormals[0] = vertices[face.a].clone();\r\n        vertexNormals[1] = vertices[face.b].clone();\r\n        vertexNormals[2] = vertices[face.c].clone();\r\n      }\r\n    }\r\n\r\n    if (this.faces.length > 0) {\r\n      this.normalsNeedUpdate = true;\r\n    }\r\n  }\r\n\r\n  computeFlatVertexNormals() {\r\n    this.computeFaceNormals();\r\n\r\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n      const face = this.faces[f];\r\n      const vertexNormals = face.vertexNormals;\r\n\r\n      if (vertexNormals.length === 3) {\r\n        vertexNormals[0].copy(face.normal);\r\n        vertexNormals[1].copy(face.normal);\r\n        vertexNormals[2].copy(face.normal);\r\n      } else {\r\n        vertexNormals[0] = face.normal.clone();\r\n        vertexNormals[1] = face.normal.clone();\r\n        vertexNormals[2] = face.normal.clone();\r\n      }\r\n    }\r\n\r\n    if (this.faces.length > 0) {\r\n      this.normalsNeedUpdate = true;\r\n    }\r\n  }\r\n\r\n  computeMorphNormals() {\r\n    // save original normals\r\n    // - create temp variables on first access\r\n    //   otherwise just copy (for faster repeated calls)\r\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n      const face = this.faces[f];\r\n\r\n      if (!face.__originalFaceNormal) {\r\n        face.__originalFaceNormal = face.normal.clone();\r\n      } else {\r\n        face.__originalFaceNormal.copy(face.normal);\r\n      }\r\n\r\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\r\n\r\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\r\n        if (!face.__originalVertexNormals[i]) {\r\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\r\n        } else {\r\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\r\n        }\r\n      }\r\n    } // use temp geometry to compute face and vertex normals for each morph\r\n\r\n\r\n    const tmpGeo = new Geometry();\r\n    tmpGeo.faces = this.faces;\r\n\r\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\r\n      // create on first access\r\n      if (!this.morphNormals[i]) {\r\n        this.morphNormals[i] = {};\r\n        this.morphNormals[i].faceNormals = [];\r\n        this.morphNormals[i].vertexNormals = [];\r\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\r\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\r\n\r\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n          const faceNormal = new Vector3();\r\n          const vertexNormals = {\r\n            a: new Vector3(),\r\n            b: new Vector3(),\r\n            c: new Vector3()\r\n          };\r\n          dstNormalsFace.push(faceNormal);\r\n          dstNormalsVertex.push(vertexNormals);\r\n        }\r\n      }\r\n\r\n      const morphNormals = this.morphNormals[i]; // set vertices to morph target\r\n\r\n      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals\r\n\r\n      tmpGeo.computeFaceNormals();\r\n      tmpGeo.computeVertexNormals(); // store morph normals\r\n\r\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n        const face = this.faces[f];\r\n        const faceNormal = morphNormals.faceNormals[f];\r\n        const vertexNormals = morphNormals.vertexNormals[f];\r\n        faceNormal.copy(face.normal);\r\n        vertexNormals.a.copy(face.vertexNormals[0]);\r\n        vertexNormals.b.copy(face.vertexNormals[1]);\r\n        vertexNormals.c.copy(face.vertexNormals[2]);\r\n      }\r\n    } // restore original normals\r\n\r\n\r\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n      const face = this.faces[f];\r\n      face.normal = face.__originalFaceNormal;\r\n      face.vertexNormals = face.__originalVertexNormals;\r\n    }\r\n  }\r\n\r\n  computeBoundingBox() {\r\n    if (this.boundingBox === null) {\r\n      this.boundingBox = new Box3();\r\n    }\r\n\r\n    this.boundingBox.setFromPoints(this.vertices);\r\n  }\r\n\r\n  computeBoundingSphere() {\r\n    if (this.boundingSphere === null) {\r\n      this.boundingSphere = new Sphere();\r\n    }\r\n\r\n    this.boundingSphere.setFromPoints(this.vertices);\r\n  }\r\n\r\n  merge(geometry, matrix, materialIndexOffset = 0) {\r\n    if (!(geometry && geometry.isGeometry)) {\r\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\r\n      return;\r\n    }\r\n\r\n    let normalMatrix;\r\n    const vertexOffset = this.vertices.length,\r\n          vertices1 = this.vertices,\r\n          vertices2 = geometry.vertices,\r\n          faces1 = this.faces,\r\n          faces2 = geometry.faces,\r\n          colors1 = this.colors,\r\n          colors2 = geometry.colors;\r\n\r\n    if (matrix !== undefined) {\r\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\r\n    } // vertices\r\n\r\n\r\n    for (let i = 0, il = vertices2.length; i < il; i++) {\r\n      const vertex = vertices2[i];\r\n      const vertexCopy = vertex.clone();\r\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\r\n      vertices1.push(vertexCopy);\r\n    } // colors\r\n\r\n\r\n    for (let i = 0, il = colors2.length; i < il; i++) {\r\n      colors1.push(colors2[i].clone());\r\n    } // faces\r\n\r\n\r\n    for (let i = 0, il = faces2.length; i < il; i++) {\r\n      const face = faces2[i];\r\n      let normal, color;\r\n      const faceVertexNormals = face.vertexNormals,\r\n            faceVertexColors = face.vertexColors;\r\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\r\n      faceCopy.normal.copy(face.normal);\r\n\r\n      if (normalMatrix !== undefined) {\r\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\r\n      }\r\n\r\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\r\n        normal = faceVertexNormals[j].clone();\r\n\r\n        if (normalMatrix !== undefined) {\r\n          normal.applyMatrix3(normalMatrix).normalize();\r\n        }\r\n\r\n        faceCopy.vertexNormals.push(normal);\r\n      }\r\n\r\n      faceCopy.color.copy(face.color);\r\n\r\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\r\n        color = faceVertexColors[j];\r\n        faceCopy.vertexColors.push(color.clone());\r\n      }\r\n\r\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n      faces1.push(faceCopy);\r\n    } // uvs\r\n\r\n\r\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\r\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\r\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];\r\n\r\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\r\n        const uvs2 = faceVertexUvs2[j],\r\n              uvsCopy = [];\r\n\r\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\r\n          uvsCopy.push(uvs2[k].clone());\r\n        }\r\n\r\n        this.faceVertexUvs[i].push(uvsCopy);\r\n      }\r\n    }\r\n  }\r\n\r\n  mergeMesh(mesh) {\r\n    if (!(mesh && mesh.isMesh)) {\r\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\r\n      return;\r\n    }\r\n\r\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\r\n    this.merge(mesh.geometry, mesh.matrix);\r\n  }\r\n  /*\r\n   * Checks for duplicate vertices with hashmap.\r\n   * Duplicated vertices are removed\r\n   * and faces' vertices are updated.\r\n   */\r\n\r\n\r\n  mergeVertices(precisionPoints = 4) {\r\n    const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n\r\n    const unique = [],\r\n          changes = [];\r\n    const precision = Math.pow(10, precisionPoints);\r\n\r\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\r\n      const v = this.vertices[i];\r\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\r\n\r\n      if (verticesMap[key] === undefined) {\r\n        verticesMap[key] = i;\r\n        unique.push(this.vertices[i]);\r\n        changes[i] = unique.length - 1;\r\n      } else {\r\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n        changes[i] = changes[verticesMap[key]];\r\n      }\r\n    } // if faces are completely degenerate after merging vertices, we\r\n    // have to remove them from the geometry.\r\n\r\n\r\n    const faceIndicesToRemove = [];\r\n\r\n    for (let i = 0, il = this.faces.length; i < il; i++) {\r\n      const face = this.faces[i];\r\n      face.a = changes[face.a];\r\n      face.b = changes[face.b];\r\n      face.c = changes[face.c];\r\n      const indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\r\n      // we have to remove the face as nothing can be saved\r\n\r\n      for (let n = 0; n < 3; n++) {\r\n        if (indices[n] === indices[(n + 1) % 3]) {\r\n          faceIndicesToRemove.push(i);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\r\n      const idx = faceIndicesToRemove[i];\r\n      this.faces.splice(idx, 1);\r\n\r\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\r\n        this.faceVertexUvs[j].splice(idx, 1);\r\n      }\r\n    } // Use unique set of vertices\r\n\r\n\r\n    const diff = this.vertices.length - unique.length;\r\n    this.vertices = unique;\r\n    return diff;\r\n  }\r\n\r\n  setFromPoints(points) {\r\n    this.vertices = [];\r\n\r\n    for (let i = 0, l = points.length; i < l; i++) {\r\n      const point = points[i];\r\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  sortFacesByMaterialIndex() {\r\n    const faces = this.faces;\r\n    const length = faces.length; // tag faces\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      faces[i]._id = i;\r\n    } // sort faces\r\n\r\n\r\n    function materialIndexSort(a, b) {\r\n      return a.materialIndex - b.materialIndex;\r\n    }\r\n\r\n    faces.sort(materialIndexSort); // sort uvs\r\n\r\n    const uvs1 = this.faceVertexUvs[0];\r\n    const uvs2 = this.faceVertexUvs[1];\r\n    let newUvs1, newUvs2;\r\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\r\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      const id = faces[i]._id;\r\n      if (newUvs1) newUvs1.push(uvs1[id]);\r\n      if (newUvs2) newUvs2.push(uvs2[id]);\r\n    }\r\n\r\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\r\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\r\n  }\r\n\r\n  toJSON() {\r\n    const data = {\r\n      metadata: {\r\n        version: 4.5,\r\n        type: 'Geometry',\r\n        generator: 'Geometry.toJSON'\r\n      }\r\n    }; // standard Geometry serialization\r\n\r\n    data.uuid = this.uuid;\r\n    data.type = this.type;\r\n    if (this.name !== '') data.name = this.name;\r\n\r\n    if (this.parameters !== undefined) {\r\n      const parameters = this.parameters;\r\n\r\n      for (let key in parameters) {\r\n        if (parameters[key] !== undefined) data[key] = parameters[key];\r\n      }\r\n\r\n      return data;\r\n    }\r\n\r\n    const vertices = [];\r\n\r\n    for (let i = 0; i < this.vertices.length; i++) {\r\n      const vertex = this.vertices[i];\r\n      vertices.push(vertex.x, vertex.y, vertex.z);\r\n    }\r\n\r\n    const faces = [];\r\n    const normals = [];\r\n    const normalsHash = {};\r\n    const colors = [];\r\n    const colorsHash = {};\r\n    const uvs = [];\r\n    const uvsHash = {};\r\n\r\n    for (let i = 0; i < this.faces.length; i++) {\r\n      const face = this.faces[i];\r\n      const hasMaterial = true;\r\n      const hasFaceUv = false; // deprecated\r\n\r\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\r\n      const hasFaceNormal = face.normal.length() > 0;\r\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n      const hasFaceVertexColor = face.vertexColors.length > 0;\r\n      let faceType = 0;\r\n      faceType = setBit(faceType, 0, 0); // isQuad\r\n\r\n      faceType = setBit(faceType, 1, hasMaterial);\r\n      faceType = setBit(faceType, 2, hasFaceUv);\r\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\r\n      faceType = setBit(faceType, 4, hasFaceNormal);\r\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\r\n      faceType = setBit(faceType, 6, hasFaceColor);\r\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\r\n      faces.push(faceType);\r\n      faces.push(face.a, face.b, face.c);\r\n      faces.push(face.materialIndex);\r\n\r\n      if (hasFaceVertexUv) {\r\n        const faceVertexUvs = this.faceVertexUvs[0][i];\r\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\r\n      }\r\n\r\n      if (hasFaceNormal) {\r\n        faces.push(getNormalIndex(face.normal));\r\n      }\r\n\r\n      if (hasFaceVertexNormal) {\r\n        const vertexNormals = face.vertexNormals;\r\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\r\n      }\r\n\r\n      if (hasFaceColor) {\r\n        faces.push(getColorIndex(face.color));\r\n      }\r\n\r\n      if (hasFaceVertexColor) {\r\n        const vertexColors = face.vertexColors;\r\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\r\n      }\r\n    }\r\n\r\n    function setBit(value, position, enabled) {\r\n      return enabled ? value | 1 << position : value & ~(1 << position);\r\n    }\r\n\r\n    function getNormalIndex(normal) {\r\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\r\n      if (normalsHash[hash] !== undefined) {\r\n        return normalsHash[hash];\r\n      }\r\n\r\n      normalsHash[hash] = normals.length / 3;\r\n      normals.push(normal.x, normal.y, normal.z);\r\n      return normalsHash[hash];\r\n    }\r\n\r\n    function getColorIndex(color) {\r\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\r\n      if (colorsHash[hash] !== undefined) {\r\n        return colorsHash[hash];\r\n      }\r\n\r\n      colorsHash[hash] = colors.length;\r\n      colors.push(color.getHex());\r\n      return colorsHash[hash];\r\n    }\r\n\r\n    function getUvIndex(uv) {\r\n      const hash = uv.x.toString() + uv.y.toString();\r\n\r\n      if (uvsHash[hash] !== undefined) {\r\n        return uvsHash[hash];\r\n      }\r\n\r\n      uvsHash[hash] = uvs.length / 2;\r\n      uvs.push(uv.x, uv.y);\r\n      return uvsHash[hash];\r\n    }\r\n\r\n    data.data = {};\r\n    data.data.vertices = vertices;\r\n    data.data.normals = normals;\r\n    if (colors.length > 0) data.data.colors = colors;\r\n    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\r\n\r\n    data.data.faces = faces;\r\n    return data;\r\n  }\r\n\r\n  clone() {\r\n    /*\r\n    // Handle primitives\r\n    const parameters = this.parameters;\r\n    if ( parameters !== undefined ) {\r\n    const values = [];\r\n    for ( const key in parameters ) {\r\n    values.push( parameters[ key ] );\r\n    }\r\n    const geometry = Object.create( this.constructor.prototype );\r\n    this.constructor.apply( geometry, values );\r\n    return geometry;\r\n    }\r\n    return new this.constructor().copy( this );\r\n    */\r\n    return new Geometry().copy(this);\r\n  }\r\n\r\n  copy(source) {\r\n    // reset\r\n    this.vertices = [];\r\n    this.colors = [];\r\n    this.faces = [];\r\n    this.faceVertexUvs = [[]];\r\n    this.morphTargets = [];\r\n    this.morphNormals = [];\r\n    this.skinWeights = [];\r\n    this.skinIndices = [];\r\n    this.lineDistances = [];\r\n    this.boundingBox = null;\r\n    this.boundingSphere = null; // name\r\n\r\n    this.name = source.name; // vertices\r\n\r\n    const vertices = source.vertices;\r\n\r\n    for (let i = 0, il = vertices.length; i < il; i++) {\r\n      this.vertices.push(vertices[i].clone());\r\n    } // colors\r\n\r\n\r\n    const colors = source.colors;\r\n\r\n    for (let i = 0, il = colors.length; i < il; i++) {\r\n      this.colors.push(colors[i].clone());\r\n    } // faces\r\n\r\n\r\n    const faces = source.faces;\r\n\r\n    for (let i = 0, il = faces.length; i < il; i++) {\r\n      this.faces.push(faces[i].clone());\r\n    } // face vertex uvs\r\n\r\n\r\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\r\n      const faceVertexUvs = source.faceVertexUvs[i];\r\n\r\n      if (this.faceVertexUvs[i] === undefined) {\r\n        this.faceVertexUvs[i] = [];\r\n      }\r\n\r\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\r\n        const uvs = faceVertexUvs[j],\r\n              uvsCopy = [];\r\n\r\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\r\n          const uv = uvs[k];\r\n          uvsCopy.push(uv.clone());\r\n        }\r\n\r\n        this.faceVertexUvs[i].push(uvsCopy);\r\n      }\r\n    } // morph targets\r\n\r\n\r\n    const morphTargets = source.morphTargets;\r\n\r\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\r\n      const morphTarget = {};\r\n      morphTarget.name = morphTargets[i].name; // vertices\r\n\r\n      if (morphTargets[i].vertices !== undefined) {\r\n        morphTarget.vertices = [];\r\n\r\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\r\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\r\n        }\r\n      } // normals\r\n\r\n\r\n      if (morphTargets[i].normals !== undefined) {\r\n        morphTarget.normals = [];\r\n\r\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\r\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\r\n        }\r\n      }\r\n\r\n      this.morphTargets.push(morphTarget);\r\n    } // morph normals\r\n\r\n\r\n    const morphNormals = source.morphNormals;\r\n\r\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\r\n      const morphNormal = {}; // vertex normals\r\n\r\n      if (morphNormals[i].vertexNormals !== undefined) {\r\n        morphNormal.vertexNormals = [];\r\n\r\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\r\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\r\n          const destVertexNormal = {};\r\n          destVertexNormal.a = srcVertexNormal.a.clone();\r\n          destVertexNormal.b = srcVertexNormal.b.clone();\r\n          destVertexNormal.c = srcVertexNormal.c.clone();\r\n          morphNormal.vertexNormals.push(destVertexNormal);\r\n        }\r\n      } // face normals\r\n\r\n\r\n      if (morphNormals[i].faceNormals !== undefined) {\r\n        morphNormal.faceNormals = [];\r\n\r\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\r\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\r\n        }\r\n      }\r\n\r\n      this.morphNormals.push(morphNormal);\r\n    } // skin weights\r\n\r\n\r\n    const skinWeights = source.skinWeights;\r\n\r\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\r\n      this.skinWeights.push(skinWeights[i].clone());\r\n    } // skin indices\r\n\r\n\r\n    const skinIndices = source.skinIndices;\r\n\r\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\r\n      this.skinIndices.push(skinIndices[i].clone());\r\n    } // line distances\r\n\r\n\r\n    const lineDistances = source.lineDistances;\r\n\r\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\r\n      this.lineDistances.push(lineDistances[i]);\r\n    } // bounding box\r\n\r\n\r\n    const boundingBox = source.boundingBox;\r\n\r\n    if (boundingBox !== null) {\r\n      this.boundingBox = boundingBox.clone();\r\n    } // bounding sphere\r\n\r\n\r\n    const boundingSphere = source.boundingSphere;\r\n\r\n    if (boundingSphere !== null) {\r\n      this.boundingSphere = boundingSphere.clone();\r\n    } // update flags\r\n\r\n\r\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\r\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\r\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\r\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\r\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\r\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\r\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\r\n    return this;\r\n  }\r\n\r\n  toBufferGeometry() {\r\n    const geometry = new DirectGeometry().fromGeometry(this);\r\n    const buffergeometry = new BufferGeometry();\r\n    const positions = new Float32Array(geometry.vertices.length * 3);\r\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\r\n\r\n    if (geometry.normals.length > 0) {\r\n      const normals = new Float32Array(geometry.normals.length * 3);\r\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\r\n    }\r\n\r\n    if (geometry.colors.length > 0) {\r\n      const colors = new Float32Array(geometry.colors.length * 3);\r\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\r\n    }\r\n\r\n    if (geometry.uvs.length > 0) {\r\n      const uvs = new Float32Array(geometry.uvs.length * 2);\r\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\r\n    }\r\n\r\n    if (geometry.uvs2.length > 0) {\r\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\r\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\r\n    } // groups\r\n\r\n\r\n    buffergeometry.groups = geometry.groups; // morphs\r\n\r\n    for (let name in geometry.morphTargets) {\r\n      const array = [];\r\n      const morphTargets = geometry.morphTargets[name];\r\n\r\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\r\n        const morphTarget = morphTargets[i];\r\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\r\n        attribute.name = morphTarget.name;\r\n        array.push(attribute.copyVector3sArray(morphTarget.data));\r\n      }\r\n\r\n      buffergeometry.morphAttributes[name] = array;\r\n    } // skinning\r\n\r\n\r\n    if (geometry.skinIndices.length > 0) {\r\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\r\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\r\n    }\r\n\r\n    if (geometry.skinWeights.length > 0) {\r\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\r\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\r\n    } //\r\n\r\n\r\n    if (geometry.boundingSphere !== null) {\r\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\r\n    }\r\n\r\n    if (geometry.boundingBox !== null) {\r\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\r\n    }\r\n\r\n    return buffergeometry;\r\n  }\r\n\r\n  computeTangents() {\r\n    console.error('THREE.Geometry: .computeTangents() has been removed.');\r\n  }\r\n\r\n  computeLineDistances() {\r\n    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\r\n  }\r\n\r\n  applyMatrix(matrix) {\r\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\r\n    return this.applyMatrix4(matrix);\r\n  }\r\n\r\n  dispose() {\r\n    this.dispatchEvent({\r\n      type: 'dispose'\r\n    });\r\n  }\r\n\r\n}\r\n\r\nGeometry.createBufferGeometryFromObject = object => {\r\n  let buffergeometry = new BufferGeometry();\r\n  const geometry = object.geometry;\r\n\r\n  if (object.isPoints || object.isLine) {\r\n    const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\r\n    const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\r\n    buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\r\n    buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\r\n\r\n    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\r\n      const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\r\n      buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\r\n    }\r\n\r\n    if (geometry.boundingSphere !== null) {\r\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\r\n    }\r\n\r\n    if (geometry.boundingBox !== null) {\r\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\r\n    }\r\n  } else if (object.isMesh) {\r\n    buffergeometry = geometry.toBufferGeometry();\r\n  }\r\n\r\n  return buffergeometry;\r\n};\r\n\r\nclass DirectGeometry {\r\n  constructor() {\r\n    this.vertices = [];\r\n    this.normals = [];\r\n    this.colors = [];\r\n    this.uvs = [];\r\n    this.uvs2 = [];\r\n    this.groups = [];\r\n    this.morphTargets = {};\r\n    this.skinWeights = [];\r\n    this.skinIndices = []; // this.lineDistances = [];\r\n\r\n    this.boundingBox = null;\r\n    this.boundingSphere = null; // update flags\r\n\r\n    this.verticesNeedUpdate = false;\r\n    this.normalsNeedUpdate = false;\r\n    this.colorsNeedUpdate = false;\r\n    this.uvsNeedUpdate = false;\r\n    this.groupsNeedUpdate = false;\r\n  }\r\n\r\n  computeGroups(geometry) {\r\n    const groups = [];\r\n    let group, i;\r\n    let materialIndex = undefined;\r\n    const faces = geometry.faces;\r\n\r\n    for (i = 0; i < faces.length; i++) {\r\n      const face = faces[i]; // materials\r\n\r\n      if (face.materialIndex !== materialIndex) {\r\n        materialIndex = face.materialIndex;\r\n\r\n        if (group !== undefined) {\r\n          group.count = i * 3 - group.start;\r\n          groups.push(group);\r\n        }\r\n\r\n        group = {\r\n          start: i * 3,\r\n          materialIndex\r\n        };\r\n      }\r\n    }\r\n\r\n    if (group !== undefined) {\r\n      group.count = i * 3 - group.start;\r\n      groups.push(group);\r\n    }\r\n\r\n    this.groups = groups;\r\n  }\r\n\r\n  fromGeometry(geometry) {\r\n    const faces = geometry.faces;\r\n    const vertices = geometry.vertices;\r\n    const faceVertexUvs = geometry.faceVertexUvs;\r\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\r\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\r\n\r\n    const morphTargets = geometry.morphTargets;\r\n    const morphTargetsLength = morphTargets.length;\r\n    let morphTargetsPosition;\r\n\r\n    if (morphTargetsLength > 0) {\r\n      morphTargetsPosition = [];\r\n\r\n      for (let i = 0; i < morphTargetsLength; i++) {\r\n        morphTargetsPosition[i] = {\r\n          name: morphTargets[i].name,\r\n          data: []\r\n        };\r\n      }\r\n\r\n      this.morphTargets.position = morphTargetsPosition;\r\n    }\r\n\r\n    const morphNormals = geometry.morphNormals;\r\n    const morphNormalsLength = morphNormals.length;\r\n    let morphTargetsNormal;\r\n\r\n    if (morphNormalsLength > 0) {\r\n      morphTargetsNormal = [];\r\n\r\n      for (let i = 0; i < morphNormalsLength; i++) {\r\n        morphTargetsNormal[i] = {\r\n          name: morphNormals[i].name,\r\n          data: []\r\n        };\r\n      }\r\n\r\n      this.morphTargets.normal = morphTargetsNormal;\r\n    } // skins\r\n\r\n\r\n    const skinIndices = geometry.skinIndices;\r\n    const skinWeights = geometry.skinWeights;\r\n    const hasSkinIndices = skinIndices.length === vertices.length;\r\n    const hasSkinWeights = skinWeights.length === vertices.length; //\r\n\r\n    if (vertices.length > 0 && faces.length === 0) {\r\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\r\n    }\r\n\r\n    for (let i = 0; i < faces.length; i++) {\r\n      const face = faces[i];\r\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\r\n      const vertexNormals = face.vertexNormals;\r\n\r\n      if (vertexNormals.length === 3) {\r\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\r\n      } else {\r\n        const normal = face.normal;\r\n        this.normals.push(normal, normal, normal);\r\n      }\r\n\r\n      const vertexColors = face.vertexColors;\r\n\r\n      if (vertexColors.length === 3) {\r\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\r\n      } else {\r\n        const color = face.color;\r\n        this.colors.push(color, color, color);\r\n      }\r\n\r\n      if (hasFaceVertexUv === true) {\r\n        const vertexUvs = faceVertexUvs[0][i];\r\n\r\n        if (vertexUvs !== undefined) {\r\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\r\n        } else {\r\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\r\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\r\n        }\r\n      }\r\n\r\n      if (hasFaceVertexUv2 === true) {\r\n        const vertexUvs = faceVertexUvs[1][i];\r\n\r\n        if (vertexUvs !== undefined) {\r\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\r\n        } else {\r\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\r\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\r\n        }\r\n      } // morphs\r\n\r\n\r\n      for (let j = 0; j < morphTargetsLength; j++) {\r\n        const morphTarget = morphTargets[j].vertices;\r\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\r\n      }\r\n\r\n      for (let j = 0; j < morphNormalsLength; j++) {\r\n        const morphNormal = morphNormals[j].vertexNormals[i];\r\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\r\n      } // skins\r\n\r\n\r\n      if (hasSkinIndices) {\r\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\r\n      }\r\n\r\n      if (hasSkinWeights) {\r\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\r\n      }\r\n    }\r\n\r\n    this.computeGroups(geometry);\r\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n    if (geometry.boundingSphere !== null) {\r\n      this.boundingSphere = geometry.boundingSphere.clone();\r\n    }\r\n\r\n    if (geometry.boundingBox !== null) {\r\n      this.boundingBox = geometry.boundingBox.clone();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n}\r\n\r\nclass Face3 {\r\n  constructor(a, b, c, normal, color, materialIndex = 0) {\r\n    this.a = a;\r\n    this.b = b;\r\n    this.c = c;\r\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\r\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\r\n    this.color = color && color.isColor ? color : new Color();\r\n    this.vertexColors = Array.isArray(color) ? color : [];\r\n    this.materialIndex = materialIndex;\r\n  }\r\n\r\n  clone() {\r\n    return new this.constructor().copy(this);\r\n  }\r\n\r\n  copy(source) {\r\n    this.a = source.a;\r\n    this.b = source.b;\r\n    this.c = source.c;\r\n    this.normal.copy(source.normal);\r\n    this.color.copy(source.color);\r\n    this.materialIndex = source.materialIndex;\r\n\r\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\r\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\r\n    }\r\n\r\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\r\n      this.vertexColors[i] = source.vertexColors[i].clone();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n}\r\n\r\nexport { Face3, Geometry };\r\n", "import { ShaderMaterial, Material } from 'three';\r\nimport { getNodesKeys } from '../core/NodeUtils.js';\r\n\r\nclass NodeMaterial extends ShaderMaterial {\r\n  constructor() {\r\n    super();\r\n    this.type = this.constructor.name;\r\n    this.lights = true;\r\n  }\r\n\r\n  setDefaultValues(values) {\r\n    // This approach is to reuse the native refreshUniforms*\r\n    // and turn available the use of features like transmission and environment in core\r\n    let value;\r\n\r\n    for (const property in values) {\r\n      value = values[property];\r\n\r\n      if (this[property] === undefined) {\r\n        if (value && typeof value.clone === 'function') {\r\n          this[property] = value.clone();\r\n        } else {\r\n          this[property] = value;\r\n        }\r\n      }\r\n    }\r\n\r\n    Object.assign(this.defines, values.defines);\r\n  }\r\n\r\n  toJSON(meta) {\r\n    const isRoot = meta === undefined || typeof meta === 'string';\r\n\r\n    if (isRoot) {\r\n      meta = {\r\n        textures: {},\r\n        images: {},\r\n        nodes: {}\r\n      };\r\n    }\r\n\r\n    const data = Material.prototype.toJSON.call(this, meta);\r\n    const nodeKeys = getNodesKeys(this);\r\n    data.inputNodes = {};\r\n\r\n    for (const name of nodeKeys) {\r\n      data.inputNodes[name] = this[name].toJSON(meta).uuid;\r\n    } // TODO: Copied from Object3D.toJSON\r\n\r\n\r\n    function extractFromCache(cache) {\r\n      const values = [];\r\n\r\n      for (const key in cache) {\r\n        const data = cache[key];\r\n        delete data.metadata;\r\n        values.push(data);\r\n      }\r\n\r\n      return values;\r\n    }\r\n\r\n    if (isRoot) {\r\n      const textures = extractFromCache(meta.textures);\r\n      const images = extractFromCache(meta.images);\r\n      const nodes = extractFromCache(meta.nodes);\r\n      if (textures.length > 0) data.textures = textures;\r\n      if (images.length > 0) data.images = images;\r\n      if (nodes.length > 0) data.nodes = nodes;\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n}\r\n\r\nNodeMaterial.prototype.isNodeMaterial = true;\r\n\r\nexport default NodeMaterial;\r\n", "import NodeMaterial from './NodeMaterial.js';\r\nimport { LineBasicMaterial } from 'three';\r\n\r\nconst defaultValues = new LineBasicMaterial();\r\n\r\nclass LineBasicNodeMaterial extends NodeMaterial {\r\n  constructor(parameters) {\r\n    super();\r\n    this.colorNode = null;\r\n    this.opacityNode = null;\r\n    this.alphaTestNode = null;\r\n    this.lightNode = null;\r\n    this.positionNode = null;\r\n    this.setDefaultValues(defaultValues);\r\n    this.setValues(parameters);\r\n  }\r\n\r\n  copy(source) {\r\n    this.colorNode = source.colorNode;\r\n    this.opacityNode = source.opacityNode;\r\n    this.alphaTestNode = source.alphaTestNode;\r\n    this.lightNode = source.lightNode;\r\n    this.positionNode = source.positionNode;\r\n    return super.copy(source);\r\n  }\r\n\r\n}\r\n\r\nLineBasicNodeMaterial.prototype.isLineBasicNodeMaterial = true;\r\n\r\nexport default LineBasicNodeMaterial;\r\n", "import NodeMaterial from './NodeMaterial.js';\r\nimport { MeshBasicMaterial } from 'three';\r\n\r\nconst defaultValues = new MeshBasicMaterial();\r\n\r\nclass MeshBasicNodeMaterial extends NodeMaterial {\r\n  constructor(parameters) {\r\n    super();\r\n    this.lights = true;\r\n    this.colorNode = null;\r\n    this.opacityNode = null;\r\n    this.alphaTestNode = null;\r\n    this.lightNode = null;\r\n    this.positionNode = null;\r\n    this.setDefaultValues(defaultValues);\r\n    this.setValues(parameters);\r\n  }\r\n\r\n  copy(source) {\r\n    this.colorNode = source.colorNode;\r\n    this.opacityNode = source.opacityNode;\r\n    this.alphaTestNode = source.alphaTestNode;\r\n    this.lightNode = source.lightNode;\r\n    this.positionNode = source.positionNode;\r\n    return super.copy(source);\r\n  }\r\n\r\n}\r\n\r\nMeshBasicNodeMaterial.prototype.isMeshBasicNodeMaterial = true;\r\n\r\nexport default MeshBasicNodeMaterial;\r\n", "import NodeMaterial from './NodeMaterial.js';\r\nimport { MeshStandardMaterial } from 'three';\r\n\r\nconst defaultValues = new MeshStandardMaterial();\r\nclass MeshStandardNodeMaterial extends NodeMaterial {\r\n  constructor(parameters) {\r\n    super();\r\n    this.colorNode = null;\r\n    this.opacityNode = null;\r\n    this.alphaTestNode = null;\r\n    this.normalNode = null;\r\n    this.emissiveNode = null;\r\n    this.metalnessNode = null;\r\n    this.roughnessNode = null;\r\n    this.clearcoatNode = null;\r\n    this.clearcoatRoughnessNode = null;\r\n    this.envNode = null;\r\n    this.lightNode = null;\r\n    this.positionNode = null;\r\n    this.setDefaultValues(defaultValues);\r\n    this.setValues(parameters);\r\n  }\r\n\r\n  copy(source) {\r\n    this.colorNode = source.colorNode;\r\n    this.opacityNode = source.opacityNode;\r\n    this.alphaTestNode = source.alphaTestNode;\r\n    this.normalNode = source.normalNode;\r\n    this.emissiveNode = source.emissiveNode;\r\n    this.metalnessNode = source.metalnessNode;\r\n    this.roughnessNode = source.roughnessNode;\r\n    this.clearcoatNode = source.clearcoatNode;\r\n    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;\r\n    this.envNode = source.envNode;\r\n    this.lightNode = source.lightNode;\r\n    this.positionNode = source.positionNode;\r\n    return super.copy(source);\r\n  }\r\n\r\n}\r\nMeshStandardNodeMaterial.prototype.isMeshStandardNodeMaterial = true;\r\n\r\nexport default MeshStandardNodeMaterial;\r\n", "import NodeMaterial from './NodeMaterial.js';\r\nimport { PointsMaterial } from 'three';\r\n\r\nconst defaultValues = new PointsMaterial();\r\n\r\nclass PointsNodeMaterial extends NodeMaterial {\r\n  constructor(parameters) {\r\n    super();\r\n    this.transparent = true;\r\n    this.colorNode = null;\r\n    this.opacityNode = null;\r\n    this.alphaTestNode = null;\r\n    this.lightNode = null;\r\n    this.sizeNode = null;\r\n    this.positionNode = null;\r\n    this.setDefaultValues(defaultValues);\r\n    this.setValues(parameters);\r\n  }\r\n\r\n  copy(source) {\r\n    this.colorNode = source.colorNode;\r\n    this.opacityNode = source.opacityNode;\r\n    this.alphaTestNode = source.alphaTestNode;\r\n    this.lightNode = source.lightNode;\r\n    this.sizeNode = source.sizeNode;\r\n    this.positionNode = source.positionNode;\r\n    return super.copy(source);\r\n  }\r\n\r\n}\r\n\r\nPointsNodeMaterial.prototype.isPointsNodeMaterial = true;\r\n\r\nexport default PointsNodeMaterial;\r\n"],
  "mappings": "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,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE,CAAC;;;ACtlBlhc,IAAM,eAAN,MAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASjB,YAAY,IAAI,MAAM;AACpB,oBAAgB,MAAM,SAAS,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,EAAE,GAAG,CAAC,IAAI,GAAG,EAAE,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,EAAE,GAAG,CAAC,GAAG,IAAI,EAAE,CAAC,CAAC;AAE/K,oBAAgB,MAAM,SAAS,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,GAAG,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,IAAI,EAAE,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,EAAE,GAAG,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,IAAI,EAAE,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,GAAG,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,IAAI,EAAE,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,GAAG,EAAE,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,IAAI,EAAE,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,EAAE,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,GAAG,EAAE,GAAG,CAAC,IAAI,IAAI,GAAG,CAAC,GAAG,CAAC,IAAI,IAAI,GAAG,EAAE,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqOA;AAAA;AAAA,IAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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",
  "names": ["equal", "a", "b", "length", "i", "entry", "deepEqual", "deepEqual", "i", "name", "mix", "i", "attribute", "t", "distance", "min", "max", "j", "v1", "a", "b", "i", "i", "j", "v1", "i", "label", "step", "i", "vector", "color", "j", "vector2", "offset", "jl", "fromPoint", "toPoint", "size", "j", "i", "label", "color", "type", "i", "j", "length", "min", "max", "element", "i", "j", "attribute", "buffer", "type", "Node", "type", "data", "type", "type", "attribute", "type", "type", "type", "type", "type", "type", "type", "type", "type", "texture", "type", "i", "type", "i", "type", "a", "b", "type", "a", "b", "type", "type", "nodeObject", "i", "bool", "uint", "int", "float", "texture", "a", "b", "type", "uv", "roughness", "uv", "i", "j", "options", "attribute", "texture", "buffer", "a", "color", "jl", "nodeIndex", "element", "matrix", "faces", "i", "length", "i", "i", "j", "jl", "MMDPhysics", "i", "world", "RigidBody", "t", "a", "v1", "t2", "vector", "MMDAnimationHelper", "i", "vector", "j", "jl", "max", "buffer", "color", "rotationMatrix", "color", "rotationMatrix", "visible", "updateRefractorPlane", "updateVirtualCamera", "dot", "positionView", "element", "size", "i", "uniforms", "invAspect", "texture", "distance", "color", "rotationMatrix", "resolution", "a", "b", "t", "i", "sign", "size", "size2", "i", "j", "t", "t2", "i2", "j2", "i", "uv", "length", "i", "color", "yAxis", "rotationMatrix", "color", "i", "j", "a", "b", "MeshSurfaceSampler", "i", "targetPosition", "matrix", "obb", "i", "j", "_v1", "_v2", "Capsule", "a", "b", "color", "b", "_v1", "_v2", "_plane", "_sphere", "Octree", "i", "j", "distance", "v1", "min", "max", "step", "i", "j", "color", "STATE", "_vector", "STATE", "i", "size", "i", "stdDev", "i", "i", "i", "j", "sigma", "i", "element", "_vector", "i", "j", "a", "b", "t", "a", "b", "i", "SphereGeometry", "size", "u", "v", "PlaneGeometry", "i", "j", "SelectionHelper", "SelectionBox", "frustum", "size", "i", "i", "XboneInf", "XAnimationInfo", "XAnimationObj", "XKeyFrameInfo", "XLoader", "_start", "FileLoader", "_end", "_obj", "b", "i", "resolve", "msg", "FileLoader", "jsContent", "binaryContent", "buffer", "texture", "type", "i", "a", "b", "FileLoader", "buffer", "matrix", "time", "j", "i", "a", "b", "t", "path", "v1", "length", "i2", "size", "bool", "uv", "_taskCache", "FileLoader", "texture", "buffer", "i", "jsContent", "binaryContent", "worker", "a", "b", "IFFParser", "length", "IFFParser", "length", "buffer", "length", "type", "texture", "i", "j", "size", "a", "i", "j", "type", "R", "Q", "b", "a", "_vector", "_start", "_end", "_closestPoint", "_box", "_v1", "_v1", "_v2", "matrix", "i", "j", "jl", "vector", "color", "uv", "uv2", "a", "b", "cb", "ab", "length", "attribute", "data", "defaultValues", "defaultValues", "defaultValues", "_vector3", "type", "i", "b", "world", "t", "React", "_defineProperty", "a", "size", "matrix", "api"]
}
