import {
  JA,
  JI,
  LI,
  NA,
  SA,
  hA,
  yI
} from "./chunk-PZIKDRNP.js";
import {
  KHR_DF_FLAG_ALPHA_PREMULTIPLIED,
  KHR_DF_TRANSFER_SRGB,
  KHR_SUPERCOMPRESSION_NONE,
  KHR_SUPERCOMPRESSION_ZSTD,
  Q,
  VK_FORMAT_R16G16B16A16_SFLOAT,
  VK_FORMAT_R16G16_SFLOAT,
  VK_FORMAT_R16_SFLOAT,
  VK_FORMAT_R32G32B32A32_SFLOAT,
  VK_FORMAT_R32G32_SFLOAT,
  VK_FORMAT_R32_SFLOAT,
  VK_FORMAT_R8G8B8A8_SRGB,
  VK_FORMAT_R8G8B8A8_UNORM,
  VK_FORMAT_R8G8_SRGB,
  VK_FORMAT_R8G8_UNORM,
  VK_FORMAT_R8_SRGB,
  VK_FORMAT_R8_UNORM,
  VK_FORMAT_UNDEFINED,
  _defineProperty,
  read
} from "./chunk-JFW2U76E.js";
import {
  useFrame
} from "./chunk-MKDV457A.js";
import {
  AddEquation,
  AdditiveBlending,
  AnimationClip,
  AnimationMixer,
  BackSide,
  Bone,
  BooleanKeyframeTrack,
  Box2,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Camera,
  ClampToEdgeWrapping,
  Clock,
  Color,
  ColorKeyframeTrack,
  CompressedTexture,
  Curve,
  CustomBlending,
  CylinderGeometry,
  Data3DTexture,
  DataTexture,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicDrawUsage,
  Euler,
  EventDispatcher,
  FileLoader as FileLoader2,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  Frustum,
  HalfFloatType,
  InstancedMesh,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  InterpolateDiscrete,
  InterpolateLinear,
  Line,
  Line3,
  LineBasicMaterial,
  LineLoop,
  LineSegments,
  LinearEncoding,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  Loader,
  LoaderUtils,
  LuminanceFormat,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MirroredRepeatWrapping,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NoBlending,
  NormalBlending,
  NumberKeyframeTrack,
  Object3D,
  OneMinusSrcAlphaFactor,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointLight,
  Points,
  PointsMaterial,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  RGBADepthPacking,
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  RawShaderMaterial,
  Ray,
  Raycaster,
  RedFormat,
  RepeatWrapping,
  Scene,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  ShapePath,
  Skeleton,
  SkeletonHelper,
  SkinnedMesh,
  Sphere,
  SphereGeometry,
  SpotLight,
  SrcAlphaFactor,
  Texture,
  TextureLoader,
  Triangle,
  Uint16BufferAttribute,
  Uint32BufferAttribute,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt248Type,
  UnsignedShortType,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  WebGLRenderTarget,
  ZeroFactor,
  sRGBEncoding
} from "./chunk-75NQQATE.js";
import "./chunk-VCGGRANA.js";
import {
  require_react
} from "./chunk-WC4MWUMO.js";
import {
  __commonJS,
  __toESM
} from "./chunk-4EOJPDL2.js";

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal2(a2, b2) {
      if (a2 === b2)
        return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor)
          return false;
        var length2, i2, keys;
        if (Array.isArray(a2)) {
          length2 = a2.length;
          if (length2 != b2.length)
            return false;
          for (i2 = length2; i2-- !== 0; )
            if (!equal2(a2[i2], b2[i2]))
              return false;
          return true;
        }
        if (a2.constructor === RegExp)
          return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf)
          return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString)
          return a2.toString() === b2.toString();
        keys = Object.keys(a2);
        length2 = keys.length;
        if (length2 !== Object.keys(b2).length)
          return false;
        for (i2 = length2; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys[i2]))
            return false;
        for (i2 = length2; i2-- !== 0; ) {
          var key = keys[i2];
          if (!equal2(a2[key], b2[key]))
            return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    };
  }
});

// node_modules/@react-three/rapier/dist/react-three-rapier.esm.js
var import_react = __toESM(require_react());

// node_modules/use-asset/dist/index.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var globalCache = [];
function handleAsset(fn, cache, args, lifespan = 0, preload = false) {
  for (const entry2 of cache) {
    if ((0, import_fast_deep_equal.default)(args, entry2.args)) {
      if (preload)
        return;
      if (entry2.error)
        throw entry2.error;
      if (entry2.response)
        return entry2.response;
      throw entry2.promise;
    }
  }
  const entry = {
    args,
    promise: (
      // Make the promise request.
      fn(...args).then((response) => entry.response = response != null ? response : true).catch((e) => entry.error = e != null ? e : "unknown error").then(() => {
        if (lifespan > 0) {
          setTimeout(() => {
            const index = cache.indexOf(entry);
            if (index !== -1)
              cache.splice(index, 1);
          }, lifespan);
        }
      })
    )
  };
  cache.push(entry);
  if (!preload)
    throw entry.promise;
}
function clear(cache, ...args) {
  if (args === void 0 || args.length === 0)
    cache.splice(0, cache.length);
  else {
    const entry = cache.find((entry2) => (0, import_fast_deep_equal.default)(args, entry2.args));
    if (entry) {
      const index = cache.indexOf(entry);
      if (index !== -1)
        cache.splice(index, 1);
    }
  }
}
function useAsset(fn, ...args) {
  return handleAsset(fn, globalCache, args, useAsset.lifespan);
}
useAsset.lifespan = 0;
useAsset.clear = (...args) => clear(globalCache, ...args);
useAsset.preload = (fn, ...args) => void handleAsset(fn, globalCache, args, useAsset.lifespan, true);
useAsset.peek = (...args) => {
  var _globalCache$find;
  return (_globalCache$find = globalCache.find((entry) => (0, import_fast_deep_equal.default)(args, entry.args))) == null ? void 0 : _globalCache$find.response;
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/misc/MorphBlendMesh.js
var MorphBlendMesh = function(geometry, material) {
  Mesh.call(this, geometry, material);
  this.animationsMap = {};
  this.animationsList = [];
  var numFrames = Object.keys(this.morphTargetDictionary).length;
  var name = "__default";
  var startFrame = 0;
  var endFrame = numFrames - 1;
  var fps = numFrames / 1;
  this.createAnimation(name, startFrame, endFrame, fps);
  this.setAnimationWeight(name, 1);
};
MorphBlendMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: MorphBlendMesh,
  createAnimation: function(name, start, end, fps) {
    var animation = {
      start,
      end,
      length: end - start + 1,
      fps,
      duration: (end - start) / fps,
      lastFrame: 0,
      currentFrame: 0,
      active: false,
      time: 0,
      direction: 1,
      weight: 1,
      directionBackwards: false,
      mirroredLoop: false
    };
    this.animationsMap[name] = animation;
    this.animationsList.push(animation);
  },
  autoCreateAnimations: function(fps) {
    var pattern = /([a-z]+)_?(\d+)/i;
    var firstAnimation, frameRanges = {};
    var i2 = 0;
    for (let key in this.morphTargetDictionary) {
      var chunks = key.match(pattern);
      if (chunks && chunks.length > 1) {
        var name = chunks[1];
        if (!frameRanges[name])
          frameRanges[name] = {
            start: Infinity,
            end: -Infinity
          };
        var range = frameRanges[name];
        if (i2 < range.start)
          range.start = i2;
        if (i2 > range.end)
          range.end = i2;
        if (!firstAnimation)
          firstAnimation = name;
      }
      i2++;
    }
    for (let name2 in frameRanges) {
      var range = frameRanges[name2];
      this.createAnimation(name2, range.start, range.end, fps);
    }
    this.firstAnimation = firstAnimation;
  },
  setAnimationDirectionForward: function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.direction = 1;
      animation.directionBackwards = false;
    }
  },
  setAnimationDirectionBackward: function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.direction = -1;
      animation.directionBackwards = true;
    }
  },
  setAnimationFPS: function(name, fps) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.fps = fps;
      animation.duration = (animation.end - animation.start) / animation.fps;
    }
  },
  setAnimationDuration: function(name, duration) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.duration = duration;
      animation.fps = (animation.end - animation.start) / animation.duration;
    }
  },
  setAnimationWeight: function(name, weight) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.weight = weight;
    }
  },
  setAnimationTime: function(name, time) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.time = time;
    }
  },
  getAnimationTime: function(name) {
    var time = 0;
    var animation = this.animationsMap[name];
    if (animation) {
      time = animation.time;
    }
    return time;
  },
  getAnimationDuration: function(name) {
    var duration = -1;
    var animation = this.animationsMap[name];
    if (animation) {
      duration = animation.duration;
    }
    return duration;
  },
  playAnimation: function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.time = 0;
      animation.active = true;
    } else {
      console.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
    }
  },
  stopAnimation: function(name) {
    var animation = this.animationsMap[name];
    if (animation) {
      animation.active = false;
    }
  },
  update: function(delta) {
    for (let i2 = 0, il = this.animationsList.length; i2 < il; i2++) {
      var animation = this.animationsList[i2];
      if (!animation.active)
        continue;
      var frameTime = animation.duration / animation.length;
      animation.time += animation.direction * delta;
      if (animation.mirroredLoop) {
        if (animation.time > animation.duration || animation.time < 0) {
          animation.direction *= -1;
          if (animation.time > animation.duration) {
            animation.time = animation.duration;
            animation.directionBackwards = true;
          }
          if (animation.time < 0) {
            animation.time = 0;
            animation.directionBackwards = false;
          }
        }
      } else {
        animation.time = animation.time % animation.duration;
        if (animation.time < 0)
          animation.time += animation.duration;
      }
      var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
      var weight = animation.weight;
      if (keyframe !== animation.currentFrame) {
        this.morphTargetInfluences[animation.lastFrame] = 0;
        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
        this.morphTargetInfluences[keyframe] = 0;
        animation.lastFrame = animation.currentFrame;
        animation.currentFrame = keyframe;
      }
      var mix2 = animation.time % frameTime / frameTime;
      if (animation.directionBackwards)
        mix2 = 1 - mix2;
      if (animation.currentFrame !== animation.lastFrame) {
        this.morphTargetInfluences[animation.currentFrame] = mix2 * weight;
        this.morphTargetInfluences[animation.lastFrame] = (1 - mix2) * weight;
      } else {
        this.morphTargetInfluences[animation.currentFrame] = weight;
      }
    }
  }
});

// node_modules/@react-three/rapier/node_modules/three-stdlib/math/ConvexHull.js
var Visible = 0;
var Deleted = 1;
var _v1 = new Vector3();
var _line3 = new Line3();
var _plane = new Plane();
var _closestPoint = new Vector3();
var _triangle = new Triangle();
var ConvexHull = class {
  constructor() {
    this.tolerance = -1;
    this.faces = [];
    this.newFaces = [];
    this.assigned = new VertexList();
    this.unassigned = new VertexList();
    this.vertices = [];
  }
  setFromPoints(points) {
    if (points.length >= 4) {
      this.makeEmpty();
      for (let i2 = 0, l = points.length; i2 < l; i2++) {
        this.vertices.push(new VertexNode(points[i2]));
      }
      this.compute();
    }
    return this;
  }
  setFromObject(object) {
    const points = [];
    object.updateMatrixWorld(true);
    object.traverse(function(node) {
      const geometry = node.geometry;
      if (geometry !== void 0) {
        if (geometry.isGeometry) {
          console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");
          return;
        } else if (geometry.isBufferGeometry) {
          const attribute2 = geometry.attributes.position;
          if (attribute2 !== void 0) {
            for (let i2 = 0, l = attribute2.count; i2 < l; i2++) {
              const point = new Vector3();
              point.fromBufferAttribute(attribute2, i2).applyMatrix4(node.matrixWorld);
              points.push(point);
            }
          }
        }
      }
    });
    return this.setFromPoints(points);
  }
  containsPoint(point) {
    const faces = this.faces;
    for (let i2 = 0, l = faces.length; i2 < l; i2++) {
      const face = faces[i2];
      if (face.distanceToPoint(point) > this.tolerance)
        return false;
    }
    return true;
  }
  intersectRay(ray, target) {
    const faces = this.faces;
    let tNear = -Infinity;
    let tFar = Infinity;
    for (let i2 = 0, l = faces.length; i2 < l; i2++) {
      const face = faces[i2];
      const vN = face.distanceToPoint(ray.origin);
      const vD = face.normal.dot(ray.direction);
      if (vN > 0 && vD >= 0)
        return null;
      const t2 = vD !== 0 ? -vN / vD : 0;
      if (t2 <= 0)
        continue;
      if (vD > 0) {
        tFar = Math.min(t2, tFar);
      } else {
        tNear = Math.max(t2, tNear);
      }
      if (tNear > tFar) {
        return null;
      }
    }
    if (tNear !== -Infinity) {
      ray.at(tNear, target);
    } else {
      ray.at(tFar, target);
    }
    return target;
  }
  intersectsRay(ray) {
    return this.intersectRay(ray, _v1) !== null;
  }
  makeEmpty() {
    this.faces = [];
    this.vertices = [];
    return this;
  }
  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face
  addVertexToFace(vertex, face) {
    vertex.face = face;
    if (face.outside === null) {
      this.assigned.append(vertex);
    } else {
      this.assigned.insertBefore(face.outside, vertex);
    }
    face.outside = vertex;
    return this;
  }
  // Removes a vertex from the 'assigned' list of vertices and from the given face
  removeVertexFromFace(vertex, face) {
    if (vertex === face.outside) {
      if (vertex.next !== null && vertex.next.face === face) {
        face.outside = vertex.next;
      } else {
        face.outside = null;
      }
    }
    this.assigned.remove(vertex);
    return this;
  }
  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list
  removeAllVerticesFromFace(face) {
    if (face.outside !== null) {
      const start = face.outside;
      let end = face.outside;
      while (end.next !== null && end.next.face === face) {
        end = end.next;
      }
      this.assigned.removeSubList(start, end);
      start.prev = end.next = null;
      face.outside = null;
      return start;
    }
  }
  // Removes all the visible vertices that 'face' is able to see
  deleteFaceVertices(face, absorbingFace) {
    const faceVertices = this.removeAllVerticesFromFace(face);
    if (faceVertices !== void 0) {
      if (absorbingFace === void 0) {
        this.unassigned.appendChain(faceVertices);
      } else {
        let vertex = faceVertices;
        do {
          const nextVertex = vertex.next;
          const distance2 = absorbingFace.distanceToPoint(vertex.point);
          if (distance2 > this.tolerance) {
            this.addVertexToFace(vertex, absorbingFace);
          } else {
            this.unassigned.append(vertex);
          }
          vertex = nextVertex;
        } while (vertex !== null);
      }
    }
    return this;
  }
  // Reassigns as many vertices as possible from the unassigned list to the new faces
  resolveUnassignedPoints(newFaces) {
    if (this.unassigned.isEmpty() === false) {
      let vertex = this.unassigned.first();
      do {
        const nextVertex = vertex.next;
        let maxDistance = this.tolerance;
        let maxFace = null;
        for (let i2 = 0; i2 < newFaces.length; i2++) {
          const face = newFaces[i2];
          if (face.mark === Visible) {
            const distance2 = face.distanceToPoint(vertex.point);
            if (distance2 > maxDistance) {
              maxDistance = distance2;
              maxFace = face;
            }
            if (maxDistance > 1e3 * this.tolerance)
              break;
          }
        }
        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
        vertex = nextVertex;
      } while (vertex !== null);
    }
    return this;
  }
  // Computes the extremes of a simplex which will be the initial hull
  computeExtremes() {
    const min2 = new Vector3();
    const max2 = new Vector3();
    const minVertices = [];
    const maxVertices = [];
    for (let i2 = 0; i2 < 3; i2++) {
      minVertices[i2] = maxVertices[i2] = this.vertices[0];
    }
    min2.copy(this.vertices[0].point);
    max2.copy(this.vertices[0].point);
    for (let i2 = 0, l = this.vertices.length; i2 < l; i2++) {
      const vertex = this.vertices[i2];
      const point = vertex.point;
      for (let j2 = 0; j2 < 3; j2++) {
        if (point.getComponent(j2) < min2.getComponent(j2)) {
          min2.setComponent(j2, point.getComponent(j2));
          minVertices[j2] = vertex;
        }
      }
      for (let j2 = 0; j2 < 3; j2++) {
        if (point.getComponent(j2) > max2.getComponent(j2)) {
          max2.setComponent(j2, point.getComponent(j2));
          maxVertices[j2] = vertex;
        }
      }
    }
    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min2.x), Math.abs(max2.x)) + Math.max(Math.abs(min2.y), Math.abs(max2.y)) + Math.max(Math.abs(min2.z), Math.abs(max2.z)));
    return {
      min: minVertices,
      max: maxVertices
    };
  }
  // Computes the initial simplex assigning to its faces all the points
  // that are candidates to form part of the hull
  computeInitialHull() {
    const vertices = this.vertices;
    const extremes = this.computeExtremes();
    const min2 = extremes.min;
    const max2 = extremes.max;
    let maxDistance = 0;
    let index = 0;
    for (let i2 = 0; i2 < 3; i2++) {
      const distance2 = max2[i2].point.getComponent(i2) - min2[i2].point.getComponent(i2);
      if (distance2 > maxDistance) {
        maxDistance = distance2;
        index = i2;
      }
    }
    const v0 = min2[index];
    const v12 = max2[index];
    let v2;
    let v3;
    maxDistance = 0;
    _line3.set(v0.point, v12.point);
    for (let i2 = 0, l = this.vertices.length; i2 < l; i2++) {
      const vertex = vertices[i2];
      if (vertex !== v0 && vertex !== v12) {
        _line3.closestPointToPoint(vertex.point, true, _closestPoint);
        const distance2 = _closestPoint.distanceToSquared(vertex.point);
        if (distance2 > maxDistance) {
          maxDistance = distance2;
          v2 = vertex;
        }
      }
    }
    maxDistance = -1;
    _plane.setFromCoplanarPoints(v0.point, v12.point, v2.point);
    for (let i2 = 0, l = this.vertices.length; i2 < l; i2++) {
      const vertex = vertices[i2];
      if (vertex !== v0 && vertex !== v12 && vertex !== v2) {
        const distance2 = Math.abs(_plane.distanceToPoint(vertex.point));
        if (distance2 > maxDistance) {
          maxDistance = distance2;
          v3 = vertex;
        }
      }
    }
    const faces = [];
    if (_plane.distanceToPoint(v3.point) < 0) {
      faces.push(Face.create(v0, v12, v2), Face.create(v3, v12, v0), Face.create(v3, v2, v12), Face.create(v3, v0, v2));
      for (let i2 = 0; i2 < 3; i2++) {
        const j2 = (i2 + 1) % 3;
        faces[i2 + 1].getEdge(2).setTwin(faces[0].getEdge(j2));
        faces[i2 + 1].getEdge(1).setTwin(faces[j2 + 1].getEdge(0));
      }
    } else {
      faces.push(Face.create(v0, v2, v12), Face.create(v3, v0, v12), Face.create(v3, v12, v2), Face.create(v3, v2, v0));
      for (let i2 = 0; i2 < 3; i2++) {
        const j2 = (i2 + 1) % 3;
        faces[i2 + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i2) % 3));
        faces[i2 + 1].getEdge(0).setTwin(faces[j2 + 1].getEdge(1));
      }
    }
    for (let i2 = 0; i2 < 4; i2++) {
      this.faces.push(faces[i2]);
    }
    for (let i2 = 0, l = vertices.length; i2 < l; i2++) {
      const vertex = vertices[i2];
      if (vertex !== v0 && vertex !== v12 && vertex !== v2 && vertex !== v3) {
        maxDistance = this.tolerance;
        let maxFace = null;
        for (let j2 = 0; j2 < 4; j2++) {
          const distance2 = this.faces[j2].distanceToPoint(vertex.point);
          if (distance2 > maxDistance) {
            maxDistance = distance2;
            maxFace = this.faces[j2];
          }
        }
        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
      }
    }
    return this;
  }
  // Removes inactive faces
  reindexFaces() {
    const activeFaces = [];
    for (let i2 = 0; i2 < this.faces.length; i2++) {
      const face = this.faces[i2];
      if (face.mark === Visible) {
        activeFaces.push(face);
      }
    }
    this.faces = activeFaces;
    return this;
  }
  // Finds the next vertex to create faces with the current hull
  nextVertexToAdd() {
    if (this.assigned.isEmpty() === false) {
      let eyeVertex, maxDistance = 0;
      const eyeFace = this.assigned.first().face;
      let vertex = eyeFace.outside;
      do {
        const distance2 = eyeFace.distanceToPoint(vertex.point);
        if (distance2 > maxDistance) {
          maxDistance = distance2;
          eyeVertex = vertex;
        }
        vertex = vertex.next;
      } while (vertex !== null && vertex.face === eyeFace);
      return eyeVertex;
    }
  }
  // Computes a chain of half edges in CCW order called the 'horizon'.
  // For an edge to be part of the horizon it must join a face that can see
  // 'eyePoint' and a face that cannot see 'eyePoint'.
  computeHorizon(eyePoint, crossEdge, face, horizon) {
    this.deleteFaceVertices(face);
    face.mark = Deleted;
    let edge;
    if (crossEdge === null) {
      edge = crossEdge = face.getEdge(0);
    } else {
      edge = crossEdge.next;
    }
    do {
      const twinEdge = edge.twin;
      const oppositeFace = twinEdge.face;
      if (oppositeFace.mark === Visible) {
        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {
          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);
        } else {
          horizon.push(edge);
        }
      }
      edge = edge.next;
    } while (edge !== crossEdge);
    return this;
  }
  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order
  addAdjoiningFace(eyeVertex, horizonEdge) {
    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());
    this.faces.push(face);
    face.getEdge(-1).setTwin(horizonEdge.twin);
    return face.getEdge(0);
  }
  //  Adds 'horizon.length' faces to the hull, each face will be linked with the
  //  horizon opposite face and the face on the left/right
  addNewFaces(eyeVertex, horizon) {
    this.newFaces = [];
    let firstSideEdge = null;
    let previousSideEdge = null;
    for (let i2 = 0; i2 < horizon.length; i2++) {
      const horizonEdge = horizon[i2];
      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);
      if (firstSideEdge === null) {
        firstSideEdge = sideEdge;
      } else {
        sideEdge.next.setTwin(previousSideEdge);
      }
      this.newFaces.push(sideEdge.face);
      previousSideEdge = sideEdge;
    }
    firstSideEdge.next.setTwin(previousSideEdge);
    return this;
  }
  // Adds a vertex to the hull
  addVertexToHull(eyeVertex) {
    const horizon = [];
    this.unassigned.clear();
    this.removeVertexFromFace(eyeVertex, eyeVertex.face);
    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
    this.addNewFaces(eyeVertex, horizon);
    this.resolveUnassignedPoints(this.newFaces);
    return this;
  }
  cleanup() {
    this.assigned.clear();
    this.unassigned.clear();
    this.newFaces = [];
    return this;
  }
  compute() {
    let vertex;
    this.computeInitialHull();
    while ((vertex = this.nextVertexToAdd()) !== void 0) {
      this.addVertexToHull(vertex);
    }
    this.reindexFaces();
    this.cleanup();
    return this;
  }
};
var Face = class {
  constructor() {
    this.normal = new Vector3();
    this.midpoint = new Vector3();
    this.area = 0;
    this.constant = 0;
    this.outside = null;
    this.mark = Visible;
    this.edge = null;
  }
  static create(a2, b2, c) {
    const face = new Face();
    const e0 = new HalfEdge(a2, face);
    const e1 = new HalfEdge(b2, face);
    const e2 = new HalfEdge(c, face);
    e0.next = e2.prev = e1;
    e1.next = e0.prev = e2;
    e2.next = e1.prev = e0;
    face.edge = e0;
    return face.compute();
  }
  getEdge(i2) {
    let edge = this.edge;
    while (i2 > 0) {
      edge = edge.next;
      i2--;
    }
    while (i2 < 0) {
      edge = edge.prev;
      i2++;
    }
    return edge;
  }
  compute() {
    const a2 = this.edge.tail();
    const b2 = this.edge.head();
    const c = this.edge.next.head();
    _triangle.set(a2.point, b2.point, c.point);
    _triangle.getNormal(this.normal);
    _triangle.getMidpoint(this.midpoint);
    this.area = _triangle.getArea();
    this.constant = this.normal.dot(this.midpoint);
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) - this.constant;
  }
};
var HalfEdge = class {
  constructor(vertex, face) {
    this.vertex = vertex;
    this.prev = null;
    this.next = null;
    this.twin = null;
    this.face = face;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceTo(head.point);
    }
    return -1;
  }
  lengthSquared() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceToSquared(head.point);
    }
    return -1;
  }
  setTwin(edge) {
    this.twin = edge;
    edge.twin = this;
    return this;
  }
};
var VertexNode = class {
  constructor(point) {
    this.point = point;
    this.prev = null;
    this.next = null;
    this.face = null;
  }
};
var VertexList = class {
  constructor() {
    this.head = null;
    this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    this.head = this.tail = null;
    return this;
  }
  // Inserts a vertex before the target vertex
  insertBefore(target, vertex) {
    vertex.prev = target.prev;
    vertex.next = target;
    if (vertex.prev === null) {
      this.head = vertex;
    } else {
      vertex.prev.next = vertex;
    }
    target.prev = vertex;
    return this;
  }
  // Inserts a vertex after the target vertex
  insertAfter(target, vertex) {
    vertex.prev = target;
    vertex.next = target.next;
    if (vertex.next === null) {
      this.tail = vertex;
    } else {
      vertex.next.prev = vertex;
    }
    target.next = vertex;
    return this;
  }
  // Appends a vertex to the end of the linked list
  append(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    vertex.next = null;
    this.tail = vertex;
    return this;
  }
  // Appends a chain of vertices where 'vertex' is the head.
  appendChain(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    while (vertex.next !== null) {
      vertex = vertex.next;
    }
    this.tail = vertex;
    return this;
  }
  // Removes a vertex from the linked list
  remove(vertex) {
    if (vertex.prev === null) {
      this.head = vertex.next;
    } else {
      vertex.prev.next = vertex.next;
    }
    if (vertex.next === null) {
      this.tail = vertex.prev;
    } else {
      vertex.next.prev = vertex.prev;
    }
    return this;
  }
  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b
  removeSubList(a2, b2) {
    if (a2.prev === null) {
      this.head = b2.next;
    } else {
      a2.prev.next = b2.next;
    }
    if (b2.next === null) {
      this.tail = a2.prev;
    } else {
      b2.next.prev = a2.prev;
    }
    return this;
  }
  isEmpty() {
    return this.head === null;
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/geometries/ConvexGeometry.js
var ConvexGeometry = class extends BufferGeometry {
  constructor(points = []) {
    super();
    const vertices = [];
    const normals = [];
    if (ConvexHull === void 0) {
      console.error("THREE.ConvexGeometry: ConvexGeometry relies on ConvexHull");
    }
    const convexHull = new ConvexHull().setFromPoints(points);
    const faces = convexHull.faces;
    for (let i2 = 0; i2 < faces.length; i2++) {
      const face = faces[i2];
      let edge = face.edge;
      do {
        const point = edge.head().point;
        vertices.push(point.x, point.y, point.z);
        normals.push(face.normal.x, face.normal.y, face.normal.z);
        edge = edge.next;
      } while (edge !== face.edge);
    }
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/misc/ConvexObjectBreaker.js
var ConvexObjectBreaker = function(minSizeForBreak, smallDelta) {
  this.minSizeForBreak = minSizeForBreak || 1.4;
  this.smallDelta = smallDelta || 1e-4;
  this.tempLine1 = new Line3();
  this.tempPlane1 = new Plane();
  this.tempPlane2 = new Plane();
  this.tempPlane_Cut = new Plane();
  this.tempCM1 = new Vector3();
  this.tempCM2 = new Vector3();
  this.tempVector3 = new Vector3();
  this.tempVector3_2 = new Vector3();
  this.tempVector3_3 = new Vector3();
  this.tempVector3_P0 = new Vector3();
  this.tempVector3_P1 = new Vector3();
  this.tempVector3_P2 = new Vector3();
  this.tempVector3_N0 = new Vector3();
  this.tempVector3_N1 = new Vector3();
  this.tempVector3_AB = new Vector3();
  this.tempVector3_CB = new Vector3();
  this.tempResultObjects = {
    object1: null,
    object2: null
  };
  this.segments = [];
  var n = 30 * 30;
  for (let i2 = 0; i2 < n; i2++)
    this.segments[i2] = false;
};
ConvexObjectBreaker.prototype = {
  constructor: ConvexObjectBreaker,
  prepareBreakableObject: function(object, mass, velocity, angularVelocity, breakable) {
    if (!object.geometry.isBufferGeometry) {
      console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.");
    }
    var userData = object.userData;
    userData.mass = mass;
    userData.velocity = velocity.clone();
    userData.angularVelocity = angularVelocity.clone();
    userData.breakable = breakable;
  },
  /*
   * @param {int} maxRadialIterations Iterations for radial cuts.
   * @param {int} maxRandomIterations Max random iterations for not-radial cuts
   *
   * Returns the array of pieces
   */
  subdivideByImpact: function(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {
    var debris = [];
    var tempPlane1 = this.tempPlane1;
    var tempPlane2 = this.tempPlane2;
    this.tempVector3.addVectors(pointOfImpact, normal);
    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);
    var maxTotalIterations = maxRandomIterations + maxRadialIterations;
    var scope = this;
    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {
      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {
        debris.push(subObject);
        return;
      }
      var angle = Math.PI;
      if (numIterations === 0) {
        tempPlane2.normal.copy(tempPlane1.normal);
        tempPlane2.constant = tempPlane1.constant;
      } else {
        if (numIterations <= maxRadialIterations) {
          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;
          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);
          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);
        } else {
          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;
          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);
          scope.tempVector3_3.copy(normal).add(subObject.position);
          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);
        }
      }
      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);
      var obj1 = scope.tempResultObjects.object1;
      var obj2 = scope.tempResultObjects.object2;
      if (obj1) {
        subdivideRadial(obj1, startAngle, angle, numIterations + 1);
      }
      if (obj2) {
        subdivideRadial(obj2, angle, endAngle, numIterations + 1);
      }
    }
    subdivideRadial(object, 0, 2 * Math.PI, 0);
    return debris;
  },
  cutByPlane: function(object, plane, output) {
    var geometry = object.geometry;
    var coords = geometry.attributes.position.array;
    var normals = geometry.attributes.normal.array;
    var numPoints = coords.length / 3;
    var numFaces = numPoints / 3;
    var indices = geometry.getIndex();
    if (indices) {
      indices = indices.array;
      numFaces = indices.length / 3;
    }
    function getVertexIndex(faceIdx, vert) {
      var idx = faceIdx * 3 + vert;
      return indices ? indices[idx] : idx;
    }
    var points1 = [];
    var points2 = [];
    var delta = this.smallDelta;
    var numPointPairs = numPoints * numPoints;
    for (let i2 = 0; i2 < numPointPairs; i2++)
      this.segments[i2] = false;
    var p0 = this.tempVector3_P0;
    var p1 = this.tempVector3_P1;
    var n0 = this.tempVector3_N0;
    var n1 = this.tempVector3_N1;
    for (let i2 = 0; i2 < numFaces - 1; i2++) {
      var a1 = getVertexIndex(i2, 0);
      var b1 = getVertexIndex(i2, 1);
      var c1 = getVertexIndex(i2, 2);
      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);
      for (let j2 = i2 + 1; j2 < numFaces; j2++) {
        var a2 = getVertexIndex(j2, 0);
        var b2 = getVertexIndex(j2, 1);
        var c2 = getVertexIndex(j2, 2);
        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);
        var coplanar = 1 - n0.dot(n1) < delta;
        if (coplanar) {
          if (a1 === a2 || a1 === b2 || a1 === c2) {
            if (b1 === a2 || b1 === b2 || b1 === c2) {
              this.segments[a1 * numPoints + b1] = true;
              this.segments[b1 * numPoints + a1] = true;
            } else {
              this.segments[c1 * numPoints + a1] = true;
              this.segments[a1 * numPoints + c1] = true;
            }
          } else if (b1 === a2 || b1 === b2 || b1 === c2) {
            this.segments[c1 * numPoints + b1] = true;
            this.segments[b1 * numPoints + c1] = true;
          }
        }
      }
    }
    var localPlane = this.tempPlane_Cut;
    object.updateMatrix();
    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);
    for (let i2 = 0; i2 < numFaces; i2++) {
      var va = getVertexIndex(i2, 0);
      var vb = getVertexIndex(i2, 1);
      var vc = getVertexIndex(i2, 2);
      for (let segment = 0; segment < 3; segment++) {
        var i0 = segment === 0 ? va : segment === 1 ? vb : vc;
        var i1 = segment === 0 ? vb : segment === 1 ? vc : va;
        var segmentState = this.segments[i0 * numPoints + i1];
        if (segmentState)
          continue;
        this.segments[i0 * numPoints + i1] = true;
        this.segments[i1 * numPoints + i0] = true;
        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);
        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);
        var mark0 = 0;
        var d = localPlane.distanceToPoint(p0);
        if (d > delta) {
          mark0 = 2;
          points2.push(p0.clone());
        } else if (d < -delta) {
          mark0 = 1;
          points1.push(p0.clone());
        } else {
          mark0 = 3;
          points1.push(p0.clone());
          points2.push(p0.clone());
        }
        var mark1 = 0;
        var d = localPlane.distanceToPoint(p1);
        if (d > delta) {
          mark1 = 2;
          points2.push(p1.clone());
        } else if (d < -delta) {
          mark1 = 1;
          points1.push(p1.clone());
        } else {
          mark1 = 3;
          points1.push(p1.clone());
          points2.push(p1.clone());
        }
        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {
          this.tempLine1.start.copy(p0);
          this.tempLine1.end.copy(p1);
          var intersection = new Vector3();
          intersection = localPlane.intersectLine(this.tempLine1, intersection);
          if (intersection === void 0) {
            console.error("Internal error: segment does not intersect plane.");
            output.segmentedObject1 = null;
            output.segmentedObject2 = null;
            return 0;
          }
          points1.push(intersection);
          points2.push(intersection.clone());
        }
      }
    }
    var newMass = object.userData.mass * 0.5;
    this.tempCM1.set(0, 0, 0);
    var radius1 = 0;
    var numPoints1 = points1.length;
    if (numPoints1 > 0) {
      for (let i2 = 0; i2 < numPoints1; i2++)
        this.tempCM1.add(points1[i2]);
      this.tempCM1.divideScalar(numPoints1);
      for (let i2 = 0; i2 < numPoints1; i2++) {
        var p = points1[i2];
        p.sub(this.tempCM1);
        radius1 = Math.max(radius1, p.x, p.y, p.z);
      }
      this.tempCM1.add(object.position);
    }
    this.tempCM2.set(0, 0, 0);
    var radius2 = 0;
    var numPoints2 = points2.length;
    if (numPoints2 > 0) {
      for (let i2 = 0; i2 < numPoints2; i2++)
        this.tempCM2.add(points2[i2]);
      this.tempCM2.divideScalar(numPoints2);
      for (let i2 = 0; i2 < numPoints2; i2++) {
        var p = points2[i2];
        p.sub(this.tempCM2);
        radius2 = Math.max(radius2, p.x, p.y, p.z);
      }
      this.tempCM2.add(object.position);
    }
    var object1 = null;
    var object2 = null;
    var numObjects = 0;
    if (numPoints1 > 4) {
      object1 = new Mesh(new ConvexGeometry(points1), object.material);
      object1.position.copy(this.tempCM1);
      object1.quaternion.copy(object.quaternion);
      this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);
      numObjects++;
    }
    if (numPoints2 > 4) {
      object2 = new Mesh(new ConvexGeometry(points2), object.material);
      object2.position.copy(this.tempCM2);
      object2.quaternion.copy(object.quaternion);
      this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);
      numObjects++;
    }
    output.object1 = object1;
    output.object2 = object2;
    return numObjects;
  }
};
ConvexObjectBreaker.transformFreeVector = function(v, m) {
  var x = v.x, y = v.y, z = v.z;
  var e = m.elements;
  v.x = e[0] * x + e[4] * y + e[8] * z;
  v.y = e[1] * x + e[5] * y + e[9] * z;
  v.z = e[2] * x + e[6] * y + e[10] * z;
  return v;
};
ConvexObjectBreaker.transformFreeVectorInverse = function(v, m) {
  var x = v.x, y = v.y, z = v.z;
  var e = m.elements;
  v.x = e[0] * x + e[1] * y + e[2] * z;
  v.y = e[4] * x + e[5] * y + e[6] * z;
  v.z = e[8] * x + e[9] * y + e[10] * z;
  return v;
};
ConvexObjectBreaker.transformTiedVectorInverse = function(v, m) {
  var x = v.x, y = v.y, z = v.z;
  var e = m.elements;
  v.x = e[0] * x + e[1] * y + e[2] * z - e[12];
  v.y = e[4] * x + e[5] * y + e[6] * z - e[13];
  v.z = e[8] * x + e[9] * y + e[10] * z - e[14];
  return v;
};
ConvexObjectBreaker.transformPlaneToLocalSpace = function() {
  var v12 = new Vector3();
  return function transformPlaneToLocalSpace(plane, m, resultPlane) {
    resultPlane.normal.copy(plane.normal);
    resultPlane.constant = plane.constant;
    var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v12), m);
    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m);
    resultPlane.constant = -referencePoint.dot(resultPlane.normal);
  };
}();

// node_modules/@react-three/rapier/node_modules/three-stdlib/misc/Gyroscope.js
var Gyroscope = function() {
  Object3D.call(this);
};
Gyroscope.prototype = Object.create(Object3D.prototype);
Gyroscope.prototype.constructor = Gyroscope;
Gyroscope.prototype.updateMatrixWorld = function() {
  var translationObject = new Vector3();
  var quaternionObject = new Quaternion();
  var scaleObject = new Vector3();
  var translationWorld = new Vector3();
  var quaternionWorld = new Quaternion();
  var scaleWorld = new Vector3();
  return function updateMatrixWorld(force) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent !== null) {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        this.matrixWorld.decompose(translationWorld, quaternionWorld, scaleWorld);
        this.matrix.decompose(translationObject, quaternionObject, scaleObject);
        this.matrixWorld.compose(translationWorld, quaternionObject, scaleWorld);
      } else {
        this.matrixWorld.copy(this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    for (let i2 = 0, l = this.children.length; i2 < l; i2++) {
      this.children[i2].updateMatrixWorld(force);
    }
  };
}();

// node_modules/@react-three/rapier/node_modules/three-stdlib/misc/MorphAnimMesh.js
var MorphAnimMesh = function(geometry, material) {
  Mesh.call(this, geometry, material);
  this.type = "MorphAnimMesh";
  this.mixer = new AnimationMixer(this);
  this.activeAction = null;
};
MorphAnimMesh.prototype = Object.create(Mesh.prototype);
MorphAnimMesh.prototype.constructor = MorphAnimMesh;
MorphAnimMesh.prototype.setDirectionForward = function() {
  this.mixer.timeScale = 1;
};
MorphAnimMesh.prototype.setDirectionBackward = function() {
  this.mixer.timeScale = -1;
};
MorphAnimMesh.prototype.playAnimation = function(label2, fps) {
  if (this.activeAction) {
    this.activeAction.stop();
    this.activeAction = null;
  }
  var clip = AnimationClip.findByName(this, label2);
  if (clip) {
    var action = this.mixer.clipAction(clip);
    action.timeScale = clip.tracks.length * fps / clip.duration;
    this.activeAction = action.play();
  } else {
    throw new Error("THREE.MorphAnimMesh: animations[" + label2 + "] undefined in .playAnimation()");
  }
};
MorphAnimMesh.prototype.updateAnimation = function(delta) {
  this.mixer.update(delta);
};
MorphAnimMesh.prototype.copy = function(source) {
  Mesh.prototype.copy.call(this, source);
  this.mixer = new AnimationMixer(this);
  return this;
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/misc/RollerCoaster.js
var RollerCoasterGeometry = function(curve, divisions) {
  BufferGeometry.call(this);
  var vertices = [];
  var normals = [];
  var colors = [];
  var color1 = [1, 1, 1];
  var color2 = [1, 1, 0];
  var up = new Vector3(0, 1, 0);
  var forward = new Vector3();
  var right = new Vector3();
  var quaternion = new Quaternion();
  var prevQuaternion = new Quaternion();
  prevQuaternion.setFromAxisAngle(up, Math.PI / 2);
  var point = new Vector3();
  var prevPoint = new Vector3();
  prevPoint.copy(curve.getPointAt(0));
  var step2 = [new Vector3(-0.225, 0, 0), new Vector3(0, -0.05, 0), new Vector3(0, -0.175, 0), new Vector3(0, -0.05, 0), new Vector3(0.225, 0, 0), new Vector3(0, -0.175, 0)];
  var PI2 = Math.PI * 2;
  var sides = 5;
  var tube1 = [];
  for (let i2 = 0; i2 < sides; i2++) {
    var angle = i2 / sides * PI2;
    tube1.push(new Vector3(Math.sin(angle) * 0.06, Math.cos(angle) * 0.06, 0));
  }
  var sides = 6;
  var tube2 = [];
  for (let i2 = 0; i2 < sides; i2++) {
    var angle = i2 / sides * PI2;
    tube2.push(new Vector3(Math.sin(angle) * 0.025, Math.cos(angle) * 0.025, 0));
  }
  var vector2 = new Vector3();
  var normal = new Vector3();
  function drawShape(shape, color3) {
    normal.set(0, 0, -1).applyQuaternion(quaternion);
    for (let j2 = 0; j2 < shape.length; j2++) {
      vector2.copy(shape[j2]);
      vector2.applyQuaternion(quaternion);
      vector2.add(point);
      vertices.push(vector2.x, vector2.y, vector2.z);
      normals.push(normal.x, normal.y, normal.z);
      colors.push(color3[0], color3[1], color3[2]);
    }
    normal.set(0, 0, 1).applyQuaternion(quaternion);
    for (let j2 = shape.length - 1; j2 >= 0; j2--) {
      vector2.copy(shape[j2]);
      vector2.applyQuaternion(quaternion);
      vector2.add(point);
      vertices.push(vector2.x, vector2.y, vector2.z);
      normals.push(normal.x, normal.y, normal.z);
      colors.push(color3[0], color3[1], color3[2]);
    }
  }
  var vector1 = new Vector3();
  var vector22 = new Vector3();
  var vector3 = new Vector3();
  var vector4 = new Vector3();
  var normal1 = new Vector3();
  var normal2 = new Vector3();
  var normal3 = new Vector3();
  var normal4 = new Vector3();
  function extrudeShape(shape, offset2, color3) {
    for (let j2 = 0, jl2 = shape.length; j2 < jl2; j2++) {
      var point1 = shape[j2];
      var point2 = shape[(j2 + 1) % jl2];
      vector1.copy(point1).add(offset2);
      vector1.applyQuaternion(quaternion);
      vector1.add(point);
      vector22.copy(point2).add(offset2);
      vector22.applyQuaternion(quaternion);
      vector22.add(point);
      vector3.copy(point2).add(offset2);
      vector3.applyQuaternion(prevQuaternion);
      vector3.add(prevPoint);
      vector4.copy(point1).add(offset2);
      vector4.applyQuaternion(prevQuaternion);
      vector4.add(prevPoint);
      vertices.push(vector1.x, vector1.y, vector1.z);
      vertices.push(vector22.x, vector22.y, vector22.z);
      vertices.push(vector4.x, vector4.y, vector4.z);
      vertices.push(vector22.x, vector22.y, vector22.z);
      vertices.push(vector3.x, vector3.y, vector3.z);
      vertices.push(vector4.x, vector4.y, vector4.z);
      normal1.copy(point1);
      normal1.applyQuaternion(quaternion);
      normal1.normalize();
      normal2.copy(point2);
      normal2.applyQuaternion(quaternion);
      normal2.normalize();
      normal3.copy(point2);
      normal3.applyQuaternion(prevQuaternion);
      normal3.normalize();
      normal4.copy(point1);
      normal4.applyQuaternion(prevQuaternion);
      normal4.normalize();
      normals.push(normal1.x, normal1.y, normal1.z);
      normals.push(normal2.x, normal2.y, normal2.z);
      normals.push(normal4.x, normal4.y, normal4.z);
      normals.push(normal2.x, normal2.y, normal2.z);
      normals.push(normal3.x, normal3.y, normal3.z);
      normals.push(normal4.x, normal4.y, normal4.z);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
      colors.push(color3[0], color3[1], color3[2]);
    }
  }
  var offset = new Vector3();
  for (let i2 = 1; i2 <= divisions; i2++) {
    point.copy(curve.getPointAt(i2 / divisions));
    up.set(0, 1, 0);
    forward.subVectors(point, prevPoint).normalize();
    right.crossVectors(up, forward).normalize();
    up.crossVectors(forward, right);
    var angle = Math.atan2(forward.x, forward.z);
    quaternion.setFromAxisAngle(up, angle);
    if (i2 % 2 === 0) {
      drawShape(step2, color2);
    }
    extrudeShape(tube1, offset.set(0, -0.125, 0), color2);
    extrudeShape(tube2, offset.set(0.2, 0, 0), color1);
    extrudeShape(tube2, offset.set(-0.2, 0, 0), color1);
    prevPoint.copy(point);
    prevQuaternion.copy(quaternion);
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
  this.setAttribute("normal", new BufferAttribute(new Float32Array(normals), 3));
  this.setAttribute("color", new BufferAttribute(new Float32Array(colors), 3));
};
RollerCoasterGeometry.prototype = Object.create(BufferGeometry.prototype);
var RollerCoasterLiftersGeometry = function(curve, divisions) {
  BufferGeometry.call(this);
  var vertices = [];
  var normals = [];
  var quaternion = new Quaternion();
  var up = new Vector3(0, 1, 0);
  var point = new Vector3();
  var tangent = new Vector3();
  var tube1 = [new Vector3(0, 0.05, -0.05), new Vector3(0, 0.05, 0.05), new Vector3(0, -0.05, 0)];
  var tube2 = [new Vector3(-0.05, 0, 0.05), new Vector3(-0.05, 0, -0.05), new Vector3(0.05, 0, 0)];
  var tube3 = [new Vector3(0.05, 0, -0.05), new Vector3(0.05, 0, 0.05), new Vector3(-0.05, 0, 0)];
  var vector1 = new Vector3();
  var vector2 = new Vector3();
  var vector3 = new Vector3();
  var vector4 = new Vector3();
  var normal1 = new Vector3();
  var normal2 = new Vector3();
  var normal3 = new Vector3();
  var normal4 = new Vector3();
  function extrudeShape(shape, fromPoint2, toPoint2) {
    for (let j2 = 0, jl2 = shape.length; j2 < jl2; j2++) {
      var point1 = shape[j2];
      var point2 = shape[(j2 + 1) % jl2];
      vector1.copy(point1);
      vector1.applyQuaternion(quaternion);
      vector1.add(fromPoint2);
      vector2.copy(point2);
      vector2.applyQuaternion(quaternion);
      vector2.add(fromPoint2);
      vector3.copy(point2);
      vector3.applyQuaternion(quaternion);
      vector3.add(toPoint2);
      vector4.copy(point1);
      vector4.applyQuaternion(quaternion);
      vector4.add(toPoint2);
      vertices.push(vector1.x, vector1.y, vector1.z);
      vertices.push(vector2.x, vector2.y, vector2.z);
      vertices.push(vector4.x, vector4.y, vector4.z);
      vertices.push(vector2.x, vector2.y, vector2.z);
      vertices.push(vector3.x, vector3.y, vector3.z);
      vertices.push(vector4.x, vector4.y, vector4.z);
      normal1.copy(point1);
      normal1.applyQuaternion(quaternion);
      normal1.normalize();
      normal2.copy(point2);
      normal2.applyQuaternion(quaternion);
      normal2.normalize();
      normal3.copy(point2);
      normal3.applyQuaternion(quaternion);
      normal3.normalize();
      normal4.copy(point1);
      normal4.applyQuaternion(quaternion);
      normal4.normalize();
      normals.push(normal1.x, normal1.y, normal1.z);
      normals.push(normal2.x, normal2.y, normal2.z);
      normals.push(normal4.x, normal4.y, normal4.z);
      normals.push(normal2.x, normal2.y, normal2.z);
      normals.push(normal3.x, normal3.y, normal3.z);
      normals.push(normal4.x, normal4.y, normal4.z);
    }
  }
  var fromPoint = new Vector3();
  var toPoint = new Vector3();
  for (let i2 = 1; i2 <= divisions; i2++) {
    point.copy(curve.getPointAt(i2 / divisions));
    tangent.copy(curve.getTangentAt(i2 / divisions));
    var angle = Math.atan2(tangent.x, tangent.z);
    quaternion.setFromAxisAngle(up, angle);
    if (point.y > 10) {
      fromPoint.set(-0.75, -0.35, 0);
      fromPoint.applyQuaternion(quaternion);
      fromPoint.add(point);
      toPoint.set(0.75, -0.35, 0);
      toPoint.applyQuaternion(quaternion);
      toPoint.add(point);
      extrudeShape(tube1, fromPoint, toPoint);
      fromPoint.set(-0.7, -0.3, 0);
      fromPoint.applyQuaternion(quaternion);
      fromPoint.add(point);
      toPoint.set(-0.7, -point.y, 0);
      toPoint.applyQuaternion(quaternion);
      toPoint.add(point);
      extrudeShape(tube2, fromPoint, toPoint);
      fromPoint.set(0.7, -0.3, 0);
      fromPoint.applyQuaternion(quaternion);
      fromPoint.add(point);
      toPoint.set(0.7, -point.y, 0);
      toPoint.applyQuaternion(quaternion);
      toPoint.add(point);
      extrudeShape(tube3, fromPoint, toPoint);
    } else {
      fromPoint.set(0, -0.2, 0);
      fromPoint.applyQuaternion(quaternion);
      fromPoint.add(point);
      toPoint.set(0, -point.y, 0);
      toPoint.applyQuaternion(quaternion);
      toPoint.add(point);
      extrudeShape(tube3, fromPoint, toPoint);
    }
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
  this.setAttribute("normal", new BufferAttribute(new Float32Array(normals), 3));
};
RollerCoasterLiftersGeometry.prototype = Object.create(BufferGeometry.prototype);
var RollerCoasterShadowGeometry = function(curve, divisions) {
  BufferGeometry.call(this);
  var vertices = [];
  var up = new Vector3(0, 1, 0);
  var forward = new Vector3();
  var quaternion = new Quaternion();
  var prevQuaternion = new Quaternion();
  prevQuaternion.setFromAxisAngle(up, Math.PI / 2);
  var point = new Vector3();
  var prevPoint = new Vector3();
  prevPoint.copy(curve.getPointAt(0));
  prevPoint.y = 0;
  var vector1 = new Vector3();
  var vector2 = new Vector3();
  var vector3 = new Vector3();
  var vector4 = new Vector3();
  for (let i2 = 1; i2 <= divisions; i2++) {
    point.copy(curve.getPointAt(i2 / divisions));
    point.y = 0;
    forward.subVectors(point, prevPoint);
    var angle = Math.atan2(forward.x, forward.z);
    quaternion.setFromAxisAngle(up, angle);
    vector1.set(-0.3, 0, 0);
    vector1.applyQuaternion(quaternion);
    vector1.add(point);
    vector2.set(0.3, 0, 0);
    vector2.applyQuaternion(quaternion);
    vector2.add(point);
    vector3.set(0.3, 0, 0);
    vector3.applyQuaternion(prevQuaternion);
    vector3.add(prevPoint);
    vector4.set(-0.3, 0, 0);
    vector4.applyQuaternion(prevQuaternion);
    vector4.add(prevPoint);
    vertices.push(vector1.x, vector1.y, vector1.z);
    vertices.push(vector2.x, vector2.y, vector2.z);
    vertices.push(vector4.x, vector4.y, vector4.z);
    vertices.push(vector2.x, vector2.y, vector2.z);
    vertices.push(vector3.x, vector3.y, vector3.z);
    vertices.push(vector4.x, vector4.y, vector4.z);
    prevPoint.copy(point);
    prevQuaternion.copy(quaternion);
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
};
RollerCoasterShadowGeometry.prototype = Object.create(BufferGeometry.prototype);
var SkyGeometry = function() {
  BufferGeometry.call(this);
  var vertices = [];
  for (let i2 = 0; i2 < 100; i2++) {
    var x = Math.random() * 800 - 400;
    var y = Math.random() * 50 + 50;
    var z = Math.random() * 800 - 400;
    var size2 = Math.random() * 40 + 20;
    vertices.push(x - size2, y, z - size2);
    vertices.push(x + size2, y, z - size2);
    vertices.push(x - size2, y, z + size2);
    vertices.push(x + size2, y, z - size2);
    vertices.push(x + size2, y, z + size2);
    vertices.push(x - size2, y, z + size2);
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
};
SkyGeometry.prototype = Object.create(BufferGeometry.prototype);
var TreesGeometry = function(landscape) {
  BufferGeometry.call(this);
  var vertices = [];
  var colors = [];
  var raycaster = new Raycaster();
  raycaster.ray.direction.set(0, -1, 0);
  for (let i2 = 0; i2 < 2e3; i2++) {
    var x = Math.random() * 500 - 250;
    var z = Math.random() * 500 - 250;
    raycaster.ray.origin.set(x, 50, z);
    var intersections = raycaster.intersectObject(landscape);
    if (intersections.length === 0)
      continue;
    var y = intersections[0].point.y;
    var height = Math.random() * 5 + 0.5;
    var angle = Math.random() * Math.PI * 2;
    vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));
    vertices.push(x, y + height, z);
    vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));
    angle += Math.PI / 2;
    vertices.push(x + Math.sin(angle), y, z + Math.cos(angle));
    vertices.push(x, y + height, z);
    vertices.push(x + Math.sin(angle + Math.PI), y, z + Math.cos(angle + Math.PI));
    var random = Math.random() * 0.1;
    for (let j2 = 0; j2 < 6; j2++) {
      colors.push(0.2 + random, 0.4 + random, 0);
    }
  }
  this.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
  this.setAttribute("color", new BufferAttribute(new Float32Array(colors), 3));
};
TreesGeometry.prototype = Object.create(BufferGeometry.prototype);

// node_modules/@react-three/rapier/node_modules/three-stdlib/misc/VolumeSlice.js
var VolumeSlice = function(volume, index, axis) {
  var slice = this;
  this.volume = volume;
  index = index || 0;
  Object.defineProperty(this, "index", {
    get: function() {
      return index;
    },
    set: function(value) {
      index = value;
      slice.geometryNeedsUpdate = true;
      return index;
    }
  });
  this.axis = axis || "z";
  this.canvas = document.createElement("canvas");
  this.canvasBuffer = document.createElement("canvas");
  this.updateGeometry();
  var canvasMap = new Texture(this.canvas);
  canvasMap.minFilter = LinearFilter;
  canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;
  var material = new MeshBasicMaterial({
    map: canvasMap,
    side: DoubleSide,
    transparent: true
  });
  this.mesh = new Mesh(this.geometry, material);
  this.mesh.matrixAutoUpdate = false;
  this.geometryNeedsUpdate = true;
  this.repaint();
};
VolumeSlice.prototype = {
  constructor: VolumeSlice,
  /**
   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true
   * @memberof VolumeSlice
   */
  repaint: function() {
    if (this.geometryNeedsUpdate) {
      this.updateGeometry();
    }
    var iLength = this.iLength, jLength = this.jLength, sliceAccess = this.sliceAccess, volume = this.volume, canvas = this.canvasBuffer, ctx = this.ctxBuffer;
    var imgData = ctx.getImageData(0, 0, iLength, jLength);
    var data = imgData.data;
    var volumeData = volume.data;
    var upperThreshold = volume.upperThreshold;
    var lowerThreshold = volume.lowerThreshold;
    var windowLow = volume.windowLow;
    var windowHigh = volume.windowHigh;
    var pixelCount = 0;
    if (volume.dataType === "label") {
      for (let j2 = 0; j2 < jLength; j2++) {
        for (let i2 = 0; i2 < iLength; i2++) {
          var label2 = volumeData[sliceAccess(i2, j2)];
          label2 = label2 >= this.colorMap.length ? label2 % this.colorMap.length + 1 : label2;
          var color2 = this.colorMap[label2];
          data[4 * pixelCount] = color2 >> 24 & 255;
          data[4 * pixelCount + 1] = color2 >> 16 & 255;
          data[4 * pixelCount + 2] = color2 >> 8 & 255;
          data[4 * pixelCount + 3] = color2 & 255;
          pixelCount++;
        }
      }
    } else {
      for (let j2 = 0; j2 < jLength; j2++) {
        for (let i2 = 0; i2 < iLength; i2++) {
          var value = volumeData[sliceAccess(i2, j2)];
          var alpha = 255;
          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0;
          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));
          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;
          data[4 * pixelCount] = value;
          data[4 * pixelCount + 1] = value;
          data[4 * pixelCount + 2] = value;
          data[4 * pixelCount + 3] = alpha;
          pixelCount++;
        }
      }
    }
    ctx.putImageData(imgData, 0, 0);
    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);
    this.mesh.material.map.needsUpdate = true;
  },
  /**
   * @member {Function} Refresh the geometry according to axis and index
   * @see Volume.extractPerpendicularPlane
   * @memberof VolumeSlice
   */
  updateGeometry: function() {
    var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);
    this.sliceAccess = extracted.sliceAccess;
    this.jLength = extracted.jLength;
    this.iLength = extracted.iLength;
    this.matrix = extracted.matrix;
    this.canvas.width = extracted.planeWidth;
    this.canvas.height = extracted.planeHeight;
    this.canvasBuffer.width = this.iLength;
    this.canvasBuffer.height = this.jLength;
    this.ctx = this.canvas.getContext("2d");
    this.ctxBuffer = this.canvasBuffer.getContext("2d");
    if (this.geometry)
      this.geometry.dispose();
    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);
    if (this.mesh) {
      this.mesh.geometry = this.geometry;
      this.mesh.matrix.identity();
      this.mesh.applyMatrix4(this.matrix);
    }
    this.geometryNeedsUpdate = false;
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/misc/Volume.js
var Volume = function(xLength, yLength, zLength, type2, arrayBuffer) {
  if (arguments.length > 0) {
    this.xLength = Number(xLength) || 1;
    this.yLength = Number(yLength) || 1;
    this.zLength = Number(zLength) || 1;
    switch (type2) {
      case "Uint8":
      case "uint8":
      case "uchar":
      case "unsigned char":
      case "uint8_t":
        this.data = new Uint8Array(arrayBuffer);
        break;
      case "Int8":
      case "int8":
      case "signed char":
      case "int8_t":
        this.data = new Int8Array(arrayBuffer);
        break;
      case "Int16":
      case "int16":
      case "short":
      case "short int":
      case "signed short":
      case "signed short int":
      case "int16_t":
        this.data = new Int16Array(arrayBuffer);
        break;
      case "Uint16":
      case "uint16":
      case "ushort":
      case "unsigned short":
      case "unsigned short int":
      case "uint16_t":
        this.data = new Uint16Array(arrayBuffer);
        break;
      case "Int32":
      case "int32":
      case "int":
      case "signed int":
      case "int32_t":
        this.data = new Int32Array(arrayBuffer);
        break;
      case "Uint32":
      case "uint32":
      case "uint":
      case "unsigned int":
      case "uint32_t":
        this.data = new Uint32Array(arrayBuffer);
        break;
      case "longlong":
      case "long long":
      case "long long int":
      case "signed long long":
      case "signed long long int":
      case "int64":
      case "int64_t":
      case "ulonglong":
      case "unsigned long long":
      case "unsigned long long int":
      case "uint64":
      case "uint64_t":
        throw "Error in Volume constructor : this type is not supported in JavaScript";
      case "Float32":
      case "float32":
      case "float":
        this.data = new Float32Array(arrayBuffer);
        break;
      case "Float64":
      case "float64":
      case "double":
        this.data = new Float64Array(arrayBuffer);
        break;
      default:
        this.data = new Uint8Array(arrayBuffer);
    }
    if (this.data.length !== this.xLength * this.yLength * this.zLength) {
      throw "Error in Volume constructor, lengths are not matching arrayBuffer size";
    }
  }
  this.spacing = [1, 1, 1];
  this.offset = [0, 0, 0];
  this.matrix = new Matrix3();
  this.matrix.identity();
  var lowerThreshold = -Infinity;
  Object.defineProperty(this, "lowerThreshold", {
    get: function() {
      return lowerThreshold;
    },
    set: function(value) {
      lowerThreshold = value;
      this.sliceList.forEach(function(slice) {
        slice.geometryNeedsUpdate = true;
      });
    }
  });
  var upperThreshold = Infinity;
  Object.defineProperty(this, "upperThreshold", {
    get: function() {
      return upperThreshold;
    },
    set: function(value) {
      upperThreshold = value;
      this.sliceList.forEach(function(slice) {
        slice.geometryNeedsUpdate = true;
      });
    }
  });
  this.sliceList = [];
};
Volume.prototype = {
  constructor: Volume,
  /**
   * @member {Function} getData Shortcut for data[access(i,j,k)]
   * @memberof Volume
   * @param {number} i    First coordinate
   * @param {number} j    Second coordinate
   * @param {number} k    Third coordinate
   * @returns {number}  value in the data array
   */
  getData: function(i2, j2, k) {
    return this.data[k * this.xLength * this.yLength + j2 * this.xLength + i2];
  },
  /**
   * @member {Function} access compute the index in the data array corresponding to the given coordinates in IJK system
   * @memberof Volume
   * @param {number} i    First coordinate
   * @param {number} j    Second coordinate
   * @param {number} k    Third coordinate
   * @returns {number}  index
   */
  access: function(i2, j2, k) {
    return k * this.xLength * this.yLength + j2 * this.xLength + i2;
  },
  /**
   * @member {Function} reverseAccess Retrieve the IJK coordinates of the voxel corresponding of the given index in the data
   * @memberof Volume
   * @param {number} index index of the voxel
   * @returns {Array}  [x,y,z]
   */
  reverseAccess: function(index) {
    var z = Math.floor(index / (this.yLength * this.xLength));
    var y = Math.floor((index - z * this.yLength * this.xLength) / this.xLength);
    var x = index - z * this.yLength * this.xLength - y * this.xLength;
    return [x, y, z];
  },
  /**
   * @member {Function} map Apply a function to all the voxels, be careful, the value will be replaced
   * @memberof Volume
   * @param {Function} functionToMap A function to apply to every voxel, will be called with the following parameters :
   *                                 value of the voxel
   *                                 index of the voxel
   *                                 the data (TypedArray)
   * @param {Object}   context    You can specify a context in which call the function, default if this Volume
   * @returns {Volume}   this
   */
  map: function(functionToMap, context) {
    var length2 = this.data.length;
    context = context || this;
    for (let i2 = 0; i2 < length2; i2++) {
      this.data[i2] = functionToMap.call(context, this.data[i2], i2, this.data);
    }
    return this;
  },
  /**
   * @member {Function} extractPerpendicularPlane Compute the orientation of the slice and returns all the information relative to the geometry such as sliceAccess, the plane matrix (orientation and position in RAS coordinate) and the dimensions of the plane in both coordinate system.
   * @memberof Volume
   * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'
   * @param {number}            index the index of the slice
   * @returns {Object} an object containing all the usefull information on the geometry of the slice
   */
  extractPerpendicularPlane: function(axis, RASIndex) {
    var iLength, jLength, sliceAccess, planeMatrix = new Matrix4().identity(), volume = this, planeWidth, planeHeight, firstSpacing, secondSpacing, positionOffset, IJKIndex;
    var axisInIJK = new Vector3(), firstDirection = new Vector3(), secondDirection = new Vector3();
    var dimensions = new Vector3(this.xLength, this.yLength, this.zLength);
    switch (axis) {
      case "x":
        axisInIJK.set(1, 0, 0);
        firstDirection.set(0, 0, -1);
        secondDirection.set(0, -1, 0);
        firstSpacing = this.spacing[2];
        secondSpacing = this.spacing[1];
        IJKIndex = new Vector3(RASIndex, 0, 0);
        planeMatrix.multiply(new Matrix4().makeRotationY(Math.PI / 2));
        positionOffset = (volume.RASDimensions[0] - 1) / 2;
        planeMatrix.setPosition(new Vector3(RASIndex - positionOffset, 0, 0));
        break;
      case "y":
        axisInIJK.set(0, 1, 0);
        firstDirection.set(1, 0, 0);
        secondDirection.set(0, 0, 1);
        firstSpacing = this.spacing[0];
        secondSpacing = this.spacing[2];
        IJKIndex = new Vector3(0, RASIndex, 0);
        planeMatrix.multiply(new Matrix4().makeRotationX(-Math.PI / 2));
        positionOffset = (volume.RASDimensions[1] - 1) / 2;
        planeMatrix.setPosition(new Vector3(0, RASIndex - positionOffset, 0));
        break;
      case "z":
      default:
        axisInIJK.set(0, 0, 1);
        firstDirection.set(1, 0, 0);
        secondDirection.set(0, -1, 0);
        firstSpacing = this.spacing[0];
        secondSpacing = this.spacing[1];
        IJKIndex = new Vector3(0, 0, RASIndex);
        positionOffset = (volume.RASDimensions[2] - 1) / 2;
        planeMatrix.setPosition(new Vector3(0, 0, RASIndex - positionOffset));
        break;
    }
    firstDirection.applyMatrix4(volume.inverseMatrix).normalize();
    firstDirection.argVar = "i";
    secondDirection.applyMatrix4(volume.inverseMatrix).normalize();
    secondDirection.argVar = "j";
    axisInIJK.applyMatrix4(volume.inverseMatrix).normalize();
    iLength = Math.floor(Math.abs(firstDirection.dot(dimensions)));
    jLength = Math.floor(Math.abs(secondDirection.dot(dimensions)));
    planeWidth = Math.abs(iLength * firstSpacing);
    planeHeight = Math.abs(jLength * secondSpacing);
    IJKIndex = Math.abs(Math.round(IJKIndex.applyMatrix4(volume.inverseMatrix).dot(axisInIJK)));
    var base = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)];
    var iDirection = [firstDirection, secondDirection, axisInIJK].find(function(x) {
      return Math.abs(x.dot(base[0])) > 0.9;
    });
    var jDirection = [firstDirection, secondDirection, axisInIJK].find(function(x) {
      return Math.abs(x.dot(base[1])) > 0.9;
    });
    var kDirection = [firstDirection, secondDirection, axisInIJK].find(function(x) {
      return Math.abs(x.dot(base[2])) > 0.9;
    });
    sliceAccess = function(i2, j2) {
      var accessI, accessJ, accessK;
      var si = iDirection === axisInIJK ? IJKIndex : iDirection.argVar === "i" ? i2 : j2;
      var sj = jDirection === axisInIJK ? IJKIndex : jDirection.argVar === "i" ? i2 : j2;
      var sk = kDirection === axisInIJK ? IJKIndex : kDirection.argVar === "i" ? i2 : j2;
      var accessI = iDirection.dot(base[0]) > 0 ? si : volume.xLength - 1 - si;
      var accessJ = jDirection.dot(base[1]) > 0 ? sj : volume.yLength - 1 - sj;
      var accessK = kDirection.dot(base[2]) > 0 ? sk : volume.zLength - 1 - sk;
      return volume.access(accessI, accessJ, accessK);
    };
    return {
      iLength,
      jLength,
      sliceAccess,
      matrix: planeMatrix,
      planeWidth,
      planeHeight
    };
  },
  /**
   * @member {Function} extractSlice Returns a slice corresponding to the given axis and index
   *                        The coordinate are given in the Right Anterior Superior coordinate format
   * @memberof Volume
   * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'
   * @param {number}            index the index of the slice
   * @returns {VolumeSlice} the extracted slice
   */
  extractSlice: function(axis, index) {
    var slice = new VolumeSlice(this, index, axis);
    this.sliceList.push(slice);
    return slice;
  },
  /**
   * @member {Function} repaintAllSlices Call repaint on all the slices extracted from this volume
   * @see VolumeSlice.repaint
   * @memberof Volume
   * @returns {Volume} this
   */
  repaintAllSlices: function() {
    this.sliceList.forEach(function(slice) {
      slice.repaint();
    });
    return this;
  },
  /**
   * @member {Function} computeMinMax Compute the minimum and the maximum of the data in the volume
   * @memberof Volume
   * @returns {Array} [min,max]
   */
  computeMinMax: function() {
    var min2 = Infinity;
    var max2 = -Infinity;
    var datasize = this.data.length;
    var i2 = 0;
    for (i2 = 0; i2 < datasize; i2++) {
      if (!isNaN(this.data[i2])) {
        var value = this.data[i2];
        min2 = Math.min(min2, value);
        max2 = Math.max(max2, value);
      }
    }
    this.min = min2;
    this.max = max2;
    return [min2, max2];
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/renderers/CSS2DRenderer.js
var _vector = new Vector3();
var _viewMatrix = new Matrix4();
var _viewProjectionMatrix = new Matrix4();
var _a = new Vector3();
var _b = new Vector3();

// node_modules/@react-three/rapier/node_modules/three-stdlib/renderers/CSS3DRenderer.js
var CSS3DObject = function(element2) {
  Object3D.call(this);
  this.element = element2 || document.createElement("div");
  this.element.style.position = "absolute";
  this.element.style.pointerEvents = "auto";
  this.addEventListener("removed", function() {
    this.traverse(function(object) {
      if (object.element instanceof Element && object.element.parentNode !== null) {
        object.element.parentNode.removeChild(object.element);
      }
    });
  });
};
CSS3DObject.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: CSS3DObject,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.element = source.element.cloneNode(true);
    return this;
  }
});
var CSS3DSprite = function(element2) {
  CSS3DObject.call(this, element2);
};
CSS3DSprite.prototype = Object.create(CSS3DObject.prototype);
CSS3DSprite.prototype.constructor = CSS3DSprite;

// node_modules/@react-three/rapier/node_modules/three-stdlib/renderers/Projector.js
var RenderableVertex = function() {
  this.position = new Vector3();
  this.positionWorld = new Vector3();
  this.positionScreen = new Vector4();
  this.visible = true;
};
RenderableVertex.prototype.copy = function(vertex) {
  this.positionWorld.copy(vertex.positionWorld);
  this.positionScreen.copy(vertex.positionScreen);
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/renderers/SVGRenderer.js
var SVGObject = function(node) {
  Object3D.call(this);
  this.node = node;
};
SVGObject.prototype = Object.create(Object3D.prototype);
SVGObject.prototype.constructor = SVGObject;

// node_modules/@react-three/rapier/node_modules/three-stdlib/modifiers/CurveModifier.js
var matrix = new Matrix4();

// node_modules/@react-three/rapier/node_modules/three-stdlib/utils/BufferGeometryUtils.js
function mergeVertices(geometry, tolerance = 1e-4) {
  tolerance = Math.max(tolerance, Number.EPSILON);
  const hashToIndex = {};
  const indices = geometry.getIndex();
  const positions = geometry.getAttribute("position");
  const vertexCount = indices ? indices.count : positions.count;
  let nextIndex = 0;
  const attributeNames = Object.keys(geometry.attributes);
  const attrArrays = {};
  const morphAttrsArrays = {};
  const newIndices = [];
  const getters = ["getX", "getY", "getZ", "getW"];
  for (let i2 = 0, l = attributeNames.length; i2 < l; i2++) {
    const name = attributeNames[i2];
    attrArrays[name] = [];
    const morphAttr = geometry.morphAttributes[name];
    if (morphAttr) {
      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);
    }
  }
  const decimalShift = Math.log10(1 / tolerance);
  const shiftMultiplier = Math.pow(10, decimalShift);
  for (let i2 = 0; i2 < vertexCount; i2++) {
    const index = indices ? indices.getX(i2) : i2;
    let hash = "";
    for (let j2 = 0, l = attributeNames.length; j2 < l; j2++) {
      const name = attributeNames[j2];
      const attribute2 = geometry.getAttribute(name);
      const itemSize = attribute2.itemSize;
      for (let k = 0; k < itemSize; k++) {
        hash += `${~~(attribute2[getters[k]](index) * shiftMultiplier)},`;
      }
    }
    if (hash in hashToIndex) {
      newIndices.push(hashToIndex[hash]);
    } else {
      for (let j2 = 0, l = attributeNames.length; j2 < l; j2++) {
        const name = attributeNames[j2];
        const attribute2 = geometry.getAttribute(name);
        const morphAttr = geometry.morphAttributes[name];
        const itemSize = attribute2.itemSize;
        const newarray = attrArrays[name];
        const newMorphArrays = morphAttrsArrays[name];
        for (let k = 0; k < itemSize; k++) {
          const getterFunc = getters[k];
          newarray.push(attribute2[getterFunc](index));
          if (morphAttr) {
            for (let m = 0, ml = morphAttr.length; m < ml; m++) {
              newMorphArrays[m].push(morphAttr[m][getterFunc](index));
            }
          }
        }
      }
      hashToIndex[hash] = nextIndex;
      newIndices.push(nextIndex);
      nextIndex++;
    }
  }
  const result = geometry.clone();
  for (let i2 = 0, l = attributeNames.length; i2 < l; i2++) {
    const name = attributeNames[i2];
    const oldAttribute = geometry.getAttribute(name);
    const buffer2 = new oldAttribute.array.constructor(attrArrays[name]);
    const attribute2 = new BufferAttribute(buffer2, oldAttribute.itemSize, oldAttribute.normalized);
    result.setAttribute(name, attribute2);
    if (name in morphAttrsArrays) {
      for (let j2 = 0; j2 < morphAttrsArrays[name].length; j2++) {
        const oldMorphAttribute = geometry.morphAttributes[name][j2];
        const buffer3 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j2]);
        const morphAttribute = new BufferAttribute(buffer3, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);
        result.morphAttributes[name][j2] = morphAttribute;
      }
    }
  }
  result.setIndex(newIndices);
  return result;
}

// node_modules/@react-three/rapier/node_modules/three-stdlib/modifiers/SimplifyModifier.js
var cb = new Vector3();
var ab = new Vector3();

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/constants.js
var NodeShaderStage = {
  Vertex: "vertex",
  Fragment: "fragment"
};
var NodeUpdateType = {
  None: "none",
  Frame: "frame",
  Object: "object"
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeUtils.js
var getNodesKeys = (object) => {
  const props = [];
  for (const name in object) {
    const value = object[name];
    if (value && value.isNode === true) {
      props.push(name);
    }
  }
  return props;
};
var getValueType = (value) => {
  if (typeof value === "number") {
    return "float";
  } else if (typeof value === "boolean") {
    return "bool";
  } else if ((value === null || value === void 0 ? void 0 : value.isVector2) === true) {
    return "vec2";
  } else if ((value === null || value === void 0 ? void 0 : value.isVector3) === true) {
    return "vec3";
  } else if ((value === null || value === void 0 ? void 0 : value.isVector4) === true) {
    return "vec4";
  } else if ((value === null || value === void 0 ? void 0 : value.isMatrix3) === true) {
    return "mat3";
  } else if ((value === null || value === void 0 ? void 0 : value.isMatrix4) === true) {
    return "mat4";
  } else if ((value === null || value === void 0 ? void 0 : value.isColor) === true) {
    return "color";
  }
  return null;
};
var getValueFromType = (type2, ...params) => {
  const last4 = type2 === null || type2 === void 0 ? void 0 : type2.slice(-4);
  if (type2 === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type2 === "bool") {
    return false;
  } else if (type2 === "float" || type2 === "int" || type2 === "uint") {
    return 0;
  }
  return null;
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/Node.js
var _nodeId = 0;
var Node2 = class {
  constructor(nodeType = null) {
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.None;
    this.uuid = MathUtils.generateUUID();
    Object.defineProperty(this, "id", {
      value: _nodeId++
    });
  }
  get type() {
    return this.constructor.name;
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getNodeType() {
    return this.nodeType;
  }
  update() {
    console.warn("Abstract function.");
  }
  generate() {
    console.warn("Abstract function.");
  }
  analyze(builder) {
    const hash = this.getHash(builder);
    const sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode !== void 0 && this !== sharedNode) {
      return sharedNode.analyze(builder);
    }
    const nodeData = builder.getDataFromNode(this);
    nodeData.dependenciesCount = nodeData.dependenciesCount === void 0 ? 1 : nodeData.dependenciesCount + 1;
    const nodeKeys = getNodesKeys(this);
    for (const property of nodeKeys) {
      this[property].analyze(builder);
    }
  }
  build(builder, output = null) {
    const hash = this.getHash(builder);
    const sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode !== void 0 && this !== sharedNode) {
      return sharedNode.build(builder, output);
    }
    builder.addNode(this);
    builder.addStack(this);
    const nodeData = builder.getDataFromNode(this);
    const isGenerateOnce = this.generate.length === 1;
    let snippet = null;
    if (isGenerateOnce) {
      const type2 = this.getNodeType(builder);
      snippet = nodeData.snippet;
      if (snippet === void 0) {
        snippet = this.generate(builder) || "";
        nodeData.snippet = snippet;
      }
      snippet = builder.format(snippet, type2, output);
    } else {
      snippet = this.generate(builder, output) || "";
    }
    builder.removeStack(this);
    return snippet;
  }
  serialize(json) {
    const nodeKeys = getNodesKeys(this);
    if (nodeKeys.length > 0) {
      const inputNodes = {};
      for (const property of nodeKeys) {
        inputNodes[property] = this[property].toJSON(json.meta).uuid;
      }
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property in json.inputNodes) {
        const uuid = json.inputNodes[property];
        this[property] = nodes[uuid];
      }
    }
  }
  toJSON(meta) {
    const {
      uuid,
      type: type2
    } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type: type2,
        meta,
        metadata: {
          version: 4.5,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
Node2.prototype.isNode = true;
var Node_default = Node2;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/InputNode.js
var InputNode = class extends Node_default {
  constructor(value, nodeType = null) {
    super(nodeType);
    this.value = value;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  serialize(data) {
    var _this$value, _this$value$toArray;
    super.serialize(data);
    data.value = ((_this$value = this.value) === null || _this$value === void 0 ? void 0 : (_this$value$toArray = _this$value.toArray) === null || _this$value$toArray === void 0 ? void 0 : _this$value$toArray.call(_this$value)) || this.value;
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
  }
  deserialize(data) {
    var _this$value2, _this$value2$fromArra;
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = getValueFromType(data.valueType);
    this.value = ((_this$value2 = this.value) === null || _this$value2 === void 0 ? void 0 : (_this$value2$fromArra = _this$value2.fromArray) === null || _this$value2$fromArra === void 0 ? void 0 : _this$value2$fromArra.call(_this$value2, data.value)) || data.value;
  }
  generate() {
    console.warn("Abstract function.");
  }
};
InputNode.prototype.isInputNode = true;
var InputNode_default = InputNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/UniformNode.js
var UniformNode = class extends InputNode_default {
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  generate(builder, output) {
    const type2 = this.getNodeType(builder);
    const hash = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, builder.shaderStage, sharedNodeType);
    const propertyName = builder.getPropertyName(nodeUniform);
    return builder.format(propertyName, type2, output);
  }
};
UniformNode.prototype.isUniformNode = true;
var UniformNode_default = UniformNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/ArrayUniformNode.js
var ArrayUniformNode = class extends UniformNode_default {
  constructor(nodes = []) {
    super();
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return this.nodes[0].getNodeType(builder);
  }
};
ArrayUniformNode.prototype.isArrayUniformNode = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/VaryNode.js
var VaryNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const node = this.node;
    const name = this.name;
    const nodeVary = builder.getVaryFromNode(this, type2);
    if (name !== null) {
      nodeVary.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVary, NodeShaderStage.Vertex);
    builder.flowNodeFromShaderStage(NodeShaderStage.Vertex, node, type2, propertyName);
    return builder.getPropertyName(nodeVary);
  }
};
var VaryNode_default = VaryNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/AttributeNode.js
var AttributeNode = class extends Node_default {
  constructor(attributeName, nodeType) {
    super(nodeType);
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attribute2 = builder.getAttribute(this.getAttributeName(builder), this.getNodeType(builder));
    if (builder.isShaderStage("vertex")) {
      return attribute2.name;
    } else {
      const nodeVary = new VaryNode_default(this);
      return nodeVary.build(builder, attribute2.type);
    }
  }
};
var AttributeNode_default = AttributeNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder, output) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addFlowCode(snippet);
    }
    return this.outputNode.build(builder, output);
  }
};
BypassNode.prototype.isBypassNode = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/CodeNode.js
var CodeNode = class extends Node_default {
  constructor(code = "", nodeType = "code") {
    super(nodeType);
    this.code = code;
    this._includes = [];
  }
  setIncludes(includes) {
    this._includes = includes;
    return this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(builder) {
    const includes = this.getIncludes(builder);
    for (const include of includes) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
};
CodeNode.prototype.isCodeNode = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/ConstNode.js
var ConstNode = class extends InputNode_default {
  generateConst(builder) {
    return builder.getConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output) {
    const type2 = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type2, output);
  }
};
ConstNode.prototype.isConstNode = true;
var ConstNode_default = ConstNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context = {}) {
    super();
    this.node = node;
    this.context = context;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder, output) {
    const previousContext = builder.getContext();
    builder.setContext(Object.assign({}, builder.context, this.context));
    const snippet = this.node.build(builder, output);
    builder.setContext(previousContext);
    return snippet;
  }
};
ContextNode.prototype.isContextNode = true;
var ContextNode_default = ContextNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/TempNode.js
var TempNode = class extends Node_default {
  constructor(type2) {
    super(type2);
  }
  build(builder, output) {
    const type2 = builder.getVectorType(this.getNodeType(builder, output));
    const nodeData = builder.getDataFromNode(this);
    if (builder.context.temp !== false && type2 !== "void " && output !== "void" && nodeData.dependenciesCount > 1) {
      if (nodeData.snippet === void 0) {
        const snippet = super.build(builder, type2);
        const nodeVar = builder.getVarFromNode(this, type2);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
      }
      return builder.format(nodeData.propertyName, type2, output);
    }
    return super.build(builder, output);
  }
};
var TempNode_default = TempNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/ExpressionNode.js
var ExpressionNode = class extends TempNode_default {
  constructor(snipped = "", nodeType = "void") {
    super(nodeType);
    this.snipped = snipped;
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const snipped = this.snipped;
    if (type2 === "void") {
      builder.addFlowCode(snipped);
    } else {
      return `( ${snipped} )`;
    }
  }
};
var ExpressionNode_default = ExpressionNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeAttribute.js
var NodeAttribute = class {
  constructor(name, type2) {
    this.name = name;
    this.type = type2;
  }
};
NodeAttribute.prototype.isNodeAttribute = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeUniform.js
var NodeUniform = class {
  constructor(name, type2, node, needsUpdate = void 0) {
    this.name = name;
    this.type = type2;
    this.node = node;
    this.needsUpdate = needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
};
NodeUniform.prototype.isNodeUniform = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeVary.js
var NodeVary = class {
  constructor(name, type2) {
    this.name = name;
    this.type = type2;
  }
};
NodeVary.prototype.isNodeVary = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeVar.js
var NodeVar = class {
  constructor(name, type2) {
    this.name = name;
    this.type = type2;
  }
};
NodeVar.prototype.isNodeVar = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeBuilder.js
var vector = ["x", "y", "z", "w"];

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/NodeFunctionInput.js
var NodeFunctionInput = class {
  constructor(type2, name, count = null, qualifier = "", isConst = false) {
    this.type = type2;
    this.name = name;
    this.count = count;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
};
NodeFunctionInput.isNodeFunctionInput = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(name = null, nodeType = "vec4") {
    super(nodeType);
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  generate(builder) {
    const nodeVary = builder.getVarFromNode(this, this.getNodeType(builder));
    const name = this.name;
    if (name !== null) {
      nodeVary.name = name;
    }
    return builder.getPropertyName(nodeVary);
  }
};
var PropertyNode_default = PropertyNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/core/VarNode.js
var VarNode = class extends Node_default {
  constructor(node, name = null, nodeType = null) {
    super(nodeType);
    this.node = node;
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return super.getNodeType(builder) || this.node.getNodeType(builder);
  }
  generate(builder) {
    const type2 = builder.getVectorType(this.getNodeType(builder));
    const node = this.node;
    const name = this.name;
    const snippet = node.build(builder, type2);
    const nodeVar = builder.getVarFromNode(this, type2);
    if (name !== null) {
      nodeVar.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addFlowCode(`${propertyName} = ${snippet}`);
    return propertyName;
  }
};
VarNode.prototype.isVarNode = true;
var VarNode_default = VarNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/BufferNode.js
var BufferNode = class extends UniformNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getInputType() {
    return "buffer";
  }
};
BufferNode.prototype.isBufferNode = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/Object3DNode.js
var Object3DNode = class extends Node_default {
  constructor(scope = Object3DNode.VIEW_MATRIX, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.Object;
    this._uniformNode = new UniformNode_default(null);
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX) {
      return "mat4";
    } else if (scope === Object3DNode.NORMAL_MATRIX) {
      return "mat3";
    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d !== null ? this.object3d : frame.object;
    const uniformNode = this._uniformNode;
    const camera = frame.camera;
    const scope = this.scope;
    if (scope === Object3DNode.VIEW_MATRIX) {
      uniformNode.value = object.modelViewMatrix;
    } else if (scope === Object3DNode.NORMAL_MATRIX) {
      uniformNode.value = object.normalMatrix;
    } else if (scope === Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === Object3DNode.POSITION) {
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === Object3DNode.VIEW_POSITION) {
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === Object3DNode.NORMAL_MATRIX) {
      this._uniformNode.nodeType = "mat3";
    } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION) {
      this._uniformNode.nodeType = "vec3";
      this._uniformNode.value = new Vector3();
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
_defineProperty(Object3DNode, "VIEW_MATRIX", "viewMatrix");
_defineProperty(Object3DNode, "NORMAL_MATRIX", "normalMatrix");
_defineProperty(Object3DNode, "WORLD_MATRIX", "worldMatrix");
_defineProperty(Object3DNode, "POSITION", "position");
_defineProperty(Object3DNode, "VIEW_POSITION", "viewPosition");
var Object3DNode_default = Object3DNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/CameraNode.js
var CameraNode = class extends Object3DNode_default {
  constructor(scope = CameraNode.POSITION) {
    super(scope);
  }
  getNodeType(builder) {
    const scope = this.scope;
    if (scope === CameraNode.PROJECTION_MATRIX) {
      return "mat4";
    }
    return super.getNodeType(builder);
  }
  update(frame) {
    const camera = frame.camera;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === CameraNode.PROJECTION_MATRIX) {
      uniformNode.value = camera.projectionMatrix;
    } else if (scope === CameraNode.VIEW_MATRIX) {
      uniformNode.value = camera.matrixWorldInverse;
    } else {
      this.object3d = camera;
      super.update(frame);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === CameraNode.PROJECTION_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    }
    return super.generate(builder);
  }
};
_defineProperty(CameraNode, "PROJECTION_MATRIX", "projectionMatrix");
var CameraNode_default = CameraNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/UVNode.js
var UVNode = class extends AttributeNode_default {
  constructor(index = 0) {
    super(null, "vec2");
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "uv" + (index > 0 ? index + 1 : "");
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
UVNode.prototype.isUVNode = true;
var UVNode_default = UVNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/TextureNode.js
var TextureNode = class extends UniformNode_default {
  constructor(value, uvNode = new UVNode_default(), biasNode = null) {
    super(value, "vec4");
    this.uvNode = uvNode;
    this.biasNode = biasNode;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getInputType() {
    return "texture";
  }
  generate(builder, output) {
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "texture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let snippet = nodeData.snippet;
      if (snippet === void 0) {
        const uvSnippet = this.uvNode.build(builder, "vec2");
        const biasNode = this.biasNode;
        if (biasNode !== null) {
          const biasSnippet = biasNode.build(builder, "float");
          snippet = builder.getTextureBias(textureProperty, uvSnippet, biasSnippet);
        } else {
          snippet = builder.getTexture(textureProperty, uvSnippet);
        }
        nodeData.snippet = snippet;
      }
      return builder.format(snippet, "vec4", output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
  }
};
TextureNode.prototype.isTextureNode = true;
var TextureNode_default = TextureNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/ModelNode.js
var ModelNode = class extends Object3DNode_default {
  constructor(scope = ModelNode.VIEW_MATRIX) {
    super(scope);
  }
};
var ModelNode_default = ModelNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/utils/JoinNode.js
var JoinNode = class extends Node_default {
  constructor(nodes = []) {
    super();
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const nodes = this.nodes;
    const snippetValues = [];
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const input = nodes[i2];
      const inputSnippet = input.build(builder);
      snippetValues.push(inputSnippet);
    }
    return `${builder.getType(type2)}( ${snippetValues.join(", ")} )`;
  }
};
var JoinNode_default = JoinNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/utils/SplitNode.js
var SplitNode = class extends Node_default {
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vector.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length);
  }
  generate(builder) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    if (nodeTypeLength > 1) {
      let type2 = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type2 = builder.getTypeFromLength(this.getVectorLength());
      }
      const nodeSnippet = node.build(builder, type2);
      return `${nodeSnippet}.${this.components}`;
    } else {
      return node.build(builder);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SplitNode_default = SplitNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/math/OperatorNode.js
var OperatorNode = class extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i2 = 0; i2 < params.length; i2++) {
        finalBNode = new OperatorNode(op, finalBNode, params[i2]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getNodeType(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode.getNodeType(builder);
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "=" || op === "%") {
      return typeA;
    } else if (op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return "int";
    } else if (op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = builder.getTypeLength(output);
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type2 = this.getNodeType(builder, output);
    let typeA = null;
    let typeB = null;
    if (type2 !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode.getNodeType(builder);
      if (op === "=") {
        typeB = typeA;
      } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type2;
      }
    } else {
      typeA = typeB = type2;
    }
    const a2 = aNode.build(builder, typeA);
    const b2 = bNode.build(builder, typeB);
    const outputLength = builder.getTypeLength(output);
    if (output !== "void") {
      if (op === "=") {
        builder.addFlowCode(`${a2} ${this.op} ${b2}`);
        return a2;
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a2}, ${b2} )`, type2, output);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a2}, ${b2} )`, type2, output);
      } else {
        return builder.format(`( ${a2} ${this.op} ${b2} )`, type2, output);
      }
    } else if (typeA !== "void") {
      return builder.format(`${a2} ${this.op} ${b2}`, type2, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var OperatorNode_default = OperatorNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/math/MathNode.js
var MathNode = class extends TempNode_default {
  // 1 input
  // 2 inputs
  // 3 inputs
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.getTypeLength(aType);
    const bLen = builder.getTypeLength(bType);
    const cLen = builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {
      return "float";
    } else if (method === MathNode.CROSS) {
      return "vec3";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output) {
    const method = this.method;
    const type2 = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a2 = this.aNode;
    const b2 = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (isWebGL && (method === MathNode.DFDX || method === MathNode.DFDY) && output === "vec3") {
      return new JoinNode_default([new MathNode(method, new SplitNode_default(a2, "x")), new MathNode(method, new SplitNode_default(a2, "y")), new MathNode(method, new SplitNode_default(a2, "z"))]).build(builder);
    } else if (method === MathNode.TRANSFORM_DIRECTION) {
      let tA = a2;
      let tB = b2;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = new ExpressionNode_default(`${builder.getType("vec4")}( ${tB.build(builder, "vec3")}, 0.0 )`, "vec4");
      } else {
        tA = new ExpressionNode_default(`${builder.getType("vec4")}( ${tA.build(builder, "vec3")}, 0.0 )`, "vec4");
      }
      const mulNode = new SplitNode_default(new OperatorNode_default("*", tA, tB), "xyz");
      return new MathNode(MathNode.NORMALIZE, mulNode).build(builder);
    } else if (method === MathNode.SATURATE) {
      return builder.format(`clamp( ${a2.build(builder, inputType)}, 0.0, 1.0 )`, type2, output);
    } else if (method === MathNode.NEGATE) {
      return builder.format("( -" + a2.build(builder, inputType) + " )", type2, output);
    } else if (method === MathNode.INVERT) {
      return builder.format("( 1.0 - " + a2.build(builder, inputType) + " )", type2, output);
    } else {
      const params = [];
      if (method === MathNode.CROSS) {
        params.push(a2.build(builder, type2), b2.build(builder, type2));
      } else if (method === MathNode.STEP) {
        params.push(a2.build(builder, builder.getTypeLength(a2.getNodeType(builder)) === 1 ? "float" : inputType), b2.build(builder, inputType));
      } else if (isWebGL && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {
        params.push(a2.build(builder, inputType), b2.build(builder, builder.getTypeLength(b2.getNodeType(builder)) === 1 ? "float" : inputType));
      } else if (method === MathNode.REFRACT) {
        params.push(a2.build(builder, inputType), b2.build(builder, inputType), c.build(builder, "float"));
      } else if (method === MathNode.MIX) {
        params.push(a2.build(builder, inputType), b2.build(builder, inputType), c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType));
      } else {
        params.push(a2.build(builder, inputType));
        if (c !== null) {
          params.push(b2.build(builder, inputType), c.build(builder, inputType));
        } else if (b2 !== null) {
          params.push(b2.build(builder, inputType));
        }
      }
      return builder.format(`${builder.getMethod(method)}( ${params.join(", ")} )`, type2, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
_defineProperty(MathNode, "RAD", "radians");
_defineProperty(MathNode, "DEG", "degrees");
_defineProperty(MathNode, "EXP", "exp");
_defineProperty(MathNode, "EXP2", "exp2");
_defineProperty(MathNode, "LOG", "log");
_defineProperty(MathNode, "LOG2", "log2");
_defineProperty(MathNode, "SQRT", "sqrt");
_defineProperty(MathNode, "INV_SQRT", "inversesqrt");
_defineProperty(MathNode, "FLOOR", "floor");
_defineProperty(MathNode, "CEIL", "ceil");
_defineProperty(MathNode, "NORMALIZE", "normalize");
_defineProperty(MathNode, "FRACT", "fract");
_defineProperty(MathNode, "SIN", "sin");
_defineProperty(MathNode, "COS", "cos");
_defineProperty(MathNode, "TAN", "tan");
_defineProperty(MathNode, "ASIN", "asin");
_defineProperty(MathNode, "ACOS", "acos");
_defineProperty(MathNode, "ATAN", "atan");
_defineProperty(MathNode, "ABS", "abs");
_defineProperty(MathNode, "SIGN", "sign");
_defineProperty(MathNode, "LENGTH", "length");
_defineProperty(MathNode, "NEGATE", "negate");
_defineProperty(MathNode, "INVERT", "invert");
_defineProperty(MathNode, "DFDX", "dFdx");
_defineProperty(MathNode, "DFDY", "dFdy");
_defineProperty(MathNode, "SATURATE", "saturate");
_defineProperty(MathNode, "ROUND", "round");
_defineProperty(MathNode, "MIN", "min");
_defineProperty(MathNode, "MAX", "max");
_defineProperty(MathNode, "MOD", "mod");
_defineProperty(MathNode, "STEP", "step");
_defineProperty(MathNode, "REFLECT", "reflect");
_defineProperty(MathNode, "DISTANCE", "distance");
_defineProperty(MathNode, "DOT", "dot");
_defineProperty(MathNode, "CROSS", "cross");
_defineProperty(MathNode, "POW", "pow");
_defineProperty(MathNode, "TRANSFORM_DIRECTION", "transformDirection");
_defineProperty(MathNode, "MIX", "mix");
_defineProperty(MathNode, "CLAMP", "clamp");
_defineProperty(MathNode, "REFRACT", "refract");
_defineProperty(MathNode, "SMOOTHSTEP", "smoothstep");
_defineProperty(MathNode, "FACEFORWARD", "faceforward");
var MathNode_default = MathNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/PositionNode.js
var PositionNode = class extends Node_default {
  constructor(scope = PositionNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === PositionNode.GEOMETRY) {
      outputNode = new AttributeNode_default("position", "vec3");
    } else if (scope === PositionNode.LOCAL) {
      outputNode = new VaryNode_default(new PositionNode(PositionNode.GEOMETRY));
    } else if (scope === PositionNode.WORLD) {
      const vertexPositionNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new ModelNode_default(ModelNode_default.WORLD_MATRIX), new PositionNode(PositionNode.LOCAL));
      outputNode = new VaryNode_default(vertexPositionNode);
    } else if (scope === PositionNode.VIEW) {
      const vertexPositionNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.VIEW_MATRIX), new PositionNode(PositionNode.LOCAL));
      outputNode = new VaryNode_default(vertexPositionNode);
    } else if (scope === PositionNode.VIEW_DIRECTION) {
      const vertexPositionNode = new MathNode_default(MathNode_default.NEGATE, new PositionNode(PositionNode.VIEW));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexPositionNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
_defineProperty(PositionNode, "GEOMETRY", "geometry");
_defineProperty(PositionNode, "LOCAL", "local");
_defineProperty(PositionNode, "WORLD", "world");
_defineProperty(PositionNode, "VIEW", "view");
_defineProperty(PositionNode, "VIEW_DIRECTION", "viewDirection");
var PositionNode_default = PositionNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/NormalNode.js
var NormalNode = class extends Node_default {
  constructor(scope = NormalNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === NormalNode.GEOMETRY) {
      outputNode = new AttributeNode_default("normal", "vec3");
    } else if (scope === NormalNode.LOCAL) {
      outputNode = new VaryNode_default(new NormalNode(NormalNode.GEOMETRY));
    } else if (scope === NormalNode.VIEW) {
      const vertexNormalNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.NORMAL_MATRIX), new NormalNode(NormalNode.LOCAL));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexNormalNode));
    } else if (scope === NormalNode.WORLD) {
      const vertexNormalNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new NormalNode(NormalNode.VIEW), new CameraNode_default(CameraNode_default.VIEW_MATRIX));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryNode_default(vertexNormalNode));
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
_defineProperty(NormalNode, "GEOMETRY", "geometry");
_defineProperty(NormalNode, "LOCAL", "local");
_defineProperty(NormalNode, "WORLD", "world");
_defineProperty(NormalNode, "VIEW", "view");
var NormalNode_default = NormalNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(node, ifNode, elseNode) {
    super();
    this.node = node;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    const elseType = this.elseNode.getNodeType(builder);
    if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
      return elseType;
    }
    return ifType;
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const context = {
      temp: false
    };
    const nodeProperty = new PropertyNode_default(null, type2).build(builder);
    const nodeSnippet = new ContextNode_default(
      this.node
      /*, context*/
    ).build(builder, "bool"), ifSnippet = new ContextNode_default(this.ifNode, context).build(builder, type2), elseSnippet = new ContextNode_default(this.elseNode, context).build(builder, type2);
    builder.addFlowCode(`if ( ${nodeSnippet} ) {

		${nodeProperty} = ${ifSnippet};

	} else {

		${nodeProperty} = ${elseSnippet};

	}`);
    return nodeProperty;
  }
};
var CondNode_default = CondNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/utils/ArrayElementNode.js
var ArrayElementNode = class extends Node_default {
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "int");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ArrayElementNode_default = ArrayElementNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/utils/ConvertNode.js
var ConvertNode = class extends Node_default {
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType() {
    return this.convertTo;
  }
  generate(builder) {
    const convertTo = this.convertTo;
    const node = this.node;
    if (builder.isReference(convertTo) === false) {
      const convertToSnippet = builder.getType(convertTo);
      const nodeSnippet = node.build(builder, convertTo);
      return `${builder.getVectorType(convertToSnippet)}( ${nodeSnippet} )`;
    } else {
      return node.build(builder, convertTo);
    }
  }
};
var ConvertNode_default = ConvertNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/ShaderNode.js
var NodeHandler = {
  construct(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(new ShaderNodeObjects(inputs), ...params);
  },
  get: function(node, prop) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = prop.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
        return new ShaderNodeObject(new SplitNode_default(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return new ShaderNodeObject(new ArrayElementNode_default(node, uint(Number(prop))));
      }
    }
    return node[prop];
  }
};
var nodeObjects = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj) {
  const type2 = typeof obj;
  if (type2 === "number" || type2 === "boolean") {
    return new ShaderNodeObject(getAutoTypedConstNode(obj));
  } else if (type2 === "object") {
    if (obj.isNode === true) {
      let nodeObject2 = nodeObjects.get(obj);
      if (nodeObject2 === void 0) {
        nodeObject2 = new Proxy(obj, NodeHandler);
        nodeObjects.set(obj, nodeObject2);
        nodeObjects.set(nodeObject2, nodeObject2);
      }
      return nodeObject2;
    }
  }
  return obj;
};
var ShaderNodeObjects = function(objects) {
  for (const name in objects) {
    objects[name] = new ShaderNodeObject(objects[name]);
  }
  return objects;
};
var getShaderNodeArray = (array) => {
  const len = array.length;
  for (let i2 = 0; i2 < len; i2++) {
    array[i2] = new ShaderNodeObject(array[i2]);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null) {
  if (scope === null) {
    return (...params) => {
      return new ShaderNodeObject(new NodeClass(...getShaderNodeArray(params)));
    };
  } else if (factor === null) {
    return (...params) => {
      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params)));
    };
  } else {
    factor = new ShaderNodeObject(factor);
    return (...params) => {
      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params), factor));
    };
  }
};
var ShaderNodeScript = function(jsFunc) {
  return (inputs, builder) => {
    new ShaderNodeObjects(inputs);
    return new ShaderNodeObject(jsFunc(inputs, builder));
  };
};
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (let bool2 of bools)
  boolsCacheMap.set(bool2, new ConstNode_default(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (let uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode_default(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode_default(el.value, "int")));
for (let int2 of ints)
  intsCacheMap.set(int2, new ConstNode_default(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode_default(el.value)));
for (let float2 of floats)
  floatsCacheMap.set(float2, new ConstNode_default(float2));
for (let float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode_default(-float2));
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getAutoTypedConstNode = (value) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode_default(value);
  }
};
var ConvertType = function(type2, cacheMap = null) {
  return (...params) => {
    if (params.length === 0) {
      return nodeObject(new ConstNode_default(getValueFromType(type2), type2));
    } else {
      if (type2 === "color" && params[0].isNode !== true) {
        params = [getValueFromType(type2, ...params)];
      }
      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
        return cacheMap.get(params[0]);
      }
      const nodes = params.map(getAutoTypedConstNode);
      return nodeObject(new ConvertNode_default(nodes.length === 1 ? nodes[0] : new JoinNode_default(nodes), type2));
    }
  };
};
var ShaderNode = new Proxy(ShaderNodeScript, NodeHandler);
var nodeObject = (val) => {
  return new ShaderNodeObject(val);
};
var color = new ConvertType("color");
var float = new ConvertType("float", floatsCacheMap);
var int = new ConvertType("int", intsCacheMap);
var uint = new ConvertType("uint", uintsCacheMap);
var bool = new ConvertType("bool", boolsCacheMap);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat3 = new ConvertType("mat3");
var imat3 = new ConvertType("imat3");
var umat3 = new ConvertType("umat3");
var bmat3 = new ConvertType("bmat3");
var mat4 = new ConvertType("mat4");
var imat4 = new ConvertType("imat4");
var umat4 = new ConvertType("umat4");
var bmat4 = new ConvertType("bmat4");
var join = (...params) => nodeObject(new JoinNode_default(getShaderNodeArray(params)));
var cond = (...params) => nodeObject(new CondNode_default(...getShaderNodeArray(params)));
var addTo = (varNode, ...params) => {
  varNode.node = add(varNode.node, ...getShaderNodeArray(params));
  return nodeObject(varNode);
};
var add = new ShaderNodeProxy(OperatorNode_default, "+");
var sub = new ShaderNodeProxy(OperatorNode_default, "-");
var mul = new ShaderNodeProxy(OperatorNode_default, "*");
var div = new ShaderNodeProxy(OperatorNode_default, "/");
var remainder = new ShaderNodeProxy(OperatorNode_default, "%");
var equal = new ShaderNodeProxy(OperatorNode_default, "==");
var assign = new ShaderNodeProxy(OperatorNode_default, "=");
var lessThan = new ShaderNodeProxy(OperatorNode_default, "<");
var greaterThan = new ShaderNodeProxy(OperatorNode_default, ">");
var lessThanEqual = new ShaderNodeProxy(OperatorNode_default, "<=");
var greaterThanEqual = new ShaderNodeProxy(OperatorNode_default, ">=");
var and = new ShaderNodeProxy(OperatorNode_default, "&&");
var or = new ShaderNodeProxy(OperatorNode_default, "||");
var xor = new ShaderNodeProxy(OperatorNode_default, "^^");
var bitAnd = new ShaderNodeProxy(OperatorNode_default, "&");
var bitOr = new ShaderNodeProxy(OperatorNode_default, "|");
var bitXor = new ShaderNodeProxy(OperatorNode_default, "^");
var shiftLeft = new ShaderNodeProxy(OperatorNode_default, "<<");
var shiftRight = new ShaderNodeProxy(OperatorNode_default, ">>");
var element = new ShaderNodeProxy(ArrayElementNode_default);
var normalGeometry = new ShaderNodeObject(new NormalNode_default(NormalNode_default.GEOMETRY));
var normalLocal = new ShaderNodeObject(new NormalNode_default(NormalNode_default.LOCAL));
var normalWorld = new ShaderNodeObject(new NormalNode_default(NormalNode_default.WORLD));
var normalView = new ShaderNodeObject(new NormalNode_default(NormalNode_default.VIEW));
var transformedNormalView = new ShaderNodeObject(new VarNode_default(new NormalNode_default(NormalNode_default.VIEW), "TransformedNormalView", "vec3"));
var positionLocal = new ShaderNodeObject(new PositionNode_default(PositionNode_default.LOCAL));
var positionWorld = new ShaderNodeObject(new PositionNode_default(PositionNode_default.WORLD));
var positionView = new ShaderNodeObject(new PositionNode_default(PositionNode_default.VIEW));
var positionViewDirection = new ShaderNodeObject(new PositionNode_default(PositionNode_default.VIEW_DIRECTION));
var viewMatrix = new ShaderNodeObject(new ModelNode_default(ModelNode_default.VIEW_MATRIX));
var cameraPosition = new ShaderNodeObject(new CameraNode_default(CameraNode_default.POSITION));
var diffuseColor = new ShaderNodeObject(new PropertyNode_default("DiffuseColor", "vec4"));
var roughness = new ShaderNodeObject(new PropertyNode_default("Roughness", "float"));
var metalness = new ShaderNodeObject(new PropertyNode_default("Metalness", "float"));
var alphaTest = new ShaderNodeObject(new PropertyNode_default("AlphaTest", "float"));
var specularColor = new ShaderNodeObject(new PropertyNode_default("SpecularColor", "color"));
var abs = new ShaderNodeProxy(MathNode_default, "abs");
var acos = new ShaderNodeProxy(MathNode_default, "acos");
var asin = new ShaderNodeProxy(MathNode_default, "asin");
var atan = new ShaderNodeProxy(MathNode_default, "atan");
var ceil = new ShaderNodeProxy(MathNode_default, "ceil");
var clamp = new ShaderNodeProxy(MathNode_default, "clamp");
var cos = new ShaderNodeProxy(MathNode_default, "cos");
var cross = new ShaderNodeProxy(MathNode_default, "cross");
var degrees = new ShaderNodeProxy(MathNode_default, "degrees");
var dFdx = new ShaderNodeProxy(MathNode_default, "dFdx");
var dFdy = new ShaderNodeProxy(MathNode_default, "dFdy");
var distance = new ShaderNodeProxy(MathNode_default, "distance");
var dot = new ShaderNodeProxy(MathNode_default, "dot");
var exp = new ShaderNodeProxy(MathNode_default, "exp");
var exp2 = new ShaderNodeProxy(MathNode_default, "exp2");
var faceforward = new ShaderNodeProxy(MathNode_default, "faceforward");
var floor = new ShaderNodeProxy(MathNode_default, "floor");
var fract = new ShaderNodeProxy(MathNode_default, "fract");
var invert = new ShaderNodeProxy(MathNode_default, "invert");
var inversesqrt = new ShaderNodeProxy(MathNode_default, "inversesqrt");
var length = new ShaderNodeProxy(MathNode_default, "length");
var log = new ShaderNodeProxy(MathNode_default, "log");
var log2 = new ShaderNodeProxy(MathNode_default, "log2");
var max = new ShaderNodeProxy(MathNode_default, "max");
var min = new ShaderNodeProxy(MathNode_default, "min");
var mix = new ShaderNodeProxy(MathNode_default, "mix");
var mod = new ShaderNodeProxy(MathNode_default, "mod");
var negate = new ShaderNodeProxy(MathNode_default, "negate");
var normalize = new ShaderNodeProxy(MathNode_default, "normalize");
var pow = new ShaderNodeProxy(MathNode_default, "pow");
var pow2 = new ShaderNodeProxy(MathNode_default, "pow", 2);
var pow3 = new ShaderNodeProxy(MathNode_default, "pow", 3);
var pow4 = new ShaderNodeProxy(MathNode_default, "pow", 4);
var radians = new ShaderNodeProxy(MathNode_default, "radians");
var reflect = new ShaderNodeProxy(MathNode_default, "reflect");
var refract = new ShaderNodeProxy(MathNode_default, "refract");
var round = new ShaderNodeProxy(MathNode_default, "round");
var saturate = new ShaderNodeProxy(MathNode_default, "saturate");
var sign = new ShaderNodeProxy(MathNode_default, "sign");
var sin = new ShaderNodeProxy(MathNode_default, "sin");
var smoothstep = new ShaderNodeProxy(MathNode_default, "smoothstep");
var sqrt = new ShaderNodeProxy(MathNode_default, "sqrt");
var step = new ShaderNodeProxy(MathNode_default, "step");
var tan = new ShaderNodeProxy(MathNode_default, "tan");
var transformDirection = new ShaderNodeProxy(MathNode_default, "transformDirection");
var EPSILON = float(1e-6);
var INFINITY = float(1e6);

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/ReflectNode.js
var ReflectNode = class extends Node_default {
  constructor(scope = ReflectNode.CUBE) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `reflect-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === ReflectNode.VECTOR) {
      const cameraToFrag = normalize(sub(positionWorld, cameraPosition));
      const reflectVec = reflect(cameraToFrag, normalWorld);
      return reflectVec.build(builder);
    } else if (scope === ReflectNode.CUBE) {
      const reflectVec = nodeObject(new ReflectNode(ReflectNode.VECTOR));
      const cubeUV = join(negate(reflectVec.x), reflectVec.yz);
      return cubeUV.build(builder);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
_defineProperty(ReflectNode, "VECTOR", "vector");
_defineProperty(ReflectNode, "CUBE", "cube");
var ReflectNode_default = ReflectNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/CubeTextureNode.js
var CubeTextureNode = class extends TextureNode_default {
  constructor(value, uvNode = new ReflectNode_default(), biasNode = null) {
    super(value, uvNode, biasNode);
  }
  getInputType() {
    return "cubeTexture";
  }
  generate(builder, output) {
    const texture2 = this.value;
    if (!texture2 || texture2.isCubeTexture !== true) {
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    }
    const textureProperty = UniformNode_default.prototype.generate.call(this, builder, "cubeTexture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let snippet = nodeData.snippet;
      if (snippet === void 0) {
        const uvSnippet = this.uvNode.build(builder, "vec3");
        const biasNode = this.biasNode;
        if (biasNode !== null) {
          const biasSnippet = biasNode.build(builder, "float");
          snippet = builder.getCubeTextureBias(textureProperty, uvSnippet, biasSnippet);
        } else {
          snippet = builder.getCubeTexture(textureProperty, uvSnippet);
        }
        nodeData.snippet = snippet;
      }
      return builder.format(snippet, "vec4", output);
    }
  }
};
CubeTextureNode.prototype.isCubeTextureNode = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/ReferenceNode.js
var ReferenceNode = class extends Node_default {
  constructor(property, uniformType, object = null) {
    super();
    this.property = property;
    this.uniformType = uniformType;
    this.object = object;
    this.node = null;
    this.updateType = NodeUpdateType.Object;
    this.setNodeType(uniformType);
  }
  setNodeType(uniformType) {
    this.node = new UniformNode_default(null, uniformType);
    this.nodeType = uniformType;
    if (uniformType === "color") {
      this.nodeType = "vec3";
    } else if (uniformType === "texture") {
      this.nodeType = "vec4";
    }
  }
  getNodeType() {
    return this.uniformType;
  }
  update(frame) {
    const object = this.object !== null ? this.object : frame.object;
    const value = object[this.property];
    this.node.value = value;
  }
  generate(builder) {
    return this.node.build(builder, this.getNodeType(builder));
  }
};
var ReferenceNode_default = ReferenceNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/MaterialReferenceNode.js
var MaterialReferenceNode = class extends ReferenceNode_default {
  constructor(property, inputType, material = null) {
    super(property, inputType, material);
    this.material = material;
  }
  update(frame) {
    this.object = this.material !== null ? this.material : frame.material;
    super.update(frame);
  }
};
var MaterialReferenceNode_default = MaterialReferenceNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/MaterialNode.js
var MaterialNode = class extends Node_default {
  constructor(scope = MaterialNode.COLOR) {
    super();
    this.scope = scope;
  }
  getNodeType(builder) {
    const scope = this.scope;
    const material = builder.context.material;
    if (scope === MaterialNode.COLOR) {
      return material.map !== null ? "vec4" : "vec3";
    } else if (scope === MaterialNode.OPACITY) {
      return "float";
    } else if (scope === MaterialNode.SPECULAR) {
      return "vec3";
    } else if (scope === MaterialNode.ROUGHNESS || scope === MaterialNode.METALNESS) {
      return "float";
    }
  }
  generate(builder, output) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === MaterialNode.ALPHA_TEST) {
      node = new MaterialReferenceNode_default("alphaTest", "float");
    } else if (scope === MaterialNode.COLOR) {
      const colorNode = new MaterialReferenceNode_default("color", "color");
      if (material.map !== null && material.map !== void 0 && material.map.isTexture === true) {
        node = new OperatorNode_default("*", colorNode, new MaterialReferenceNode_default("map", "texture"));
      } else {
        node = colorNode;
      }
    } else if (scope === MaterialNode.OPACITY) {
      const opacityNode = new MaterialReferenceNode_default("opacity", "float");
      if (material.alphaMap !== null && material.alphaMap !== void 0 && material.alphaMap.isTexture === true) {
        node = new OperatorNode_default("*", opacityNode, new MaterialReferenceNode_default("alphaMap", "texture"));
      } else {
        node = opacityNode;
      }
    } else if (scope === MaterialNode.SPECULAR) {
      const specularColorNode = new MaterialReferenceNode_default("specularColor", "color");
      if (material.specularColorMap !== null && material.specularColorMap !== void 0 && material.specularColorMap.isTexture === true) {
        node = new OperatorNode_default("*", specularColorNode, new MaterialReferenceNode_default("specularColorMap", "texture"));
      } else {
        node = specularColorNode;
      }
    } else {
      const outputType = this.getNodeType(builder);
      node = new MaterialReferenceNode_default(scope, outputType);
    }
    return node.build(builder, output);
  }
};
_defineProperty(MaterialNode, "ALPHA_TEST", "alphaTest");
_defineProperty(MaterialNode, "COLOR", "color");
_defineProperty(MaterialNode, "OPACITY", "opacity");
_defineProperty(MaterialNode, "SPECULAR", "specular");
_defineProperty(MaterialNode, "ROUGHNESS", "roughness");
_defineProperty(MaterialNode, "METALNESS", "metalness");

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/PointUVNode.js
var PointUVNode = class extends Node_default {
  constructor() {
    super("vec2");
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
PointUVNode.prototype.isPointUVNode = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/accessors/SkinningNode.js
var Skinning = new ShaderNode((inputs, builder) => {
  const {
    index,
    weight,
    bindMatrix,
    bindMatrixInverse,
    boneMatrices
  } = inputs;
  const boneMatX = element(boneMatrices, index.x);
  const boneMatY = element(boneMatrices, index.y);
  const boneMatZ = element(boneMatrices, index.z);
  const boneMatW = element(boneMatrices, index.w);
  const skinVertex = mul(bindMatrix, positionLocal);
  const skinned = add(mul(mul(boneMatX, skinVertex), weight.x), mul(mul(boneMatY, skinVertex), weight.y), mul(mul(boneMatZ, skinVertex), weight.z), mul(mul(boneMatW, skinVertex), weight.w));
  const skinPosition = mul(bindMatrixInverse, skinned).xyz;
  let skinMatrix = add(mul(weight.x, boneMatX), mul(weight.y, boneMatY), mul(weight.z, boneMatZ), mul(weight.w, boneMatW));
  skinMatrix = mul(mul(bindMatrixInverse, skinMatrix), bindMatrix);
  const skinNormal = transformDirection(skinMatrix, normalLocal).xyz;
  assign(positionLocal, skinPosition).build(builder);
  assign(normalLocal, skinNormal).build(builder);
});

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/display/ColorSpaceNode.js
var LinearToLinear = new ShaderNode((inputs) => {
  return inputs.value;
});
var LinearTosRGB = new ShaderNode((inputs) => {
  const {
    value
  } = inputs;
  const rgb = value.rgb;
  const a2 = sub(mul(pow(value.rgb, vec3(0.41666)), 1.055), vec3(0.055));
  const b2 = mul(rgb, 12.92);
  const factor = vec3(lessThanEqual(rgb, vec3(31308e-7)));
  const rgbResult = mix(a2, b2, factor);
  return join(rgbResult.r, rgbResult.g, rgbResult.b, value.a);
});
var EncodingLib = {
  LinearToLinear,
  LinearTosRGB
};
var ColorSpaceNode = class extends Node_default {
  constructor(method, node) {
    super("vec4");
    this.method = method;
    this.node = node;
  }
  fromEncoding(encoding) {
    let method = null;
    if (encoding === LinearEncoding) {
      method = "Linear";
    } else if (encoding === sRGBEncoding) {
      method = "sRGB";
    }
    this.method = "LinearTo" + method;
    return this;
  }
  generate(builder) {
    const type2 = this.getNodeType(builder);
    const method = this.method;
    const node = this.node;
    if (method !== ColorSpaceNode.LINEAR_TO_LINEAR) {
      const encodingFunctionNode = EncodingLib[method];
      return encodingFunctionNode({
        value: node
      }).build(builder, type2);
    } else {
      return node.build(builder, type2);
    }
  }
};
_defineProperty(ColorSpaceNode, "LINEAR_TO_LINEAR", "LinearToLinear");
_defineProperty(ColorSpaceNode, "LINEAR_TO_SRGB", "LinearTosRGB");

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/display/NormalMapNode.js
var perturbNormal2ArbNode = new ShaderNode((inputs) => {
  const {
    eye_pos,
    surf_norm,
    mapN,
    faceDirection,
    uv: uv2
  } = inputs;
  const q0 = dFdx(eye_pos.xyz);
  const q1 = dFdy(eye_pos.xyz);
  const st0 = dFdx(uv2.st);
  const st1 = dFdy(uv2.st);
  const N = surf_norm;
  const q1perp = cross(q1, N);
  const q0perp = cross(N, q0);
  const T = add(mul(q1perp, st0.x), mul(q0perp, st1.x));
  const B = add(mul(q1perp, st0.y), mul(q0perp, st1.y));
  const det = max(dot(T, T), dot(B, B));
  const scale = cond(equal(det, 0), 0, mul(faceDirection, inversesqrt(det)));
  return normalize(add(mul(T, mul(mapN.x, scale)), mul(B, mul(mapN.y, scale)), mul(N, mapN.z)));
});

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/functions/BSDFs.js
var F_Schlick = new ShaderNode((inputs) => {
  const {
    f0,
    f90,
    dotVH
  } = inputs;
  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));
  return add(mul(f0, sub(1, fresnel)), mul(f90, fresnel));
});
var BRDF_Lambert = new ShaderNode((inputs) => {
  return mul(1 / Math.PI, inputs.diffuseColor);
});
var getDistanceAttenuation = new ShaderNode((inputs) => {
  const {
    lightDistance,
    cutoffDistance,
    decayExponent
  } = inputs;
  return cond(and(greaterThan(cutoffDistance, 0), greaterThan(decayExponent, 0)), pow(saturate(add(div(negate(lightDistance), cutoffDistance), 1)), decayExponent), 1);
});
var V_GGX_SmithCorrelated = new ShaderNode((inputs) => {
  const {
    alpha,
    dotNL,
    dotNV
  } = inputs;
  const a2 = pow2(alpha);
  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1, a2), pow2(dotNV)))));
  const gl = mul(dotNV, sqrt(add(a2, mul(sub(1, a2), pow2(dotNL)))));
  return div(0.5, max(add(gv, gl), EPSILON));
});
var D_GGX = new ShaderNode((inputs) => {
  const {
    alpha,
    dotNH
  } = inputs;
  const a2 = pow2(alpha);
  const denom = add(mul(pow2(dotNH), sub(a2, 1)), 1);
  return mul(1 / Math.PI, div(a2, pow2(denom)));
});
var BRDF_GGX = new ShaderNode((inputs) => {
  const {
    lightDirection,
    f0,
    f90,
    roughness: roughness2
  } = inputs;
  const alpha = pow2(roughness2);
  const halfDir = normalize(add(lightDirection, positionViewDirection));
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  const dotNV = saturate(dot(transformedNormalView, positionViewDirection));
  const dotNH = saturate(dot(transformedNormalView, halfDir));
  const dotVH = saturate(dot(positionViewDirection, halfDir));
  const F = F_Schlick({
    f0,
    f90,
    dotVH
  });
  const V = V_GGX_SmithCorrelated({
    alpha,
    dotNL,
    dotNV
  });
  const D = D_GGX({
    alpha,
    dotNH
  });
  return mul(F, mul(V, D));
});
var RE_Direct_Physical = new ShaderNode((inputs) => {
  const {
    lightDirection,
    lightColor,
    directDiffuse,
    directSpecular
  } = inputs;
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  let irradiance = mul(dotNL, lightColor);
  irradiance = mul(irradiance, Math.PI);
  addTo(directDiffuse, mul(irradiance, BRDF_Lambert({
    diffuseColor: diffuseColor.rgb
  })));
  addTo(directSpecular, mul(irradiance, BRDF_GGX({
    lightDirection,
    f0: specularColor,
    f90: 1,
    roughness
  })));
});
var PhysicalLightingModel = new ShaderNode((inputs) => {
  RE_Direct_Physical(inputs);
});

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/utils/TimerNode.js
var TimerNode = class extends UniformNode_default {
  constructor(scope = TimerNode.LOCAL) {
    super(0);
    this.scope = scope;
    this.scale = 1;
    this.updateType = NodeUpdateType.Frame;
  }
  update(frame) {
    const scope = this.scope;
    const scale = this.scale;
    if (scope === TimerNode.LOCAL) {
      this.value += frame.deltaTime * scale;
    } else if (scope === TimerNode.DELTA) {
      this.value = frame.deltaTime * scale;
    } else {
      this.value = frame.time * scale;
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
    data.scale = this.scale;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
    this.scale = data.scale;
  }
};
_defineProperty(TimerNode, "LOCAL", "local");
_defineProperty(TimerNode, "GLOBAL", "global");
_defineProperty(TimerNode, "DELTA", "delta");
var TimerNode_default = TimerNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/utils/OscNode.js
var OscNode = class extends Node_default {
  constructor(method = OscNode.SINE, timeNode = new TimerNode_default()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  generate(builder) {
    const method = this.method;
    const timeNode = this.timeNode;
    let outputNode = null;
    if (method === OscNode.SINE) {
      outputNode = add(mul(sin(mul(add(timeNode, 0.75), Math.PI * 2)), 0.5), 0.5);
    } else if (method === OscNode.SQUARE) {
      outputNode = round(fract(timeNode));
    } else if (method === OscNode.TRIANGLE) {
      outputNode = abs(sub(1, mul(fract(add(timeNode, 0.5)), 2)));
    } else if (method === OscNode.SAWTOOTH) {
      outputNode = fract(timeNode);
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
_defineProperty(OscNode, "SINE", "sine");
_defineProperty(OscNode, "SQUARE", "square");
_defineProperty(OscNode, "TRIANGLE", "triangle");
_defineProperty(OscNode, "SAWTOOTH", "sawtooth");

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/procedural/CheckerNode.js
var checkerShaderNode = new ShaderNode((inputs) => {
  const uv2 = mul(inputs.uv, 2);
  const cx = floor(uv2.x);
  const cy = floor(uv2.y);
  const result = mod(add(cx, cy), 2);
  return sign(result);
});

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/fog/FogNode.js
var FogNode = class extends Node_default {
  constructor(colorNode, factorNode) {
    super("float");
    this.colorNode = colorNode;
    this.factorNode = factorNode;
  }
  generate(builder) {
    return this.factorNode.build(builder, "float");
  }
};
FogNode.prototype.isFogNode = true;
var FogNode_default = FogNode;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/fog/FogRangeNode.js
var FogRangeNode = class extends FogNode_default {
  constructor(colorNode, nearNode, farNode) {
    super(colorNode);
    this.nearNode = nearNode;
    this.farNode = farNode;
  }
  generate(builder) {
    this.factorNode = smoothstep(this.nearNode, this.farNode, negate(positionView.z));
    return super.generate(builder);
  }
};
FogRangeNode.prototype.isFogRangeNode = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/exporters/GLTFExporter.js
var GLTFExporter = class {
  constructor() {
    _defineProperty(this, "pluginCallbacks", void 0);
    this.pluginCallbacks = [];
    this.register(function(writer) {
      return new GLTFLightExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsUnlitExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsPBRSpecularGlossiness(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsTransmissionExtension(writer);
    });
    this.register(function(writer) {
      return new GLTFMaterialsVolumeExtension(writer);
    });
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(input, onDone, options) {
    const writer = new GLTFWriter();
    const plugins = [];
    for (let i2 = 0, il = this.pluginCallbacks.length; i2 < il; i2++) {
      plugins.push(this.pluginCallbacks[i2](writer));
    }
    writer.setPlugins(plugins);
    writer.write(input, onDone, options);
  }
  /**
   * Static utility functions
   */
};
_defineProperty(GLTFExporter, "Utils", {
  insertKeyframe: function(track, time) {
    const tolerance = 1e-3;
    const valueSize = track.getValueSize();
    const times = new track.TimeBufferType(track.times.length + 1);
    const values = new track.ValueBufferType(track.values.length + valueSize);
    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));
    let index;
    if (track.times.length === 0) {
      times[0] = time;
      for (let i2 = 0; i2 < valueSize; i2++) {
        values[i2] = 0;
      }
      index = 0;
    } else if (time < track.times[0]) {
      if (Math.abs(track.times[0] - time) < tolerance)
        return 0;
      times[0] = time;
      times.set(track.times, 1);
      values.set(interpolant.evaluate(time), 0);
      values.set(track.values, valueSize);
      index = 0;
    } else if (time > track.times[track.times.length - 1]) {
      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {
        return track.times.length - 1;
      }
      times[times.length - 1] = time;
      times.set(track.times, 0);
      values.set(track.values, 0);
      values.set(interpolant.evaluate(time), track.values.length);
      index = times.length - 1;
    } else {
      for (let i2 = 0; i2 < track.times.length; i2++) {
        if (Math.abs(track.times[i2] - time) < tolerance)
          return i2;
        if (track.times[i2] < time && track.times[i2 + 1] > time) {
          times.set(track.times.slice(0, i2 + 1), 0);
          times[i2 + 1] = time;
          times.set(track.times.slice(i2 + 1), i2 + 2);
          values.set(track.values.slice(0, (i2 + 1) * valueSize), 0);
          values.set(interpolant.evaluate(time), (i2 + 1) * valueSize);
          values.set(track.values.slice((i2 + 1) * valueSize), (i2 + 2) * valueSize);
          index = i2 + 1;
          break;
        }
      }
    }
    track.times = times;
    track.values = values;
    return index;
  },
  mergeMorphTargetTracks: function(clip, root) {
    const tracks = [];
    const mergedTracks = {};
    const sourceTracks = clip.tracks;
    for (let i2 = 0; i2 < sourceTracks.length; ++i2) {
      let sourceTrack = sourceTracks[i2];
      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);
      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);
      if (sourceTrackBinding.propertyName !== "morphTargetInfluences" || sourceTrackBinding.propertyIndex === void 0) {
        tracks.push(sourceTrack);
        continue;
      }
      if (
        // @ts-expect-error
        sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && // @ts-expect-error
        sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear
      ) {
        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        }
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.");
        sourceTrack = sourceTrack.clone();
        sourceTrack.setInterpolation(InterpolateLinear);
      }
      const targetCount = sourceTrackNode.morphTargetInfluences.length;
      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];
      if (targetIndex === void 0) {
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + sourceTrackBinding.propertyIndex);
      }
      let mergedTrack;
      if (mergedTracks[sourceTrackNode.uuid] === void 0) {
        mergedTrack = sourceTrack.clone();
        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);
        for (let j2 = 0; j2 < mergedTrack.times.length; j2++) {
          values[j2 * targetCount + targetIndex] = mergedTrack.values[j2];
        }
        mergedTrack.name = (sourceTrackBinding.nodeName || "") + ".morphTargetInfluences";
        mergedTrack.values = values;
        mergedTracks[sourceTrackNode.uuid] = mergedTrack;
        tracks.push(mergedTrack);
        continue;
      }
      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));
      mergedTrack = mergedTracks[sourceTrackNode.uuid];
      for (let j2 = 0; j2 < mergedTrack.times.length; j2++) {
        mergedTrack.values[j2 * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j2]);
      }
      for (let j2 = 0; j2 < sourceTrack.times.length; j2++) {
        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j2]);
        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j2];
      }
    }
    clip.tracks = tracks;
    return clip;
  }
});
var WEBGL_CONSTANTS = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123,
  FLOAT: 5126,
  UNSIGNED_INT: 5125,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
};
var THREE_TO_WEBGL = {};
THREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;
THREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;
THREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;
THREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;
THREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;
THREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;
THREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;
THREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;
THREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;
var PATH_PROPERTIES = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
};
var GLB_HEADER_BYTES = 12;
var GLB_HEADER_MAGIC = 1179937895;
var GLB_VERSION = 2;
var GLB_CHUNK_PREFIX_BYTES = 8;
var GLB_CHUNK_TYPE_JSON = 1313821514;
var GLB_CHUNK_TYPE_BIN = 5130562;
var GLTFWriter = class {
  constructor() {
    _defineProperty(this, "plugins", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "pending", void 0);
    _defineProperty(this, "buffers", void 0);
    _defineProperty(this, "byteOffset", void 0);
    _defineProperty(this, "nodeMap", void 0);
    _defineProperty(this, "skins", void 0);
    _defineProperty(this, "extensionsUsed", void 0);
    _defineProperty(this, "uids", void 0);
    _defineProperty(this, "uid", void 0);
    _defineProperty(this, "json", void 0);
    _defineProperty(this, "cache", void 0);
    _defineProperty(this, "cachedCanvas", void 0);
    this.plugins = [];
    this.options = {};
    this.pending = [];
    this.buffers = [];
    this.byteOffset = 0;
    this.nodeMap = /* @__PURE__ */ new Map();
    this.skins = [];
    this.extensionsUsed = {};
    this.uids = /* @__PURE__ */ new Map();
    this.uid = 0;
    this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter"
      }
    };
    this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
    this.cachedCanvas = null;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  write(input, onDone, options) {
    this.options = Object.assign({}, {
      // default options
      binary: false,
      trs: false,
      onlyVisible: true,
      truncateDrawRange: true,
      embedImages: true,
      maxTextureSize: Infinity,
      animations: [],
      includeCustomExtensions: false
    }, options);
    if (this.options.animations !== void 0 && this.options.animations.length > 0) {
      this.options.trs = true;
    }
    this.processInput(input);
    const writer = this;
    Promise.all(this.pending).then(() => {
      const buffers = writer.buffers;
      const json = writer.json;
      const options2 = writer.options;
      const extensionsUsed = writer.extensionsUsed;
      const blob = new Blob(buffers, {
        type: "application/octet-stream"
      });
      const extensionsUsedList = Object.keys(extensionsUsed);
      if (extensionsUsedList.length > 0)
        json.extensionsUsed = extensionsUsedList;
      if (json.buffers && json.buffers.length > 0)
        json.buffers[0].byteLength = blob.size;
      if (options2.binary) {
        const reader = new window.FileReader();
        reader.readAsArrayBuffer(blob);
        reader.onloadend = () => {
          if (reader.result !== null && typeof reader.result !== "string") {
            const binaryChunk = this.getPaddedArrayBuffer(reader.result);
            const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);
            const jsonChunk = this.getPaddedArrayBuffer(this.stringToArrayBuffer(JSON.stringify(json)), 32);
            const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);
            const header = new ArrayBuffer(GLB_HEADER_BYTES);
            const headerView = new DataView(header);
            headerView.setUint32(0, GLB_HEADER_MAGIC, true);
            headerView.setUint32(4, GLB_VERSION, true);
            const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
            headerView.setUint32(8, totalByteLength, true);
            const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {
              type: "application/octet-stream"
            });
            const glbReader = new window.FileReader();
            glbReader.readAsArrayBuffer(glbBlob);
            glbReader.onloadend = function() {
              if (glbReader.result !== null && typeof glbReader.result !== "string") {
                onDone(glbReader.result);
              }
            };
          }
        };
      } else {
        if (json.buffers && json.buffers.length > 0) {
          const reader = new window.FileReader();
          reader.readAsDataURL(blob);
          reader.onloadend = function() {
            const base64data = reader.result;
            if (json.buffers !== void 0 && base64data !== null) {
              json.buffers[0].uri = base64data;
              onDone(json);
            }
          };
        } else {
          onDone(json);
        }
      }
    });
  }
  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(object, objectDef) {
    if (Object.keys(object.userData).length === 0)
      return;
    const options = this.options;
    const extensionsUsed = this.extensionsUsed;
    try {
      const json = JSON.parse(JSON.stringify(object.userData));
      if (options.includeCustomExtensions && json.gltfExtensions) {
        if (objectDef.extensions === void 0)
          objectDef.extensions = {};
        for (const extensionName in json.gltfExtensions) {
          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];
          extensionsUsed[extensionName] = true;
        }
        delete json.gltfExtensions;
      }
      if (Object.keys(json).length > 0)
        objectDef.extras = json;
    } catch (error) {
      if (error instanceof Error) {
        console.warn("THREE.GLTFExporter: userData of '" + object.name + "' won't be serialized because of JSON.stringify error - " + error.message);
      }
    }
  }
  /**
   * Assign and return a temporal unique id for an object
   * especially which doesn't have .uuid
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(object) {
    if (!this.uids.has(object))
      this.uids.set(object, this.uid++);
    return this.uids.get(object);
  }
  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal))
      return false;
    const v = new Vector3();
    for (let i2 = 0, il = normal.count; i2 < il; i2++) {
      if (Math.abs(v.fromBufferAttribute(normal, i2).length() - 1) > 5e-4)
        return false;
    }
    return true;
  }
  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(normal) {
    const cache = this.cache;
    if (cache.attributesNormalized.has(normal))
      return cache.attributesNormalized.get(normal);
    const attribute2 = normal.clone();
    const v = new Vector3();
    for (let i2 = 0, il = attribute2.count; i2 < il; i2++) {
      v.fromBufferAttribute(attribute2, i2);
      if (v.x === 0 && v.y === 0 && v.z === 0) {
        v.setX(1);
      } else {
        v.normalize();
      }
      attribute2.setXYZ(i2, v.x, v.y, v.z);
    }
    cache.attributesNormalized.set(normal, attribute2);
    return attribute2;
  }
  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(mapDef, texture2) {
    let didTransform = false;
    const transformDef = {};
    if (texture2.offset.x !== 0 || texture2.offset.y !== 0) {
      transformDef.offset = texture2.offset.toArray();
      didTransform = true;
    }
    if (texture2.rotation !== 0) {
      transformDef.rotation = texture2.rotation;
      didTransform = true;
    }
    if (texture2.repeat.x !== 1 || texture2.repeat.y !== 1) {
      transformDef.scale = texture2.repeat.toArray();
      didTransform = true;
    }
    if (didTransform) {
      mapDef.extensions = mapDef.extensions || {};
      mapDef.extensions["KHR_texture_transform"] = transformDef;
      this.extensionsUsed["KHR_texture_transform"] = true;
    }
  }
  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(buffer2) {
    const json = this.json;
    const buffers = this.buffers;
    if (!json.buffers)
      json.buffers = [{
        byteLength: 0
      }];
    buffers.push(buffer2);
    return 0;
  }
  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(attribute2, componentType, start, count, target) {
    const json = this.json;
    if (!json.bufferViews)
      json.bufferViews = [];
    let componentSize;
    if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {
      componentSize = 1;
    } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {
      componentSize = 2;
    } else {
      componentSize = 4;
    }
    const byteLength = this.getPaddedBufferSize(count * attribute2.itemSize * componentSize);
    const dataView = new DataView(new ArrayBuffer(byteLength));
    let offset = 0;
    for (let i2 = start; i2 < start + count; i2++) {
      for (let a2 = 0; a2 < attribute2.itemSize; a2++) {
        let value;
        if (attribute2.itemSize > 4) {
          value = attribute2.array[i2 * attribute2.itemSize + a2];
        } else {
          if (a2 === 0)
            value = attribute2.getX(i2);
          else if (a2 === 1)
            value = attribute2.getY(i2);
          else if (a2 === 2)
            value = attribute2.getZ(i2);
          else if (a2 === 3)
            value = attribute2.getW(i2);
        }
        if (value !== void 0) {
          if (componentType === WEBGL_CONSTANTS.FLOAT) {
            dataView.setFloat32(offset, value, true);
          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {
            dataView.setUint32(offset, value, true);
          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {
            dataView.setUint16(offset, value, true);
          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {
            dataView.setUint8(offset, value);
          }
        }
        offset += componentSize;
      }
    }
    const bufferViewDef = {
      buffer: this.processBuffer(dataView.buffer),
      byteOffset: this.byteOffset,
      byteLength
    };
    if (target !== void 0)
      bufferViewDef.target = target;
    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {
      bufferViewDef.byteStride = attribute2.itemSize * componentSize;
    }
    this.byteOffset += byteLength;
    json.bufferViews.push(bufferViewDef);
    const output = {
      id: json.bufferViews.length - 1,
      byteLength: 0
    };
    return output;
  }
  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(blob) {
    const writer = this;
    const json = writer.json;
    if (!json.bufferViews)
      json.bufferViews = [];
    return new Promise((resolve) => {
      const reader = new window.FileReader();
      reader.readAsArrayBuffer(blob);
      reader.onloadend = () => {
        if (reader.result !== null && typeof reader.result !== "string" && json.bufferViews !== void 0) {
          const buffer2 = this.getPaddedArrayBuffer(reader.result);
          const bufferViewDef = {
            buffer: writer.processBuffer(buffer2),
            byteOffset: writer.byteOffset,
            byteLength: buffer2.byteLength
          };
          writer.byteOffset += buffer2.byteLength;
          resolve(json.bufferViews.push(bufferViewDef) - 1);
        }
      };
    });
  }
  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(attribute2, geometry, start, count) {
    const options = this.options;
    const json = this.json;
    const types = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      16: "MAT4"
    };
    let componentType;
    if (attribute2.array.constructor === Float32Array) {
      componentType = WEBGL_CONSTANTS.FLOAT;
    } else if (attribute2.array.constructor === Uint32Array) {
      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;
    } else if (attribute2.array.constructor === Uint16Array) {
      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;
    } else if (attribute2.array.constructor === Uint8Array) {
      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
    }
    if (start === void 0)
      start = 0;
    if (count === void 0)
      count = attribute2.count;
    if (options.truncateDrawRange && geometry !== void 0 && geometry.index === null) {
      const end = start + count;
      const end2 = geometry.drawRange.count === Infinity ? attribute2.count : geometry.drawRange.start + geometry.drawRange.count;
      start = Math.max(start, geometry.drawRange.start);
      count = Math.min(end, end2) - start;
      if (count < 0)
        count = 0;
    }
    if (count === 0)
      return null;
    const minMax = this.getMinMax(attribute2, start, count);
    let bufferViewTarget;
    if (geometry !== void 0) {
      bufferViewTarget = attribute2 === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;
    }
    if (bufferViewTarget !== void 0) {
      const bufferView = this.processBufferView(attribute2, componentType, start, count, bufferViewTarget);
      const accessorDef = {
        bufferView: bufferView.id,
        byteOffset: bufferView.byteOffset,
        componentType,
        count,
        max: minMax.max,
        min: minMax.min,
        type: types[attribute2.itemSize]
      };
      if (attribute2.normalized)
        accessorDef.normalized = true;
      if (!json.accessors)
        json.accessors = [];
      return json.accessors.push(accessorDef) - 1;
    }
  }
  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(image, format, flipY) {
    const writer = this;
    const cache = writer.cache;
    const json = writer.json;
    const options = writer.options;
    const pending = writer.pending;
    if (!cache.images.has(image))
      cache.images.set(image, {});
    const cachedImages = cache.images.get(image);
    const mimeType = format === RGBAFormat ? "image/png" : "image/jpeg";
    const key = mimeType + ":flipY/" + flipY.toString();
    if (cachedImages !== void 0 && cachedImages[key] !== void 0)
      return cachedImages[key];
    if (!json.images)
      json.images = [];
    const imageDef = {
      mimeType
    };
    if (options.embedImages && options.maxTextureSize !== void 0) {
      const canvas = this.cachedCanvas = this.cachedCanvas || document.createElement("canvas");
      canvas.width = Math.min(image.width, options.maxTextureSize);
      canvas.height = Math.min(image.height, options.maxTextureSize);
      const ctx = canvas.getContext("2d");
      if (flipY) {
        ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, canvas.height);
        ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);
      }
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && image instanceof OffscreenCanvas || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      } else {
        if (format !== RGBAFormat) {
          console.error("GLTFExporter: Only RGBA format is supported.");
        }
        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {
          console.warn("GLTFExporter: Image size is bigger than maxTextureSize", image);
        }
        const data = new Uint8ClampedArray(image.height * image.width * 4);
        if (image instanceof ImageData) {
          for (let i2 = 0; i2 < data.length; i2 += 4) {
            data[i2 + 0] = image.data[i2 + 0];
            data[i2 + 1] = image.data[i2 + 1];
            data[i2 + 2] = image.data[i2 + 2];
            data[i2 + 3] = image.data[i2 + 3];
          }
        }
        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);
      }
      if (options.binary) {
        pending.push(new Promise(function(resolve) {
          canvas.toBlob(function(blob) {
            if (blob !== null) {
              writer.processBufferViewImage(blob).then(function(bufferViewIndex) {
                imageDef.bufferView = bufferViewIndex;
                resolve();
              });
            }
          }, mimeType);
        }));
      } else {
        imageDef.uri = canvas.toDataURL(mimeType);
      }
    } else if (image instanceof Image) {
      imageDef.uri = image.src;
    }
    const index = json.images.push(imageDef) - 1;
    if (cachedImages !== void 0)
      cachedImages[key] = index;
    return index;
  }
  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(map) {
    const json = this.json;
    if (!json.samplers)
      json.samplers = [];
    const samplerDef = {
      magFilter: THREE_TO_WEBGL[map.magFilter],
      minFilter: THREE_TO_WEBGL[map.minFilter],
      wrapS: THREE_TO_WEBGL[map.wrapS],
      wrapT: THREE_TO_WEBGL[map.wrapT]
    };
    return json.samplers.push(samplerDef) - 1;
  }
  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(map) {
    const cache = this.cache;
    const json = this.json;
    if (cache.textures.has(map))
      return cache.textures.get(map);
    if (!json.textures)
      json.textures = [];
    const textureDef = {
      sampler: this.processSampler(map),
      source: this.processImage(map.image, map.format, map.flipY)
    };
    if (map.name)
      textureDef.name = map.name;
    this._invokeAll(function(ext) {
      ext.writeTexture && ext.writeTexture(map, textureDef);
    });
    const index = json.textures.push(textureDef) - 1;
    cache.textures.set(map, index);
    return index;
  }
  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(material) {
    const cache = this.cache;
    const json = this.json;
    if (cache.materials.has(material))
      return cache.materials.get(material);
    if (material instanceof ShaderMaterial && material.isShaderMaterial) {
      console.warn("GLTFExporter: THREE.ShaderMaterial not supported.");
      return null;
    }
    if (!json.materials)
      json.materials = [];
    const materialDef = {
      pbrMetallicRoughness: {}
    };
    if (!(material instanceof MeshStandardMaterial && material.isMeshStandardMaterial && material instanceof MeshBasicMaterial && // @ts-expect-error
    material.isMeshBasicMaterial)) {
      console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    }
    if (material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) {
      const color2 = material.color.toArray().concat([material.opacity]);
      if (!this.equalArray(color2, [1, 1, 1, 1])) {
        materialDef.pbrMetallicRoughness.baseColorFactor = color2;
      }
    }
    if (material instanceof MeshStandardMaterial && material.isMeshStandardMaterial) {
      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;
      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;
    } else {
      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;
      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;
    }
    if (material instanceof MeshStandardMaterial && material.metalnessMap || material instanceof MeshStandardMaterial && material.roughnessMap) {
      if (material.metalnessMap === material.roughnessMap && material.metalnessMap !== null) {
        const metalRoughMapDef = {
          index: this.processTexture(material.metalnessMap)
        };
        this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);
        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;
      } else {
        console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");
      }
    }
    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.map) {
      const baseColorMapDef = {
        index: this.processTexture(material.map)
      };
      this.applyTextureTransform(baseColorMapDef, material.map);
      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;
    }
    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.emissive) {
      const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);
      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);
      if (maxEmissiveComponent > 1) {
        emissive.multiplyScalar(1 / maxEmissiveComponent);
        console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited");
      }
      if (maxEmissiveComponent > 0) {
        materialDef.emissiveFactor = emissive.toArray();
      }
      if (material.emissiveMap) {
        const emissiveMapDef = {
          index: this.processTexture(material.emissiveMap)
        };
        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);
        materialDef.emissiveTexture = emissiveMapDef;
      }
    }
    if ((material instanceof MeshMatcapMaterial || material instanceof MeshNormalMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.normalMap) {
      const normalMapDef = {
        index: this.processTexture(material.normalMap)
      };
      if (material.normalScale && material.normalScale.x !== 1) {
        normalMapDef.scale = material.normalScale.x;
      }
      this.applyTextureTransform(normalMapDef, material.normalMap);
      materialDef.normalTexture = normalMapDef;
    }
    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.aoMap) {
      const occlusionMapDef = {
        index: this.processTexture(material.aoMap),
        texCoord: 1
      };
      if (material.aoMapIntensity !== 1) {
        occlusionMapDef.strength = material.aoMapIntensity;
      }
      this.applyTextureTransform(occlusionMapDef, material.aoMap);
      materialDef.occlusionTexture = occlusionMapDef;
    }
    if (material.transparent) {
      materialDef.alphaMode = "BLEND";
    } else {
      if (material.alphaTest > 0) {
        materialDef.alphaMode = "MASK";
        materialDef.alphaCutoff = material.alphaTest;
      }
    }
    if (material.side === DoubleSide)
      materialDef.doubleSided = true;
    if (material.name !== "")
      materialDef.name = material.name;
    this.serializeUserData(material, materialDef);
    this._invokeAll(function(ext) {
      ext.writeMaterial && ext.writeMaterial(material, materialDef);
    });
    const index = json.materials.push(materialDef) - 1;
    cache.materials.set(material, index);
    return index;
  }
  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(mesh) {
    const cache = this.cache;
    const json = this.json;
    const meshCacheKeyParts = [mesh.geometry.uuid];
    if (Array.isArray(mesh.material)) {
      for (let i2 = 0, l = mesh.material.length; i2 < l; i2++) {
        meshCacheKeyParts.push(mesh.material[i2].uuid);
      }
    } else {
      meshCacheKeyParts.push(mesh.material.uuid);
    }
    const meshCacheKey = meshCacheKeyParts.join(":");
    if (cache.meshes.has(meshCacheKey))
      return cache.meshes.get(meshCacheKey);
    const geometry = mesh.geometry;
    let mode;
    if (mesh instanceof LineSegments && mesh.isLineSegments) {
      mode = WEBGL_CONSTANTS.LINES;
    } else if (mesh instanceof LineLoop && mesh.isLineLoop) {
      mode = WEBGL_CONSTANTS.LINE_LOOP;
    } else if (mesh instanceof Line && mesh.isLine) {
      mode = WEBGL_CONSTANTS.LINE_STRIP;
    } else if (mesh instanceof Points && mesh.isPoints) {
      mode = WEBGL_CONSTANTS.POINTS;
    } else {
      mode = (mesh.material instanceof MeshBasicMaterial || mesh.material instanceof MeshDepthMaterial || mesh.material instanceof MeshLambertMaterial || mesh.material instanceof MeshNormalMaterial || mesh.material instanceof MeshPhongMaterial || mesh.material instanceof MeshStandardMaterial || mesh.material instanceof MeshToonMaterial || mesh.material instanceof ShaderMaterial) && mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;
    }
    if (!geometry.isBufferGeometry) {
      throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
    }
    const meshDef = {};
    const attributes = {};
    const primitives = [];
    const targets = [];
    const nameConversion = {
      uv: "TEXCOORD_0",
      uv2: "TEXCOORD_1",
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    };
    const originalNormal = geometry.getAttribute("normal");
    if (originalNormal !== void 0 && !(originalNormal instanceof InterleavedBufferAttribute) && !this.isNormalizedNormalAttribute(originalNormal)) {
      console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.");
      geometry.setAttribute("normal", this.createNormalizedNormalAttribute(originalNormal));
    }
    let modifiedAttribute = null;
    for (let attributeName in geometry.attributes) {
      if (attributeName.substr(0, 5) === "morph")
        continue;
      const attribute2 = geometry.attributes[attributeName];
      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();
      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/;
      if (!validVertexAttributes.test(attributeName))
        attributeName = "_" + attributeName;
      if (cache.attributes.has(this.getUID(attribute2))) {
        attributes[attributeName] = cache.attributes.get(this.getUID(attribute2));
        continue;
      }
      modifiedAttribute = null;
      const array = attribute2.array;
      if (attributeName === "JOINTS_0" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {
        console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.');
        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute2.itemSize, attribute2.normalized);
      }
      const accessor = modifiedAttribute !== null && this.processAccessor(modifiedAttribute || attribute2, geometry);
      if (accessor) {
        attributes[attributeName] = accessor;
        cache.attributes.set(this.getUID(attribute2), accessor);
      }
    }
    if (originalNormal !== void 0)
      geometry.setAttribute("normal", originalNormal);
    if (Object.keys(attributes).length === 0)
      return null;
    if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {
      const weights = [];
      const targetNames = [];
      const reverseDictionary = {};
      if (mesh.morphTargetDictionary !== void 0) {
        for (const key in mesh.morphTargetDictionary) {
          reverseDictionary[mesh.morphTargetDictionary[key]] = key;
        }
      }
      for (let i2 = 0; i2 < mesh.morphTargetInfluences.length; ++i2) {
        const target = {};
        let warned = false;
        for (const attributeName in geometry.morphAttributes) {
          if (attributeName !== "position" && attributeName !== "normal") {
            if (!warned) {
              console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported.");
              warned = true;
            }
            continue;
          }
          const attribute2 = geometry.morphAttributes[attributeName][i2];
          const gltfAttributeName = attributeName.toUpperCase();
          const baseAttribute = geometry.attributes[attributeName];
          if (cache.attributes.has(this.getUID(attribute2))) {
            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute2));
            continue;
          }
          const relativeAttribute = attribute2.clone();
          if (!geometry.morphTargetsRelative) {
            for (let j2 = 0, jl2 = attribute2.count; j2 < jl2; j2++) {
              relativeAttribute.setXYZ(j2, attribute2.getX(j2) - baseAttribute.getX(j2), attribute2.getY(j2) - baseAttribute.getY(j2), attribute2.getZ(j2) - baseAttribute.getZ(j2));
            }
          }
          const accessor = this.processAccessor(relativeAttribute, geometry);
          if (accessor != void 0) {
            target[gltfAttributeName] = accessor;
          }
          cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);
        }
        targets.push(target);
        weights.push(mesh.morphTargetInfluences[i2]);
        if (mesh.morphTargetDictionary !== void 0)
          targetNames.push(reverseDictionary[i2]);
      }
      meshDef.weights = weights;
      if (targetNames.length > 0) {
        meshDef.extras = {};
        meshDef.extras.targetNames = targetNames;
      }
    }
    const isMultiMaterial = Array.isArray(mesh.material);
    if (isMultiMaterial && geometry.groups.length === 0)
      return null;
    const materials = isMultiMaterial ? mesh.material : [mesh.material];
    const groups = isMultiMaterial ? geometry.groups : [{
      materialIndex: 0,
      start: void 0,
      count: void 0
    }];
    for (let i2 = 0, il = groups.length; i2 < il; i2++) {
      const primitive = {
        mode,
        attributes
      };
      if (geometry instanceof Object3D || geometry instanceof Material) {
        this.serializeUserData(geometry, primitive);
      }
      if (targets.length > 0)
        primitive.targets = targets;
      if (geometry.index !== null) {
        let cacheKey = this.getUID(geometry.index);
        if (groups[i2].start !== void 0 || groups[i2].count !== void 0) {
          cacheKey += `:${groups[i2].start}:${groups[i2].count}`;
        }
        if (cache.attributes.has(cacheKey)) {
          primitive.indices = cache.attributes.get(cacheKey);
        } else {
          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i2].start, groups[i2].count);
          cache.attributes.set(cacheKey, primitive.indices);
        }
        if (primitive.indices === null)
          delete primitive.indices;
      }
      const materialIndex = groups[i2].materialIndex;
      if (materialIndex !== void 0 && Array.isArray(materials)) {
        const targetMaterials = materials[materialIndex];
        if (!Array.isArray(targetMaterials)) {
          const material = this.processMaterial(targetMaterials);
          if (material !== null)
            primitive.material = material;
          primitives.push(primitive);
        }
      }
    }
    meshDef.primitives = primitives;
    if (!json.meshes)
      json.meshes = [];
    this._invokeAll(function(ext) {
      ext.writeMesh && ext.writeMesh(mesh, meshDef);
    });
    const index = json.meshes.push(meshDef) - 1;
    cache.meshes.set(meshCacheKey, index);
    return index;
  }
  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(camera) {
    const json = this.json;
    if (!json.cameras)
      json.cameras = [];
    const isOrtho = camera instanceof OrthographicCamera && camera.isOrthographicCamera;
    const cameraDef = {
      type: isOrtho ? "orthographic" : "perspective"
    };
    if (camera instanceof OrthographicCamera && isOrtho) {
      cameraDef.orthographic = {
        xmag: camera.right * 2,
        ymag: camera.top * 2,
        zfar: camera.far <= 0 ? 1e-3 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    } else if (camera instanceof PerspectiveCamera) {
      cameraDef.perspective = {
        aspectRatio: camera.aspect,
        yfov: MathUtils.degToRad(camera.fov),
        zfar: camera.far <= 0 ? 1e-3 : camera.far,
        znear: camera.near < 0 ? 0 : camera.near
      };
    }
    if (camera.name !== "")
      cameraDef.name = camera.type;
    return json.cameras.push(cameraDef) - 1;
  }
  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(clip, root) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    if (!json.animations)
      json.animations = [];
    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);
    const tracks = clip.tracks;
    const channels = [];
    const samplers = [];
    for (let i2 = 0; i2 < tracks.length; ++i2) {
      const track = tracks[i2];
      const trackBinding = PropertyBinding.parseTrackName(track.name);
      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);
      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];
      if (trackBinding.objectName === "bones") {
        if (trackNode.isSkinnedMesh) {
          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);
        } else {
          trackNode = void 0;
        }
      }
      if (!trackNode || !trackProperty) {
        console.warn('THREE.GLTFExporter: Could not export animation track "%s".', track.name);
        return null;
      }
      const inputItemSize = 1;
      let outputItemSize = track.values.length / track.times.length;
      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {
        outputItemSize /= trackNode.morphTargetInfluences.length;
      }
      let interpolation;
      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        interpolation = "CUBICSPLINE";
        outputItemSize /= 3;
      } else if (track.getInterpolation() === InterpolateDiscrete) {
        interpolation = "STEP";
      } else {
        interpolation = "LINEAR";
      }
      samplers.push({
        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),
        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),
        interpolation
      });
      channels.push({
        sampler: samplers.length - 1,
        target: {
          node: nodeMap.get(trackNode),
          path: trackProperty
        }
      });
    }
    json.animations.push({
      name: clip.name || "clip_" + json.animations.length,
      samplers,
      channels
    });
    return json.animations.length - 1;
  }
  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(object) {
    const json = this.json;
    const nodeMap = this.nodeMap;
    if (json.nodes !== void 0 && object instanceof SkinnedMesh) {
      const node = json.nodes[nodeMap.get(object)];
      const skeleton = object.skeleton;
      if (skeleton === void 0)
        return null;
      const rootJoint = object.skeleton.bones[0];
      if (rootJoint === void 0)
        return null;
      const joints = [];
      const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);
      const temporaryBoneInverse = new Matrix4();
      for (let i2 = 0; i2 < skeleton.bones.length; ++i2) {
        joints.push(nodeMap.get(skeleton.bones[i2]));
        temporaryBoneInverse.copy(skeleton.boneInverses[i2]);
        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i2 * 16);
      }
      if (json.skins === void 0)
        json.skins = [];
      json.skins.push({
        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),
        joints,
        skeleton: nodeMap.get(rootJoint)
      });
      const skinIndex = node.skin = json.skins.length - 1;
      return skinIndex;
    } else {
      return null;
    }
  }
  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(object) {
    const json = this.json;
    const options = this.options;
    const nodeMap = this.nodeMap;
    if (!json.nodes)
      json.nodes = [];
    const nodeDef = {};
    if (options.trs) {
      const rotation = object.quaternion.toArray();
      const position = object.position.toArray();
      const scale = object.scale.toArray();
      if (!this.equalArray(rotation, [0, 0, 0, 1])) {
        nodeDef.rotation = rotation;
      }
      if (!this.equalArray(position, [0, 0, 0])) {
        nodeDef.translation = position;
      }
      if (!this.equalArray(scale, [1, 1, 1])) {
        nodeDef.scale = scale;
      }
    } else {
      if (object.matrixAutoUpdate) {
        object.updateMatrix();
      }
      if (!this.isIdentityMatrix(object.matrix)) {
        nodeDef.matrix = object.matrix.elements;
      }
    }
    if (object.name !== "")
      nodeDef.name = String(object.name);
    this.serializeUserData(object, nodeDef);
    if ((object instanceof Mesh && object.isMesh || object instanceof Line && object.isLine || object instanceof Points && object.isPoints) && object instanceof Mesh) {
      const meshIndex = this.processMesh(object);
      if (meshIndex !== null)
        nodeDef.mesh = meshIndex;
    } else if (object instanceof Camera && object.isCamera) {
      nodeDef.camera = this.processCamera(object);
    }
    if (object instanceof SkinnedMesh && object.isSkinnedMesh)
      this.skins.push(object);
    if (object.children.length > 0) {
      const children = [];
      for (let i2 = 0, l = object.children.length; i2 < l; i2++) {
        const child = object.children[i2];
        if (child.visible || !options.onlyVisible) {
          const nodeIndex2 = this.processNode(child);
          if (nodeIndex2 !== null)
            children.push(nodeIndex2);
        }
      }
      if (children.length > 0)
        nodeDef.children = children;
    }
    this._invokeAll(function(ext) {
      ext.writeNode && ext.writeNode(object, nodeDef);
    });
    const nodeIndex = json.nodes.push(nodeDef) - 1;
    nodeMap.set(object, nodeIndex);
    return nodeIndex;
  }
  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(scene) {
    const json = this.json;
    const options = this.options;
    if (!json.scenes) {
      json.scenes = [];
      json.scene = 0;
    }
    const sceneDef = {};
    if (scene.name !== "")
      sceneDef.name = scene.name;
    json.scenes.push(sceneDef);
    const nodes = [];
    for (let i2 = 0, l = scene.children.length; i2 < l; i2++) {
      const child = scene.children[i2];
      if (child.visible || !options.onlyVisible) {
        const nodeIndex = this.processNode(child);
        if (nodeIndex !== null)
          nodes.push(nodeIndex);
      }
    }
    if (nodes.length > 0)
      sceneDef.nodes = nodes;
    this.serializeUserData(scene, sceneDef);
  }
  processObjects(objects) {
    const scene = new Scene();
    scene.name = "AuxScene";
    for (let i2 = 0; i2 < objects.length; i2++) {
      scene.children.push(objects[i2]);
    }
    this.processScene(scene);
  }
  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(input) {
    const options = this.options;
    input = input instanceof Array ? input : [input];
    this._invokeAll(function(ext) {
      ext.beforeParse && ext.beforeParse(input);
    });
    const objectsWithoutScene = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const inputScene = input[i2];
      if (inputScene instanceof Scene) {
        this.processScene(inputScene);
      } else {
        objectsWithoutScene.push(input[i2]);
      }
    }
    if (objectsWithoutScene.length > 0)
      this.processObjects(objectsWithoutScene);
    for (let i2 = 0; i2 < this.skins.length; ++i2) {
      this.processSkin(this.skins[i2]);
    }
    for (let i2 = 0; options.animations !== void 0 && i2 < options.animations.length; ++i2) {
      this.processAnimation(options.animations[i2], input[0]);
    }
    this._invokeAll(function(ext) {
      ext.afterParse && ext.afterParse(input);
    });
  }
  _invokeAll(func) {
    for (let i2 = 0, il = this.plugins.length; i2 < il; i2++) {
      func(this.plugins[i2]);
    }
  }
  //------------------------------------------------------------------------------
  // Utility functions
  //------------------------------------------------------------------------------
  /**
   * Compare two arrays
   * @param  {Array} array1 Array 1 to compare
   * @param  {Array} array2 Array 2 to compare
   * @return {Boolean}        Returns true if both arrays are equal
   */
  equalArray(array1, array2) {
    return array1.length === array2.length && array1.every(function(element2, index) {
      return element2 === array2[index];
    });
  }
  /**
   * Converts a string to an ArrayBuffer.
   * @param  {string} text
   * @return {ArrayBuffer}
   */
  stringToArrayBuffer(text) {
    if (window.TextEncoder !== void 0) {
      return new TextEncoder().encode(text).buffer;
    }
    const array = new Uint8Array(new ArrayBuffer(text.length));
    for (let i2 = 0, il = text.length; i2 < il; i2++) {
      const value = text.charCodeAt(i2);
      array[i2] = value > 255 ? 32 : value;
    }
    return array.buffer;
  }
  isIdentityMatrix(matrix3) {
    return this.equalArray(matrix3.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  getMinMax(attribute2, start, count) {
    const output = {
      min: new Array(attribute2.itemSize).fill(Number.POSITIVE_INFINITY),
      max: new Array(attribute2.itemSize).fill(Number.NEGATIVE_INFINITY)
    };
    for (let i2 = start; i2 < start + count; i2++) {
      for (let a2 = 0; a2 < attribute2.itemSize; a2++) {
        let value;
        if (attribute2.itemSize > 4) {
          value = attribute2.array[i2 * attribute2.itemSize + a2];
        } else {
          if (a2 === 0)
            value = attribute2.getX(i2);
          else if (a2 === 1)
            value = attribute2.getY(i2);
          else if (a2 === 2)
            value = attribute2.getZ(i2);
          else if (a2 === 3)
            value = attribute2.getW(i2);
        }
        if (value !== void 0) {
          output.min[a2] = Math.min(output.min[a2], value);
          output.max[a2] = Math.max(output.max[a2], value);
        }
      }
    }
    return output;
  }
  /**
   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment
   */
  getPaddedBufferSize(bufferSize) {
    return Math.ceil(bufferSize / 4) * 4;
  }
  /**
   * Returns a buffer aligned to 4-byte boundary.
   *
   * @param {ArrayBuffer} arrayBuffer Buffer to pad
   * @param {Integer} paddingByte (Optional)
   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer
   */
  getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {
    const paddedLength = this.getPaddedBufferSize(arrayBuffer.byteLength);
    if (paddedLength !== arrayBuffer.byteLength) {
      const array = new Uint8Array(paddedLength);
      array.set(new Uint8Array(arrayBuffer));
      if (paddingByte !== 0) {
        for (let i2 = arrayBuffer.byteLength; i2 < paddedLength; i2++) {
          array[i2] = paddingByte;
        }
      }
      return array.buffer;
    }
    return arrayBuffer;
  }
};
var GLTFLightExtension = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_lights_punctual";
  }
  writeNode(light, nodeDef) {
    if (!light.isLight)
      return;
    if (!(light instanceof DirectionalLight && light.isDirectionalLight) && // @ts-expect-error
    !(light instanceof PointLight && light.isPointLight) && !(light instanceof SpotLight && light.isSpotLight)) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", light);
      return;
    }
    const writer = this.writer;
    const json = writer.json;
    const extensionsUsed = writer.extensionsUsed;
    const lightDef = {};
    if (light.name)
      lightDef.name = light.name;
    lightDef.color = light.color.toArray();
    lightDef.intensity = light.intensity;
    if (light instanceof DirectionalLight && light.isDirectionalLight) {
      lightDef.type = "directional";
    } else if (light instanceof PointLight && // @ts-expect-error
    light.isPointLight) {
      lightDef.type = "point";
      if (light.distance > 0)
        lightDef.range = light.distance;
    } else if (light instanceof SpotLight && light.isSpotLight) {
      lightDef.type = "spot";
      if (light.distance > 0)
        lightDef.range = light.distance;
      lightDef.spot = {};
      lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;
      lightDef.spot.outerConeAngle = light.angle;
    }
    if (!(light instanceof DirectionalLight) && light.decay !== void 0 && light.decay !== 2) {
      console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.");
    }
    if (!(light instanceof PointLight) && light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {
      console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.");
    }
    if (!extensionsUsed[this.name]) {
      json.extensions = json.extensions || {};
      json.extensions[this.name] = {
        lights: []
      };
      extensionsUsed[this.name] = true;
    }
    if (json.extensions !== void 0) {
      const lights = json.extensions[this.name].lights;
      lights.push(lightDef);
      nodeDef.extensions = nodeDef.extensions || {};
      nodeDef.extensions[this.name] = {
        light: lights.length - 1
      };
    }
  }
};
var GLTFMaterialsUnlitExtension = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_materials_unlit";
  }
  writeMaterial(material, materialDef) {
    if (!(material instanceof MeshBasicMaterial && // @ts-expect-error
    material.isMeshBasicMaterial)) {
      return;
    }
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = {};
    extensionsUsed[this.name] = true;
    materialDef.pbrMetallicRoughness.metallicFactor = 0;
    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
};
var GLTFMaterialsPBRSpecularGlossiness = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_materials_pbrSpecularGlossiness";
  }
  writeMaterial(material, materialDef) {
    if (!material.isGLTFSpecularGlossinessMaterial)
      return;
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    if (materialDef.pbrMetallicRoughness.baseColorFactor) {
      extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;
    }
    if (material instanceof MeshPhongMaterial) {
      const specularFactor = [1, 1, 1];
      material.specular.toArray(specularFactor, 0);
      extensionDef.specularFactor = specularFactor;
      extensionDef.glossinessFactor = // @ts-expect-error
      material.glossiness;
    }
    if (materialDef.pbrMetallicRoughness.baseColorTexture) {
      extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;
    }
    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial) && material.specularMap) {
      const specularMapDef = {
        index: writer.processTexture(material.specularMap)
      };
      writer.applyTextureTransform(specularMapDef, material.specularMap);
      extensionDef.specularGlossinessTexture = specularMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsTransmissionExtension = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_materials_transmission";
  }
  writeMaterial(material, materialDef) {
    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error
    material.isMeshPhysicalMaterial) || material.transmission === 0) {
      return;
    }
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.transmissionFactor = material.transmission;
    if (material.transmissionMap) {
      const transmissionMapDef = {
        index: writer.processTexture(material.transmissionMap)
      };
      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);
      extensionDef.transmissionTexture = transmissionMapDef;
    }
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};
var GLTFMaterialsVolumeExtension = class {
  constructor(writer) {
    _defineProperty(this, "writer", void 0);
    _defineProperty(this, "name", void 0);
    this.writer = writer;
    this.name = "KHR_materials_volume";
  }
  writeMaterial(material, materialDef) {
    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error
    material.isMeshPhysicalMaterial) || material.thickness === 0) {
      return;
    }
    const writer = this.writer;
    const extensionsUsed = writer.extensionsUsed;
    const extensionDef = {};
    extensionDef.thickness = material.thickness;
    if (material.thicknessMap) {
      const thicknessMapDef = {
        index: writer.processTexture(material.thicknessMap)
      };
      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);
      extensionDef.thicknessTexture = thicknessMapDef;
    }
    extensionDef.attenuationDistance = material.attenuationDistance;
    extensionDef.attenuationColor = //@ts-expect-error
    material.attenuationTint.toArray();
    materialDef.extensions = materialDef.extensions || {};
    materialDef.extensions[this.name] = extensionDef;
    extensionsUsed[this.name] = true;
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/exporters/DRACOExporter.js
var DRACOExporter = class {
  // Encoder methods
  // Geometry type
  // Attribute type
  parse(object, options = {
    decodeSpeed: 5,
    encodeSpeed: 5,
    encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,
    quantization: [16, 8, 8, 8, 8],
    exportUvs: true,
    exportNormals: true,
    exportColor: false
  }) {
    if (object instanceof BufferGeometry && object.isBufferGeometry) {
      throw new Error("DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.");
    }
    if (DracoEncoderModule === void 0) {
      throw new Error("THREE.DRACOExporter: required the draco_encoder to work.");
    }
    const geometry = object.geometry;
    const dracoEncoder = DracoEncoderModule();
    const encoder = new dracoEncoder.Encoder();
    let builder;
    let dracoObject;
    if (!geometry.isBufferGeometry) {
      throw new Error("THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.");
    }
    if (object instanceof Mesh && object.isMesh) {
      builder = new dracoEncoder.MeshBuilder();
      dracoObject = new dracoEncoder.Mesh();
      const vertices = geometry.getAttribute("position");
      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);
      const faces = geometry.getIndex();
      if (faces !== null) {
        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);
      } else {
        const faces2 = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);
        for (let i2 = 0; i2 < faces2.length; i2++) {
          faces2[i2] = i2;
        }
        builder.AddFacesToMesh(dracoObject, vertices.count, faces2);
      }
      if (options.exportNormals) {
        const normals = geometry.getAttribute("normal");
        if (normals !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);
        }
      }
      if (options.exportUvs) {
        const uvs = geometry.getAttribute("uv");
        if (uvs !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);
        }
      }
      if (options.exportColor) {
        const colors = geometry.getAttribute("color");
        if (colors !== void 0) {
          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);
        }
      }
    } else if (object instanceof Points && object.isPoints) {
      builder = new dracoEncoder.PointCloudBuilder();
      dracoObject = new dracoEncoder.PointCloud();
      const vertices = geometry.getAttribute("position");
      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);
      if (options.exportColor) {
        const colors = geometry.getAttribute("color");
        if (colors !== void 0) {
          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);
        }
      }
    } else {
      throw new Error("DRACOExporter: Unsupported object type.");
    }
    const encodedData = new dracoEncoder.DracoInt8Array();
    const encodeSpeed = options.encodeSpeed !== void 0 ? options.encodeSpeed : 5;
    const decodeSpeed = options.decodeSpeed !== void 0 ? options.decodeSpeed : 5;
    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed);
    if (options.encoderMethod !== void 0) {
      encoder.SetEncodingMethod(options.encoderMethod);
    }
    if (options.quantization !== void 0) {
      for (let i2 = 0; i2 < 5; i2++) {
        if (options.quantization[i2] !== void 0) {
          encoder.SetAttributeQuantization(i2, options.quantization[i2]);
        }
      }
    }
    let length2;
    if (object instanceof Mesh && object.isMesh) {
      length2 = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);
    } else {
      length2 = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);
    }
    dracoEncoder.destroy(dracoObject);
    if (length2 === 0) {
      throw new Error("THREE.DRACOExporter: Draco encoding failed.");
    }
    const outputData = new Int8Array(new ArrayBuffer(length2));
    for (let i2 = 0; i2 < length2; i2++) {
      outputData[i2] = encodedData.GetValue(i2);
    }
    dracoEncoder.destroy(encodedData);
    dracoEncoder.destroy(encoder);
    dracoEncoder.destroy(builder);
    return outputData;
  }
};
_defineProperty(DRACOExporter, "MESH_EDGEBREAKER_ENCODING", 1);
_defineProperty(DRACOExporter, "MESH_SEQUENTIAL_ENCODING", 0);
_defineProperty(DRACOExporter, "POINT_CLOUD", 0);
_defineProperty(DRACOExporter, "TRIANGULAR_MESH", 1);
_defineProperty(DRACOExporter, "INVALID", -1);
_defineProperty(DRACOExporter, "POSITION", 0);
_defineProperty(DRACOExporter, "NORMAL", 1);
_defineProperty(DRACOExporter, "COLOR", 2);
_defineProperty(DRACOExporter, "TEX_COORD", 3);
_defineProperty(DRACOExporter, "GENERIC", 4);

// node_modules/@react-three/rapier/node_modules/three-stdlib/animation/AnimationClipCreator.js
var AnimationClipCreator = () => {
};
AnimationClipCreator.CreateRotationAnimation = (period, axis) => {
  const times = [0, period], values = [0, 360];
  axis = axis || "x";
  const trackName = `.rotation[${axis}]`;
  const track = new NumberKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, period, [track]);
};
AnimationClipCreator.CreateScaleAxisAnimation = (period, axis) => {
  const times = [0, period], values = [0, 1];
  axis = axis || "x";
  const trackName = `.scale[${axis}]`;
  const track = new NumberKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, period, [track]);
};
AnimationClipCreator.CreateShakeAnimation = (duration, shakeScale) => {
  const times = [], values = [], tmp = new Vector3();
  for (let i2 = 0; i2 < duration * 10; i2++) {
    times.push(i2 / 10);
    tmp.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).multiply(shakeScale).toArray(values, values.length);
  }
  const trackName = ".position";
  const track = new VectorKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, duration, [track]);
};
AnimationClipCreator.CreatePulsationAnimation = (duration, pulseScale) => {
  const times = [], values = [], tmp = new Vector3();
  for (let i2 = 0; i2 < duration * 10; i2++) {
    times.push(i2 / 10);
    const scaleFactor = Math.random() * pulseScale;
    tmp.set(scaleFactor, scaleFactor, scaleFactor).toArray(values, values.length);
  }
  const trackName = ".scale";
  const track = new VectorKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, duration, [track]);
};
AnimationClipCreator.CreateVisibilityAnimation = (duration) => {
  const times = [0, duration / 2, duration], values = [true, false, true];
  const trackName = ".visible";
  const track = new BooleanKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, duration, [track]);
};
AnimationClipCreator.CreateMaterialColorAnimation = (duration, colors) => {
  const times = [], values = [], timeStep = duration / colors.length;
  for (let i2 = 0; i2 <= colors.length; i2++) {
    times.push(i2 * timeStep);
    values.push(colors[i2 % colors.length]);
  }
  const trackName = ".material[0].color";
  const track = new ColorKeyframeTrack(trackName, times, values);
  return new AnimationClip(null, duration, [track]);
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/animation/CCDIKSolver.js
var CCDIKHelper = class extends Object3D {
  constructor(mesh, iks = [], sphereSize = 0.25) {
    super();
    _defineProperty(this, "_m", new Matrix4());
    _defineProperty(this, "_v", new Vector3());
    this.root = mesh;
    this.iks = iks;
    this.matrix.copy(mesh.matrixWorld);
    this.matrixAutoUpdate = false;
    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);
    this.targetSphereMaterial = new MeshBasicMaterial({
      color: new Color(16746632),
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.effectorSphereMaterial = new MeshBasicMaterial({
      color: new Color(8978312),
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.linkSphereMaterial = new MeshBasicMaterial({
      color: new Color(8947967),
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    this.lineMaterial = new LineBasicMaterial({
      color: new Color(16711680),
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    function createLineGeometry(ik) {
      const geometry = new BufferGeometry();
      const vertices = new Float32Array((2 + ik.links.length) * 3);
      geometry.setAttribute("position", new BufferAttribute(vertices, 3));
      return geometry;
    }
    const scope = this;
    function createTargetMesh() {
      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);
    }
    function createEffectorMesh() {
      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);
    }
    function createLinkMesh() {
      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);
    }
    function createLine(ik) {
      return new Line(createLineGeometry(ik), scope.lineMaterial);
    }
    for (let i2 = 0, il = iks.length; i2 < il; i2++) {
      const ik = iks[i2];
      this.add(createTargetMesh());
      this.add(createEffectorMesh());
      for (let j2 = 0, jl2 = ik.links.length; j2 < jl2; j2++) {
        this.add(createLinkMesh());
      }
      this.add(createLine(ik));
    }
  }
  _getPosition(bone, matrixWorldInv) {
    return this._v.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);
  }
  _setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {
    const v = this._getPosition(bone, matrixWorldInv);
    array[index * 3 + 0] = v.x;
    array[index * 3 + 1] = v.y;
    array[index * 3 + 2] = v.z;
  }
  updateMatrixWorld(force) {
    const mesh = this.root;
    if (this.visible) {
      let offset = 0;
      const iks = this.iks;
      const bones = mesh.skeleton.bones;
      this._m.copy(mesh.matrixWorld).invert();
      for (let i2 = 0, il = iks.length; i2 < il; i2++) {
        const ik = iks[i2];
        const targetBone = bones[ik.target];
        const effectorBone = bones[ik.effector];
        const targetMesh = this.children[offset++];
        const effectorMesh = this.children[offset++];
        targetMesh.position.copy(this._getPosition(targetBone, this._m));
        effectorMesh.position.copy(this._getPosition(effectorBone, this._m));
        for (let j2 = 0, jl2 = ik.links.length; j2 < jl2; j2++) {
          const link = ik.links[j2];
          const linkBone = bones[link.index];
          const linkMesh = this.children[offset++];
          linkMesh.position.copy(this._getPosition(linkBone, this._m));
        }
        const line = this.children[offset++];
        const array = line.geometry.attributes.position.array;
        this._setPositionOfBoneToAttributeArray(array, 0, targetBone, this._m);
        this._setPositionOfBoneToAttributeArray(array, 1, effectorBone, this._m);
        for (let j2 = 0, jl2 = ik.links.length; j2 < jl2; j2++) {
          const link = ik.links[j2];
          const linkBone = bones[link.index];
          this._setPositionOfBoneToAttributeArray(array, j2 + 2, linkBone, this._m);
        }
        line.geometry.attributes.position.needsUpdate = true;
      }
    }
    this.matrix.copy(mesh.matrixWorld);
    super.updateMatrixWorld(force);
  }
};
var CCDIKSolver = class {
  constructor(mesh, iks) {
    _defineProperty(this, "q", new Quaternion());
    _defineProperty(this, "targetPos", new Vector3());
    _defineProperty(this, "targetVec", new Vector3());
    _defineProperty(this, "effectorPos", new Vector3());
    _defineProperty(this, "effectorVec", new Vector3());
    _defineProperty(this, "linkPos", new Vector3());
    _defineProperty(this, "invLinkQ", new Quaternion());
    _defineProperty(this, "linkScale", new Vector3());
    _defineProperty(this, "axis", new Vector3());
    _defineProperty(this, "vector", new Vector3());
    this.mesh = mesh;
    this.iks = iks;
    const bones = this.mesh.skeleton.bones;
    for (let i2 = 0, il = this.iks.length; i2 < il; i2++) {
      const ik = this.iks[i2];
      const effector = bones[ik.effector];
      const links = ik.links;
      let link0, link1;
      link0 = effector;
      for (let j2 = 0, jl2 = links.length; j2 < jl2; j2++) {
        link1 = bones[links[j2].index];
        if (link0.parent !== link1) {
          console.warn(`THREE.CCDIKSolver: bone ${link0.name} is not the child of bone ${link1.name}`);
        }
        link0 = link1;
      }
    }
  }
  update() {
    const bones = this.mesh.skeleton.bones;
    const iks = this.iks;
    const math = Math;
    for (let i2 = 0, il = iks.length; i2 < il; i2++) {
      const ik = iks[i2];
      const effector = bones[ik.effector];
      const target = bones[ik.target];
      this.targetPos.setFromMatrixPosition(target.matrixWorld);
      const links = ik.links;
      const iteration = ik.iteration !== void 0 ? ik.iteration : 1;
      for (let j2 = 0; j2 < iteration; j2++) {
        let rotated = false;
        for (let k = 0, kl = links.length; k < kl; k++) {
          const link = bones[links[k].index];
          if (links[k].enabled === false)
            break;
          const limitation = links[k].limitation;
          const rotationMin = links[k].rotationMin;
          const rotationMax = links[k].rotationMax;
          link.matrixWorld.decompose(this.linkPos, this.invLinkQ, this.linkScale);
          this.invLinkQ.invert();
          this.effectorPos.setFromMatrixPosition(effector.matrixWorld);
          this.effectorVec.subVectors(this.effectorPos, this.linkPos);
          this.effectorVec.applyQuaternion(this.invLinkQ);
          this.effectorVec.normalize();
          this.targetVec.subVectors(this.targetPos, this.linkPos);
          this.targetVec.applyQuaternion(this.invLinkQ);
          this.targetVec.normalize();
          let angle = this.targetVec.dot(this.effectorVec);
          if (angle > 1) {
            angle = 1;
          } else if (angle < -1) {
            angle = -1;
          }
          angle = math.acos(angle);
          if (angle < 1e-5)
            continue;
          if (ik.minAngle !== void 0 && angle < ik.minAngle) {
            angle = ik.minAngle;
          }
          if (ik.maxAngle !== void 0 && angle > ik.maxAngle) {
            angle = ik.maxAngle;
          }
          this.axis.crossVectors(this.effectorVec, this.targetVec);
          this.axis.normalize();
          this.q.setFromAxisAngle(this.axis, angle);
          link.quaternion.multiply(this.q);
          if (limitation !== void 0) {
            let c = link.quaternion.w;
            if (c > 1)
              c = 1;
            const c2 = math.sqrt(1 - c * c);
            link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);
          }
          if (rotationMin !== void 0) {
            link.rotation.setFromVector3(this.vector.setFromEuler(link.rotation).max(rotationMin));
          }
          if (rotationMax !== void 0) {
            link.rotation.setFromVector3(this.vector.setFromEuler(link.rotation).min(rotationMax));
          }
          link.updateMatrixWorld(true);
          rotated = true;
        }
        if (!rotated)
          break;
      }
    }
    return this;
  }
  createHelper() {
    return new CCDIKHelper(this.mesh, this.mesh.geometry.userData.MMD.iks);
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/animation/MMDPhysics.js
var MMDPhysics = (() => {
  function MMDPhysics2(mesh, rigidBodyParams, constraintParams, params) {
    if (typeof Ammo === "undefined") {
      throw new Error("THREE.MMDPhysics: Import ammo.js https://github.com/kripken/ammo.js");
    }
    constraintParams = constraintParams || [];
    params = params || {};
    this.manager = new ResourceManager();
    this.mesh = mesh;
    this.unitStep = params.unitStep !== void 0 ? params.unitStep : 1 / 65;
    this.maxStepNum = params.maxStepNum !== void 0 ? params.maxStepNum : 3;
    this.gravity = new Vector3(0, -9.8 * 10, 0);
    if (params.gravity !== void 0)
      this.gravity.copy(params.gravity);
    this.world = params.world !== void 0 ? params.world : null;
    this.bodies = [];
    this.constraints = [];
    this._init(mesh, rigidBodyParams, constraintParams);
  }
  MMDPhysics2.prototype = {
    constructor: MMDPhysics2,
    /**
     * Advances Physics calculation and updates bones.
     *
     * @param {Number} delta - time in second
     * @return {MMDPhysics}
     */
    update: function(delta) {
      const manager = this.manager;
      const mesh = this.mesh;
      let isNonDefaultScale = false;
      const position = manager.allocThreeVector3();
      const quaternion = manager.allocThreeQuaternion();
      const scale = manager.allocThreeVector3();
      mesh.matrixWorld.decompose(position, quaternion, scale);
      if (scale.x !== 1 || scale.y !== 1 || scale.z !== 1) {
        isNonDefaultScale = true;
      }
      let parent;
      if (isNonDefaultScale) {
        parent = mesh.parent;
        if (parent !== null)
          mesh.parent = null;
        scale.copy(this.mesh.scale);
        mesh.scale.set(1, 1, 1);
        mesh.updateMatrixWorld(true);
      }
      this._updateRigidBodies();
      this._stepSimulation(delta);
      this._updateBones();
      if (isNonDefaultScale) {
        if (parent !== null)
          mesh.parent = parent;
        mesh.scale.copy(scale);
      }
      manager.freeThreeVector3(scale);
      manager.freeThreeQuaternion(quaternion);
      manager.freeThreeVector3(position);
      return this;
    },
    /**
     * Resets rigid bodies transorm to current bone's.
     *
     * @return {MMDPhysics}
     */
    reset: function() {
      for (let i2 = 0, il = this.bodies.length; i2 < il; i2++) {
        this.bodies[i2].reset();
      }
      return this;
    },
    /**
     * Warm ups Rigid bodies. Calculates cycles steps.
     *
     * @param {Integer} cycles
     * @return {MMDPhysics}
     */
    warmup: function(cycles) {
      for (let i2 = 0; i2 < cycles; i2++) {
        this.update(1 / 60);
      }
      return this;
    },
    /**
     * Sets gravity.
     *
     * @param {Vector3} gravity
     * @return {MMDPhysicsHelper}
     */
    setGravity: function(gravity) {
      this.world.setGravity(new Ammo.btVector3(gravity.x, gravity.y, gravity.z));
      this.gravity.copy(gravity);
      return this;
    },
    /**
     * Creates MMDPhysicsHelper
     *
     * @return {MMDPhysicsHelper}
     */
    createHelper: function() {
      return new MMDPhysicsHelper(this.mesh, this);
    },
    // private methods
    _init: function(mesh, rigidBodyParams, constraintParams) {
      const manager = this.manager;
      let parent = mesh.parent;
      if (parent !== null)
        parent = null;
      const currentPosition = manager.allocThreeVector3();
      const currentQuaternion = manager.allocThreeQuaternion();
      const currentScale = manager.allocThreeVector3();
      currentPosition.copy(mesh.position);
      currentQuaternion.copy(mesh.quaternion);
      currentScale.copy(mesh.scale);
      mesh.position.set(0, 0, 0);
      mesh.quaternion.set(0, 0, 0, 1);
      mesh.scale.set(1, 1, 1);
      mesh.updateMatrixWorld(true);
      if (this.world === null) {
        this.world = this._createWorld();
        this.setGravity(this.gravity);
      }
      this._initRigidBodies(rigidBodyParams);
      this._initConstraints(constraintParams);
      if (parent !== null)
        mesh.parent = parent;
      mesh.position.copy(currentPosition);
      mesh.quaternion.copy(currentQuaternion);
      mesh.scale.copy(currentScale);
      mesh.updateMatrixWorld(true);
      this.reset();
      manager.freeThreeVector3(currentPosition);
      manager.freeThreeQuaternion(currentQuaternion);
      manager.freeThreeVector3(currentScale);
    },
    _createWorld: function() {
      const config = new Ammo.btDefaultCollisionConfiguration();
      const dispatcher = new Ammo.btCollisionDispatcher(config);
      const cache = new Ammo.btDbvtBroadphase();
      const solver = new Ammo.btSequentialImpulseConstraintSolver();
      const world2 = new Ammo.btDiscreteDynamicsWorld(dispatcher, cache, solver, config);
      return world2;
    },
    _initRigidBodies: function(rigidBodies) {
      for (let i2 = 0, il = rigidBodies.length; i2 < il; i2++) {
        this.bodies.push(new RigidBody2(this.mesh, this.world, rigidBodies[i2], this.manager));
      }
    },
    _initConstraints: function(constraints) {
      for (let i2 = 0, il = constraints.length; i2 < il; i2++) {
        const params = constraints[i2];
        const bodyA = this.bodies[params.rigidBodyIndex1];
        const bodyB = this.bodies[params.rigidBodyIndex2];
        this.constraints.push(new Constraint(this.mesh, this.world, bodyA, bodyB, params, this.manager));
      }
    },
    _stepSimulation: function(delta) {
      const unitStep = this.unitStep;
      let stepTime = delta;
      let maxStepNum = (delta / unitStep | 0) + 1;
      if (stepTime < unitStep) {
        stepTime = unitStep;
        maxStepNum = 1;
      }
      if (maxStepNum > this.maxStepNum) {
        maxStepNum = this.maxStepNum;
      }
      this.world.stepSimulation(stepTime, maxStepNum, unitStep);
    },
    _updateRigidBodies: function() {
      for (let i2 = 0, il = this.bodies.length; i2 < il; i2++) {
        this.bodies[i2].updateFromBone();
      }
    },
    _updateBones: function() {
      for (let i2 = 0, il = this.bodies.length; i2 < il; i2++) {
        this.bodies[i2].updateBone();
      }
    }
  };
  function ResourceManager() {
    this.threeVector3s = [];
    this.threeMatrix4s = [];
    this.threeQuaternions = [];
    this.threeEulers = [];
    this.transforms = [];
    this.quaternions = [];
    this.vector3s = [];
  }
  ResourceManager.prototype = {
    constructor: ResourceManager,
    allocThreeVector3: function() {
      return this.threeVector3s.length > 0 ? this.threeVector3s.pop() : new Vector3();
    },
    freeThreeVector3: function(v) {
      this.threeVector3s.push(v);
    },
    allocThreeMatrix4: function() {
      return this.threeMatrix4s.length > 0 ? this.threeMatrix4s.pop() : new Matrix4();
    },
    freeThreeMatrix4: function(m) {
      this.threeMatrix4s.push(m);
    },
    allocThreeQuaternion: function() {
      return this.threeQuaternions.length > 0 ? this.threeQuaternions.pop() : new Quaternion();
    },
    freeThreeQuaternion: function(q) {
      this.threeQuaternions.push(q);
    },
    allocThreeEuler: function() {
      return this.threeEulers.length > 0 ? this.threeEulers.pop() : new Euler();
    },
    freeThreeEuler: function(e) {
      this.threeEulers.push(e);
    },
    allocTransform: function() {
      return this.transforms.length > 0 ? this.transforms.pop() : new Ammo.btTransform();
    },
    freeTransform: function(t2) {
      this.transforms.push(t2);
    },
    allocQuaternion: function() {
      return this.quaternions.length > 0 ? this.quaternions.pop() : new Ammo.btQuaternion();
    },
    freeQuaternion: function(q) {
      this.quaternions.push(q);
    },
    allocVector3: function() {
      return this.vector3s.length > 0 ? this.vector3s.pop() : new Ammo.btVector3();
    },
    freeVector3: function(v) {
      this.vector3s.push(v);
    },
    setIdentity: function(t2) {
      t2.setIdentity();
    },
    getBasis: function(t2) {
      const q = this.allocQuaternion();
      t2.getBasis().getRotation(q);
      return q;
    },
    getBasisAsMatrix3: function(t2) {
      const q = this.getBasis(t2);
      const m = this.quaternionToMatrix3(q);
      this.freeQuaternion(q);
      return m;
    },
    getOrigin: function(t2) {
      return t2.getOrigin();
    },
    setOrigin: function(t2, v) {
      t2.getOrigin().setValue(v.x(), v.y(), v.z());
    },
    copyOrigin: function(t1, t2) {
      const o = t2.getOrigin();
      this.setOrigin(t1, o);
    },
    setBasis: function(t2, q) {
      t2.setRotation(q);
    },
    setBasisFromMatrix3: function(t2, m) {
      const q = this.matrix3ToQuaternion(m);
      this.setBasis(t2, q);
      this.freeQuaternion(q);
    },
    setOriginFromArray3: function(t2, a2) {
      t2.getOrigin().setValue(a2[0], a2[1], a2[2]);
    },
    setOriginFromThreeVector3: function(t2, v) {
      t2.getOrigin().setValue(v.x, v.y, v.z);
    },
    setBasisFromArray3: function(t2, a2) {
      const thQ = this.allocThreeQuaternion();
      const thE = this.allocThreeEuler();
      thE.set(a2[0], a2[1], a2[2]);
      this.setBasisFromThreeQuaternion(t2, thQ.setFromEuler(thE));
      this.freeThreeEuler(thE);
      this.freeThreeQuaternion(thQ);
    },
    setBasisFromThreeQuaternion: function(t2, a2) {
      const q = this.allocQuaternion();
      q.setX(a2.x);
      q.setY(a2.y);
      q.setZ(a2.z);
      q.setW(a2.w);
      this.setBasis(t2, q);
      this.freeQuaternion(q);
    },
    multiplyTransforms: function(t1, t2) {
      const t3 = this.allocTransform();
      this.setIdentity(t3);
      const m1 = this.getBasisAsMatrix3(t1);
      const m2 = this.getBasisAsMatrix3(t2);
      const o1 = this.getOrigin(t1);
      const o2 = this.getOrigin(t2);
      const v12 = this.multiplyMatrix3ByVector3(m1, o2);
      const v2 = this.addVector3(v12, o1);
      this.setOrigin(t3, v2);
      const m3 = this.multiplyMatrices3(m1, m2);
      this.setBasisFromMatrix3(t3, m3);
      this.freeVector3(v12);
      this.freeVector3(v2);
      return t3;
    },
    inverseTransform: function(t2) {
      const t22 = this.allocTransform();
      const m1 = this.getBasisAsMatrix3(t2);
      const o = this.getOrigin(t2);
      const m2 = this.transposeMatrix3(m1);
      const v12 = this.negativeVector3(o);
      const v2 = this.multiplyMatrix3ByVector3(m2, v12);
      this.setOrigin(t22, v2);
      this.setBasisFromMatrix3(t22, m2);
      this.freeVector3(v12);
      this.freeVector3(v2);
      return t22;
    },
    multiplyMatrices3: function(m1, m2) {
      const m3 = [];
      const v10 = this.rowOfMatrix3(m1, 0);
      const v11 = this.rowOfMatrix3(m1, 1);
      const v12 = this.rowOfMatrix3(m1, 2);
      const v20 = this.columnOfMatrix3(m2, 0);
      const v21 = this.columnOfMatrix3(m2, 1);
      const v22 = this.columnOfMatrix3(m2, 2);
      m3[0] = this.dotVectors3(v10, v20);
      m3[1] = this.dotVectors3(v10, v21);
      m3[2] = this.dotVectors3(v10, v22);
      m3[3] = this.dotVectors3(v11, v20);
      m3[4] = this.dotVectors3(v11, v21);
      m3[5] = this.dotVectors3(v11, v22);
      m3[6] = this.dotVectors3(v12, v20);
      m3[7] = this.dotVectors3(v12, v21);
      m3[8] = this.dotVectors3(v12, v22);
      this.freeVector3(v10);
      this.freeVector3(v11);
      this.freeVector3(v12);
      this.freeVector3(v20);
      this.freeVector3(v21);
      this.freeVector3(v22);
      return m3;
    },
    addVector3: function(v12, v2) {
      const v = this.allocVector3();
      v.setValue(v12.x() + v2.x(), v12.y() + v2.y(), v12.z() + v2.z());
      return v;
    },
    dotVectors3: function(v12, v2) {
      return v12.x() * v2.x() + v12.y() * v2.y() + v12.z() * v2.z();
    },
    rowOfMatrix3: function(m, i2) {
      const v = this.allocVector3();
      v.setValue(m[i2 * 3 + 0], m[i2 * 3 + 1], m[i2 * 3 + 2]);
      return v;
    },
    columnOfMatrix3: function(m, i2) {
      const v = this.allocVector3();
      v.setValue(m[i2 + 0], m[i2 + 3], m[i2 + 6]);
      return v;
    },
    negativeVector3: function(v) {
      const v2 = this.allocVector3();
      v2.setValue(-v.x(), -v.y(), -v.z());
      return v2;
    },
    multiplyMatrix3ByVector3: function(m, v) {
      const v4 = this.allocVector3();
      const v0 = this.rowOfMatrix3(m, 0);
      const v12 = this.rowOfMatrix3(m, 1);
      const v2 = this.rowOfMatrix3(m, 2);
      const x = this.dotVectors3(v0, v);
      const y = this.dotVectors3(v12, v);
      const z = this.dotVectors3(v2, v);
      v4.setValue(x, y, z);
      this.freeVector3(v0);
      this.freeVector3(v12);
      this.freeVector3(v2);
      return v4;
    },
    transposeMatrix3: function(m) {
      const m2 = [];
      m2[0] = m[0];
      m2[1] = m[3];
      m2[2] = m[6];
      m2[3] = m[1];
      m2[4] = m[4];
      m2[5] = m[7];
      m2[6] = m[2];
      m2[7] = m[5];
      m2[8] = m[8];
      return m2;
    },
    quaternionToMatrix3: function(q) {
      const m = [];
      const x = q.x();
      const y = q.y();
      const z = q.z();
      const w = q.w();
      const xx = x * x;
      const yy = y * y;
      const zz = z * z;
      const xy = x * y;
      const yz = y * z;
      const zx = z * x;
      const xw = x * w;
      const yw = y * w;
      const zw = z * w;
      m[0] = 1 - 2 * (yy + zz);
      m[1] = 2 * (xy - zw);
      m[2] = 2 * (zx + yw);
      m[3] = 2 * (xy + zw);
      m[4] = 1 - 2 * (zz + xx);
      m[5] = 2 * (yz - xw);
      m[6] = 2 * (zx - yw);
      m[7] = 2 * (yz + xw);
      m[8] = 1 - 2 * (xx + yy);
      return m;
    },
    matrix3ToQuaternion: function(m) {
      const t2 = m[0] + m[4] + m[8];
      let s, x, y, z, w;
      if (t2 > 0) {
        s = Math.sqrt(t2 + 1) * 2;
        w = 0.25 * s;
        x = (m[7] - m[5]) / s;
        y = (m[2] - m[6]) / s;
        z = (m[3] - m[1]) / s;
      } else if (m[0] > m[4] && m[0] > m[8]) {
        s = Math.sqrt(1 + m[0] - m[4] - m[8]) * 2;
        w = (m[7] - m[5]) / s;
        x = 0.25 * s;
        y = (m[1] + m[3]) / s;
        z = (m[2] + m[6]) / s;
      } else if (m[4] > m[8]) {
        s = Math.sqrt(1 + m[4] - m[0] - m[8]) * 2;
        w = (m[2] - m[6]) / s;
        x = (m[1] + m[3]) / s;
        y = 0.25 * s;
        z = (m[5] + m[7]) / s;
      } else {
        s = Math.sqrt(1 + m[8] - m[0] - m[4]) * 2;
        w = (m[3] - m[1]) / s;
        x = (m[2] + m[6]) / s;
        y = (m[5] + m[7]) / s;
        z = 0.25 * s;
      }
      const q = this.allocQuaternion();
      q.setX(x);
      q.setY(y);
      q.setZ(z);
      q.setW(w);
      return q;
    }
  };
  function RigidBody2(mesh, world2, params, manager) {
    this.mesh = mesh;
    this.world = world2;
    this.params = params;
    this.manager = manager;
    this.body = null;
    this.bone = null;
    this.boneOffsetForm = null;
    this.boneOffsetFormInverse = null;
    this._init();
  }
  RigidBody2.prototype = {
    constructor: MMDPhysics2.RigidBody,
    /**
     * Resets rigid body transform to the current bone's.
     *
     * @return {RigidBody}
     */
    reset: function() {
      this._setTransformFromBone();
      return this;
    },
    /**
     * Updates rigid body's transform from the current bone.
     *
     * @return {RidigBody}
     */
    updateFromBone: function() {
      if (this.params.boneIndex !== -1 && this.params.type === 0) {
        this._setTransformFromBone();
      }
      return this;
    },
    /**
     * Updates bone from the current ridid body's transform.
     *
     * @return {RidigBody}
     */
    updateBone: function() {
      if (this.params.type === 0 || this.params.boneIndex === -1) {
        return this;
      }
      this._updateBoneRotation();
      if (this.params.type === 1) {
        this._updateBonePosition();
      }
      this.bone.updateMatrixWorld(true);
      if (this.params.type === 2) {
        this._setPositionFromBone();
      }
      return this;
    },
    // private methods
    _init: function() {
      function generateShape(p) {
        switch (p.shapeType) {
          case 0:
            return new Ammo.btSphereShape(p.width);
          case 1:
            return new Ammo.btBoxShape(new Ammo.btVector3(p.width, p.height, p.depth));
          case 2:
            return new Ammo.btCapsuleShape(p.width, p.height);
          default:
            throw `unknown shape type ${p.shapeType}`;
        }
      }
      const manager = this.manager;
      const params = this.params;
      const bones = this.mesh.skeleton.bones;
      const bone = params.boneIndex === -1 ? new Bone() : bones[params.boneIndex];
      const shape = generateShape(params);
      const weight = params.type === 0 ? 0 : params.weight;
      const localInertia = manager.allocVector3();
      localInertia.setValue(0, 0, 0);
      if (weight !== 0) {
        shape.calculateLocalInertia(weight, localInertia);
      }
      const boneOffsetForm = manager.allocTransform();
      manager.setIdentity(boneOffsetForm);
      manager.setOriginFromArray3(boneOffsetForm, params.position);
      manager.setBasisFromArray3(boneOffsetForm, params.rotation);
      const vector2 = manager.allocThreeVector3();
      const boneForm = manager.allocTransform();
      manager.setIdentity(boneForm);
      manager.setOriginFromThreeVector3(boneForm, bone.getWorldPosition(vector2));
      const form = manager.multiplyTransforms(boneForm, boneOffsetForm);
      const state = new Ammo.btDefaultMotionState(form);
      const info = new Ammo.btRigidBodyConstructionInfo(weight, state, shape, localInertia);
      info.set_m_friction(params.friction);
      info.set_m_restitution(params.restitution);
      const body = new Ammo.btRigidBody(info);
      if (params.type === 0) {
        body.setCollisionFlags(body.getCollisionFlags() | 2);
        body.setActivationState(4);
      }
      body.setDamping(params.positionDamping, params.rotationDamping);
      body.setSleepingThresholds(0, 0);
      this.world.addRigidBody(body, 1 << params.groupIndex, params.groupTarget);
      this.body = body;
      this.bone = bone;
      this.boneOffsetForm = boneOffsetForm;
      this.boneOffsetFormInverse = manager.inverseTransform(boneOffsetForm);
      manager.freeVector3(localInertia);
      manager.freeTransform(form);
      manager.freeTransform(boneForm);
      manager.freeThreeVector3(vector2);
    },
    _getBoneTransform: function() {
      const manager = this.manager;
      const p = manager.allocThreeVector3();
      const q = manager.allocThreeQuaternion();
      const s = manager.allocThreeVector3();
      this.bone.matrixWorld.decompose(p, q, s);
      const tr = manager.allocTransform();
      manager.setOriginFromThreeVector3(tr, p);
      manager.setBasisFromThreeQuaternion(tr, q);
      const form = manager.multiplyTransforms(tr, this.boneOffsetForm);
      manager.freeTransform(tr);
      manager.freeThreeVector3(s);
      manager.freeThreeQuaternion(q);
      manager.freeThreeVector3(p);
      return form;
    },
    _getWorldTransformForBone: function() {
      const manager = this.manager;
      const tr = this.body.getCenterOfMassTransform();
      return manager.multiplyTransforms(tr, this.boneOffsetFormInverse);
    },
    _setTransformFromBone: function() {
      const manager = this.manager;
      const form = this._getBoneTransform();
      this.body.setCenterOfMassTransform(form);
      this.body.getMotionState().setWorldTransform(form);
      manager.freeTransform(form);
    },
    _setPositionFromBone: function() {
      const manager = this.manager;
      const form = this._getBoneTransform();
      const tr = manager.allocTransform();
      this.body.getMotionState().getWorldTransform(tr);
      manager.copyOrigin(tr, form);
      this.body.setCenterOfMassTransform(tr);
      this.body.getMotionState().setWorldTransform(tr);
      manager.freeTransform(tr);
      manager.freeTransform(form);
    },
    _updateBoneRotation: function() {
      const manager = this.manager;
      const tr = this._getWorldTransformForBone();
      const q = manager.getBasis(tr);
      const thQ = manager.allocThreeQuaternion();
      const thQ2 = manager.allocThreeQuaternion();
      const thQ3 = manager.allocThreeQuaternion();
      thQ.set(q.x(), q.y(), q.z(), q.w());
      thQ2.setFromRotationMatrix(this.bone.matrixWorld);
      thQ2.conjugate();
      thQ2.multiply(thQ);
      thQ3.setFromRotationMatrix(this.bone.matrix);
      this.bone.quaternion.copy(thQ2.multiply(thQ3).normalize());
      manager.freeThreeQuaternion(thQ);
      manager.freeThreeQuaternion(thQ2);
      manager.freeThreeQuaternion(thQ3);
      manager.freeQuaternion(q);
      manager.freeTransform(tr);
    },
    _updateBonePosition: function() {
      const manager = this.manager;
      const tr = this._getWorldTransformForBone();
      const thV = manager.allocThreeVector3();
      const o = manager.getOrigin(tr);
      thV.set(o.x(), o.y(), o.z());
      if (this.bone.parent) {
        this.bone.parent.worldToLocal(thV);
      }
      this.bone.position.copy(thV);
      manager.freeThreeVector3(thV);
      manager.freeTransform(tr);
    }
  };
  function Constraint(mesh, world2, bodyA, bodyB, params, manager) {
    this.mesh = mesh;
    this.world = world2;
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.params = params;
    this.manager = manager;
    this.constraint = null;
    this._init();
  }
  Constraint.prototype = {
    constructor: Constraint,
    // private method
    _init: function() {
      const manager = this.manager;
      const params = this.params;
      const bodyA = this.bodyA;
      const bodyB = this.bodyB;
      const form = manager.allocTransform();
      manager.setIdentity(form);
      manager.setOriginFromArray3(form, params.position);
      manager.setBasisFromArray3(form, params.rotation);
      const formA = manager.allocTransform();
      const formB = manager.allocTransform();
      bodyA.body.getMotionState().getWorldTransform(formA);
      bodyB.body.getMotionState().getWorldTransform(formB);
      const formInverseA = manager.inverseTransform(formA);
      const formInverseB = manager.inverseTransform(formB);
      const formA2 = manager.multiplyTransforms(formInverseA, form);
      const formB2 = manager.multiplyTransforms(formInverseB, form);
      const constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA.body, bodyB.body, formA2, formB2, true);
      const lll = manager.allocVector3();
      const lul = manager.allocVector3();
      const all = manager.allocVector3();
      const aul = manager.allocVector3();
      lll.setValue(params.translationLimitation1[0], params.translationLimitation1[1], params.translationLimitation1[2]);
      lul.setValue(params.translationLimitation2[0], params.translationLimitation2[1], params.translationLimitation2[2]);
      all.setValue(params.rotationLimitation1[0], params.rotationLimitation1[1], params.rotationLimitation1[2]);
      aul.setValue(params.rotationLimitation2[0], params.rotationLimitation2[1], params.rotationLimitation2[2]);
      constraint.setLinearLowerLimit(lll);
      constraint.setLinearUpperLimit(lul);
      constraint.setAngularLowerLimit(all);
      constraint.setAngularUpperLimit(aul);
      for (let i2 = 0; i2 < 3; i2++) {
        if (params.springPosition[i2] !== 0) {
          constraint.enableSpring(i2, true);
          constraint.setStiffness(i2, params.springPosition[i2]);
        }
      }
      for (let i2 = 0; i2 < 3; i2++) {
        if (params.springRotation[i2] !== 0) {
          constraint.enableSpring(i2 + 3, true);
          constraint.setStiffness(i2 + 3, params.springRotation[i2]);
        }
      }
      if (constraint.setParam !== void 0) {
        for (let i2 = 0; i2 < 6; i2++) {
          constraint.setParam(2, 0.475, i2);
        }
      }
      this.world.addConstraint(constraint, true);
      this.constraint = constraint;
      manager.freeTransform(form);
      manager.freeTransform(formA);
      manager.freeTransform(formB);
      manager.freeTransform(formInverseA);
      manager.freeTransform(formInverseB);
      manager.freeTransform(formA2);
      manager.freeTransform(formB2);
      manager.freeVector3(lll);
      manager.freeVector3(lul);
      manager.freeVector3(all);
      manager.freeVector3(aul);
    }
  };
  function MMDPhysicsHelper(mesh, physics) {
    Object3D.call(this);
    this.root = mesh;
    this.physics = physics;
    this.matrix.copy(mesh.matrixWorld);
    this.matrixAutoUpdate = false;
    this.materials = [];
    this.materials.push(new MeshBasicMaterial({
      color: new Color(16746632),
      wireframe: true,
      depthTest: false,
      depthWrite: false,
      opacity: 0.25,
      transparent: true
    }));
    this.materials.push(new MeshBasicMaterial({
      color: new Color(8978312),
      wireframe: true,
      depthTest: false,
      depthWrite: false,
      opacity: 0.25,
      transparent: true
    }));
    this.materials.push(new MeshBasicMaterial({
      color: new Color(8947967),
      wireframe: true,
      depthTest: false,
      depthWrite: false,
      opacity: 0.25,
      transparent: true
    }));
    this._init();
  }
  MMDPhysicsHelper.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: MMDPhysicsHelper,
    /**
     * Updates Rigid Bodies visualization.
     */
    updateMatrixWorld: (() => {
      const position = new Vector3();
      const quaternion = new Quaternion();
      const scale = new Vector3();
      const matrixWorldInv = new Matrix4();
      return function updateMatrixWorld(force) {
        const mesh = this.root;
        if (this.visible) {
          const bodies = this.physics.bodies;
          matrixWorldInv.copy(mesh.matrixWorld).decompose(position, quaternion, scale).compose(position, quaternion, scale.set(1, 1, 1)).invert();
          for (let i2 = 0, il = bodies.length; i2 < il; i2++) {
            const body = bodies[i2].body;
            const child = this.children[i2];
            const tr = body.getCenterOfMassTransform();
            const origin = tr.getOrigin();
            const rotation = tr.getRotation();
            child.position.set(origin.x(), origin.y(), origin.z()).applyMatrix4(matrixWorldInv);
            child.quaternion.setFromRotationMatrix(matrixWorldInv).multiply(quaternion.set(rotation.x(), rotation.y(), rotation.z(), rotation.w()));
          }
        }
        this.matrix.copy(mesh.matrixWorld).decompose(position, quaternion, scale).compose(position, quaternion, scale.set(1, 1, 1));
        Object3D.prototype.updateMatrixWorld.call(this, force);
      };
    })(),
    // private method
    _init: function() {
      const bodies = this.physics.bodies;
      function createGeometry(param) {
        switch (param.shapeType) {
          case 0:
            return new SphereGeometry(param.width, 16, 8);
          case 1:
            return new BoxGeometry(param.width * 2, param.height * 2, param.depth * 2, 8, 8, 8);
          case 2:
            return new createCapsuleGeometry(param.width, param.height, 16, 8);
          default:
            return null;
        }
      }
      function createCapsuleGeometry(radius, cylinderHeight, segmentsRadius, segmentsHeight) {
        const geometry = new CylinderGeometry(radius, radius, cylinderHeight, segmentsRadius, segmentsHeight, true);
        const upperSphere = new Mesh(new SphereGeometry(radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, 0, Math.PI / 2));
        const lowerSphere = new Mesh(new SphereGeometry(radius, segmentsRadius, segmentsHeight, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2));
        upperSphere.position.set(0, cylinderHeight / 2, 0);
        lowerSphere.position.set(0, -cylinderHeight / 2, 0);
        upperSphere.updateMatrix();
        lowerSphere.updateMatrix();
        geometry.merge(upperSphere.geometry, upperSphere.matrix);
        geometry.merge(lowerSphere.geometry, lowerSphere.matrix);
        return geometry;
      }
      for (let i2 = 0, il = bodies.length; i2 < il; i2++) {
        const param = bodies[i2].params;
        this.add(new Mesh(createGeometry(param), this.materials[param.type]));
      }
    }
  });
  return MMDPhysics2;
})();

// node_modules/@react-three/rapier/node_modules/three-stdlib/animation/MMDAnimationHelper.js
var MMDAnimationHelper = (() => {
  function MMDAnimationHelper2(params) {
    params = params || {};
    this.meshes = [];
    this.camera = null;
    this.cameraTarget = new Object3D();
    this.cameraTarget.name = "target";
    this.audio = null;
    this.audioManager = null;
    this.objects = /* @__PURE__ */ new WeakMap();
    this.configuration = {
      sync: params.sync !== void 0 ? params.sync : true,
      afterglow: params.afterglow !== void 0 ? params.afterglow : 0,
      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== void 0 ? params.resetPhysicsOnLoop : true
    };
    this.enabled = {
      animation: true,
      ik: true,
      grant: true,
      physics: true,
      cameraAnimation: true
    };
    this.onBeforePhysics = () => {
    };
    this.sharedPhysics = false;
    this.masterPhysics = null;
  }
  MMDAnimationHelper2.prototype = {
    constructor: MMDAnimationHelper2,
    /**
     * Adds an Three.js Object to helper and setups animation.
     * The anmation durations of added objects are synched
     * if this.configuration.sync is true.
     *
     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object
     * @param {Object} params - (optional)
     * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.
     * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.
     * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.
     * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.
     * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.
     * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).
     * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.
     * @return {MMDAnimationHelper}
     */
    add: function(object, params) {
      params = params || {};
      if (object.isSkinnedMesh) {
        this._addMesh(object, params);
      } else if (object.isCamera) {
        this._setupCamera(object, params);
      } else if (object.type === "Audio") {
        this._setupAudio(object, params);
      } else {
        throw new Error("THREE.MMDAnimationHelper.add: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.");
      }
      if (this.configuration.sync)
        this._syncDuration();
      return this;
    },
    /**
     * Removes an Three.js Object from helper.
     *
     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object
     * @return {MMDAnimationHelper}
     */
    remove: function(object) {
      if (object.isSkinnedMesh) {
        this._removeMesh(object);
      } else if (object.isCamera) {
        this._clearCamera(object);
      } else if (object.type === "Audio") {
        this._clearAudio(object);
      } else {
        throw new Error("THREE.MMDAnimationHelper.remove: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.");
      }
      if (this.configuration.sync)
        this._syncDuration();
      return this;
    },
    /**
     * Updates the animation.
     *
     * @param {Number} delta
     * @return {MMDAnimationHelper}
     */
    update: function(delta) {
      if (this.audioManager !== null)
        this.audioManager.control(delta);
      for (let i2 = 0; i2 < this.meshes.length; i2++) {
        this._animateMesh(this.meshes[i2], delta);
      }
      if (this.sharedPhysics)
        this._updateSharedPhysics(delta);
      if (this.camera !== null)
        this._animateCamera(this.camera, delta);
      return this;
    },
    /**
     * Changes the pose of SkinnedMesh as VPD specifies.
     *
     * @param {THREE.SkinnedMesh} mesh
     * @param {Object} vpd - VPD content parsed MMDParser
     * @param {Object} params - (optional)
     * @param {boolean} params.resetPose - Default is true.
     * @param {boolean} params.ik - Default is true.
     * @param {boolean} params.grant - Default is true.
     * @return {MMDAnimationHelper}
     */
    pose: function(mesh, vpd, params) {
      params = params || {};
      if (params.resetPose !== false)
        mesh.pose();
      const bones = mesh.skeleton.bones;
      const boneParams = vpd.bones;
      const boneNameDictionary = {};
      for (let i2 = 0, il = bones.length; i2 < il; i2++) {
        boneNameDictionary[bones[i2].name] = i2;
      }
      const vector2 = new Vector3();
      const quaternion = new Quaternion();
      for (let i2 = 0, il = boneParams.length; i2 < il; i2++) {
        const boneParam = boneParams[i2];
        const boneIndex = boneNameDictionary[boneParam.name];
        if (boneIndex === void 0)
          continue;
        const bone = bones[boneIndex];
        bone.position.add(vector2.fromArray(boneParam.translation));
        bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));
      }
      mesh.updateMatrixWorld(true);
      if (params.ik !== false) {
        this._createCCDIKSolver(mesh).update(params.saveOriginalBonesBeforeIK);
      }
      if (params.grant !== false) {
        this.createGrantSolver(mesh).update();
      }
      return this;
    },
    /**
     * Enabes/Disables an animation feature.
     *
     * @param {string} key
     * @param {boolean} enabled
     * @return {MMDAnimationHelper}
     */
    enable: function(key, enabled) {
      if (this.enabled[key] === void 0) {
        throw new Error(`THREE.MMDAnimationHelper.enable: unknown key ${key}`);
      }
      this.enabled[key] = enabled;
      if (key === "physics") {
        for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
          this._optimizeIK(this.meshes[i2], enabled);
        }
      }
      return this;
    },
    /**
     * Creates an GrantSolver instance.
     *
     * @param {THREE.SkinnedMesh} mesh
     * @return {GrantSolver}
     */
    createGrantSolver: function(mesh) {
      return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);
    },
    // private methods
    _addMesh: function(mesh, params) {
      if (this.meshes.indexOf(mesh) >= 0) {
        throw new Error(`THREE.MMDAnimationHelper._addMesh: SkinnedMesh '${mesh.name}' has already been added.`);
      }
      this.meshes.push(mesh);
      this.objects.set(mesh, {
        looped: false
      });
      this._setupMeshAnimation(mesh, params.animation);
      if (params.physics !== false) {
        this._setupMeshPhysics(mesh, params);
      }
      return this;
    },
    _setupCamera: function(camera, params) {
      if (this.camera === camera) {
        throw new Error(`THREE.MMDAnimationHelper._setupCamera: Camera '${camera.name}' has already been set.`);
      }
      if (this.camera)
        this.clearCamera(this.camera);
      this.camera = camera;
      camera.add(this.cameraTarget);
      this.objects.set(camera, {});
      if (params.animation !== void 0) {
        this._setupCameraAnimation(camera, params.animation);
      }
      return this;
    },
    _setupAudio: function(audio, params) {
      if (this.audio === audio) {
        throw new Error(`THREE.MMDAnimationHelper._setupAudio: Audio '${audio.name}' has already been set.`);
      }
      if (this.audio)
        this.clearAudio(this.audio);
      this.audio = audio;
      this.audioManager = new AudioManager(audio, params);
      this.objects.set(this.audioManager, {
        duration: this.audioManager.duration
      });
      return this;
    },
    _removeMesh: function(mesh) {
      let found = false;
      let writeIndex = 0;
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        if (this.meshes[i2] === mesh) {
          this.objects.delete(mesh);
          found = true;
          continue;
        }
        this.meshes[writeIndex++] = this.meshes[i2];
      }
      if (!found) {
        throw new Error(`THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '${mesh.name}' has not been added yet.`);
      }
      this.meshes.length = writeIndex;
      return this;
    },
    _clearCamera: function(camera) {
      if (camera !== this.camera) {
        throw new Error(`THREE.MMDAnimationHelper._clearCamera: Camera '${camera.name}' has not been set yet.`);
      }
      this.camera.remove(this.cameraTarget);
      this.objects.delete(this.camera);
      this.camera = null;
      return this;
    },
    _clearAudio: function(audio) {
      if (audio !== this.audio) {
        throw new Error(`THREE.MMDAnimationHelper._clearAudio: Audio '${audio.name}' has not been set yet.`);
      }
      this.objects.delete(this.audioManager);
      this.audio = null;
      this.audioManager = null;
      return this;
    },
    _setupMeshAnimation: function(mesh, animation) {
      const objects = this.objects.get(mesh);
      if (animation !== void 0) {
        const animations = Array.isArray(animation) ? animation : [animation];
        objects.mixer = new AnimationMixer(mesh);
        for (let i2 = 0, il = animations.length; i2 < il; i2++) {
          objects.mixer.clipAction(animations[i2]).play();
        }
        objects.mixer.addEventListener("loop", (event) => {
          const tracks = event.action._clip.tracks;
          if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== ".bones")
            return;
          objects.looped = true;
        });
      }
      objects.ikSolver = this._createCCDIKSolver(mesh);
      objects.grantSolver = this.createGrantSolver(mesh);
      return this;
    },
    _setupCameraAnimation: function(camera, animation) {
      const animations = Array.isArray(animation) ? animation : [animation];
      const objects = this.objects.get(camera);
      objects.mixer = new AnimationMixer(camera);
      for (let i2 = 0, il = animations.length; i2 < il; i2++) {
        objects.mixer.clipAction(animations[i2]).play();
      }
    },
    _setupMeshPhysics: function(mesh, params) {
      const objects = this.objects.get(mesh);
      if (params.world === void 0 && this.sharedPhysics) {
        const masterPhysics = this._getMasterPhysics();
        if (masterPhysics !== null)
          world = masterPhysics.world;
      }
      objects.physics = this._createMMDPhysics(mesh, params);
      if (objects.mixer && params.animationWarmup !== false) {
        this._animateMesh(mesh, 0);
        objects.physics.reset();
      }
      objects.physics.warmup(params.warmup !== void 0 ? params.warmup : 60);
      this._optimizeIK(mesh, true);
    },
    _animateMesh: function(mesh, delta) {
      const objects = this.objects.get(mesh);
      const mixer = objects.mixer;
      const ikSolver = objects.ikSolver;
      const grantSolver = objects.grantSolver;
      const physics = objects.physics;
      const looped = objects.looped;
      if (mixer && this.enabled.animation) {
        this._restoreBones(mesh);
        mixer.update(delta);
        this._saveBones(mesh);
        if (ikSolver && this.enabled.ik) {
          mesh.updateMatrixWorld(true);
          ikSolver.update();
        }
        if (grantSolver && this.enabled.grant) {
          grantSolver.update();
        }
      }
      if (looped === true && this.enabled.physics) {
        if (physics && this.configuration.resetPhysicsOnLoop)
          physics.reset();
        objects.looped = false;
      }
      if (physics && this.enabled.physics && !this.sharedPhysics) {
        this.onBeforePhysics(mesh);
        physics.update(delta);
      }
    },
    _animateCamera: function(camera, delta) {
      const mixer = this.objects.get(camera).mixer;
      if (mixer && this.enabled.cameraAnimation) {
        mixer.update(delta);
        camera.updateProjectionMatrix();
        camera.up.set(0, 1, 0);
        camera.up.applyQuaternion(camera.quaternion);
        camera.lookAt(this.cameraTarget.position);
      }
    },
    _optimizeIK: function(mesh, physicsEnabled) {
      const iks = mesh.geometry.userData.MMD.iks;
      const bones = mesh.geometry.userData.MMD.bones;
      for (let i2 = 0, il = iks.length; i2 < il; i2++) {
        const ik = iks[i2];
        const links = ik.links;
        for (let j2 = 0, jl2 = links.length; j2 < jl2; j2++) {
          const link = links[j2];
          if (physicsEnabled === true) {
            link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;
          } else {
            link.enabled = true;
          }
        }
      }
    },
    _createCCDIKSolver: function(mesh) {
      if (CCDIKSolver === void 0) {
        throw new Error("THREE.MMDAnimationHelper: Import CCDIKSolver.");
      }
      return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);
    },
    _createMMDPhysics: function(mesh, params) {
      if (MMDPhysics === void 0) {
        throw new Error("THREE.MMDPhysics: Import MMDPhysics.");
      }
      return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);
    },
    /*
     * Detects the longest duration and then sets it to them to sync.
     * TODO: Not to access private properties ( ._actions and ._clip )
     */
    _syncDuration: function() {
      let max2 = 0;
      const objects = this.objects;
      const meshes = this.meshes;
      const camera = this.camera;
      const audioManager = this.audioManager;
      for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
        var mixer = this.objects.get(meshes[i2]).mixer;
        if (mixer === void 0)
          continue;
        for (let j2 = 0; j2 < mixer._actions.length; j2++) {
          var clip = mixer._actions[j2]._clip;
          if (!objects.has(clip)) {
            objects.set(clip, {
              duration: clip.duration
            });
          }
          max2 = Math.max(max2, objects.get(clip).duration);
        }
      }
      if (camera !== null) {
        var mixer = this.objects.get(camera).mixer;
        if (mixer !== void 0) {
          for (let i2 = 0, il = mixer._actions.length; i2 < il; i2++) {
            var clip = mixer._actions[i2]._clip;
            if (!objects.has(clip)) {
              objects.set(clip, {
                duration: clip.duration
              });
            }
            max2 = Math.max(max2, objects.get(clip).duration);
          }
        }
      }
      if (audioManager !== null) {
        max2 = Math.max(max2, objects.get(audioManager).duration);
      }
      max2 += this.configuration.afterglow;
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        var mixer = this.objects.get(this.meshes[i2]).mixer;
        if (mixer === void 0)
          continue;
        for (let j2 = 0, jl2 = mixer._actions.length; j2 < jl2; j2++) {
          mixer._actions[j2]._clip.duration = max2;
        }
      }
      if (camera !== null) {
        var mixer = this.objects.get(camera).mixer;
        if (mixer !== void 0) {
          for (let i2 = 0, il = mixer._actions.length; i2 < il; i2++) {
            mixer._actions[i2]._clip.duration = max2;
          }
        }
      }
      if (audioManager !== null) {
        audioManager.duration = max2;
      }
    },
    // workaround
    _updatePropertyMixersBuffer: function(mesh) {
      const mixer = this.objects.get(mesh).mixer;
      const propertyMixers = mixer._bindings;
      const accuIndex = mixer._accuIndex;
      for (let i2 = 0, il = propertyMixers.length; i2 < il; i2++) {
        const propertyMixer = propertyMixers[i2];
        const buffer2 = propertyMixer.buffer;
        const stride = propertyMixer.valueSize;
        const offset = (accuIndex + 1) * stride;
        propertyMixer.binding.getValue(buffer2, offset);
      }
    },
    /*
     * Avoiding these two issues by restore/save bones before/after mixer animation.
     *
     * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.
     *    Calculating IK, Grant, and Physics after mixer animation can break
     *    the cache coherency.
     *
     * 2. Applying Grant two or more times without reset the posing breaks model.
     */
    _saveBones: function(mesh) {
      const objects = this.objects.get(mesh);
      const bones = mesh.skeleton.bones;
      let backupBones = objects.backupBones;
      if (backupBones === void 0) {
        backupBones = new Float32Array(bones.length * 7);
        objects.backupBones = backupBones;
      }
      for (let i2 = 0, il = bones.length; i2 < il; i2++) {
        const bone = bones[i2];
        bone.position.toArray(backupBones, i2 * 7);
        bone.quaternion.toArray(backupBones, i2 * 7 + 3);
      }
    },
    _restoreBones: function(mesh) {
      const objects = this.objects.get(mesh);
      const backupBones = objects.backupBones;
      if (backupBones === void 0)
        return;
      const bones = mesh.skeleton.bones;
      for (let i2 = 0, il = bones.length; i2 < il; i2++) {
        const bone = bones[i2];
        bone.position.fromArray(backupBones, i2 * 7);
        bone.quaternion.fromArray(backupBones, i2 * 7 + 3);
      }
    },
    // experimental
    _getMasterPhysics: function() {
      if (this.masterPhysics !== null)
        return this.masterPhysics;
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        const physics = this.meshes[i2].physics;
        if (physics !== void 0 && physics !== null) {
          this.masterPhysics = physics;
          return this.masterPhysics;
        }
      }
      return null;
    },
    _updateSharedPhysics: function(delta) {
      if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics)
        return;
      const physics = this._getMasterPhysics();
      if (physics === null)
        return;
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        var p = this.meshes[i2].physics;
        if (p !== null && p !== void 0) {
          p.updateRigidBodies();
        }
      }
      physics.stepSimulation(delta);
      for (let i2 = 0, il = this.meshes.length; i2 < il; i2++) {
        var p = this.meshes[i2].physics;
        if (p !== null && p !== void 0) {
          p.updateBones();
        }
      }
    }
  };
  function AudioManager(audio, params) {
    params = params || {};
    this.audio = audio;
    this.elapsedTime = 0;
    this.currentTime = 0;
    this.delayTime = params.delayTime !== void 0 ? params.delayTime : 0;
    this.audioDuration = this.audio.buffer.duration;
    this.duration = this.audioDuration + this.delayTime;
  }
  AudioManager.prototype = {
    constructor: AudioManager,
    /**
     * @param {Number} delta
     * @return {AudioManager}
     */
    control: function(delta) {
      this.elapsed += delta;
      this.currentTime += delta;
      if (this._shouldStopAudio())
        this.audio.stop();
      if (this._shouldStartAudio())
        this.audio.play();
      return this;
    },
    // private methods
    _shouldStartAudio: function() {
      if (this.audio.isPlaying)
        return false;
      while (this.currentTime >= this.duration) {
        this.currentTime -= this.duration;
      }
      if (this.currentTime < this.delayTime)
        return false;
      if (this.currentTime - this.delayTime > this.audioDuration)
        return false;
      return true;
    },
    _shouldStopAudio: function() {
      return this.audio.isPlaying && this.currentTime >= this.duration;
    }
  };
  function GrantSolver(mesh, grants) {
    this.mesh = mesh;
    this.grants = grants || [];
  }
  GrantSolver.prototype = {
    constructor: GrantSolver,
    /**
     * @return {GrantSolver}
     */
    update: (() => {
      const quaternion = new Quaternion();
      return function() {
        const bones = this.mesh.skeleton.bones;
        const grants = this.grants;
        for (let i2 = 0, il = grants.length; i2 < il; i2++) {
          const grant = grants[i2];
          const bone = bones[grant.index];
          const parentBone = bones[grant.parentIndex];
          if (grant.isLocal) {
            if (grant.affectPosition)
              ;
            if (grant.affectRotation)
              ;
          } else {
            if (grant.affectPosition)
              ;
            if (grant.affectRotation) {
              quaternion.set(0, 0, 0, 1);
              quaternion.slerp(parentBone.quaternion, grant.ratio);
              bone.quaternion.multiply(quaternion);
            }
          }
        }
        return this;
      };
    })()
  };
  return MMDAnimationHelper2;
})();

// node_modules/@react-three/rapier/node_modules/three-stdlib/objects/Reflector.js
var Reflector = class extends Mesh {
  constructor(geometry, options = {}) {
    super(geometry);
    this.type = "Reflector";
    const scope = this;
    const color2 = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const shader = options.shader || Reflector.ReflectorShader;
    const reflectorPlane = new Plane();
    const normal = new Vector3();
    const reflectorWorldPosition = new Vector3();
    const cameraWorldPosition = new Vector3();
    const rotationMatrix2 = new Matrix4();
    const lookAtPosition = new Vector3(0, 0, -1);
    const clipPlane = new Vector4();
    const view = new Vector3();
    const target = new Vector3();
    const q = new Vector4();
    const textureMatrix = new Matrix4();
    const virtualCamera = new PerspectiveCamera();
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);
    const material = new ShaderMaterial({
      uniforms: UniformsUtils.clone(shader.uniforms),
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader
    });
    material.uniforms["tDiffuse"].value = renderTarget.texture;
    material.uniforms["color"].value = color2;
    material.uniforms["textureMatrix"].value = textureMatrix;
    this.material = material;
    this.onBeforeRender = function(renderer, scene, camera) {
      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix2.extractRotation(scope.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix2);
      view.subVectors(reflectorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(reflectorWorldPosition);
      rotationMatrix2.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix2);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(reflectorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(reflectorWorldPosition);
      virtualCamera.position.copy(view);
      virtualCamera.up.set(0, 1, 0);
      virtualCamera.up.applyMatrix4(rotationMatrix2);
      virtualCamera.up.reflect(normal);
      virtualCamera.lookAt(target);
      virtualCamera.far = camera.far;
      virtualCamera.updateMatrixWorld();
      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(virtualCamera.projectionMatrix);
      textureMatrix.multiply(virtualCamera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);
      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);
      const projectionMatrix = virtualCamera.projectionMatrix;
      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
      q.z = -1;
      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
      clipPlane.multiplyScalar(2 / clipPlane.dot(q));
      projectionMatrix.elements[2] = clipPlane.x;
      projectionMatrix.elements[6] = clipPlane.y;
      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;
      projectionMatrix.elements[14] = clipPlane.w;
      renderTarget.texture.encoding = renderer.outputEncoding;
      scope.visible = false;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.setRenderTarget(renderTarget);
      renderer.state.buffers.depth.setMask(true);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
      scope.visible = true;
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
    this.dispose = function() {
      renderTarget.dispose();
      scope.material.dispose();
    };
  }
};
Reflector.prototype.isReflector = true;
Reflector.ReflectorShader = {
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

		}`
  )
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/objects/Refractor.js
var Refractor = class extends Mesh {
  constructor(geometry, options = {}) {
    super(geometry);
    this.type = "Refractor";
    const scope = this;
    const color2 = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const shader = options.shader || Refractor.RefractorShader;
    const virtualCamera = new PerspectiveCamera();
    virtualCamera.matrixAutoUpdate = false;
    virtualCamera.userData.refractor = true;
    const refractorPlane = new Plane();
    const textureMatrix = new Matrix4();
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);
    this.material = new ShaderMaterial({
      uniforms: UniformsUtils.clone(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      transparent: true
      // ensures, refractors are drawn from farthest to closest
    });
    this.material.uniforms["color"].value = color2;
    this.material.uniforms["tDiffuse"].value = renderTarget.texture;
    this.material.uniforms["textureMatrix"].value = textureMatrix;
    const visible = function() {
      const refractorWorldPosition = new Vector3();
      const cameraWorldPosition = new Vector3();
      const rotationMatrix2 = new Matrix4();
      const view = new Vector3();
      const normal = new Vector3();
      return function visible2(camera) {
        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
        view.subVectors(refractorWorldPosition, cameraWorldPosition);
        rotationMatrix2.extractRotation(scope.matrixWorld);
        normal.set(0, 0, 1);
        normal.applyMatrix4(rotationMatrix2);
        return view.dot(normal) < 0;
      };
    }();
    const updateRefractorPlane = function() {
      const normal = new Vector3();
      const position = new Vector3();
      const quaternion = new Quaternion();
      const scale = new Vector3();
      return function updateRefractorPlane2() {
        scope.matrixWorld.decompose(position, quaternion, scale);
        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();
        normal.negate();
        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);
      };
    }();
    const updateVirtualCamera = function() {
      const clipPlane = new Plane();
      const clipVector = new Vector4();
      const q = new Vector4();
      return function updateVirtualCamera2(camera) {
        virtualCamera.matrixWorld.copy(camera.matrixWorld);
        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();
        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
        virtualCamera.far = camera.far;
        clipPlane.copy(refractorPlane);
        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);
        const projectionMatrix = virtualCamera.projectionMatrix;
        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
        q.z = -1;
        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
        clipVector.multiplyScalar(2 / clipVector.dot(q));
        projectionMatrix.elements[2] = clipVector.x;
        projectionMatrix.elements[6] = clipVector.y;
        projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;
        projectionMatrix.elements[14] = clipVector.w;
      };
    }();
    function updateTextureMatrix(camera) {
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(camera.projectionMatrix);
      textureMatrix.multiply(camera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
    }
    function render(renderer, scene, camera) {
      scope.visible = false;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.setRenderTarget(renderTarget);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
      scope.visible = true;
    }
    this.onBeforeRender = function(renderer, scene, camera) {
      renderTarget.texture.encoding = renderer.outputEncoding;
      if (camera.userData.refractor === true)
        return;
      if (!visible(camera) === true)
        return;
      updateRefractorPlane();
      updateTextureMatrix(camera);
      updateVirtualCamera(camera);
      render(renderer, scene, camera);
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
    this.dispose = function() {
      renderTarget.dispose();
      scope.material.dispose();
    };
  }
};
Refractor.prototype.isRefractor = true;
Refractor.RefractorShader = {
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

		}`
  )
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/objects/ShadowMesh.js
var _shadowMatrix = new Matrix4();
var ShadowMesh = class extends Mesh {
  constructor(mesh) {
    const shadowMaterial = new MeshBasicMaterial({
      color: 0,
      transparent: true,
      opacity: 0.6,
      depthWrite: false
    });
    super(mesh.geometry, shadowMaterial);
    this.meshMatrix = mesh.matrixWorld;
    this.frustumCulled = false;
    this.matrixAutoUpdate = false;
  }
  update(plane, lightPosition4D) {
    const dot2 = plane.normal.x * lightPosition4D.x + plane.normal.y * lightPosition4D.y + plane.normal.z * lightPosition4D.z + -plane.constant * lightPosition4D.w;
    const sme = _shadowMatrix.elements;
    sme[0] = dot2 - lightPosition4D.x * plane.normal.x;
    sme[4] = -lightPosition4D.x * plane.normal.y;
    sme[8] = -lightPosition4D.x * plane.normal.z;
    sme[12] = -lightPosition4D.x * -plane.constant;
    sme[1] = -lightPosition4D.y * plane.normal.x;
    sme[5] = dot2 - lightPosition4D.y * plane.normal.y;
    sme[9] = -lightPosition4D.y * plane.normal.z;
    sme[13] = -lightPosition4D.y * -plane.constant;
    sme[2] = -lightPosition4D.z * plane.normal.x;
    sme[6] = -lightPosition4D.z * plane.normal.y;
    sme[10] = dot2 - lightPosition4D.z * plane.normal.z;
    sme[14] = -lightPosition4D.z * -plane.constant;
    sme[3] = -lightPosition4D.w * plane.normal.x;
    sme[7] = -lightPosition4D.w * plane.normal.y;
    sme[11] = -lightPosition4D.w * plane.normal.z;
    sme[15] = dot2 - lightPosition4D.w * -plane.constant;
    this.matrix.multiplyMatrices(_shadowMatrix, this.meshMatrix);
  }
};
ShadowMesh.prototype.isShadowMesh = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/objects/Lensflare.js
var Lensflare = class extends Mesh {
  constructor() {
    super(Lensflare.Geometry, new MeshBasicMaterial({
      opacity: 0,
      transparent: true
    }));
    this.type = "Lensflare";
    this.frustumCulled = false;
    this.renderOrder = Infinity;
    const positionScreen = new Vector3();
    const positionView2 = new Vector3();
    const tempMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);
    tempMap.minFilter = NearestFilter;
    tempMap.magFilter = NearestFilter;
    tempMap.wrapS = ClampToEdgeWrapping;
    tempMap.wrapT = ClampToEdgeWrapping;
    const occlusionMap = new DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, RGBAFormat);
    occlusionMap.minFilter = NearestFilter;
    occlusionMap.magFilter = NearestFilter;
    occlusionMap.wrapS = ClampToEdgeWrapping;
    occlusionMap.wrapT = ClampToEdgeWrapping;
    const geometry = Lensflare.Geometry;
    const material1a = new RawShaderMaterial({
      uniforms: {
        scale: {
          value: null
        },
        screenPosition: {
          value: null
        }
      },
      vertexShader: (
        /* glsl */
        `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`
      ),
      fragmentShader: (
        /* glsl */
        `

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`
      ),
      depthTest: true,
      depthWrite: false,
      transparent: false
    });
    const material1b = new RawShaderMaterial({
      uniforms: {
        map: {
          value: tempMap
        },
        scale: {
          value: null
        },
        screenPosition: {
          value: null
        }
      },
      vertexShader: (
        /* glsl */
        `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`
      ),
      fragmentShader: (
        /* glsl */
        `

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`
      ),
      depthTest: false,
      depthWrite: false,
      transparent: false
    });
    const mesh1 = new Mesh(geometry, material1a);
    const elements = [];
    const shader = LensflareElement.Shader;
    const material2 = new RawShaderMaterial({
      uniforms: {
        map: {
          value: null
        },
        occlusionMap: {
          value: occlusionMap
        },
        color: {
          value: new Color(16777215)
        },
        scale: {
          value: new Vector2()
        },
        screenPosition: {
          value: new Vector3()
        }
      },
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      blending: AdditiveBlending,
      transparent: true,
      depthWrite: false
    });
    const mesh2 = new Mesh(geometry, material2);
    this.addElement = function(element2) {
      elements.push(element2);
    };
    const scale = new Vector2();
    const screenPositionPixels = new Vector2();
    const validArea = new Box2();
    const viewport = new Vector4();
    this.onBeforeRender = function(renderer, scene, camera) {
      renderer.getCurrentViewport(viewport);
      const invAspect = viewport.w / viewport.z;
      const halfViewportWidth = viewport.z / 2;
      const halfViewportHeight = viewport.w / 2;
      let size2 = 16 / viewport.w;
      scale.set(size2 * invAspect, size2);
      validArea.min.set(viewport.x, viewport.y);
      validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));
      positionView2.setFromMatrixPosition(this.matrixWorld);
      positionView2.applyMatrix4(camera.matrixWorldInverse);
      if (positionView2.z > 0)
        return;
      positionScreen.copy(positionView2).applyMatrix4(camera.projectionMatrix);
      screenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;
      screenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8;
      if (validArea.containsPoint(screenPositionPixels)) {
        renderer.copyFramebufferToTexture(screenPositionPixels, tempMap);
        let uniforms = material1a.uniforms;
        uniforms["scale"].value = scale;
        uniforms["screenPosition"].value = positionScreen;
        renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null);
        renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap);
        uniforms = material1b.uniforms;
        uniforms["scale"].value = scale;
        uniforms["screenPosition"].value = positionScreen;
        renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null);
        const vecX = -positionScreen.x * 2;
        const vecY = -positionScreen.y * 2;
        for (let i2 = 0, l = elements.length; i2 < l; i2++) {
          const element2 = elements[i2];
          const uniforms2 = material2.uniforms;
          uniforms2["color"].value.copy(element2.color);
          uniforms2["map"].value = element2.texture;
          uniforms2["screenPosition"].value.x = positionScreen.x + vecX * element2.distance;
          uniforms2["screenPosition"].value.y = positionScreen.y + vecY * element2.distance;
          size2 = element2.size / viewport.w;
          const invAspect2 = viewport.w / viewport.z;
          uniforms2["scale"].value.set(size2 * invAspect2, size2);
          material2.uniformsNeedUpdate = true;
          renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);
        }
      }
    };
    this.dispose = function() {
      material1a.dispose();
      material1b.dispose();
      material2.dispose();
      tempMap.dispose();
      occlusionMap.dispose();
      for (let i2 = 0, l = elements.length; i2 < l; i2++) {
        elements[i2].texture.dispose();
      }
    };
  }
};
Lensflare.prototype.isLensflare = true;
var LensflareElement = class {
  constructor(texture2, size2 = 1, distance2 = 0, color2 = new Color(16777215)) {
    this.texture = texture2;
    this.size = size2;
    this.distance = distance2;
    this.color = color2;
  }
};
LensflareElement.Shader = {
  uniforms: {
    map: {
      value: null
    },
    occlusionMap: {
      value: null
    },
    color: {
      value: null
    },
    scale: {
      value: null
    },
    screenPosition: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `

		precision highp float;

		uniform vec3 screenPosition;
		uniform vec2 scale;

		uniform sampler2D occlusionMap;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vUV = uv;

			vec2 pos = position.xy;

			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

			vVisibility =        visibility.r / 9.0;
			vVisibility *= 1.0 - visibility.g / 9.0;
			vVisibility *=       visibility.b / 9.0;

			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		precision highp float;

		uniform sampler2D map;
		uniform vec3 color;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vec4 texture = texture2D( map, vUV );
			texture.a *= vVisibility;
			gl_FragColor = texture;
			gl_FragColor.rgb *= color;

		}`
  )
};
Lensflare.Geometry = function() {
  const geometry = new BufferGeometry();
  const float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);
  const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
  geometry.setIndex([0, 1, 2, 0, 2, 3]);
  geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
  geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
  return geometry;
}();

// node_modules/@react-three/rapier/node_modules/three-stdlib/objects/Water.js
var Water = class extends Mesh {
  constructor(geometry, options = {}) {
    super(geometry);
    const scope = this;
    const textureWidth = options.textureWidth !== void 0 ? options.textureWidth : 512;
    const textureHeight = options.textureHeight !== void 0 ? options.textureHeight : 512;
    const clipBias = options.clipBias !== void 0 ? options.clipBias : 0;
    const alpha = options.alpha !== void 0 ? options.alpha : 1;
    const time = options.time !== void 0 ? options.time : 0;
    const normalSampler = options.waterNormals !== void 0 ? options.waterNormals : null;
    const sunDirection = options.sunDirection !== void 0 ? options.sunDirection : new Vector3(0.70707, 0.70707, 0);
    const sunColor = new Color(options.sunColor !== void 0 ? options.sunColor : 16777215);
    const waterColor = new Color(options.waterColor !== void 0 ? options.waterColor : 8355711);
    const eye = options.eye !== void 0 ? options.eye : new Vector3(0, 0, 0);
    const distortionScale = options.distortionScale !== void 0 ? options.distortionScale : 20;
    const side = options.side !== void 0 ? options.side : FrontSide;
    const fog = options.fog !== void 0 ? options.fog : false;
    const mirrorPlane = new Plane();
    const normal = new Vector3();
    const mirrorWorldPosition = new Vector3();
    const cameraWorldPosition = new Vector3();
    const rotationMatrix2 = new Matrix4();
    const lookAtPosition = new Vector3(0, 0, -1);
    const clipPlane = new Vector4();
    const view = new Vector3();
    const target = new Vector3();
    const q = new Vector4();
    const textureMatrix = new Matrix4();
    const mirrorCamera = new PerspectiveCamera();
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight);
    const mirrorShader = {
      uniforms: UniformsUtils.merge([UniformsLib["fog"], UniformsLib["lights"], {
        normalSampler: {
          value: null
        },
        mirrorSampler: {
          value: null
        },
        alpha: {
          value: 1
        },
        time: {
          value: 0
        },
        size: {
          value: 1
        },
        distortionScale: {
          value: 20
        },
        textureMatrix: {
          value: new Matrix4()
        },
        sunColor: {
          value: new Color(8355711)
        },
        sunDirection: {
          value: new Vector3(0.70707, 0.70707, 0)
        },
        eye: {
          value: new Vector3()
        },
        waterColor: {
          value: new Color(5592405)
        }
      }]),
      vertexShader: (
        /* glsl */
        `
				uniform mat4 textureMatrix;
				uniform float time;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				#include <common>
				#include <fog_pars_vertex>
				#include <shadowmap_pars_vertex>
				#include <logdepthbuf_pars_vertex>

				void main() {
					mirrorCoord = modelMatrix * vec4( position, 1.0 );
					worldPosition = mirrorCoord.xyzw;
					mirrorCoord = textureMatrix * mirrorCoord;
					vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );
					gl_Position = projectionMatrix * mvPosition;

				#include <beginnormal_vertex>
				#include <defaultnormal_vertex>
				#include <logdepthbuf_vertex>
				#include <fog_vertex>
				#include <shadowmap_vertex>
			}`
      ),
      fragmentShader: (
        /* glsl */
        `
				uniform sampler2D mirrorSampler;
				uniform float alpha;
				uniform float time;
				uniform float size;
				uniform float distortionScale;
				uniform sampler2D normalSampler;
				uniform vec3 sunColor;
				uniform vec3 sunDirection;
				uniform vec3 eye;
				uniform vec3 waterColor;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				vec4 getNoise( vec2 uv ) {
					vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
					vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
					vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
					vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
					vec4 noise = texture2D( normalSampler, uv0 ) +
						texture2D( normalSampler, uv1 ) +
						texture2D( normalSampler, uv2 ) +
						texture2D( normalSampler, uv3 );
					return noise * 0.5 - 1.0;
				}

				void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {
					vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );
					float direction = max( 0.0, dot( eyeDirection, reflection ) );
					specularColor += pow( direction, shiny ) * sunColor * spec;
					diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;
				}

				#include <common>
				#include <packing>
				#include <bsdfs>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <lights_pars_begin>
				#include <shadowmap_pars_fragment>
				#include <shadowmask_pars_fragment>

				void main() {

					#include <logdepthbuf_fragment>
					vec4 noise = getNoise( worldPosition.xz * size );
					vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );

					vec3 diffuseLight = vec3(0.0);
					vec3 specularLight = vec3(0.0);

					vec3 worldToEye = eye-worldPosition.xyz;
					vec3 eyeDirection = normalize( worldToEye );
					sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );

					float distance = length(worldToEye);

					vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;
					vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );

					float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );
					float rf0 = 0.3;
					float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );
					vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;
					vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);
					vec3 outgoingLight = albedo;
					gl_FragColor = vec4( outgoingLight, alpha );

					#include <tonemapping_fragment>
					#include <fog_fragment>
				}`
      )
    };
    const material = new ShaderMaterial({
      fragmentShader: mirrorShader.fragmentShader,
      vertexShader: mirrorShader.vertexShader,
      uniforms: UniformsUtils.clone(mirrorShader.uniforms),
      lights: true,
      side,
      fog
    });
    material.uniforms["mirrorSampler"].value = renderTarget.texture;
    material.uniforms["textureMatrix"].value = textureMatrix;
    material.uniforms["alpha"].value = alpha;
    material.uniforms["time"].value = time;
    material.uniforms["normalSampler"].value = normalSampler;
    material.uniforms["sunColor"].value = sunColor;
    material.uniforms["waterColor"].value = waterColor;
    material.uniforms["sunDirection"].value = sunDirection;
    material.uniforms["distortionScale"].value = distortionScale;
    material.uniforms["eye"].value = eye;
    scope.material = material;
    scope.onBeforeRender = function(renderer, scene, camera) {
      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix2.extractRotation(scope.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix2);
      view.subVectors(mirrorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(mirrorWorldPosition);
      rotationMatrix2.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix2);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(mirrorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(mirrorWorldPosition);
      mirrorCamera.position.copy(view);
      mirrorCamera.up.set(0, 1, 0);
      mirrorCamera.up.applyMatrix4(rotationMatrix2);
      mirrorCamera.up.reflect(normal);
      mirrorCamera.lookAt(target);
      mirrorCamera.far = camera.far;
      mirrorCamera.updateMatrixWorld();
      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix);
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(mirrorCamera.projectionMatrix);
      textureMatrix.multiply(mirrorCamera.matrixWorldInverse);
      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);
      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);
      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);
      const projectionMatrix = mirrorCamera.projectionMatrix;
      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
      q.z = -1;
      q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
      clipPlane.multiplyScalar(2 / clipPlane.dot(q));
      projectionMatrix.elements[2] = clipPlane.x;
      projectionMatrix.elements[6] = clipPlane.y;
      projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;
      projectionMatrix.elements[14] = clipPlane.w;
      eye.setFromMatrixPosition(camera.matrixWorld);
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      scope.visible = false;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.setRenderTarget(renderTarget);
      renderer.state.buffers.depth.setMask(true);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, mirrorCamera);
      scope.visible = true;
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
    };
  }
};
Water.prototype.isWater = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/objects/MarchingCubes.js
var MarchingCubes = class extends Mesh {
  constructor(resolution, material, enableUvs = false, enableColors = false, maxPolyCount = 1e4) {
    const geometry = new BufferGeometry();
    super(geometry, material);
    const scope = this;
    const vlist = new Float32Array(12 * 3);
    const nlist = new Float32Array(12 * 3);
    const clist = new Float32Array(12 * 3);
    this.enableUvs = enableUvs;
    this.enableColors = enableColors;
    this.init = function(resolution2) {
      this.resolution = resolution2;
      this.isolation = 80;
      this.size = resolution2;
      this.size2 = this.size * this.size;
      this.size3 = this.size2 * this.size;
      this.halfsize = this.size / 2;
      this.delta = 2 / this.size;
      this.yd = this.size;
      this.zd = this.size2;
      this.field = new Float32Array(this.size3);
      this.normal_cache = new Float32Array(this.size3 * 3);
      this.palette = new Float32Array(this.size3 * 3);
      this.count = 0;
      const maxVertexCount = maxPolyCount * 3;
      this.positionArray = new Float32Array(maxVertexCount * 3);
      const positionAttribute = new BufferAttribute(this.positionArray, 3);
      positionAttribute.setUsage(DynamicDrawUsage);
      geometry.setAttribute("position", positionAttribute);
      this.normalArray = new Float32Array(maxVertexCount * 3);
      const normalAttribute = new BufferAttribute(this.normalArray, 3);
      normalAttribute.setUsage(DynamicDrawUsage);
      geometry.setAttribute("normal", normalAttribute);
      if (this.enableUvs) {
        this.uvArray = new Float32Array(maxVertexCount * 2);
        const uvAttribute = new BufferAttribute(this.uvArray, 2);
        uvAttribute.setUsage(DynamicDrawUsage);
        geometry.setAttribute("uv", uvAttribute);
      }
      if (this.enableColors) {
        this.colorArray = new Float32Array(maxVertexCount * 3);
        const colorAttribute = new BufferAttribute(this.colorArray, 3);
        colorAttribute.setUsage(DynamicDrawUsage);
        geometry.setAttribute("color", colorAttribute);
      }
    };
    function lerp(a2, b2, t2) {
      return a2 + (b2 - a2) * t2;
    }
    function VIntX(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {
      const mu = (isol - valp1) / (valp2 - valp1), nc = scope.normal_cache;
      vlist[offset + 0] = x + mu * scope.delta;
      vlist[offset + 1] = y;
      vlist[offset + 2] = z;
      nlist[offset + 0] = lerp(nc[q + 0], nc[q + 3], mu);
      nlist[offset + 1] = lerp(nc[q + 1], nc[q + 4], mu);
      nlist[offset + 2] = lerp(nc[q + 2], nc[q + 5], mu);
      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);
      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);
      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);
    }
    function VIntY(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {
      const mu = (isol - valp1) / (valp2 - valp1), nc = scope.normal_cache;
      vlist[offset + 0] = x;
      vlist[offset + 1] = y + mu * scope.delta;
      vlist[offset + 2] = z;
      const q2 = q + scope.yd * 3;
      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);
      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);
      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);
      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);
      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);
      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);
    }
    function VIntZ(q, offset, isol, x, y, z, valp1, valp2, c_offset1, c_offset2) {
      const mu = (isol - valp1) / (valp2 - valp1), nc = scope.normal_cache;
      vlist[offset + 0] = x;
      vlist[offset + 1] = y;
      vlist[offset + 2] = z + mu * scope.delta;
      const q2 = q + scope.zd * 3;
      nlist[offset + 0] = lerp(nc[q + 0], nc[q2 + 0], mu);
      nlist[offset + 1] = lerp(nc[q + 1], nc[q2 + 1], mu);
      nlist[offset + 2] = lerp(nc[q + 2], nc[q2 + 2], mu);
      clist[offset + 0] = lerp(scope.palette[c_offset1 * 3 + 0], scope.palette[c_offset2 * 3 + 0], mu);
      clist[offset + 1] = lerp(scope.palette[c_offset1 * 3 + 1], scope.palette[c_offset2 * 3 + 1], mu);
      clist[offset + 2] = lerp(scope.palette[c_offset1 * 3 + 2], scope.palette[c_offset2 * 3 + 2], mu);
    }
    function compNorm(q) {
      const q3 = q * 3;
      if (scope.normal_cache[q3] === 0) {
        scope.normal_cache[q3 + 0] = scope.field[q - 1] - scope.field[q + 1];
        scope.normal_cache[q3 + 1] = scope.field[q - scope.yd] - scope.field[q + scope.yd];
        scope.normal_cache[q3 + 2] = scope.field[q - scope.zd] - scope.field[q + scope.zd];
      }
    }
    function polygonize(fx, fy, fz, q, isol) {
      const q1 = q + 1, qy = q + scope.yd, qz = q + scope.zd, q1y = q1 + scope.yd, q1z = q1 + scope.zd, qyz = q + scope.yd + scope.zd, q1yz = q1 + scope.yd + scope.zd;
      let cubeindex = 0;
      const field0 = scope.field[q], field1 = scope.field[q1], field2 = scope.field[qy], field3 = scope.field[q1y], field4 = scope.field[qz], field5 = scope.field[q1z], field6 = scope.field[qyz], field7 = scope.field[q1yz];
      if (field0 < isol)
        cubeindex |= 1;
      if (field1 < isol)
        cubeindex |= 2;
      if (field2 < isol)
        cubeindex |= 8;
      if (field3 < isol)
        cubeindex |= 4;
      if (field4 < isol)
        cubeindex |= 16;
      if (field5 < isol)
        cubeindex |= 32;
      if (field6 < isol)
        cubeindex |= 128;
      if (field7 < isol)
        cubeindex |= 64;
      const bits = edgeTable[cubeindex];
      if (bits === 0)
        return 0;
      const d = scope.delta, fx2 = fx + d, fy2 = fy + d, fz2 = fz + d;
      if (bits & 1) {
        compNorm(q);
        compNorm(q1);
        VIntX(q * 3, 0, isol, fx, fy, fz, field0, field1, q, q1);
      }
      if (bits & 2) {
        compNorm(q1);
        compNorm(q1y);
        VIntY(q1 * 3, 3, isol, fx2, fy, fz, field1, field3, q1, q1y);
      }
      if (bits & 4) {
        compNorm(qy);
        compNorm(q1y);
        VIntX(qy * 3, 6, isol, fx, fy2, fz, field2, field3, qy, q1y);
      }
      if (bits & 8) {
        compNorm(q);
        compNorm(qy);
        VIntY(q * 3, 9, isol, fx, fy, fz, field0, field2, q, qy);
      }
      if (bits & 16) {
        compNorm(qz);
        compNorm(q1z);
        VIntX(qz * 3, 12, isol, fx, fy, fz2, field4, field5, qz, q1z);
      }
      if (bits & 32) {
        compNorm(q1z);
        compNorm(q1yz);
        VIntY(q1z * 3, 15, isol, fx2, fy, fz2, field5, field7, q1z, q1yz);
      }
      if (bits & 64) {
        compNorm(qyz);
        compNorm(q1yz);
        VIntX(qyz * 3, 18, isol, fx, fy2, fz2, field6, field7, qyz, q1yz);
      }
      if (bits & 128) {
        compNorm(qz);
        compNorm(qyz);
        VIntY(qz * 3, 21, isol, fx, fy, fz2, field4, field6, qz, qyz);
      }
      if (bits & 256) {
        compNorm(q);
        compNorm(qz);
        VIntZ(q * 3, 24, isol, fx, fy, fz, field0, field4, q, qz);
      }
      if (bits & 512) {
        compNorm(q1);
        compNorm(q1z);
        VIntZ(q1 * 3, 27, isol, fx2, fy, fz, field1, field5, q1, q1z);
      }
      if (bits & 1024) {
        compNorm(q1y);
        compNorm(q1yz);
        VIntZ(q1y * 3, 30, isol, fx2, fy2, fz, field3, field7, q1y, q1yz);
      }
      if (bits & 2048) {
        compNorm(qy);
        compNorm(qyz);
        VIntZ(qy * 3, 33, isol, fx, fy2, fz, field2, field6, qy, qyz);
      }
      cubeindex <<= 4;
      let o1, o2, o3, numtris = 0, i2 = 0;
      while (triTable[cubeindex + i2] != -1) {
        o1 = cubeindex + i2;
        o2 = o1 + 1;
        o3 = o1 + 2;
        posnormtriv(vlist, nlist, clist, 3 * triTable[o1], 3 * triTable[o2], 3 * triTable[o3]);
        i2 += 3;
        numtris++;
      }
      return numtris;
    }
    function posnormtriv(pos, norm, colors, o1, o2, o3) {
      const c = scope.count * 3;
      scope.positionArray[c + 0] = pos[o1];
      scope.positionArray[c + 1] = pos[o1 + 1];
      scope.positionArray[c + 2] = pos[o1 + 2];
      scope.positionArray[c + 3] = pos[o2];
      scope.positionArray[c + 4] = pos[o2 + 1];
      scope.positionArray[c + 5] = pos[o2 + 2];
      scope.positionArray[c + 6] = pos[o3];
      scope.positionArray[c + 7] = pos[o3 + 1];
      scope.positionArray[c + 8] = pos[o3 + 2];
      if (scope.material.flatShading === true) {
        const nx = (norm[o1 + 0] + norm[o2 + 0] + norm[o3 + 0]) / 3;
        const ny = (norm[o1 + 1] + norm[o2 + 1] + norm[o3 + 1]) / 3;
        const nz = (norm[o1 + 2] + norm[o2 + 2] + norm[o3 + 2]) / 3;
        scope.normalArray[c + 0] = nx;
        scope.normalArray[c + 1] = ny;
        scope.normalArray[c + 2] = nz;
        scope.normalArray[c + 3] = nx;
        scope.normalArray[c + 4] = ny;
        scope.normalArray[c + 5] = nz;
        scope.normalArray[c + 6] = nx;
        scope.normalArray[c + 7] = ny;
        scope.normalArray[c + 8] = nz;
      } else {
        scope.normalArray[c + 0] = norm[o1 + 0];
        scope.normalArray[c + 1] = norm[o1 + 1];
        scope.normalArray[c + 2] = norm[o1 + 2];
        scope.normalArray[c + 3] = norm[o2 + 0];
        scope.normalArray[c + 4] = norm[o2 + 1];
        scope.normalArray[c + 5] = norm[o2 + 2];
        scope.normalArray[c + 6] = norm[o3 + 0];
        scope.normalArray[c + 7] = norm[o3 + 1];
        scope.normalArray[c + 8] = norm[o3 + 2];
      }
      if (scope.enableUvs) {
        const d = scope.count * 2;
        scope.uvArray[d + 0] = pos[o1 + 0];
        scope.uvArray[d + 1] = pos[o1 + 2];
        scope.uvArray[d + 2] = pos[o2 + 0];
        scope.uvArray[d + 3] = pos[o2 + 2];
        scope.uvArray[d + 4] = pos[o3 + 0];
        scope.uvArray[d + 5] = pos[o3 + 2];
      }
      if (scope.enableColors) {
        scope.colorArray[c + 0] = colors[o1 + 0];
        scope.colorArray[c + 1] = colors[o1 + 1];
        scope.colorArray[c + 2] = colors[o1 + 2];
        scope.colorArray[c + 3] = colors[o2 + 0];
        scope.colorArray[c + 4] = colors[o2 + 1];
        scope.colorArray[c + 5] = colors[o2 + 2];
        scope.colorArray[c + 6] = colors[o3 + 0];
        scope.colorArray[c + 7] = colors[o3 + 1];
        scope.colorArray[c + 8] = colors[o3 + 2];
      }
      scope.count += 3;
    }
    this.addBall = function(ballx, bally, ballz, strength, subtract, colors) {
      const sign2 = Math.sign(strength);
      strength = Math.abs(strength);
      const userDefineColor = !(colors === void 0 || colors === null);
      let ballColor = new Color(ballx, bally, ballz);
      if (userDefineColor) {
        try {
          ballColor = colors instanceof Color ? colors : Array.isArray(colors) ? new Color(Math.min(Math.abs(colors[0]), 1), Math.min(Math.abs(colors[1]), 1), Math.min(Math.abs(colors[2]), 1)) : new Color(colors);
        } catch (err) {
          ballColor = new Color(ballx, bally, ballz);
        }
      }
      const radius = this.size * Math.sqrt(strength / subtract), zs = ballz * this.size, ys = bally * this.size, xs = ballx * this.size;
      let min_z = Math.floor(zs - radius);
      if (min_z < 1)
        min_z = 1;
      let max_z = Math.floor(zs + radius);
      if (max_z > this.size - 1)
        max_z = this.size - 1;
      let min_y = Math.floor(ys - radius);
      if (min_y < 1)
        min_y = 1;
      let max_y = Math.floor(ys + radius);
      if (max_y > this.size - 1)
        max_y = this.size - 1;
      let min_x = Math.floor(xs - radius);
      if (min_x < 1)
        min_x = 1;
      let max_x = Math.floor(xs + radius);
      if (max_x > this.size - 1)
        max_x = this.size - 1;
      let x, y, z, y_offset, z_offset, fx, fy, fz, fz2, fy2, val;
      for (z = min_z; z < max_z; z++) {
        z_offset = this.size2 * z;
        fz = z / this.size - ballz;
        fz2 = fz * fz;
        for (y = min_y; y < max_y; y++) {
          y_offset = z_offset + this.size * y;
          fy = y / this.size - bally;
          fy2 = fy * fy;
          for (x = min_x; x < max_x; x++) {
            fx = x / this.size - ballx;
            val = strength / (1e-6 + fx * fx + fy2 + fz2) - subtract;
            if (val > 0) {
              this.field[y_offset + x] += val * sign2;
              const ratio = Math.sqrt((x - xs) * (x - xs) + (y - ys) * (y - ys) + (z - zs) * (z - zs)) / radius;
              const contrib = 1 - ratio * ratio * ratio * (ratio * (ratio * 6 - 15) + 10);
              this.palette[(y_offset + x) * 3 + 0] += ballColor.r * contrib;
              this.palette[(y_offset + x) * 3 + 1] += ballColor.g * contrib;
              this.palette[(y_offset + x) * 3 + 2] += ballColor.b * contrib;
            }
          }
        }
      }
    };
    this.addPlaneX = function(strength, subtract) {
      const size2 = this.size, yd = this.yd, zd = this.zd, field = this.field;
      let x, y, z, xx, val, xdiv, cxy, dist = size2 * Math.sqrt(strength / subtract);
      if (dist > size2)
        dist = size2;
      for (x = 0; x < dist; x++) {
        xdiv = x / size2;
        xx = xdiv * xdiv;
        val = strength / (1e-4 + xx) - subtract;
        if (val > 0) {
          for (y = 0; y < size2; y++) {
            cxy = x + y * yd;
            for (z = 0; z < size2; z++) {
              field[zd * z + cxy] += val;
            }
          }
        }
      }
    };
    this.addPlaneY = function(strength, subtract) {
      const size2 = this.size, yd = this.yd, zd = this.zd, field = this.field;
      let x, y, z, yy, val, ydiv, cy, cxy, dist = size2 * Math.sqrt(strength / subtract);
      if (dist > size2)
        dist = size2;
      for (y = 0; y < dist; y++) {
        ydiv = y / size2;
        yy = ydiv * ydiv;
        val = strength / (1e-4 + yy) - subtract;
        if (val > 0) {
          cy = y * yd;
          for (x = 0; x < size2; x++) {
            cxy = cy + x;
            for (z = 0; z < size2; z++)
              field[zd * z + cxy] += val;
          }
        }
      }
    };
    this.addPlaneZ = function(strength, subtract) {
      const size2 = this.size, yd = this.yd, zd = this.zd, field = this.field;
      let x, y, z, zz, val, zdiv, cz, cyz, dist = size2 * Math.sqrt(strength / subtract);
      if (dist > size2)
        dist = size2;
      for (z = 0; z < dist; z++) {
        zdiv = z / size2;
        zz = zdiv * zdiv;
        val = strength / (1e-4 + zz) - subtract;
        if (val > 0) {
          cz = zd * z;
          for (y = 0; y < size2; y++) {
            cyz = cz + y * yd;
            for (x = 0; x < size2; x++)
              field[cyz + x] += val;
          }
        }
      }
    };
    this.setCell = function(x, y, z, value) {
      const index = this.size2 * z + this.size * y + x;
      this.field[index] = value;
    };
    this.getCell = function(x, y, z) {
      const index = this.size2 * z + this.size * y + x;
      return this.field[index];
    };
    this.blur = function(intensity = 1) {
      const field = this.field;
      const fieldCopy = field.slice();
      const size2 = this.size;
      const size22 = this.size2;
      for (let x = 0; x < size2; x++) {
        for (let y = 0; y < size2; y++) {
          for (let z = 0; z < size2; z++) {
            const index = size22 * z + size2 * y + x;
            let val = fieldCopy[index];
            let count = 1;
            for (let x2 = -1; x2 <= 1; x2 += 2) {
              const x3 = x2 + x;
              if (x3 < 0 || x3 >= size2)
                continue;
              for (let y2 = -1; y2 <= 1; y2 += 2) {
                const y3 = y2 + y;
                if (y3 < 0 || y3 >= size2)
                  continue;
                for (let z2 = -1; z2 <= 1; z2 += 2) {
                  const z3 = z2 + z;
                  if (z3 < 0 || z3 >= size2)
                    continue;
                  const index2 = size22 * z3 + size2 * y3 + x3;
                  const val2 = fieldCopy[index2];
                  count++;
                  val += intensity * (val2 - val) / count;
                }
              }
            }
            field[index] = val;
          }
        }
      }
    };
    this.reset = function() {
      for (let i2 = 0; i2 < this.size3; i2++) {
        this.normal_cache[i2 * 3] = 0;
        this.field[i2] = 0;
        this.palette[i2 * 3] = this.palette[i2 * 3 + 1] = this.palette[i2 * 3 + 2] = 0;
      }
    };
    this.onBeforeRender = function() {
      this.count = 0;
      const smin2 = this.size - 2;
      for (let z = 1; z < smin2; z++) {
        const z_offset = this.size2 * z;
        const fz = (z - this.halfsize) / this.halfsize;
        for (let y = 1; y < smin2; y++) {
          const y_offset = z_offset + this.size * y;
          const fy = (y - this.halfsize) / this.halfsize;
          for (let x = 1; x < smin2; x++) {
            const fx = (x - this.halfsize) / this.halfsize;
            const q = y_offset + x;
            polygonize(fx, fy, fz, q, this.isolation);
          }
        }
      }
      for (let i2 = this.count * 3; i2 < this.positionArray.length; i2++) {
        this.positionArray[i2] = 0;
      }
      geometry.getAttribute("position").needsUpdate = true;
      geometry.getAttribute("normal").needsUpdate = true;
      if (this.enableUvs)
        geometry.getAttribute("uv").needsUpdate = true;
      if (this.enableColors)
        geometry.getAttribute("color").needsUpdate = true;
      if (this.count / 3 > maxPolyCount) {
        console.warn("MarchingCubes: Geometry buffers too small for rendering. Please create an instance with a higher poly count.");
      }
    };
    this.init(resolution);
  }
};
MarchingCubes.prototype.isMarchingCubes = true;
var edgeTable = new Int32Array([0, 265, 515, 778, 1030, 1295, 1541, 1804, 2060, 2309, 2575, 2822, 3082, 3331, 3593, 3840, 400, 153, 915, 666, 1430, 1183, 1941, 1692, 2460, 2197, 2975, 2710, 3482, 3219, 3993, 3728, 560, 825, 51, 314, 1590, 1855, 1077, 1340, 2620, 2869, 2111, 2358, 3642, 3891, 3129, 3376, 928, 681, 419, 170, 1958, 1711, 1445, 1196, 2988, 2725, 2479, 2214, 4010, 3747, 3497, 3232, 1120, 1385, 1635, 1898, 102, 367, 613, 876, 3180, 3429, 3695, 3942, 2154, 2403, 2665, 2912, 1520, 1273, 2035, 1786, 502, 255, 1013, 764, 3580, 3317, 4095, 3830, 2554, 2291, 3065, 2800, 1616, 1881, 1107, 1370, 598, 863, 85, 348, 3676, 3925, 3167, 3414, 2650, 2899, 2137, 2384, 1984, 1737, 1475, 1226, 966, 719, 453, 204, 4044, 3781, 3535, 3270, 3018, 2755, 2505, 2240, 2240, 2505, 2755, 3018, 3270, 3535, 3781, 4044, 204, 453, 719, 966, 1226, 1475, 1737, 1984, 2384, 2137, 2899, 2650, 3414, 3167, 3925, 3676, 348, 85, 863, 598, 1370, 1107, 1881, 1616, 2800, 3065, 2291, 2554, 3830, 4095, 3317, 3580, 764, 1013, 255, 502, 1786, 2035, 1273, 1520, 2912, 2665, 2403, 2154, 3942, 3695, 3429, 3180, 876, 613, 367, 102, 1898, 1635, 1385, 1120, 3232, 3497, 3747, 4010, 2214, 2479, 2725, 2988, 1196, 1445, 1711, 1958, 170, 419, 681, 928, 3376, 3129, 3891, 3642, 2358, 2111, 2869, 2620, 1340, 1077, 1855, 1590, 314, 51, 825, 560, 3728, 3993, 3219, 3482, 2710, 2975, 2197, 2460, 1692, 1941, 1183, 1430, 666, 915, 153, 400, 3840, 3593, 3331, 3082, 2822, 2575, 2309, 2060, 1804, 1541, 1295, 1030, 778, 515, 265, 0]);
var triTable = new Int32Array([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1, 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1, 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);

// node_modules/@react-three/rapier/node_modules/three-stdlib/math/SimplexNoise.js
var SimplexNoise = class {
  // To remove the need for index wrapping, double the permutation table length
  // A lookup table to traverse the simplex around a given point in 4D.
  // Details can be found where this table is used, in the 4D noise method.
  /**
   * You can pass in a random number generator object if you like.
   * It is assumed to have a random() method.
   */
  constructor(r = Math) {
    _defineProperty(this, "grad3", [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]]);
    _defineProperty(this, "grad4", [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]]);
    _defineProperty(this, "p", []);
    _defineProperty(this, "perm", []);
    _defineProperty(this, "simplex", [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]]);
    _defineProperty(this, "dot", (g, x, y) => {
      return g[0] * x + g[1] * y;
    });
    _defineProperty(this, "dot3", (g, x, y, z) => {
      return g[0] * x + g[1] * y + g[2] * z;
    });
    _defineProperty(this, "dot4", (g, x, y, z, w) => {
      return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
    });
    _defineProperty(this, "noise", (xin, yin) => {
      let n0;
      let n1;
      let n2;
      const F2 = 0.5 * (Math.sqrt(3) - 1);
      const s = (xin + yin) * F2;
      const i2 = Math.floor(xin + s);
      const j2 = Math.floor(yin + s);
      const G2 = (3 - Math.sqrt(3)) / 6;
      const t2 = (i2 + j2) * G2;
      const X0 = i2 - t2;
      const Y0 = j2 - t2;
      const x0 = xin - X0;
      const y0 = yin - Y0;
      let i1 = 0;
      let j1 = 1;
      if (x0 > y0) {
        i1 = 1;
        j1 = 0;
      }
      const x1 = x0 - i1 + G2;
      const y1 = y0 - j1 + G2;
      const x2 = x0 - 1 + 2 * G2;
      const y2 = y0 - 1 + 2 * G2;
      const ii = i2 & 255;
      const jj = j2 & 255;
      const gi0 = this.perm[ii + this.perm[jj]] % 12;
      const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
      const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
      let t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);
      }
      let t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
      }
      let t22 = 0.5 - x2 * x2 - y2 * y2;
      if (t22 < 0) {
        n2 = 0;
      } else {
        t22 *= t22;
        n2 = t22 * t22 * this.dot(this.grad3[gi2], x2, y2);
      }
      return 70 * (n0 + n1 + n2);
    });
    _defineProperty(this, "noise3d", (xin, yin, zin) => {
      let n0;
      let n1;
      let n2;
      let n3;
      const F3 = 1 / 3;
      const s = (xin + yin + zin) * F3;
      const i2 = Math.floor(xin + s);
      const j2 = Math.floor(yin + s);
      const k = Math.floor(zin + s);
      const G3 = 1 / 6;
      const t2 = (i2 + j2 + k) * G3;
      const X0 = i2 - t2;
      const Y0 = j2 - t2;
      const Z0 = k - t2;
      const x0 = xin - X0;
      const y0 = yin - Y0;
      const z0 = zin - Z0;
      let i1;
      let j1;
      let k1;
      let i22;
      let j22;
      let k2;
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i22 = 1;
          j22 = 1;
          k2 = 0;
        } else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i22 = 1;
          j22 = 0;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i22 = 1;
          j22 = 0;
          k2 = 1;
        }
      } else {
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i22 = 0;
          j22 = 1;
          k2 = 1;
        } else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i22 = 0;
          j22 = 1;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i22 = 1;
          j22 = 1;
          k2 = 0;
        }
      }
      const x1 = x0 - i1 + G3;
      const y1 = y0 - j1 + G3;
      const z1 = z0 - k1 + G3;
      const x2 = x0 - i22 + 2 * G3;
      const y2 = y0 - j22 + 2 * G3;
      const z2 = z0 - k2 + 2 * G3;
      const x3 = x0 - 1 + 3 * G3;
      const y3 = y0 - 1 + 3 * G3;
      const z3 = z0 - 1 + 3 * G3;
      const ii = i2 & 255;
      const jj = j2 & 255;
      const kk = k & 255;
      const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
      const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
      const gi2 = this.perm[ii + i22 + this.perm[jj + j22 + this.perm[kk + k2]]] % 12;
      const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);
      }
      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);
      }
      let t22 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (t22 < 0) {
        n2 = 0;
      } else {
        t22 *= t22;
        n2 = t22 * t22 * this.dot3(this.grad3[gi2], x2, y2, z2);
      }
      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (t3 < 0) {
        n3 = 0;
      } else {
        t3 *= t3;
        n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);
      }
      return 32 * (n0 + n1 + n2 + n3);
    });
    _defineProperty(this, "noise4d", (x, y, z, w) => {
      const grad4 = this.grad4;
      const simplex = this.simplex;
      const perm = this.perm;
      const F4 = (Math.sqrt(5) - 1) / 4;
      const G4 = (5 - Math.sqrt(5)) / 20;
      let n0;
      let n1;
      let n2;
      let n3;
      let n4;
      const s = (x + y + z + w) * F4;
      const i2 = Math.floor(x + s);
      const j2 = Math.floor(y + s);
      const k = Math.floor(z + s);
      const l = Math.floor(w + s);
      const t2 = (i2 + j2 + k + l) * G4;
      const X0 = i2 - t2;
      const Y0 = j2 - t2;
      const Z0 = k - t2;
      const W0 = l - t2;
      const x0 = x - X0;
      const y0 = y - Y0;
      const z0 = z - Z0;
      const w0 = w - W0;
      const c1 = x0 > y0 ? 32 : 0;
      const c2 = x0 > z0 ? 16 : 0;
      const c3 = y0 > z0 ? 8 : 0;
      const c4 = x0 > w0 ? 4 : 0;
      const c5 = y0 > w0 ? 2 : 0;
      const c6 = z0 > w0 ? 1 : 0;
      const c = c1 + c2 + c3 + c4 + c5 + c6;
      let i1;
      let j1;
      let k1;
      let l1;
      let i22;
      let j22;
      let k2;
      let l2;
      let i3;
      let j3;
      let k3;
      let l3;
      i1 = simplex[c][0] >= 3 ? 1 : 0;
      j1 = simplex[c][1] >= 3 ? 1 : 0;
      k1 = simplex[c][2] >= 3 ? 1 : 0;
      l1 = simplex[c][3] >= 3 ? 1 : 0;
      i22 = simplex[c][0] >= 2 ? 1 : 0;
      j22 = simplex[c][1] >= 2 ? 1 : 0;
      k2 = simplex[c][2] >= 2 ? 1 : 0;
      l2 = simplex[c][3] >= 2 ? 1 : 0;
      i3 = simplex[c][0] >= 1 ? 1 : 0;
      j3 = simplex[c][1] >= 1 ? 1 : 0;
      k3 = simplex[c][2] >= 1 ? 1 : 0;
      l3 = simplex[c][3] >= 1 ? 1 : 0;
      const x1 = x0 - i1 + G4;
      const y1 = y0 - j1 + G4;
      const z1 = z0 - k1 + G4;
      const w1 = w0 - l1 + G4;
      const x2 = x0 - i22 + 2 * G4;
      const y2 = y0 - j22 + 2 * G4;
      const z2 = z0 - k2 + 2 * G4;
      const w2 = w0 - l2 + 2 * G4;
      const x3 = x0 - i3 + 3 * G4;
      const y3 = y0 - j3 + 3 * G4;
      const z3 = z0 - k3 + 3 * G4;
      const w3 = w0 - l3 + 3 * G4;
      const x4 = x0 - 1 + 4 * G4;
      const y4 = y0 - 1 + 4 * G4;
      const z4 = z0 - 1 + 4 * G4;
      const w4 = w0 - 1 + 4 * G4;
      const ii = i2 & 255;
      const jj = j2 & 255;
      const kk = k & 255;
      const ll = l & 255;
      const gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
      const gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
      const gi2 = perm[ii + i22 + perm[jj + j22 + perm[kk + k2 + perm[ll + l2]]]] % 32;
      const gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
      const gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;
      let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
      if (t0 < 0) {
        n0 = 0;
      } else {
        t0 *= t0;
        n0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);
      }
      let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
      if (t1 < 0) {
        n1 = 0;
      } else {
        t1 *= t1;
        n1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);
      }
      let t22 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
      if (t22 < 0) {
        n2 = 0;
      } else {
        t22 *= t22;
        n2 = t22 * t22 * this.dot4(grad4[gi2], x2, y2, z2, w2);
      }
      let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
      if (t3 < 0) {
        n3 = 0;
      } else {
        t3 *= t3;
        n3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);
      }
      let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
      if (t4 < 0) {
        n4 = 0;
      } else {
        t4 *= t4;
        n4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);
      }
      return 27 * (n0 + n1 + n2 + n3 + n4);
    });
    for (let i2 = 0; i2 < 256; i2++) {
      this.p[i2] = Math.floor(r.random() * 256);
    }
    for (let i2 = 0; i2 < 512; i2++) {
      this.perm[i2] = this.p[i2 & 255];
    }
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/geometries/LightningStrike.js
var LightningStrike = class extends BufferGeometry {
  constructor(rayParameters) {
    super();
    this.type = "LightningStrike";
    rayParameters = rayParameters || {};
    this.init(LightningStrike.copyParameters(rayParameters, rayParameters));
    this.createMesh();
  }
  update(time) {
    if (this.isStatic)
      return;
    if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {
      this.updateMesh(time);
      if (time < this.subrays[0].endPropagationTime) {
        this.state = LightningStrike.RAY_PROPAGATING;
      } else if (time > this.subrays[0].beginVanishingTime) {
        this.state = LightningStrike.RAY_VANISHING;
      } else {
        this.state = LightningStrike.RAY_STEADY;
      }
      this.visible = true;
    } else {
      this.visible = false;
      if (time < this.rayParameters.birthTime) {
        this.state = LightningStrike.RAY_UNBORN;
      } else {
        this.state = LightningStrike.RAY_EXTINGUISHED;
      }
    }
  }
  init(rayParameters) {
    this.rayParameters = rayParameters;
    this.maxIterations = rayParameters.maxIterations !== void 0 ? Math.floor(rayParameters.maxIterations) : 9;
    rayParameters.maxIterations = this.maxIterations;
    this.isStatic = rayParameters.isStatic !== void 0 ? rayParameters.isStatic : false;
    rayParameters.isStatic = this.isStatic;
    this.ramification = rayParameters.ramification !== void 0 ? Math.floor(rayParameters.ramification) : 5;
    rayParameters.ramification = this.ramification;
    this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== void 0 ? Math.floor(rayParameters.maxSubrayRecursion) : 3;
    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;
    this.recursionProbability = rayParameters.recursionProbability !== void 0 ? rayParameters.recursionProbability : 0.6;
    rayParameters.recursionProbability = this.recursionProbability;
    this.generateUVs = rayParameters.generateUVs !== void 0 ? rayParameters.generateUVs : false;
    rayParameters.generateUVs = this.generateUVs;
    if (rayParameters.randomGenerator !== void 0) {
      this.randomGenerator = rayParameters.randomGenerator;
      this.seedGenerator = rayParameters.randomGenerator;
      if (rayParameters.noiseSeed !== void 0) {
        this.seedGenerator.setSeed(rayParameters.noiseSeed);
      }
    } else {
      this.randomGenerator = LightningStrike.createRandomGenerator();
      this.seedGenerator = Math;
    }
    if (rayParameters.onDecideSubrayCreation !== void 0) {
      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;
    } else {
      this.createDefaultSubrayCreationCallbacks();
      if (rayParameters.onSubrayCreation !== void 0) {
        this.onSubrayCreation = rayParameters.onSubrayCreation;
      }
    }
    this.state = LightningStrike.RAY_INITIALIZED;
    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));
    rayParameters.maxSubrays = this.maxSubrays;
    this.maxRaySegments = 2 * (1 << this.maxIterations);
    this.subrays = [];
    for (let i2 = 0; i2 < this.maxSubrays; i2++) {
      this.subrays.push(this.createSubray());
    }
    this.raySegments = [];
    for (let i2 = 0; i2 < this.maxRaySegments; i2++) {
      this.raySegments.push(this.createSegment());
    }
    this.time = 0;
    this.timeFraction = 0;
    this.currentSegmentCallback = null;
    this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;
    this.numSubrays = 0;
    this.currentSubray = null;
    this.currentSegmentIndex = 0;
    this.isInitialSegment = false;
    this.subrayProbability = 0;
    this.currentVertex = 0;
    this.currentIndex = 0;
    this.currentCoordinate = 0;
    this.currentUVCoordinate = 0;
    this.vertices = null;
    this.uvs = null;
    this.indices = null;
    this.positionAttribute = null;
    this.uvsAttribute = null;
    this.simplexX = new SimplexNoise(this.seedGenerator);
    this.simplexY = new SimplexNoise(this.seedGenerator);
    this.simplexZ = new SimplexNoise(this.seedGenerator);
    this.forwards = new Vector3();
    this.forwardsFill = new Vector3();
    this.side = new Vector3();
    this.down = new Vector3();
    this.middlePos = new Vector3();
    this.middleLinPos = new Vector3();
    this.newPos = new Vector3();
    this.vPos = new Vector3();
    this.cross1 = new Vector3();
  }
  createMesh() {
    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;
    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;
    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;
    this.vertices = new Float32Array(maxVerts * 3);
    this.indices = new Uint32Array(maxIndices);
    if (this.generateUVs) {
      this.uvs = new Float32Array(maxVerts * 2);
    }
    this.fillMesh(0);
    this.setIndex(new Uint32BufferAttribute(this.indices, 1));
    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);
    this.setAttribute("position", this.positionAttribute);
    if (this.generateUVs) {
      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);
      this.setAttribute("uv", this.uvsAttribute);
    }
    if (!this.isStatic) {
      this.index.usage = DynamicDrawUsage;
      this.positionAttribute.usage = DynamicDrawUsage;
      if (this.generateUVs) {
        this.uvsAttribute.usage = DynamicDrawUsage;
      }
    }
    this.vertices = this.positionAttribute.array;
    this.indices = this.index.array;
    if (this.generateUVs) {
      this.uvs = this.uvsAttribute.array;
    }
  }
  updateMesh(time) {
    this.fillMesh(time);
    this.drawRange.count = this.currentIndex;
    this.index.needsUpdate = true;
    this.positionAttribute.needsUpdate = true;
    if (this.generateUVs) {
      this.uvsAttribute.needsUpdate = true;
    }
  }
  fillMesh(time) {
    const scope = this;
    this.currentVertex = 0;
    this.currentIndex = 0;
    this.currentCoordinate = 0;
    this.currentUVCoordinate = 0;
    this.fractalRay(time, function fillVertices(segment) {
      const subray = scope.currentSubray;
      if (time < subray.birthTime) {
        return;
      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {
        scope.createPrism(segment);
        scope.onDecideSubrayCreation(segment, scope);
      } else if (time < subray.endPropagationTime) {
        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {
          scope.createPrism(segment);
          scope.onDecideSubrayCreation(segment, scope);
        }
      } else if (time < subray.beginVanishingTime) {
        scope.createPrism(segment);
        scope.onDecideSubrayCreation(segment, scope);
      } else {
        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {
          scope.createPrism(segment);
        }
        scope.onDecideSubrayCreation(segment, scope);
      }
    });
  }
  addNewSubray() {
    return this.subrays[this.numSubrays++];
  }
  initSubray(subray, rayParameters) {
    subray.pos0.copy(rayParameters.sourceOffset);
    subray.pos1.copy(rayParameters.destOffset);
    subray.up0.copy(rayParameters.up0);
    subray.up1.copy(rayParameters.up1);
    subray.radius0 = rayParameters.radius0;
    subray.radius1 = rayParameters.radius1;
    subray.birthTime = rayParameters.birthTime;
    subray.deathTime = rayParameters.deathTime;
    subray.timeScale = rayParameters.timeScale;
    subray.roughness = rayParameters.roughness;
    subray.straightness = rayParameters.straightness;
    subray.propagationTimeFactor = rayParameters.propagationTimeFactor;
    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;
    subray.maxIterations = this.maxIterations;
    subray.seed = rayParameters.noiseSeed !== void 0 ? rayParameters.noiseSeed : 0;
    subray.recursion = 0;
  }
  fractalRay(time, segmentCallback) {
    this.time = time;
    this.currentSegmentCallback = segmentCallback;
    this.numSubrays = 0;
    this.initSubray(this.addNewSubray(), this.rayParameters);
    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {
      const subray = this.subrays[subrayIndex];
      this.currentSubray = subray;
      this.randomGenerator.setSeed(subray.seed);
      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);
      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);
      const random1 = this.randomGenerator.random;
      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);
      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);
      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);
      this.currentSegmentIndex = 0;
      this.isInitialSegment = true;
      const segment = this.getNewSegment();
      segment.iteration = 0;
      segment.pos0.copy(subray.pos0);
      segment.pos1.copy(subray.pos1);
      segment.linPos0.copy(subray.linPos0);
      segment.linPos1.copy(subray.linPos1);
      segment.up0.copy(subray.up0);
      segment.up1.copy(subray.up1);
      segment.radius0 = subray.radius0;
      segment.radius1 = subray.radius1;
      segment.fraction0 = 0;
      segment.fraction1 = 1;
      segment.positionVariationFactor = 1 - subray.straightness;
      this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);
      this.fractalRayRecursive(segment);
    }
    this.currentSegmentCallback = null;
    this.currentSubray = null;
  }
  fractalRayRecursive(segment) {
    if (segment.iteration >= this.currentSubray.maxIterations) {
      this.currentSegmentCallback(segment);
      return;
    }
    this.forwards.subVectors(segment.pos1, segment.pos0);
    let lForwards = this.forwards.length();
    if (lForwards < 1e-6) {
      this.forwards.set(0, 0, 0.01);
      lForwards = this.forwards.length();
    }
    const middleRadius = (segment.radius0 + segment.radius1) * 0.5;
    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;
    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);
    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);
    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);
    const p = this.middleLinPos;
    this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));
    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);
    this.newPos.add(this.middlePos);
    const newSegment1 = this.getNewSegment();
    newSegment1.pos0.copy(segment.pos0);
    newSegment1.pos1.copy(this.newPos);
    newSegment1.linPos0.copy(segment.linPos0);
    newSegment1.linPos1.copy(this.middleLinPos);
    newSegment1.up0.copy(segment.up0);
    newSegment1.up1.copy(segment.up1);
    newSegment1.radius0 = segment.radius0;
    newSegment1.radius1 = middleRadius;
    newSegment1.fraction0 = segment.fraction0;
    newSegment1.fraction1 = middleFraction;
    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;
    newSegment1.iteration = segment.iteration + 1;
    const newSegment2 = this.getNewSegment();
    newSegment2.pos0.copy(this.newPos);
    newSegment2.pos1.copy(segment.pos1);
    newSegment2.linPos0.copy(this.middleLinPos);
    newSegment2.linPos1.copy(segment.linPos1);
    this.cross1.crossVectors(segment.up0, this.forwards.normalize());
    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();
    newSegment2.up1.copy(segment.up1);
    newSegment2.radius0 = middleRadius;
    newSegment2.radius1 = segment.radius1;
    newSegment2.fraction0 = middleFraction;
    newSegment2.fraction1 = segment.fraction1;
    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;
    newSegment2.iteration = segment.iteration + 1;
    this.fractalRayRecursive(newSegment1);
    this.fractalRayRecursive(newSegment2);
  }
  createPrism(segment) {
    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();
    if (this.isInitialSegment) {
      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);
      this.isInitialSegment = false;
    }
    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);
    this.createPrismFaces();
  }
  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {
    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);
    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);
    const p = this.vPos;
    const v = this.vertices;
    p.copy(pos).sub(this.side).add(this.down);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    p.copy(pos).add(this.side).add(this.down);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    p.copy(up).multiplyScalar(radius).add(pos);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    this.currentVertex += 3;
  }
  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {
    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);
    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);
    const p = this.vPos;
    const v = this.vertices;
    const uv2 = this.uvs;
    p.copy(pos).sub(this.side).add(this.down);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    uv2[this.currentUVCoordinate++] = u;
    uv2[this.currentUVCoordinate++] = 0;
    p.copy(pos).add(this.side).add(this.down);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    uv2[this.currentUVCoordinate++] = u;
    uv2[this.currentUVCoordinate++] = 0.5;
    p.copy(up).multiplyScalar(radius).add(pos);
    v[this.currentCoordinate++] = p.x;
    v[this.currentCoordinate++] = p.y;
    v[this.currentCoordinate++] = p.z;
    uv2[this.currentUVCoordinate++] = u;
    uv2[this.currentUVCoordinate++] = 1;
    this.currentVertex += 3;
  }
  createPrismFaces(vertex) {
    const indices = this.indices;
    var vertex = this.currentVertex - 6;
    indices[this.currentIndex++] = vertex + 1;
    indices[this.currentIndex++] = vertex + 2;
    indices[this.currentIndex++] = vertex + 5;
    indices[this.currentIndex++] = vertex + 1;
    indices[this.currentIndex++] = vertex + 5;
    indices[this.currentIndex++] = vertex + 4;
    indices[this.currentIndex++] = vertex + 0;
    indices[this.currentIndex++] = vertex + 1;
    indices[this.currentIndex++] = vertex + 4;
    indices[this.currentIndex++] = vertex + 0;
    indices[this.currentIndex++] = vertex + 4;
    indices[this.currentIndex++] = vertex + 3;
    indices[this.currentIndex++] = vertex + 2;
    indices[this.currentIndex++] = vertex + 0;
    indices[this.currentIndex++] = vertex + 3;
    indices[this.currentIndex++] = vertex + 2;
    indices[this.currentIndex++] = vertex + 3;
    indices[this.currentIndex++] = vertex + 5;
  }
  createDefaultSubrayCreationCallbacks() {
    const random1 = this.randomGenerator.random;
    this.onDecideSubrayCreation = (segment, lightningStrike) => {
      const subray = lightningStrike.currentSubray;
      const period = lightningStrike.rayParameters.subrayPeriod;
      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;
      const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;
      const phase = lightningStrike.time - phase0;
      const currentCycle = Math.floor(phase / period);
      const childSubraySeed = random1() * (currentCycle + 1);
      const isActive = phase % period <= dutyCycle * period;
      let probability = 0;
      if (isActive) {
        probability = lightningStrike.subrayProbability;
      }
      if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {
        const childSubray = lightningStrike.addNewSubray();
        const parentSeed = lightningStrike.randomGenerator.getSeed();
        childSubray.seed = childSubraySeed;
        lightningStrike.randomGenerator.setSeed(childSubraySeed);
        childSubray.recursion = subray.recursion + 1;
        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);
        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);
        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);
        childSubray.up0.copy(subray.up0);
        childSubray.up1.copy(subray.up1);
        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;
        childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);
        childSubray.birthTime = phase0 + currentCycle * period;
        childSubray.deathTime = childSubray.birthTime + period * dutyCycle;
        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {
          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);
          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);
        }
        childSubray.timeScale = subray.timeScale * 2;
        childSubray.roughness = subray.roughness;
        childSubray.straightness = subray.straightness;
        childSubray.propagationTimeFactor = subray.propagationTimeFactor;
        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;
        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);
        lightningStrike.randomGenerator.setSeed(parentSeed);
      }
    };
    const vec1Pos = new Vector3();
    const vec2Forward = new Vector3();
    const vec3Side = new Vector3();
    const vec4Up = new Vector3();
    this.onSubrayCreation = (segment, parentSubray, childSubray, lightningStrike) => {
      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);
    };
    this.subrayConePosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {
      childSubray.pos0.copy(segment.pos0);
      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);
      vec2Forward.copy(vec1Pos).normalize();
      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));
      const length2 = vec1Pos.length();
      vec3Side.crossVectors(parentSubray.up0, vec2Forward);
      const angle = 2 * Math.PI * random1();
      vec3Side.multiplyScalar(Math.cos(angle));
      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));
      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length2 * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);
    };
    this.subrayCylinderPosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {
      childSubray.pos0.copy(segment.pos0);
      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);
      vec2Forward.copy(vec1Pos).normalize();
      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));
      const length2 = vec1Pos.length();
      vec3Side.crossVectors(parentSubray.up0, vec2Forward);
      const angle = 2 * Math.PI * random1();
      vec3Side.multiplyScalar(Math.cos(angle));
      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));
      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length2 * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);
    };
  }
  createSubray() {
    return {
      seed: 0,
      maxIterations: 0,
      recursion: 0,
      pos0: new Vector3(),
      pos1: new Vector3(),
      linPos0: new Vector3(),
      linPos1: new Vector3(),
      up0: new Vector3(),
      up1: new Vector3(),
      radius0: 0,
      radius1: 0,
      birthTime: 0,
      deathTime: 0,
      timeScale: 0,
      roughness: 0,
      straightness: 0,
      propagationTimeFactor: 0,
      vanishingTimeFactor: 0,
      endPropagationTime: 0,
      beginVanishingTime: 0
    };
  }
  createSegment() {
    return {
      iteration: 0,
      pos0: new Vector3(),
      pos1: new Vector3(),
      linPos0: new Vector3(),
      linPos1: new Vector3(),
      up0: new Vector3(),
      up1: new Vector3(),
      radius0: 0,
      radius1: 0,
      fraction0: 0,
      fraction1: 0,
      positionVariationFactor: 0
    };
  }
  getNewSegment() {
    return this.raySegments[this.currentSegmentIndex++];
  }
  copy(source) {
    super.copy(source);
    this.init(LightningStrike.copyParameters({}, source.rayParameters));
    return this;
  }
  clone() {
    return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters));
  }
};
LightningStrike.prototype.isLightningStrike = true;
LightningStrike.RAY_INITIALIZED = 0;
LightningStrike.RAY_UNBORN = 1;
LightningStrike.RAY_PROPAGATING = 2;
LightningStrike.RAY_STEADY = 3;
LightningStrike.RAY_VANISHING = 4;
LightningStrike.RAY_EXTINGUISHED = 5;
LightningStrike.COS30DEG = Math.cos(30 * Math.PI / 180);
LightningStrike.SIN30DEG = Math.sin(30 * Math.PI / 180);
LightningStrike.createRandomGenerator = () => {
  const numSeeds = 2053;
  const seeds = [];
  for (let i2 = 0; i2 < numSeeds; i2++) {
    seeds.push(Math.random());
  }
  const generator = {
    currentSeed: 0,
    random: function() {
      const value = seeds[generator.currentSeed];
      generator.currentSeed = (generator.currentSeed + 1) % numSeeds;
      return value;
    },
    getSeed: function() {
      return generator.currentSeed / numSeeds;
    },
    setSeed: function(seed) {
      generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;
    }
  };
  return generator;
};
LightningStrike.copyParameters = (dest, source) => {
  source = source || {};
  dest = dest || {};
  const vecCopy = (v) => {
    if (source === dest) {
      return v;
    } else {
      return v.clone();
    }
  };
  dest.sourceOffset = source.sourceOffset !== void 0 ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== void 0 ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== void 0 ? source.timeScale : 1, dest.roughness = source.roughness !== void 0 ? source.roughness : 0.9, dest.straightness = source.straightness !== void 0 ? source.straightness : 0.7, dest.up0 = source.up0 !== void 0 ? vecCopy(source.up0) : new Vector3(0, 0, 1);
  dest.up1 = source.up1 !== void 0 ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== void 0 ? source.radius0 : 1, dest.radius1 = source.radius1 !== void 0 ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== void 0 ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== void 0 ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== void 0 ? source.minRadius : 0.2, // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:
  dest.isEternal = source.isEternal !== void 0 ? source.isEternal : source.birthTime === void 0 || source.deathTime === void 0, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== void 0 ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== void 0 ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== void 0 ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== void 0 ? source.subrayDutyCycle : 0.6;
  dest.maxIterations = source.maxIterations !== void 0 ? source.maxIterations : 9;
  dest.isStatic = source.isStatic !== void 0 ? source.isStatic : false;
  dest.ramification = source.ramification !== void 0 ? source.ramification : 5;
  dest.maxSubrayRecursion = source.maxSubrayRecursion !== void 0 ? source.maxSubrayRecursion : 3;
  dest.recursionProbability = source.recursionProbability !== void 0 ? source.recursionProbability : 0.6;
  dest.generateUVs = source.generateUVs !== void 0 ? source.generateUVs : false;
  dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;
  return dest;
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/objects/LightningStorm.js
var LightningStorm = class extends Object3D {
  constructor(stormParams = {}) {
    super();
    this.stormParams = stormParams;
    stormParams.size = stormParams.size !== void 0 ? stormParams.size : 1e3;
    stormParams.minHeight = stormParams.minHeight !== void 0 ? stormParams.minHeight : 80;
    stormParams.maxHeight = stormParams.maxHeight !== void 0 ? stormParams.maxHeight : 100;
    stormParams.maxSlope = stormParams.maxSlope !== void 0 ? stormParams.maxSlope : 1.1;
    stormParams.maxLightnings = stormParams.maxLightnings !== void 0 ? stormParams.maxLightnings : 3;
    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== void 0 ? stormParams.lightningMinPeriod : 3;
    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== void 0 ? stormParams.lightningMaxPeriod : 7;
    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== void 0 ? stormParams.lightningMinDuration : 1;
    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== void 0 ? stormParams.lightningMaxDuration : 2.5;
    this.lightningParameters = LightningStrike.copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);
    this.lightningParameters.isEternal = false;
    this.lightningMaterial = stormParams.lightningMaterial !== void 0 ? stormParams.lightningMaterial : new MeshBasicMaterial({
      color: 11599871
    });
    if (stormParams.onRayPosition !== void 0) {
      this.onRayPosition = stormParams.onRayPosition;
    } else {
      this.onRayPosition = function(source, dest) {
        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);
        const height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());
        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);
      };
    }
    this.onLightningDown = stormParams.onLightningDown;
    this.inited = false;
    this.nextLightningTime = 0;
    this.lightningsMeshes = [];
    this.deadLightningsMeshes = [];
    for (let i2 = 0; i2 < this.stormParams.maxLightnings; i2++) {
      const lightning = new LightningStrike(LightningStrike.copyParameters({}, this.lightningParameters));
      const mesh = new Mesh(lightning, this.lightningMaterial);
      this.deadLightningsMeshes.push(mesh);
    }
  }
  update(time) {
    if (!this.inited) {
      this.nextLightningTime = this.getNextLightningTime(time) * Math.random();
      this.inited = true;
    }
    if (time >= this.nextLightningTime) {
      const lightningMesh = this.deadLightningsMeshes.pop();
      if (lightningMesh) {
        const lightningParams1 = LightningStrike.copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);
        lightningParams1.birthTime = time;
        lightningParams1.deathTime = time + MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());
        this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);
        lightningParams1.noiseSeed = Math.random();
        this.add(lightningMesh);
        this.lightningsMeshes.push(lightningMesh);
      }
      this.nextLightningTime = this.getNextLightningTime(time);
    }
    let i2 = 0, il = this.lightningsMeshes.length;
    while (i2 < il) {
      const mesh = this.lightningsMeshes[i2];
      const lightning = mesh.geometry;
      const prevState = lightning.state;
      lightning.update(time);
      if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {
        if (this.onLightningDown) {
          this.onLightningDown(lightning);
        }
      }
      if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {
        this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);
        this.deadLightningsMeshes.push(mesh);
        this.remove(mesh);
        il--;
      } else {
        i2++;
      }
    }
  }
  getNextLightningTime(currentTime) {
    return currentTime + MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);
  }
  copy(source) {
    super.copy(source);
    this.stormParams.size = source.stormParams.size;
    this.stormParams.minHeight = source.stormParams.minHeight;
    this.stormParams.maxHeight = source.stormParams.maxHeight;
    this.stormParams.maxSlope = source.stormParams.maxSlope;
    this.stormParams.maxLightnings = source.stormParams.maxLightnings;
    this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;
    this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;
    this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;
    this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;
    this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters);
    this.lightningMaterial = source.stormParams.lightningMaterial;
    this.onLightningDown = source.onLightningDown;
    return this;
  }
  clone() {
    return new this.constructor(this.stormParams).copy(this);
  }
};
LightningStorm.prototype.isLightningStorm = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/objects/ReflectorForSSRPass.js
var ReflectorForSSRPass = class extends Mesh {
  constructor(geometry, options = {}) {
    super(geometry);
    this.type = "ReflectorForSSRPass";
    const scope = this;
    const color2 = options.color !== void 0 ? new Color(options.color) : new Color(8355711);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const shader = options.shader || ReflectorForSSRPass.ReflectorShader;
    const useDepthTexture = options.useDepthTexture === true;
    const yAxis2 = new Vector3(0, 1, 0);
    const vecTemp0 = new Vector3();
    const vecTemp1 = new Vector3();
    scope.needsUpdate = false;
    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;
    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;
    scope.color = color2;
    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);
    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;
    Object.defineProperty(scope, "distanceAttenuation", {
      get() {
        return scope._distanceAttenuation;
      },
      set(val) {
        if (scope._distanceAttenuation === val)
          return;
        scope._distanceAttenuation = val;
        scope.material.defines.DISTANCE_ATTENUATION = val;
        scope.material.needsUpdate = true;
      }
    });
    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;
    Object.defineProperty(scope, "fresnel", {
      get() {
        return scope._fresnel;
      },
      set(val) {
        if (scope._fresnel === val)
          return;
        scope._fresnel = val;
        scope.material.defines.FRESNEL = val;
        scope.material.needsUpdate = true;
      }
    });
    const normal = new Vector3();
    const reflectorWorldPosition = new Vector3();
    const cameraWorldPosition = new Vector3();
    const rotationMatrix2 = new Matrix4();
    const lookAtPosition = new Vector3(0, 0, -1);
    const view = new Vector3();
    const target = new Vector3();
    const textureMatrix = new Matrix4();
    const virtualCamera = new PerspectiveCamera();
    let depthTexture;
    if (useDepthTexture) {
      depthTexture = new DepthTexture();
      depthTexture.type = UnsignedShortType;
      depthTexture.minFilter = NearestFilter;
      depthTexture.magFilter = NearestFilter;
    }
    const parameters = {
      depthTexture: useDepthTexture ? depthTexture : null
    };
    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);
    const material = new ShaderMaterial({
      transparent: useDepthTexture,
      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {
        useDepthTexture
      }),
      uniforms: UniformsUtils.clone(shader.uniforms),
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader
    });
    material.uniforms["tDiffuse"].value = renderTarget.texture;
    material.uniforms["color"].value = scope.color;
    material.uniforms["textureMatrix"].value = textureMatrix;
    if (useDepthTexture) {
      material.uniforms["tDepth"].value = renderTarget.depthTexture;
    }
    this.material = material;
    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);
    const globalPlanes = [globalPlane];
    this.doRender = function(renderer, scene, camera) {
      material.uniforms["maxDistance"].value = scope.maxDistance;
      material.uniforms["color"].value = scope.color;
      material.uniforms["opacity"].value = scope.opacity;
      vecTemp0.copy(camera.position).normalize();
      vecTemp1.copy(vecTemp0).reflect(yAxis2);
      material.uniforms["fresnelCoe"].value = (vecTemp0.dot(vecTemp1) + 1) / 2;
      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
      rotationMatrix2.extractRotation(scope.matrixWorld);
      normal.set(0, 0, 1);
      normal.applyMatrix4(rotationMatrix2);
      view.subVectors(reflectorWorldPosition, cameraWorldPosition);
      if (view.dot(normal) > 0)
        return;
      view.reflect(normal).negate();
      view.add(reflectorWorldPosition);
      rotationMatrix2.extractRotation(camera.matrixWorld);
      lookAtPosition.set(0, 0, -1);
      lookAtPosition.applyMatrix4(rotationMatrix2);
      lookAtPosition.add(cameraWorldPosition);
      target.subVectors(reflectorWorldPosition, lookAtPosition);
      target.reflect(normal).negate();
      target.add(reflectorWorldPosition);
      virtualCamera.position.copy(view);
      virtualCamera.up.set(0, 1, 0);
      virtualCamera.up.applyMatrix4(rotationMatrix2);
      virtualCamera.up.reflect(normal);
      virtualCamera.lookAt(target);
      virtualCamera.far = camera.far;
      virtualCamera.updateMatrixWorld();
      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
      material.uniforms["virtualCameraNear"].value = camera.near;
      material.uniforms["virtualCameraFar"].value = camera.far;
      material.uniforms["virtualCameraMatrixWorld"].value = virtualCamera.matrixWorld;
      material.uniforms["virtualCameraProjectionMatrix"].value = camera.projectionMatrix;
      material.uniforms["virtualCameraProjectionMatrixInverse"].value = camera.projectionMatrixInverse;
      material.uniforms["resolution"].value = scope.resolution;
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(virtualCamera.projectionMatrix);
      textureMatrix.multiply(virtualCamera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
      renderTarget.texture.encoding = renderer.outputEncoding;
      const currentRenderTarget = renderer.getRenderTarget();
      const currentXrEnabled = renderer.xr.enabled;
      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
      const currentClippingPlanes = renderer.clippingPlanes;
      renderer.xr.enabled = false;
      renderer.shadowMap.autoUpdate = false;
      renderer.clippingPlanes = globalPlanes;
      renderer.setRenderTarget(renderTarget);
      renderer.state.buffers.depth.setMask(true);
      if (renderer.autoClear === false)
        renderer.clear();
      renderer.render(scene, virtualCamera);
      renderer.xr.enabled = currentXrEnabled;
      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
      renderer.clippingPlanes = currentClippingPlanes;
      renderer.setRenderTarget(currentRenderTarget);
      const viewport = camera.viewport;
      if (viewport !== void 0) {
        renderer.state.viewport(viewport);
      }
    };
    this.getRenderTarget = function() {
      return renderTarget;
    };
  }
};
ReflectorForSSRPass.prototype.isReflectorForSSRPass = true;
ReflectorForSSRPass.ReflectorShader = {
  defines: {
    DISTANCE_ATTENUATION: true,
    FRESNEL: true
  },
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    tDepth: {
      value: null
    },
    textureMatrix: {
      value: new Matrix4()
    },
    maxDistance: {
      value: 180
    },
    opacity: {
      value: 0.5
    },
    fresnelCoe: {
      value: null
    },
    virtualCameraNear: {
      value: null
    },
    virtualCameraFar: {
      value: null
    },
    virtualCameraProjectionMatrix: {
      value: new Matrix4()
    },
    virtualCameraMatrixWorld: {
      value: new Matrix4()
    },
    virtualCameraProjectionMatrixInverse: {
      value: new Matrix4()
    },
    resolution: {
      value: new Vector2()
    }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;
		uniform float maxDistance;
		uniform float opacity;
		uniform float fresnelCoe;
		uniform float virtualCameraNear;
		uniform float virtualCameraFar;
		uniform mat4 virtualCameraProjectionMatrix;
		uniform mat4 virtualCameraProjectionMatrixInverse;
		uniform mat4 virtualCameraMatrixWorld;
		uniform vec2 resolution;
		varying vec4 vUv;
		#include <packing>
		float blendOverlay( float base, float blend ) {
			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );
		}
		vec3 blendOverlay( vec3 base, vec3 blend ) {
			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			return perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view
		}
		void main() {
			vec4 base = texture2DProj( tDiffuse, vUv );
			#ifdef useDepthTexture
				vec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;
				uv.x=1.-uv.x;
				float depth = texture2DProj( tDepth, vUv ).r;
				float viewZ = getViewZ( depth );
				float clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];
				vec3 viewPosition=getViewPosition( uv, depth, clipW );
				vec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;
				if(worldPosition.y>maxDistance) discard;
				float op=opacity;
				#ifdef DISTANCE_ATTENUATION
					float ratio=1.-(worldPosition.y/maxDistance);
					float attenuation=ratio*ratio;
					op=opacity*attenuation;
				#endif
				#ifdef FRESNEL
					op*=fresnelCoe;
				#endif
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), op );
			#else
				gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );
			#endif
		}
	`
  )
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/objects/Sky.js
var Sky = class extends Mesh {
  constructor() {
    super(new BoxGeometry(1, 1, 1), Sky.material);
  }
};
_defineProperty(Sky, "SkyShader", {
  uniforms: {
    turbidity: {
      value: 2
    },
    rayleigh: {
      value: 1
    },
    mieCoefficient: {
      value: 5e-3
    },
    mieDirectionalG: {
      value: 0.8
    },
    sunPosition: {
      value: new Vector3()
    },
    up: {
      value: new Vector3(0, 1, 0)
    }
  },
  vertexShader: [
    "uniform vec3 sunPosition;",
    "uniform float rayleigh;",
    "uniform float turbidity;",
    "uniform float mieCoefficient;",
    "uniform vec3 up;",
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    // constants for atmospheric scattering
    "const float e = 2.71828182845904523536028747135266249775724709369995957;",
    "const float pi = 3.141592653589793238462643383279502884197169;",
    // wavelength of used primaries, according to preetham
    "const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );",
    // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
    // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
    "const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );",
    // mie stuff
    // K coefficient for the primaries
    "const float v = 4.0;",
    "const vec3 K = vec3( 0.686, 0.678, 0.666 );",
    // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
    "const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );",
    // earth shadow hack
    // cutoffAngle = pi / 1.95;
    "const float cutoffAngle = 1.6110731556870734;",
    "const float steepness = 1.5;",
    "const float EE = 1000.0;",
    "float sunIntensity( float zenithAngleCos ) {",
    "	zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );",
    "	return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );",
    "}",
    "vec3 totalMie( float T ) {",
    "	float c = ( 0.2 * T ) * 10E-18;",
    "	return 0.434 * c * MieConst;",
    "}",
    "void main() {",
    "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
    "	vWorldPosition = worldPosition.xyz;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "	gl_Position.z = gl_Position.w;",
    // set z to camera.far
    "	vSunDirection = normalize( sunPosition );",
    "	vSunE = sunIntensity( dot( vSunDirection, up ) );",
    "	vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );",
    "	float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );",
    // extinction (absorbtion + out scattering)
    // rayleigh coefficients
    "	vBetaR = totalRayleigh * rayleighCoefficient;",
    // mie coefficients
    "	vBetaM = totalMie( turbidity ) * mieCoefficient;",
    "}"
  ].join("\n"),
  fragmentShader: [
    "varying vec3 vWorldPosition;",
    "varying vec3 vSunDirection;",
    "varying float vSunfade;",
    "varying vec3 vBetaR;",
    "varying vec3 vBetaM;",
    "varying float vSunE;",
    "uniform float mieDirectionalG;",
    "uniform vec3 up;",
    "const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );",
    // constants for atmospheric scattering
    "const float pi = 3.141592653589793238462643383279502884197169;",
    "const float n = 1.0003;",
    // refractive index of air
    "const float N = 2.545E25;",
    // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)
    // optical length at zenith for molecules
    "const float rayleighZenithLength = 8.4E3;",
    "const float mieZenithLength = 1.25E3;",
    // 66 arc seconds -> degrees, and the cosine of that
    "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;",
    // 3.0 / ( 16.0 * pi )
    "const float THREE_OVER_SIXTEENPI = 0.05968310365946075;",
    // 1.0 / ( 4.0 * pi )
    "const float ONE_OVER_FOURPI = 0.07957747154594767;",
    "float rayleighPhase( float cosTheta ) {",
    "	return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );",
    "}",
    "float hgPhase( float cosTheta, float g ) {",
    "	float g2 = pow( g, 2.0 );",
    "	float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );",
    "	return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );",
    "}",
    "void main() {",
    "	vec3 direction = normalize( vWorldPosition - cameraPos );",
    // optical length
    // cutoff angle at 90 to avoid singularity in next formula.
    "	float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );",
    "	float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );",
    "	float sR = rayleighZenithLength * inverse;",
    "	float sM = mieZenithLength * inverse;",
    // combined extinction factor
    "	vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );",
    // in scattering
    "	float cosTheta = dot( direction, vSunDirection );",
    "	float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );",
    "	vec3 betaRTheta = vBetaR * rPhase;",
    "	float mPhase = hgPhase( cosTheta, mieDirectionalG );",
    "	vec3 betaMTheta = vBetaM * mPhase;",
    "	vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );",
    "	Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );",
    // nightsky
    "	float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]",
    "	float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]",
    "	vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );",
    "	vec3 L0 = vec3( 0.1 ) * Fex;",
    // composition + solar disc
    "	float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );",
    "	L0 += ( vSunE * 19000.0 * Fex ) * sundisk;",
    "	vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );",
    "	vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );",
    "	gl_FragColor = vec4( retColor, 1.0 );",
    "#include <tonemapping_fragment>",
    "#include <encodings_fragment>",
    "}"
  ].join("\n")
});
_defineProperty(Sky, "material", new ShaderMaterial({
  name: "SkyShader",
  fragmentShader: Sky.SkyShader.fragmentShader,
  vertexShader: Sky.SkyShader.vertexShader,
  uniforms: UniformsUtils.clone(Sky.SkyShader.uniforms),
  side: BackSide,
  depthWrite: false
}));

// node_modules/@react-three/rapier/node_modules/three-stdlib/objects/Water2.js
var Water2 = class extends Mesh {
  constructor(geometry, options = {}) {
    super(geometry);
    this.type = "Water";
    const scope = this;
    const color2 = options.color !== void 0 ? new Color(options.color) : new Color(16777215);
    const textureWidth = options.textureWidth || 512;
    const textureHeight = options.textureHeight || 512;
    const clipBias = options.clipBias || 0;
    const flowDirection = options.flowDirection || new Vector2(1, 0);
    const flowSpeed = options.flowSpeed || 0.03;
    const reflectivity = options.reflectivity || 0.02;
    const scale = options.scale || 1;
    const shader = options.shader || Water2.WaterShader;
    const encoding = options.encoding !== void 0 ? options.encoding : LinearEncoding;
    const textureLoader = new TextureLoader();
    const flowMap = options.flowMap || void 0;
    const normalMap0 = options.normalMap0 || textureLoader.load("textures/water/Water_1_M_Normal.jpg");
    const normalMap1 = options.normalMap1 || textureLoader.load("textures/water/Water_2_M_Normal.jpg");
    const cycle = 0.15;
    const halfCycle = cycle * 0.5;
    const textureMatrix = new Matrix4();
    const clock = new Clock();
    if (Reflector === void 0) {
      console.error("THREE.Water: Required component Reflector not found.");
      return;
    }
    if (Refractor === void 0) {
      console.error("THREE.Water: Required component Refractor not found.");
      return;
    }
    const reflector = new Reflector(geometry, {
      textureWidth,
      textureHeight,
      clipBias,
      encoding
    });
    const refractor = new Refractor(geometry, {
      textureWidth,
      textureHeight,
      clipBias,
      encoding
    });
    reflector.matrixAutoUpdate = false;
    refractor.matrixAutoUpdate = false;
    this.material = new ShaderMaterial({
      uniforms: UniformsUtils.merge([UniformsLib["fog"], shader.uniforms]),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      transparent: true,
      fog: true
    });
    if (flowMap !== void 0) {
      this.material.defines.USE_FLOWMAP = "";
      this.material.uniforms["tFlowMap"] = {
        type: "t",
        value: flowMap
      };
    } else {
      this.material.uniforms["flowDirection"] = {
        type: "v2",
        value: flowDirection
      };
    }
    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;
    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;
    this.material.uniforms["tReflectionMap"].value = reflector.getRenderTarget().texture;
    this.material.uniforms["tRefractionMap"].value = refractor.getRenderTarget().texture;
    this.material.uniforms["tNormalMap0"].value = normalMap0;
    this.material.uniforms["tNormalMap1"].value = normalMap1;
    this.material.uniforms["color"].value = color2;
    this.material.uniforms["reflectivity"].value = reflectivity;
    this.material.uniforms["textureMatrix"].value = textureMatrix;
    this.material.uniforms["config"].value.x = 0;
    this.material.uniforms["config"].value.y = halfCycle;
    this.material.uniforms["config"].value.z = halfCycle;
    this.material.uniforms["config"].value.w = scale;
    function updateTextureMatrix(camera) {
      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      textureMatrix.multiply(camera.projectionMatrix);
      textureMatrix.multiply(camera.matrixWorldInverse);
      textureMatrix.multiply(scope.matrixWorld);
    }
    function updateFlow() {
      const delta = clock.getDelta();
      const config = scope.material.uniforms["config"];
      config.value.x += flowSpeed * delta;
      config.value.y = config.value.x + halfCycle;
      if (config.value.x >= cycle) {
        config.value.x = 0;
        config.value.y = halfCycle;
      } else if (config.value.y >= cycle) {
        config.value.y = config.value.y - cycle;
      }
    }
    this.onBeforeRender = function(renderer, scene, camera) {
      updateTextureMatrix(camera);
      updateFlow();
      scope.visible = false;
      reflector.matrixWorld.copy(scope.matrixWorld);
      refractor.matrixWorld.copy(scope.matrixWorld);
      reflector.onBeforeRender(renderer, scene, camera);
      refractor.onBeforeRender(renderer, scene, camera);
      scope.visible = true;
    };
  }
};
Water2.prototype.isWater = true;
Water2.WaterShader = {
  uniforms: {
    color: {
      type: "c",
      value: null
    },
    reflectivity: {
      type: "f",
      value: 0
    },
    tReflectionMap: {
      type: "t",
      value: null
    },
    tRefractionMap: {
      type: "t",
      value: null
    },
    tNormalMap0: {
      type: "t",
      value: null
    },
    tNormalMap1: {
      type: "t",
      value: null
    },
    textureMatrix: {
      type: "m4",
      value: null
    },
    config: {
      type: "v4",
      value: new Vector4()
    }
  },
  vertexShader: (
    /* glsl */
    `

		#include <common>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>

		uniform mat4 textureMatrix;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			vUv = uv;
			vCoord = textureMatrix * vec4( position, 1.0 );

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vToEye = cameraPosition - worldPosition.xyz;

			vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex
			gl_Position = projectionMatrix * mvPosition;

			#include <logdepthbuf_vertex>
			#include <fog_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		#include <common>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>

		uniform sampler2D tReflectionMap;
		uniform sampler2D tRefractionMap;
		uniform sampler2D tNormalMap0;
		uniform sampler2D tNormalMap1;

		#ifdef USE_FLOWMAP
			uniform sampler2D tFlowMap;
		#else
			uniform vec2 flowDirection;
		#endif

		uniform vec3 color;
		uniform float reflectivity;
		uniform vec4 config;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			#include <logdepthbuf_fragment>

			float flowMapOffset0 = config.x;
			float flowMapOffset1 = config.y;
			float halfCycle = config.z;
			float scale = config.w;

			vec3 toEye = normalize( vToEye );

			// determine flow direction
			vec2 flow;
			#ifdef USE_FLOWMAP
				flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;
			#else
				flow = flowDirection;
			#endif
			flow.x *= - 1.0;

			// sample normal maps (distort uvs with flowdata)
			vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );
			vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );

			// linear interpolate to get the final normal color
			float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;
			vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );

			// calculate normal vector
			vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );

			// calculate the fresnel term to blend reflection and refraction maps
			float theta = max( dot( toEye, normal ), 0.0 );
			float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );

			// calculate final uv coords
			vec3 coord = vCoord.xyz / vCoord.w;
			vec2 uv = coord.xy + coord.z * normal.xz * 0.05;

			vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );
			vec4 refractColor = texture2D( tRefractionMap, uv );

			// multiply water color with the mix of both textures
			gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>

		}`
  )
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/utils/RoughnessMipmapper.js
var _mipmapMaterial = _getMipmapMaterial();
var _mesh = new Mesh(new PlaneGeometry(2, 2), _mipmapMaterial);
var _flatCamera = new OrthographicCamera(0, 1, 0, 1, 0, 1);
var _tempTarget = null;
var _renderer = null;
function RoughnessMipmapper(renderer) {
  _renderer = renderer;
  _renderer.compile(_mesh, _flatCamera);
}
RoughnessMipmapper.prototype = {
  constructor: RoughnessMipmapper,
  generateMipmaps: function(material) {
    if ("roughnessMap" in material === false)
      return;
    var {
      roughnessMap,
      normalMap
    } = material;
    if (roughnessMap === null || normalMap === null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated) {
      return;
    }
    material.userData.roughnessUpdated = true;
    var width = Math.max(roughnessMap.image.width, normalMap.image.width);
    var height = Math.max(roughnessMap.image.height, normalMap.image.height);
    if (!MathUtils.isPowerOfTwo(width) || !MathUtils.isPowerOfTwo(height))
      return;
    var oldTarget = _renderer.getRenderTarget();
    var autoClear = _renderer.autoClear;
    _renderer.autoClear = false;
    if (_tempTarget === null || _tempTarget.width !== width || _tempTarget.height !== height) {
      if (_tempTarget !== null)
        _tempTarget.dispose();
      _tempTarget = new WebGLRenderTarget(width, height, {
        depthBuffer: false
      });
      _tempTarget.scissorTest = true;
    }
    if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {
      var params = {
        wrapS: roughnessMap.wrapS,
        wrapT: roughnessMap.wrapT,
        magFilter: roughnessMap.magFilter,
        minFilter: roughnessMap.minFilter,
        depthBuffer: false
      };
      var newRoughnessTarget = new WebGLRenderTarget(width, height, params);
      newRoughnessTarget.texture.generateMipmaps = true;
      _renderer.setRenderTarget(newRoughnessTarget);
      material.roughnessMap = newRoughnessTarget.texture;
      if (material.metalnessMap == roughnessMap)
        material.metalnessMap = material.roughnessMap;
      if (material.aoMap == roughnessMap)
        material.aoMap = material.roughnessMap;
    }
    _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;
    _mipmapMaterial.uniforms.normalMap.value = normalMap;
    var position = new Vector2(0, 0);
    var texelSize = _mipmapMaterial.uniforms.texelSize.value;
    for (let mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {
      texelSize.set(1 / width, 1 / height);
      if (mip == 0)
        texelSize.set(0, 0);
      _tempTarget.viewport.set(position.x, position.y, width, height);
      _tempTarget.scissor.set(position.x, position.y, width, height);
      _renderer.setRenderTarget(_tempTarget);
      _renderer.render(_mesh, _flatCamera);
      _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);
      _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (roughnessMap !== material.roughnessMap)
      roughnessMap.dispose();
    _renderer.setRenderTarget(oldTarget);
    _renderer.autoClear = autoClear;
  },
  dispose: function() {
    _mipmapMaterial.dispose();
    _mesh.geometry.dispose();
    if (_tempTarget != null)
      _tempTarget.dispose();
  }
};
function _getMipmapMaterial() {
  var shaderMaterial = new RawShaderMaterial({
    uniforms: {
      roughnessMap: {
        value: null
      },
      normalMap: {
        value: null
      },
      texelSize: {
        value: new Vector2(1, 1)
      }
    },
    vertexShader: (
      /* glsl */
      `
			precision mediump float;
			precision mediump int;

			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = vec4( position, 1.0 );

			}
		`
    ),
    fragmentShader: (
      /* glsl */
      `
			precision mediump float;
			precision mediump int;

			varying vec2 vUv;

			uniform sampler2D roughnessMap;
			uniform sampler2D normalMap;
			uniform vec2 texelSize;

			#define ENVMAP_TYPE_CUBE_UV

			vec4 envMapTexelToLinear( vec4 a ) { return a; }

			#include <cube_uv_reflection_fragment>

			float roughnessToVariance( float roughness ) {

				float variance = 0.0;

				if ( roughness >= r1 ) {

					variance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;

				} else if ( roughness >= r4 ) {

					variance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;

				} else if ( roughness >= r5 ) {

					variance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;

				} else {

					float roughness2 = roughness * roughness;

					variance = 1.79 * roughness2 * roughness2;

				}

				return variance;

			}

			float varianceToRoughness( float variance ) {

				float roughness = 0.0;

				if ( variance >= v1 ) {

					roughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;

				} else if ( variance >= v4 ) {

					roughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;

				} else if ( variance >= v5 ) {

					roughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;

				} else {

					roughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79

				}

				return roughness;

			}

			void main() {

				gl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );

				if ( texelSize.x == 0.0 ) return;

				float roughness = gl_FragColor.g;

				float variance = roughnessToVariance( roughness );

				vec3 avgNormal;

				for ( float x = - 1.0; x < 2.0; x += 2.0 ) {

					for ( float y = - 1.0; y < 2.0; y += 2.0 ) {

						vec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;

						avgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );

					}

				}

				variance += 1.0 - 0.25 * length( avgNormal );

				gl_FragColor.g = varianceToRoughness( variance );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  shaderMaterial.type = "RoughnessMipmapper";
  return shaderMaterial;
}

// node_modules/@react-three/rapier/node_modules/three-stdlib/utils/SkeletonUtils.js
var SkeletonUtils = {
  retarget: function() {
    var pos = new Vector3(), quat = new Quaternion(), scale = new Vector3(), bindBoneMatrix = new Matrix4(), relativeMatrix = new Matrix4(), globalMatrix = new Matrix4();
    return function(target, source, options) {
      options = options || {};
      options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;
      options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;
      options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;
      options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;
      options.hip = options.hip !== void 0 ? options.hip : "hip";
      options.names = options.names || {};
      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source), bones = target.isObject3D ? target.skeleton.bones : this.getBones(target), bindBones, bone, name, boneTo, bonesPosition, i2;
      if (target.isObject3D) {
        target.skeleton.pose();
      } else {
        options.useTargetMatrix = true;
        options.preserveMatrix = false;
      }
      if (options.preservePosition) {
        bonesPosition = [];
        for (i2 = 0; i2 < bones.length; i2++) {
          bonesPosition.push(bones[i2].position.clone());
        }
      }
      if (options.preserveMatrix) {
        target.updateMatrixWorld();
        target.matrixWorld.identity();
        for (i2 = 0; i2 < target.children.length; ++i2) {
          target.children[i2].updateMatrixWorld(true);
        }
      }
      if (options.offsets) {
        bindBones = [];
        for (i2 = 0; i2 < bones.length; ++i2) {
          bone = bones[i2];
          name = options.names[bone.name] || bone.name;
          if (options.offsets && options.offsets[name]) {
            bone.matrix.multiply(options.offsets[name]);
            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            bone.updateMatrixWorld();
          }
          bindBones.push(bone.matrixWorld.clone());
        }
      }
      for (i2 = 0; i2 < bones.length; ++i2) {
        bone = bones[i2];
        name = options.names[bone.name] || bone.name;
        boneTo = this.getBoneByName(name, sourceBones);
        globalMatrix.copy(bone.matrixWorld);
        if (boneTo) {
          boneTo.updateMatrixWorld();
          if (options.useTargetMatrix) {
            relativeMatrix.copy(boneTo.matrixWorld);
          } else {
            relativeMatrix.copy(target.matrixWorld).invert();
            relativeMatrix.multiply(boneTo.matrixWorld);
          }
          scale.setFromMatrixScale(relativeMatrix);
          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));
          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));
          if (target.isObject3D) {
            var boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();
            globalMatrix.multiply(wBindMatrix);
          }
          globalMatrix.copyPosition(relativeMatrix);
        }
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(globalMatrix);
        } else {
          bone.matrix.copy(globalMatrix);
        }
        if (options.preserveHipPosition && name === options.hip) {
          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        bone.updateMatrixWorld();
      }
      if (options.preservePosition) {
        for (i2 = 0; i2 < bones.length; ++i2) {
          bone = bones[i2];
          name = options.names[bone.name] || bone.name;
          if (name !== options.hip) {
            bone.position.copy(bonesPosition[i2]);
          }
        }
      }
      if (options.preserveMatrix) {
        target.updateMatrixWorld(true);
      }
    };
  }(),
  retargetClip: function(target, source, clip, options) {
    options = options || {};
    options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;
    options.fps = options.fps !== void 0 ? options.fps : 30;
    options.names = options.names || [];
    if (!source.isObject3D) {
      source = this.getHelperFromSkeleton(source);
    }
    var numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3), delta = 1 / options.fps, convertedTracks = [], mixer = new AnimationMixer(source), bones = this.getBones(target.skeleton), boneDatas = [], positionOffset, bone, boneTo, boneData, name, i2, j2;
    mixer.clipAction(clip).play();
    mixer.update(0);
    source.updateMatrixWorld();
    for (i2 = 0; i2 < numFrames; ++i2) {
      var time = i2 * delta;
      this.retarget(target, source, options);
      for (j2 = 0; j2 < bones.length; ++j2) {
        name = options.names[bones[j2].name] || bones[j2].name;
        boneTo = this.getBoneByName(name, source.skeleton);
        if (boneTo) {
          bone = bones[j2];
          boneData = boneDatas[j2] = boneDatas[j2] || {
            bone
          };
          if (options.hip === name) {
            if (!boneData.pos) {
              boneData.pos = {
                times: new Float32Array(numFrames),
                values: new Float32Array(numFrames * 3)
              };
            }
            if (options.useFirstFramePosition) {
              if (i2 === 0) {
                positionOffset = bone.position.clone();
              }
              bone.position.sub(positionOffset);
            }
            boneData.pos.times[i2] = time;
            bone.position.toArray(boneData.pos.values, i2 * 3);
          }
          if (!boneData.quat) {
            boneData.quat = {
              times: new Float32Array(numFrames),
              values: new Float32Array(numFrames * 4)
            };
          }
          boneData.quat.times[i2] = time;
          bone.quaternion.toArray(boneData.quat.values, i2 * 4);
        }
      }
      mixer.update(delta);
      source.updateMatrixWorld();
    }
    for (i2 = 0; i2 < boneDatas.length; ++i2) {
      boneData = boneDatas[i2];
      if (boneData) {
        if (boneData.pos) {
          convertedTracks.push(new VectorKeyframeTrack(".bones[" + boneData.bone.name + "].position", boneData.pos.times, boneData.pos.values));
        }
        convertedTracks.push(new QuaternionKeyframeTrack(".bones[" + boneData.bone.name + "].quaternion", boneData.quat.times, boneData.quat.values));
      }
    }
    mixer.uncacheAction(clip);
    return new AnimationClip(clip.name, -1, convertedTracks);
  },
  getHelperFromSkeleton: function(skeleton) {
    var source = new SkeletonHelper(skeleton.bones[0]);
    source.skeleton = skeleton;
    return source;
  },
  getSkeletonOffsets: function() {
    var targetParentPos = new Vector3(), targetPos = new Vector3(), sourceParentPos = new Vector3(), sourcePos = new Vector3(), targetDir = new Vector2(), sourceDir = new Vector2();
    return function(target, source, options) {
      options = options || {};
      options.hip = options.hip !== void 0 ? options.hip : "hip";
      options.names = options.names || {};
      if (!source.isObject3D) {
        source = this.getHelperFromSkeleton(source);
      }
      var nameKeys = Object.keys(options.names), nameValues = Object.values(options.names), sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source), bones = target.isObject3D ? target.skeleton.bones : this.getBones(target), offsets = [], bone, boneTo, name, i2;
      target.skeleton.pose();
      for (i2 = 0; i2 < bones.length; ++i2) {
        bone = bones[i2];
        name = options.names[bone.name] || bone.name;
        boneTo = this.getBoneByName(name, sourceBones);
        if (boneTo && name !== options.hip) {
          var boneParent = this.getNearestBone(bone.parent, nameKeys), boneToParent = this.getNearestBone(boneTo.parent, nameValues);
          boneParent.updateMatrixWorld();
          boneToParent.updateMatrixWorld();
          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);
          targetPos.setFromMatrixPosition(bone.matrixWorld);
          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);
          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);
          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();
          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();
          var laterialAngle = targetDir.angle() - sourceDir.angle();
          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));
          bone.matrix.multiply(offset);
          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
          bone.updateMatrixWorld();
          offsets[name] = offset;
        }
      }
      return offsets;
    };
  }(),
  renameBones: function(skeleton, names) {
    var bones = this.getBones(skeleton);
    for (let i2 = 0; i2 < bones.length; ++i2) {
      var bone = bones[i2];
      if (names[bone.name]) {
        bone.name = names[bone.name];
      }
    }
    return this;
  },
  getBones: function(skeleton) {
    return Array.isArray(skeleton) ? skeleton : skeleton.bones;
  },
  getBoneByName: function(name, skeleton) {
    for (let i2 = 0, bones = this.getBones(skeleton); i2 < bones.length; i2++) {
      if (name === bones[i2].name)
        return bones[i2];
    }
  },
  getNearestBone: function(bone, names) {
    while (bone.isBone) {
      if (names.indexOf(bone.name) !== -1) {
        return bone;
      }
      bone = bone.parent;
    }
  },
  findBoneTrackData: function(name, tracks) {
    var regexp = /\[(.*)\]\.(.*)/, result = {
      name
    };
    for (let i2 = 0; i2 < tracks.length; ++i2) {
      var trackData = regexp.exec(tracks[i2].name);
      if (trackData && name === trackData[1]) {
        result[trackData[2]] = i2;
      }
    }
    return result;
  },
  getEqualsBonesNames: function(skeleton, targetSkeleton) {
    var sourceBones = this.getBones(skeleton), targetBones = this.getBones(targetSkeleton), bones = [];
    search:
      for (let i2 = 0; i2 < sourceBones.length; i2++) {
        var boneName = sourceBones[i2].name;
        for (let j2 = 0; j2 < targetBones.length; j2++) {
          if (boneName === targetBones[j2].name) {
            bones.push(boneName);
            continue search;
          }
        }
      }
    return bones;
  },
  clone: function(source) {
    var sourceLookup = /* @__PURE__ */ new Map();
    var cloneLookup = /* @__PURE__ */ new Map();
    var clone = source.clone();
    parallelTraverse(source, clone, function(sourceNode, clonedNode) {
      sourceLookup.set(clonedNode, sourceNode);
      cloneLookup.set(sourceNode, clonedNode);
    });
    clone.traverse(function(node) {
      if (!node.isSkinnedMesh)
        return;
      var clonedMesh = node;
      var sourceMesh = sourceLookup.get(node);
      var sourceBones = sourceMesh.skeleton.bones;
      clonedMesh.skeleton = sourceMesh.skeleton.clone();
      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);
      clonedMesh.skeleton.bones = sourceBones.map(function(bone) {
        return cloneLookup.get(bone);
      });
      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);
    });
    return clone;
  }
};
function parallelTraverse(a2, b2, callback) {
  callback(a2, b2);
  for (let i2 = 0; i2 < a2.children.length; i2++) {
    parallelTraverse(a2.children[i2], b2.children[i2], callback);
  }
}

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/UnpackDepthRGBAShader.js
var UnpackDepthRGBAShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    opacity: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "#include <packing>", "void main() {", "	float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );", "	gl_FragColor = vec4( vec3( depth ), opacity );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/utils/ShadowMapViewer.js
var ShadowMapViewer = function(light) {
  var scope = this;
  var doRenderLabel = light.name !== void 0 && light.name !== "";
  var userAutoClearSetting;
  var frame = {
    x: 10,
    y: 10,
    width: 256,
    height: 256
  };
  var camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);
  camera.position.set(0, 0, 2);
  var scene = new Scene();
  var shader = UnpackDepthRGBAShader;
  var uniforms = UniformsUtils.clone(shader.uniforms);
  var material = new ShaderMaterial({
    uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader
  });
  var plane = new PlaneGeometry(frame.width, frame.height);
  var mesh = new Mesh(plane, material);
  scene.add(mesh);
  var labelCanvas, labelMesh;
  if (doRenderLabel) {
    labelCanvas = document.createElement("canvas");
    var context = labelCanvas.getContext("2d");
    context.font = "Bold 20px Arial";
    var labelWidth = context.measureText(light.name).width;
    labelCanvas.width = labelWidth;
    labelCanvas.height = 25;
    context.font = "Bold 20px Arial";
    context.fillStyle = "rgba( 255, 0, 0, 1 )";
    context.fillText(light.name, 0, 20);
    var labelTexture = new Texture(labelCanvas);
    labelTexture.magFilter = LinearFilter;
    labelTexture.minFilter = LinearFilter;
    labelTexture.needsUpdate = true;
    var labelMaterial = new MeshBasicMaterial({
      map: labelTexture,
      side: DoubleSide
    });
    labelMaterial.transparent = true;
    var labelPlane = new PlaneGeometry(labelCanvas.width, labelCanvas.height);
    labelMesh = new Mesh(labelPlane, labelMaterial);
    scene.add(labelMesh);
  }
  function resetPosition() {
    scope.position.set(scope.position.x, scope.position.y);
  }
  this.enabled = true;
  this.size = {
    width: frame.width,
    height: frame.height,
    set: function(width, height) {
      this.width = width;
      this.height = height;
      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1);
      resetPosition();
    }
  };
  this.position = {
    x: frame.x,
    y: frame.y,
    set: function(x, y) {
      this.x = x;
      this.y = y;
      var width = scope.size.width;
      var height = scope.size.height;
      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);
      if (doRenderLabel) {
        labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);
      }
    }
  };
  this.render = function(renderer) {
    if (this.enabled) {
      uniforms.tDiffuse.value = light.shadow.map.texture;
      userAutoClearSetting = renderer.autoClear;
      renderer.autoClear = false;
      renderer.clearDepth();
      renderer.render(scene, camera);
      renderer.autoClear = userAutoClearSetting;
    }
  };
  this.updateForWindowResize = function() {
    if (this.enabled) {
      camera.left = window.innerWidth / -2;
      camera.right = window.innerWidth / 2;
      camera.top = window.innerHeight / 2;
      camera.bottom = window.innerHeight / -2;
      camera.updateProjectionMatrix();
      this.update();
    }
  };
  this.update = function() {
    this.position.set(this.position.x, this.position.y);
    this.size.set(this.size.width, this.size.height);
  };
  this.update();
};
ShadowMapViewer.prototype.constructor = ShadowMapViewer;

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/BokehShader2.js
var BokehShader2 = {
  uniforms: {
    textureWidth: {
      value: 1
    },
    textureHeight: {
      value: 1
    },
    focalDepth: {
      value: 1
    },
    focalLength: {
      value: 24
    },
    fstop: {
      value: 0.9
    },
    tColor: {
      value: null
    },
    tDepth: {
      value: null
    },
    maxblur: {
      value: 1
    },
    showFocus: {
      value: 0
    },
    manualdof: {
      value: 0
    },
    vignetting: {
      value: 0
    },
    depthblur: {
      value: 0
    },
    threshold: {
      value: 0.5
    },
    gain: {
      value: 2
    },
    bias: {
      value: 0.5
    },
    fringe: {
      value: 0.7
    },
    znear: {
      value: 0.1
    },
    zfar: {
      value: 100
    },
    noise: {
      value: 1
    },
    dithering: {
      value: 1e-4
    },
    pentagon: {
      value: 0
    },
    shaderFocus: {
      value: 1
    },
    focusCoords: {
      value: new Vector2()
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", "varying vec2 vUv;", "uniform sampler2D tColor;", "uniform sampler2D tDepth;", "uniform float textureWidth;", "uniform float textureHeight;", "uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below", "uniform float focalLength; //focal length in mm", "uniform float fstop; //f-stop value", "uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)", "/*", "make sure that these two values are the same for your camera, otherwise distances will be wrong.", "*/", "uniform float znear; // camera clipping start", "uniform float zfar; // camera clipping end", "//------------------------------------------", "//user variables", "const int samples = SAMPLES; //samples on the first ring", "const int rings = RINGS; //ring count", "const int maxringsamples = rings * samples;", "uniform bool manualdof; // manual dof calculation", "float ndofstart = 1.0; // near dof blur start", "float ndofdist = 2.0; // near dof blur falloff distance", "float fdofstart = 1.0; // far dof blur start", "float fdofdist = 3.0; // far dof blur falloff distance", "float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)", "uniform bool vignetting; // use optical lens vignetting", "float vignout = 1.3; // vignetting outer border", "float vignin = 0.0; // vignetting inner border", "float vignfade = 22.0; // f-stops till vignete fades", "uniform bool shaderFocus;", "// disable if you use external focalDepth value", "uniform vec2 focusCoords;", "// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)", "// if center of screen use vec2(0.5, 0.5);", "uniform float maxblur;", "//clamp value of max blur (0.0 = no blur, 1.0 default)", "uniform float threshold; // highlight threshold;", "uniform float gain; // highlight gain;", "uniform float bias; // bokeh edge bias", "uniform float fringe; // bokeh chromatic aberration / fringing", "uniform bool noise; //use noise instead of pattern for sample dithering", "uniform float dithering;", "uniform bool depthblur; // blur the depth buffer", "float dbsize = 1.25; // depth blur size", "/*", "next part is experimental", "not looking good with small sample and ring count", "looks okay starting from samples = 4, rings = 4", "*/", "uniform bool pentagon; //use pentagon as bokeh shape?", "float feather = 0.4; //pentagon shape feather", "//------------------------------------------", "float penta(vec2 coords) {", "	//pentagonal shape", "	float scale = float(rings) - 1.3;", "	vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);", "	vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);", "	vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);", "	vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);", "	vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);", "	vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);", "	vec4  one = vec4( 1.0 );", "	vec4 P = vec4((coords),vec2(scale, scale));", "	vec4 dist = vec4(0.0);", "	float inorout = -4.0;", "	dist.x = dot( P, HS0 );", "	dist.y = dot( P, HS1 );", "	dist.z = dot( P, HS2 );", "	dist.w = dot( P, HS3 );", "	dist = smoothstep( -feather, feather, dist );", "	inorout += dot( dist, one );", "	dist.x = dot( P, HS4 );", "	dist.y = HS5.w - abs( P.z );", "	dist = smoothstep( -feather, feather, dist );", "	inorout += dist.x;", "	return clamp( inorout, 0.0, 1.0 );", "}", "float bdepth(vec2 coords) {", "	// Depth buffer blur", "	float d = 0.0;", "	float kernel[9];", "	vec2 offset[9];", "	vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;", "	offset[0] = vec2(-wh.x,-wh.y);", "	offset[1] = vec2( 0.0, -wh.y);", "	offset[2] = vec2( wh.x -wh.y);", "	offset[3] = vec2(-wh.x,  0.0);", "	offset[4] = vec2( 0.0,   0.0);", "	offset[5] = vec2( wh.x,  0.0);", "	offset[6] = vec2(-wh.x, wh.y);", "	offset[7] = vec2( 0.0,  wh.y);", "	offset[8] = vec2( wh.x, wh.y);", "	kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;", "	kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;", "	kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;", "	for( int i=0; i<9; i++ ) {", "		float tmp = texture2D(tDepth, coords + offset[i]).r;", "		d += tmp * kernel[i];", "	}", "	return d;", "}", "vec3 color(vec2 coords,float blur) {", "	//processing the sample", "	vec3 col = vec3(0.0);", "	vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);", "	col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;", "	col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;", "	col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;", "	vec3 lumcoeff = vec3(0.299,0.587,0.114);", "	float lum = dot(col.rgb, lumcoeff);", "	float thresh = max((lum-threshold)*gain, 0.0);", "	return col+mix(vec3(0.0),col,thresh*blur);", "}", "vec3 debugFocus(vec3 col, float blur, float depth) {", "	float edge = 0.002*depth; //distance based edge smoothing", "	float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);", "	float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);", "	col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);", "	col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);", "	return col;", "}", "float linearize(float depth) {", "	return -zfar * znear / (depth * (zfar - znear) - zfar);", "}", "float vignette() {", "	float dist = distance(vUv.xy, vec2(0.5,0.5));", "	dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);", "	return clamp(dist,0.0,1.0);", "}", "float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {", "	float rings2 = float(rings);", "	float step = PI*2.0 / float(ringsamples);", "	float pw = cos(j*step)*i;", "	float ph = sin(j*step)*i;", "	float p = 1.0;", "	if (pentagon) {", "		p = penta(vec2(pw,ph));", "	}", "	col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;", "	return 1.0 * mix(1.0, i /rings2, bias) * p;", "}", "void main() {", "	//scene depth calculation", "	float depth = linearize(texture2D(tDepth,vUv.xy).x);", "	// Blur depth?", "	if ( depthblur ) {", "		depth = linearize(bdepth(vUv.xy));", "	}", "	//focal plane calculation", "	float fDepth = focalDepth;", "	if (shaderFocus) {", "		fDepth = linearize(texture2D(tDepth,focusCoords).x);", "	}", "	// dof blur factor calculation", "	float blur = 0.0;", "	if (manualdof) {", "		float a = depth-fDepth; // Focal plane", "		float b = (a-fdofstart)/fdofdist; // Far DoF", "		float c = (-a-ndofstart)/ndofdist; // Near Dof", "		blur = (a>0.0) ? b : c;", "	} else {", "		float f = focalLength; // focal length in mm", "		float d = fDepth*1000.0; // focal plane in mm", "		float o = depth*1000.0; // depth in mm", "		float a = (o*f)/(o-f);", "		float b = (d*f)/(d-f);", "		float c = (d-f)/(d*fstop*CoC);", "		blur = abs(a-b)*c;", "	}", "	blur = clamp(blur,0.0,1.0);", "	// calculation of pattern for dithering", "	vec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;", "	// getting blur x and y step factor", "	float w = (1.0/textureWidth)*blur*maxblur+noise.x;", "	float h = (1.0/textureHeight)*blur*maxblur+noise.y;", "	// calculation of final color", "	vec3 col = vec3(0.0);", "	if(blur < 0.05) {", "		//some optimization thingy", "		col = texture2D(tColor, vUv.xy).rgb;", "	} else {", "		col = texture2D(tColor, vUv.xy).rgb;", "		float s = 1.0;", "		int ringsamples;", "		for (int i = 1; i <= rings; i++) {", "			/*unboxstart*/", "			ringsamples = i * samples;", "			for (int j = 0 ; j < maxringsamples ; j++) {", "				if (j >= ringsamples) break;", "				s += gather(float(i), float(j), ringsamples, col, w, h, blur);", "			}", "			/*unboxend*/", "		}", "		col /= s; //divide by sample count", "	}", "	if (showFocus) {", "		col = debugFocus(col, blur, depth);", "	}", "	if (vignetting) {", "		col *= vignette();", "	}", "	gl_FragColor.rgb = col;", "	gl_FragColor.a = 1.0;", "} "].join("\n")
};
var BokehDepthShader = {
  uniforms: {
    mNear: {
      value: 1
    },
    mFar: {
      value: 1e3
    }
  },
  vertexShader: ["varying float vViewZDepth;", "void main() {", "	#include <begin_vertex>", "	#include <project_vertex>", "	vViewZDepth = - mvPosition.z;", "}"].join("\n"),
  fragmentShader: ["uniform float mNear;", "uniform float mFar;", "varying float vViewZDepth;", "void main() {", "	float color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );", "	gl_FragColor = vec4( vec3( color ), 1.0 );", "} "].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/math/MeshSurfaceSampler.js
var MeshSurfaceSampler = function() {
  var _face = new Triangle();
  var _color = new Vector3();
  function MeshSurfaceSampler2(mesh) {
    var geometry = mesh.geometry;
    if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {
      throw new Error("THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.");
    }
    if (geometry.index) {
      console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.");
      geometry = geometry.toNonIndexed();
    }
    this.geometry = geometry;
    this.randomFunction = Math.random;
    this.positionAttribute = this.geometry.getAttribute("position");
    this.colorAttribute = this.geometry.getAttribute("color");
    this.weightAttribute = null;
    this.distribution = null;
  }
  MeshSurfaceSampler2.prototype = {
    constructor: MeshSurfaceSampler2,
    setWeightAttribute: function(name) {
      this.weightAttribute = name ? this.geometry.getAttribute(name) : null;
      return this;
    },
    build: function() {
      var positionAttribute = this.positionAttribute;
      var weightAttribute = this.weightAttribute;
      var faceWeights = new Float32Array(positionAttribute.count / 3);
      for (let i2 = 0; i2 < positionAttribute.count; i2 += 3) {
        var faceWeight = 1;
        if (weightAttribute) {
          faceWeight = weightAttribute.getX(i2) + weightAttribute.getX(i2 + 1) + weightAttribute.getX(i2 + 2);
        }
        _face.a.fromBufferAttribute(positionAttribute, i2);
        _face.b.fromBufferAttribute(positionAttribute, i2 + 1);
        _face.c.fromBufferAttribute(positionAttribute, i2 + 2);
        faceWeight *= _face.getArea();
        faceWeights[i2 / 3] = faceWeight;
      }
      this.distribution = new Float32Array(positionAttribute.count / 3);
      var cumulativeTotal = 0;
      for (let i2 = 0; i2 < faceWeights.length; i2++) {
        cumulativeTotal += faceWeights[i2];
        this.distribution[i2] = cumulativeTotal;
      }
      return this;
    },
    setRandomGenerator: function(randomFunction) {
      this.randomFunction = randomFunction;
      return this;
    },
    sample: function(targetPosition2, targetNormal, targetColor) {
      var cumulativeTotal = this.distribution[this.distribution.length - 1];
      var faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);
      return this.sampleFace(faceIndex, targetPosition2, targetNormal, targetColor);
    },
    binarySearch: function(x) {
      var dist = this.distribution;
      var start = 0;
      var end = dist.length - 1;
      var index = -1;
      while (start <= end) {
        var mid = Math.ceil((start + end) / 2);
        if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {
          index = mid;
          break;
        } else if (x < dist[mid]) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return index;
    },
    sampleFace: function(faceIndex, targetPosition2, targetNormal, targetColor) {
      var u = this.randomFunction();
      var v = this.randomFunction();
      if (u + v > 1) {
        u = 1 - u;
        v = 1 - v;
      }
      _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);
      _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);
      _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);
      targetPosition2.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));
      if (targetNormal !== void 0) {
        _face.getNormal(targetNormal);
      }
      if (targetColor !== void 0 && this.colorAttribute !== void 0) {
        _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);
        _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);
        _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);
        _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));
        targetColor.r = _color.x;
        targetColor.g = _color.y;
        targetColor.b = _color.z;
      }
      return this;
    }
  };
  return MeshSurfaceSampler2;
}();

// node_modules/@react-three/rapier/node_modules/three-stdlib/math/OBB.js
var a = {
  c: null,
  // center
  u: [new Vector3(), new Vector3(), new Vector3()],
  // basis vectors
  e: []
  // half width
};
var b = {
  c: null,
  // center
  u: [new Vector3(), new Vector3(), new Vector3()],
  // basis vectors
  e: []
  // half width
};
var R = [[], [], []];
var AbsR = [[], [], []];
var t = [];
var xAxis = new Vector3();
var yAxis = new Vector3();
var zAxis = new Vector3();
var v1 = new Vector3();
var size = new Vector3();
var closestPoint = new Vector3();
var rotationMatrix = new Matrix3();
var aabb = new Box3();
var matrix2 = new Matrix4();
var inverse = new Matrix4();
var localRay = new Ray();
function OBB(center = new Vector3(), halfSize = new Vector3(), rotation = new Matrix3()) {
  this.center = center;
  this.halfSize = halfSize;
  this.rotation = rotation;
}
Object.assign(OBB.prototype, {
  set: function(center, halfSize, rotation) {
    this.center = center;
    this.halfSize = halfSize;
    this.rotation = rotation;
    return this;
  },
  copy: function(obb2) {
    this.center.copy(obb2.center);
    this.halfSize.copy(obb2.halfSize);
    this.rotation.copy(obb2.rotation);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  getSize: function(result) {
    return result.copy(this.halfSize).multiplyScalar(2);
  },
  /**
   * Reference: Closest Point on OBB to Point in Real-Time Collision Detection
   * by Christer Ericson (chapter 5.1.4)
   */
  clampPoint: function(point, result) {
    var halfSize = this.halfSize;
    v1.subVectors(point, this.center);
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    result.copy(this.center);
    var x = MathUtils.clamp(v1.dot(xAxis), -halfSize.x, halfSize.x);
    result.add(xAxis.multiplyScalar(x));
    var y = MathUtils.clamp(v1.dot(yAxis), -halfSize.y, halfSize.y);
    result.add(yAxis.multiplyScalar(y));
    var z = MathUtils.clamp(v1.dot(zAxis), -halfSize.z, halfSize.z);
    result.add(zAxis.multiplyScalar(z));
    return result;
  },
  containsPoint: function(point) {
    v1.subVectors(point, this.center);
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    return Math.abs(v1.dot(xAxis)) <= this.halfSize.x && Math.abs(v1.dot(yAxis)) <= this.halfSize.y && Math.abs(v1.dot(zAxis)) <= this.halfSize.z;
  },
  intersectsBox3: function(box3) {
    return this.intersectsOBB(obb.fromBox3(box3));
  },
  intersectsSphere: function(sphere) {
    this.clampPoint(sphere.center, closestPoint);
    return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  },
  /**
   * Reference: OBB-OBB Intersection in Real-Time Collision Detection
   * by Christer Ericson (chapter 4.4.1)
   *
   */
  intersectsOBB: function(obb2, epsilon = Number.EPSILON) {
    a.c = this.center;
    a.e[0] = this.halfSize.x;
    a.e[1] = this.halfSize.y;
    a.e[2] = this.halfSize.z;
    this.rotation.extractBasis(a.u[0], a.u[1], a.u[2]);
    b.c = obb2.center;
    b.e[0] = obb2.halfSize.x;
    b.e[1] = obb2.halfSize.y;
    b.e[2] = obb2.halfSize.z;
    obb2.rotation.extractBasis(b.u[0], b.u[1], b.u[2]);
    for (let i2 = 0; i2 < 3; i2++) {
      for (let j2 = 0; j2 < 3; j2++) {
        R[i2][j2] = a.u[i2].dot(b.u[j2]);
      }
    }
    v1.subVectors(b.c, a.c);
    t[0] = v1.dot(a.u[0]);
    t[1] = v1.dot(a.u[1]);
    t[2] = v1.dot(a.u[2]);
    for (let i2 = 0; i2 < 3; i2++) {
      for (let j2 = 0; j2 < 3; j2++) {
        AbsR[i2][j2] = Math.abs(R[i2][j2]) + epsilon;
      }
    }
    var ra, rb;
    for (let i2 = 0; i2 < 3; i2++) {
      ra = a.e[i2];
      rb = b.e[0] * AbsR[i2][0] + b.e[1] * AbsR[i2][1] + b.e[2] * AbsR[i2][2];
      if (Math.abs(t[i2]) > ra + rb)
        return false;
    }
    for (let i2 = 0; i2 < 3; i2++) {
      ra = a.e[0] * AbsR[0][i2] + a.e[1] * AbsR[1][i2] + a.e[2] * AbsR[2][i2];
      rb = b.e[i2];
      if (Math.abs(t[0] * R[0][i2] + t[1] * R[1][i2] + t[2] * R[2][i2]) > ra + rb)
        return false;
    }
    ra = a.e[1] * AbsR[2][0] + a.e[2] * AbsR[1][0];
    rb = b.e[1] * AbsR[0][2] + b.e[2] * AbsR[0][1];
    if (Math.abs(t[2] * R[1][0] - t[1] * R[2][0]) > ra + rb)
      return false;
    ra = a.e[1] * AbsR[2][1] + a.e[2] * AbsR[1][1];
    rb = b.e[0] * AbsR[0][2] + b.e[2] * AbsR[0][0];
    if (Math.abs(t[2] * R[1][1] - t[1] * R[2][1]) > ra + rb)
      return false;
    ra = a.e[1] * AbsR[2][2] + a.e[2] * AbsR[1][2];
    rb = b.e[0] * AbsR[0][1] + b.e[1] * AbsR[0][0];
    if (Math.abs(t[2] * R[1][2] - t[1] * R[2][2]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[2][0] + a.e[2] * AbsR[0][0];
    rb = b.e[1] * AbsR[1][2] + b.e[2] * AbsR[1][1];
    if (Math.abs(t[0] * R[2][0] - t[2] * R[0][0]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[2][1] + a.e[2] * AbsR[0][1];
    rb = b.e[0] * AbsR[1][2] + b.e[2] * AbsR[1][0];
    if (Math.abs(t[0] * R[2][1] - t[2] * R[0][1]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[2][2] + a.e[2] * AbsR[0][2];
    rb = b.e[0] * AbsR[1][1] + b.e[1] * AbsR[1][0];
    if (Math.abs(t[0] * R[2][2] - t[2] * R[0][2]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[1][0] + a.e[1] * AbsR[0][0];
    rb = b.e[1] * AbsR[2][2] + b.e[2] * AbsR[2][1];
    if (Math.abs(t[1] * R[0][0] - t[0] * R[1][0]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[1][1] + a.e[1] * AbsR[0][1];
    rb = b.e[0] * AbsR[2][2] + b.e[2] * AbsR[2][0];
    if (Math.abs(t[1] * R[0][1] - t[0] * R[1][1]) > ra + rb)
      return false;
    ra = a.e[0] * AbsR[1][2] + a.e[1] * AbsR[0][2];
    rb = b.e[0] * AbsR[2][1] + b.e[1] * AbsR[2][0];
    if (Math.abs(t[1] * R[0][2] - t[0] * R[1][2]) > ra + rb)
      return false;
    return true;
  },
  /**
   * Reference: Testing Box Against Plane in Real-Time Collision Detection
   * by Christer Ericson (chapter 5.2.3)
   */
  intersectsPlane: function(plane) {
    this.rotation.extractBasis(xAxis, yAxis, zAxis);
    const r = this.halfSize.x * Math.abs(plane.normal.dot(xAxis)) + this.halfSize.y * Math.abs(plane.normal.dot(yAxis)) + this.halfSize.z * Math.abs(plane.normal.dot(zAxis));
    const d = plane.normal.dot(this.center) - plane.constant;
    return Math.abs(d) <= r;
  },
  /**
   * Performs a ray/OBB intersection test and stores the intersection point
   * to the given 3D vector. If no intersection is detected, *null* is returned.
   */
  intersectRay: function(ray, result) {
    this.getSize(size);
    aabb.setFromCenterAndSize(v1.set(0, 0, 0), size);
    matrix4FromRotationMatrix(matrix2, this.rotation);
    matrix2.setPosition(this.center);
    inverse.copy(matrix2).invert();
    localRay.copy(ray).applyMatrix4(inverse);
    if (localRay.intersectBox(aabb, result)) {
      return result.applyMatrix4(matrix2);
    } else {
      return null;
    }
  },
  /**
   * Performs a ray/OBB intersection test. Returns either true or false if
   * there is a intersection or not.
   */
  intersectsRay: function(ray) {
    return this.intersectRay(ray, v1) !== null;
  },
  fromBox3: function(box3) {
    box3.getCenter(this.center);
    box3.getSize(this.halfSize).multiplyScalar(0.5);
    this.rotation.identity();
    return this;
  },
  equals: function(obb2) {
    return obb2.center.equals(this.center) && obb2.halfSize.equals(this.halfSize) && obb2.rotation.equals(this.rotation);
  },
  applyMatrix4: function(matrix3) {
    var e = matrix3.elements;
    var sx = v1.set(e[0], e[1], e[2]).length();
    var sy = v1.set(e[4], e[5], e[6]).length();
    var sz = v1.set(e[8], e[9], e[10]).length();
    var det = matrix3.determinant();
    if (det < 0)
      sx = -sx;
    rotationMatrix.setFromMatrix4(matrix3);
    var invSX = 1 / sx;
    var invSY = 1 / sy;
    var invSZ = 1 / sz;
    rotationMatrix.elements[0] *= invSX;
    rotationMatrix.elements[1] *= invSX;
    rotationMatrix.elements[2] *= invSX;
    rotationMatrix.elements[3] *= invSY;
    rotationMatrix.elements[4] *= invSY;
    rotationMatrix.elements[5] *= invSY;
    rotationMatrix.elements[6] *= invSZ;
    rotationMatrix.elements[7] *= invSZ;
    rotationMatrix.elements[8] *= invSZ;
    this.rotation.multiply(rotationMatrix);
    this.halfSize.x *= sx;
    this.halfSize.y *= sy;
    this.halfSize.z *= sz;
    v1.setFromMatrixPosition(matrix3);
    this.center.add(v1);
    return this;
  }
});
function matrix4FromRotationMatrix(matrix4, matrix3) {
  var e = matrix4.elements;
  var me = matrix3.elements;
  e[0] = me[0];
  e[1] = me[1];
  e[2] = me[2];
  e[3] = 0;
  e[4] = me[3];
  e[5] = me[4];
  e[6] = me[5];
  e[7] = 0;
  e[8] = me[6];
  e[9] = me[7];
  e[10] = me[8];
  e[11] = 0;
  e[12] = 0;
  e[13] = 0;
  e[14] = 0;
  e[15] = 1;
}
var obb = new OBB();

// node_modules/@react-three/rapier/node_modules/three-stdlib/math/Capsule.js
var Capsule = function() {
  var _v14 = new Vector3();
  var _v23 = new Vector3();
  var _v3 = new Vector3();
  var EPS = 1e-10;
  function Capsule2(start, end, radius) {
    this.start = start == void 0 ? new Vector3(0, 0, 0) : start;
    this.end = end == void 0 ? new Vector3(0, 1, 0) : end;
    this.radius = radius == void 0 ? 1 : radius;
  }
  Object.assign(Capsule2.prototype, {
    clone: function() {
      return new Capsule2(this.start.clone(), this.end.clone(), this.radius);
    },
    set: function(start, end, radius) {
      this.start.copy(start);
      this.end.copy(end);
      this.radius = radius;
    },
    copy: function(capsule) {
      this.start.copy(capsule.start);
      this.end.copy(capsule.end);
      this.radius = capsule.radius;
    },
    getCenter: function(target) {
      return target.copy(this.end).add(this.start).multiplyScalar(0.5);
    },
    translate: function(v) {
      this.start.add(v);
      this.end.add(v);
    },
    checkAABBAxis: function(p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius) {
      return (minx - p1x < radius || minx - p2x < radius) && (p1x - maxx < radius || p2x - maxx < radius) && (miny - p1y < radius || miny - p2y < radius) && (p1y - maxy < radius || p2y - maxy < radius);
    },
    intersectsBox: function(box) {
      return this.checkAABBAxis(this.start.x, this.start.y, this.end.x, this.end.y, box.min.x, box.max.x, box.min.y, box.max.y, this.radius) && this.checkAABBAxis(this.start.x, this.start.z, this.end.x, this.end.z, box.min.x, box.max.x, box.min.z, box.max.z, this.radius) && this.checkAABBAxis(this.start.y, this.start.z, this.end.y, this.end.z, box.min.y, box.max.y, box.min.z, box.max.z, this.radius);
    },
    lineLineMinimumPoints: function(line1, line2) {
      var r = _v14.copy(line1.end).sub(line1.start);
      var s = _v23.copy(line2.end).sub(line2.start);
      var w = _v3.copy(line2.start).sub(line1.start);
      var a2 = r.dot(s), b2 = r.dot(r), c = s.dot(s), d = s.dot(w), e = r.dot(w);
      var t1, t2, divisor = b2 * c - a2 * a2;
      if (Math.abs(divisor) < EPS) {
        var d1 = -d / c;
        var d2 = (a2 - d) / c;
        if (Math.abs(d1 - 0.5) < Math.abs(d2 - 0.5)) {
          t1 = 0;
          t2 = d1;
        } else {
          t1 = 1;
          t2 = d2;
        }
      } else {
        t1 = (d * a2 + e * c) / divisor;
        t2 = (t1 * a2 - d) / c;
      }
      t2 = Math.max(0, Math.min(1, t2));
      t1 = Math.max(0, Math.min(1, t1));
      var point1 = r.multiplyScalar(t1).add(line1.start);
      var point2 = s.multiplyScalar(t2).add(line2.start);
      return [point1, point2];
    }
  });
  return Capsule2;
}();

// node_modules/@react-three/rapier/node_modules/three-stdlib/math/ColorConverter.js
var ColorConverter = {
  setHSV: function(color2, h, s, v) {
    h = MathUtils.euclideanModulo(h, 1);
    s = MathUtils.clamp(s, 0, 1);
    v = MathUtils.clamp(v, 0, 1);
    return color2.setHSL(h, s * v / ((h = (2 - s) * v) < 1 ? h : 2 - h), h * 0.5);
  },
  getHSV: function() {
    var hsl = {};
    return function getHSV(color2, target) {
      if (target === void 0) {
        console.warn("THREE.ColorConverter: .getHSV() target is now required");
        target = {
          h: 0,
          s: 0,
          l: 0
        };
      }
      color2.getHSL(hsl);
      hsl.s *= hsl.l < 0.5 ? hsl.l : 1 - hsl.l;
      target.h = hsl.h;
      target.s = 2 * hsl.s / (hsl.l + hsl.s);
      target.v = hsl.l + hsl.s;
      return target;
    };
  }(),
  // where c, m, y, k is between 0 and 1
  setCMYK: function(color2, c, m, y, k) {
    var r = (1 - c) * (1 - k);
    var g = (1 - m) * (1 - k);
    var b2 = (1 - y) * (1 - k);
    return color2.setRGB(r, g, b2);
  },
  getCMYK: function(color2, target) {
    if (target === void 0) {
      console.warn("THREE.ColorConverter: .getCMYK() target is now required");
      target = {
        c: 0,
        m: 0,
        y: 0,
        k: 0
      };
    }
    var r = color2.r;
    var g = color2.g;
    var b2 = color2.b;
    var k = 1 - Math.max(r, g, b2);
    var c = (1 - r - k) / (1 - k);
    var m = (1 - g - k) / (1 - k);
    var y = (1 - b2 - k) / (1 - k);
    target.c = c;
    target.m = m;
    target.y = y;
    target.k = k;
    return target;
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/math/Octree.js
var Octree = function() {
  var _v14 = new Vector3();
  var _v23 = new Vector3();
  var _plane2 = new Plane();
  var _line1 = new Line3();
  var _line2 = new Line3();
  var _sphere2 = new Sphere();
  var _capsule = new Capsule();
  function Octree2(box) {
    this.triangles = [];
    this.box = box;
    this.subTrees = [];
  }
  Object.assign(Octree2.prototype, {
    addTriangle: function(triangle) {
      if (!this.bounds)
        this.bounds = new Box3();
      this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x);
      this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y);
      this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z);
      this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x);
      this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y);
      this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z);
      this.triangles.push(triangle);
      return this;
    },
    calcBox: function() {
      this.box = this.bounds.clone();
      this.box.min.x -= 0.01;
      this.box.min.y -= 0.01;
      this.box.min.z -= 0.01;
      return this;
    },
    split: function(level) {
      if (!this.box)
        return;
      var subTrees = [], halfsize = _v23.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5), box, v, triangle;
      for (let x = 0; x < 2; x++) {
        for (let y = 0; y < 2; y++) {
          for (let z = 0; z < 2; z++) {
            box = new Box3();
            v = _v14.set(x, y, z);
            box.min.copy(this.box.min).add(v.multiply(halfsize));
            box.max.copy(box.min).add(halfsize);
            subTrees.push(new Octree2(box));
          }
        }
      }
      while (triangle = this.triangles.pop()) {
        for (let i2 = 0; i2 < subTrees.length; i2++) {
          if (subTrees[i2].box.intersectsTriangle(triangle)) {
            subTrees[i2].triangles.push(triangle);
          }
        }
      }
      for (let i2 = 0; i2 < subTrees.length; i2++) {
        var len = subTrees[i2].triangles.length;
        if (len > 8 && level < 16) {
          subTrees[i2].split(level + 1);
        }
        if (len != 0) {
          this.subTrees.push(subTrees[i2]);
        }
      }
      return this;
    },
    build: function() {
      this.calcBox();
      this.split(0);
      return this;
    },
    getRayTriangles: function(ray, triangles) {
      for (let i2 = 0; i2 < this.subTrees.length; i2++) {
        var subTree = this.subTrees[i2];
        if (!ray.intersectsBox(subTree.box))
          continue;
        if (subTree.triangles.length > 0) {
          for (let j2 = 0; j2 < subTree.triangles.length; j2++) {
            if (triangles.indexOf(subTree.triangles[j2]) === -1)
              triangles.push(subTree.triangles[j2]);
          }
        } else {
          subTree.getRayTriangles(ray, triangles);
        }
      }
      return triangles;
    },
    triangleCapsuleIntersect: function(capsule, triangle) {
      var point1, point2, line1, line2;
      triangle.getPlane(_plane2);
      var d1 = _plane2.distanceToPoint(capsule.start) - capsule.radius;
      var d2 = _plane2.distanceToPoint(capsule.end) - capsule.radius;
      if (d1 > 0 && d2 > 0 || d1 < -capsule.radius && d2 < -capsule.radius) {
        return false;
      }
      var delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)));
      var intersectPoint = _v14.copy(capsule.start).lerp(capsule.end, delta);
      if (triangle.containsPoint(intersectPoint)) {
        return {
          normal: _plane2.normal.clone(),
          point: intersectPoint.clone(),
          depth: Math.abs(Math.min(d1, d2))
        };
      }
      var r2 = capsule.radius * capsule.radius;
      line1 = _line1.set(capsule.start, capsule.end);
      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];
      for (let i2 = 0; i2 < lines.length; i2++) {
        line2 = _line2.set(lines[i2][0], lines[i2][1]);
        [point1, point2] = capsule.lineLineMinimumPoints(line1, line2);
        if (point1.distanceToSquared(point2) < r2) {
          return {
            normal: point1.clone().sub(point2).normalize(),
            point: point2.clone(),
            depth: capsule.radius - point1.distanceTo(point2)
          };
        }
      }
      return false;
    },
    triangleSphereIntersect: function(sphere, triangle) {
      triangle.getPlane(_plane2);
      if (!sphere.intersectsPlane(_plane2))
        return false;
      var depth = Math.abs(_plane2.distanceToSphere(sphere));
      var r2 = sphere.radius * sphere.radius - depth * depth;
      var plainPoint = _plane2.projectPoint(sphere.center, _v14);
      if (triangle.containsPoint(sphere.center)) {
        return {
          normal: _plane2.normal.clone(),
          point: plainPoint.clone(),
          depth: Math.abs(_plane2.distanceToSphere(sphere))
        };
      }
      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];
      for (let i2 = 0; i2 < lines.length; i2++) {
        _line1.set(lines[i2][0], lines[i2][1]);
        _line1.closestPointToPoint(plainPoint, true, _v23);
        var d = _v23.distanceToSquared(sphere.center);
        if (d < r2) {
          return {
            normal: sphere.center.clone().sub(_v23).normalize(),
            point: _v23.clone(),
            depth: sphere.radius - Math.sqrt(d)
          };
        }
      }
      return false;
    },
    getSphereTriangles: function(sphere, triangles) {
      for (let i2 = 0; i2 < this.subTrees.length; i2++) {
        var subTree = this.subTrees[i2];
        if (!sphere.intersectsBox(subTree.box))
          continue;
        if (subTree.triangles.length > 0) {
          for (let j2 = 0; j2 < subTree.triangles.length; j2++) {
            if (triangles.indexOf(subTree.triangles[j2]) === -1)
              triangles.push(subTree.triangles[j2]);
          }
        } else {
          subTree.getSphereTriangles(sphere, triangles);
        }
      }
    },
    getCapsuleTriangles: function(capsule, triangles) {
      for (let i2 = 0; i2 < this.subTrees.length; i2++) {
        var subTree = this.subTrees[i2];
        if (!capsule.intersectsBox(subTree.box))
          continue;
        if (subTree.triangles.length > 0) {
          for (let j2 = 0; j2 < subTree.triangles.length; j2++) {
            if (triangles.indexOf(subTree.triangles[j2]) === -1)
              triangles.push(subTree.triangles[j2]);
          }
        } else {
          subTree.getCapsuleTriangles(capsule, triangles);
        }
      }
    },
    sphereIntersect(sphere) {
      _sphere2.copy(sphere);
      var triangles = [], result, hit = false;
      this.getSphereTriangles(sphere, triangles);
      for (let i2 = 0; i2 < triangles.length; i2++) {
        if (result = this.triangleSphereIntersect(_sphere2, triangles[i2])) {
          hit = true;
          _sphere2.center.add(result.normal.multiplyScalar(result.depth));
        }
      }
      if (hit) {
        var collisionVector = _sphere2.center.clone().sub(sphere.center);
        var depth = collisionVector.length();
        return {
          normal: collisionVector.normalize(),
          depth
        };
      }
      return false;
    },
    capsuleIntersect: function(capsule) {
      _capsule.copy(capsule);
      var triangles = [], result, hit = false;
      this.getCapsuleTriangles(_capsule, triangles);
      for (let i2 = 0; i2 < triangles.length; i2++) {
        if (result = this.triangleCapsuleIntersect(_capsule, triangles[i2])) {
          hit = true;
          _capsule.translate(result.normal.multiplyScalar(result.depth));
        }
      }
      if (hit) {
        var collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v14));
        var depth = collisionVector.length();
        return {
          normal: collisionVector.normalize(),
          depth
        };
      }
      return false;
    },
    rayIntersect: function(ray) {
      if (ray.direction.length() === 0)
        return;
      var triangles = [], triangle, position, distance2 = 1e100, result;
      this.getRayTriangles(ray, triangles);
      for (let i2 = 0; i2 < triangles.length; i2++) {
        result = ray.intersectTriangle(triangles[i2].a, triangles[i2].b, triangles[i2].c, true, _v14);
        if (result) {
          var newdistance = result.sub(ray.origin).length();
          if (distance2 > newdistance) {
            position = result.clone().add(ray.origin);
            distance2 = newdistance;
            triangle = triangles[i2];
          }
        }
      }
      return distance2 < 1e100 ? {
        distance: distance2,
        triangle,
        position
      } : false;
    },
    fromGraphNode: function(group) {
      group.traverse((obj) => {
        if (obj.type === "Mesh") {
          obj.updateMatrix();
          obj.updateWorldMatrix();
          var geometry, isTemp = false;
          if (obj.geometry.index) {
            isTemp = true;
            geometry = obj.geometry.clone().toNonIndexed();
          } else {
            geometry = obj.geometry;
          }
          var positions = geometry.attributes.position.array;
          var transform = obj.matrixWorld;
          for (let i2 = 0; i2 < positions.length; i2 += 9) {
            var v12 = new Vector3(positions[i2], positions[i2 + 1], positions[i2 + 2]);
            var v2 = new Vector3(positions[i2 + 3], positions[i2 + 4], positions[i2 + 5]);
            var v3 = new Vector3(positions[i2 + 6], positions[i2 + 7], positions[i2 + 8]);
            v12.applyMatrix4(transform);
            v2.applyMatrix4(transform);
            v3.applyMatrix4(transform);
            this.addTriangle(new Triangle(v12, v2, v3));
          }
          if (isTemp) {
            geometry.dispose();
          }
        }
      });
      this.build();
      return this;
    }
  });
  return Octree2;
}();

// node_modules/@react-three/rapier/node_modules/three-stdlib/math/Lut.js
var Lut = function(colormap, numberofcolors) {
  this.lut = [];
  this.setColorMap(colormap, numberofcolors);
  return this;
};
Lut.prototype = {
  constructor: Lut,
  lut: [],
  map: [],
  n: 256,
  minV: 0,
  maxV: 1,
  set: function(value) {
    if (value instanceof Lut) {
      this.copy(value);
    }
    return this;
  },
  setMin: function(min2) {
    this.minV = min2;
    return this;
  },
  setMax: function(max2) {
    this.maxV = max2;
    return this;
  },
  setColorMap: function(colormap, numberofcolors) {
    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;
    this.n = numberofcolors || 32;
    var step2 = 1 / this.n;
    this.lut.length = 0;
    for (let i2 = 0; i2 <= 1; i2 += step2) {
      for (let j2 = 0; j2 < this.map.length - 1; j2++) {
        if (i2 >= this.map[j2][0] && i2 < this.map[j2 + 1][0]) {
          var min2 = this.map[j2][0];
          var max2 = this.map[j2 + 1][0];
          var minColor = new Color(this.map[j2][1]);
          var maxColor = new Color(this.map[j2 + 1][1]);
          var color2 = minColor.lerp(maxColor, (i2 - min2) / (max2 - min2));
          this.lut.push(color2);
        }
      }
    }
    return this;
  },
  copy: function(lut) {
    this.lut = lut.lut;
    this.map = lut.map;
    this.n = lut.n;
    this.minV = lut.minV;
    this.maxV = lut.maxV;
    return this;
  },
  getColor: function(alpha) {
    if (alpha <= this.minV) {
      alpha = this.minV;
    } else if (alpha >= this.maxV) {
      alpha = this.maxV;
    }
    alpha = (alpha - this.minV) / (this.maxV - this.minV);
    var colorPosition = Math.round(alpha * this.n);
    colorPosition == this.n ? colorPosition -= 1 : colorPosition;
    return this.lut[colorPosition];
  },
  addColorMap: function(colormapName, arrayOfColors) {
    ColorMapKeywords[colormapName] = arrayOfColors;
  },
  createCanvas: function() {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = this.n;
    this.updateCanvas(canvas);
    return canvas;
  },
  updateCanvas: function(canvas) {
    var ctx = canvas.getContext("2d", {
      alpha: false
    });
    var imageData = ctx.getImageData(0, 0, 1, this.n);
    var data = imageData.data;
    var k = 0;
    var step2 = 1 / this.n;
    for (let i2 = 1; i2 >= 0; i2 -= step2) {
      for (let j2 = this.map.length - 1; j2 >= 0; j2--) {
        if (i2 < this.map[j2][0] && i2 >= this.map[j2 - 1][0]) {
          var min2 = this.map[j2 - 1][0];
          var max2 = this.map[j2][0];
          var minColor = new Color(this.map[j2 - 1][1]);
          var maxColor = new Color(this.map[j2][1]);
          var color2 = minColor.lerp(maxColor, (i2 - min2) / (max2 - min2));
          data[k * 4] = Math.round(color2.r * 255);
          data[k * 4 + 1] = Math.round(color2.g * 255);
          data[k * 4 + 2] = Math.round(color2.b * 255);
          data[k * 4 + 3] = 255;
          k += 1;
        }
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas;
  }
};
var ColorMapKeywords = {
  rainbow: [[0, 255], [0.2, 65535], [0.5, 65280], [0.8, 16776960], [1, 16711680]],
  cooltowarm: [[0, 3952322], [0.2, 10206463], [0.5, 14474460], [0.8, 16163717], [1, 11797542]],
  blackbody: [[0, 0], [0.2, 7864320], [0.5, 15086080], [0.8, 16776960], [1, 16777215]],
  grayscale: [[0, 0], [0.2, 4210752], [0.5, 8355712], [0.8, 12566463], [1, 16777215]]
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/controls/experimental/CameraControls.js
var STATE;
(function(STATE3) {
  STATE3[STATE3["NONE"] = -1] = "NONE";
  STATE3[STATE3["ROTATE"] = 0] = "ROTATE";
  STATE3[STATE3["DOLLY"] = 1] = "DOLLY";
  STATE3[STATE3["PAN"] = 2] = "PAN";
  STATE3[STATE3["TOUCH_ROTATE"] = 3] = "TOUCH_ROTATE";
  STATE3[STATE3["TOUCH_PAN"] = 4] = "TOUCH_PAN";
  STATE3[STATE3["TOUCH_DOLLY_PAN"] = 5] = "TOUCH_DOLLY_PAN";
  STATE3[STATE3["TOUCH_DOLLY_ROTATE"] = 6] = "TOUCH_DOLLY_ROTATE";
})(STATE || (STATE = {}));

// node_modules/@react-three/rapier/node_modules/three-stdlib/controls/FirstPersonControls.js
var targetPosition = new Vector3();

// node_modules/@react-three/rapier/node_modules/three-stdlib/controls/PointerLockControls.js
var _euler = new Euler(0, 0, 0, "YXZ");
var _vector2 = new Vector3();
var _PI_2 = Math.PI / 2;

// node_modules/@react-three/rapier/node_modules/three-stdlib/controls/ArcballControls.js
var STATE2 = {
  IDLE: Symbol(),
  ROTATE: Symbol(),
  PAN: Symbol(),
  SCALE: Symbol(),
  FOV: Symbol(),
  FOCUS: Symbol(),
  ZROTATE: Symbol(),
  TOUCH_MULTI: Symbol(),
  ANIMATION_FOCUS: Symbol(),
  ANIMATION_ROTATE: Symbol()
};
var INPUT = {
  NONE: Symbol(),
  ONE_FINGER: Symbol(),
  ONE_FINGER_SWITCHED: Symbol(),
  TWO_FINGER: Symbol(),
  MULT_FINGER: Symbol(),
  CURSOR: Symbol()
};
var _transformation = {
  camera: new Matrix4(),
  gizmos: new Matrix4()
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/postprocessing/Pass.js
var Pass = class {
  constructor() {
    _defineProperty(this, "enabled", true);
    _defineProperty(this, "needsSwap", true);
    _defineProperty(this, "clear", false);
    _defineProperty(this, "renderToScreen", false);
  }
  setSize(width, height) {
  }
  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
};
var FullScreenQuad = class {
  constructor(material) {
    _defineProperty(this, "camera", new OrthographicCamera(-1, 1, 1, -1, 0, 1));
    _defineProperty(this, "geometry", new PlaneGeometry(2, 2));
    _defineProperty(this, "mesh", void 0);
    this.mesh = new Mesh(this.geometry, material);
  }
  get material() {
    return this.mesh.material;
  }
  set material(value) {
    this.mesh.material = value;
  }
  dispose() {
    this.mesh.geometry.dispose();
  }
  render(renderer) {
    renderer.render(this.mesh, this.camera);
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/HalftoneShader.js
var HalftoneShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    shape: {
      value: 1
    },
    radius: {
      value: 4
    },
    rotateR: {
      value: Math.PI / 12 * 1
    },
    rotateG: {
      value: Math.PI / 12 * 2
    },
    rotateB: {
      value: Math.PI / 12 * 3
    },
    scatter: {
      value: 0
    },
    width: {
      value: 1
    },
    height: {
      value: 1
    },
    blending: {
      value: 1
    },
    blendingMode: {
      value: 1
    },
    greyscale: {
      value: false
    },
    disable: {
      value: false
    }
  },
  vertexShader: ["varying vec2 vUV;", "void main() {", "	vUV = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join("\n"),
  fragmentShader: [
    "#define SQRT2_MINUS_ONE 0.41421356",
    "#define SQRT2_HALF_MINUS_ONE 0.20710678",
    "#define PI2 6.28318531",
    "#define SHAPE_DOT 1",
    "#define SHAPE_ELLIPSE 2",
    "#define SHAPE_LINE 3",
    "#define SHAPE_SQUARE 4",
    "#define BLENDING_LINEAR 1",
    "#define BLENDING_MULTIPLY 2",
    "#define BLENDING_ADD 3",
    "#define BLENDING_LIGHTER 4",
    "#define BLENDING_DARKER 5",
    "uniform sampler2D tDiffuse;",
    "uniform float radius;",
    "uniform float rotateR;",
    "uniform float rotateG;",
    "uniform float rotateB;",
    "uniform float scatter;",
    "uniform float width;",
    "uniform float height;",
    "uniform int shape;",
    "uniform bool disable;",
    "uniform float blending;",
    "uniform int blendingMode;",
    "varying vec2 vUV;",
    "uniform bool greyscale;",
    "const int samples = 8;",
    "float blend( float a, float b, float t ) {",
    // linear blend
    "	return a * ( 1.0 - t ) + b * t;",
    "}",
    "float hypot( float x, float y ) {",
    // vector magnitude
    "	return sqrt( x * x + y * y );",
    "}",
    "float rand( vec2 seed ){",
    // get pseudo-random number
    "return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );",
    "}",
    "float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {",
    // apply shape-specific transforms
    "	float dist = hypot( coord.x - p.x, coord.y - p.y );",
    "	float rad = channel;",
    "	if ( shape == SHAPE_DOT ) {",
    "		rad = pow( abs( rad ), 1.125 ) * rad_max;",
    "	} else if ( shape == SHAPE_ELLIPSE ) {",
    "		rad = pow( abs( rad ), 1.125 ) * rad_max;",
    "		if ( dist != 0.0 ) {",
    "			float dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );",
    "			dist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;",
    "		}",
    "	} else if ( shape == SHAPE_LINE ) {",
    "		rad = pow( abs( rad ), 1.5) * rad_max;",
    "		float dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;",
    "		dist = hypot( normal.x * dot_p, normal.y * dot_p );",
    "	} else if ( shape == SHAPE_SQUARE ) {",
    "		float theta = atan( p.y - coord.y, p.x - coord.x ) - angle;",
    "		float sin_t = abs( sin( theta ) );",
    "		float cos_t = abs( cos( theta ) );",
    "		rad = pow( abs( rad ), 1.4 );",
    "		rad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );",
    "	}",
    "	return rad - dist;",
    "}",
    "struct Cell {",
    // grid sample positions
    "	vec2 normal;",
    "	vec2 p1;",
    "	vec2 p2;",
    "	vec2 p3;",
    "	vec2 p4;",
    "	float samp2;",
    "	float samp1;",
    "	float samp3;",
    "	float samp4;",
    "};",
    "vec4 getSample( vec2 point ) {",
    // multi-sampled point
    "	vec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );",
    "	float base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;",
    "	float step = PI2 / float( samples );",
    "	float dist = radius * 0.66;",
    "	for ( int i = 0; i < samples; ++i ) {",
    "		float r = base + step * float( i );",
    "		vec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );",
    "		tex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );",
    "	}",
    "	tex /= float( samples ) + 1.0;",
    "	return tex;",
    "}",
    "float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {",
    // get colour for given point
    "	float dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;",
    "	if ( channel == 0 ) {",
    "		c.samp1 = getSample( c.p1 ).r;",
    "		c.samp2 = getSample( c.p2 ).r;",
    "		c.samp3 = getSample( c.p3 ).r;",
    "		c.samp4 = getSample( c.p4 ).r;",
    "	} else if (channel == 1) {",
    "		c.samp1 = getSample( c.p1 ).g;",
    "		c.samp2 = getSample( c.p2 ).g;",
    "		c.samp3 = getSample( c.p3 ).g;",
    "		c.samp4 = getSample( c.p4 ).g;",
    "	} else {",
    "		c.samp1 = getSample( c.p1 ).b;",
    "		c.samp3 = getSample( c.p3 ).b;",
    "		c.samp2 = getSample( c.p2 ).b;",
    "		c.samp4 = getSample( c.p4 ).b;",
    "	}",
    "	dist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );",
    "	dist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );",
    "	dist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );",
    "	dist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );",
    "	res = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;",
    "	res += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;",
    "	res += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;",
    "	res += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;",
    "	res = clamp( res, 0.0, 1.0 );",
    "	return res;",
    "}",
    "Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {",
    // get containing cell
    "	Cell c;",
    // calc grid
    "	vec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );",
    "	float threshold = step * 0.5;",
    "	float dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );",
    "	float dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );",
    "	vec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );",
    "	float offset_normal = mod( hypot( offset.x, offset.y ), step );",
    "	float normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;",
    "	float normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;",
    "	float offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );",
    "	float line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;",
    "	float line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;",
    // get closest corner
    "	c.normal = n;",
    "	c.p1.x = p.x - n.x * normal_scale + n.y * line_scale;",
    "	c.p1.y = p.y - n.y * normal_scale - n.x * line_scale;",
    // scatter
    "	if ( scatter != 0.0 ) {",
    "		float off_mag = scatter * threshold * 0.5;",
    "		float off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;",
    "		c.p1.x += cos( off_angle ) * off_mag;",
    "		c.p1.y += sin( off_angle ) * off_mag;",
    "	}",
    // find corners
    "	float normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );",
    "	float line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );",
    "	c.p2.x = c.p1.x - n.x * normal_step;",
    "	c.p2.y = c.p1.y - n.y * normal_step;",
    "	c.p3.x = c.p1.x + n.y * line_step;",
    "	c.p3.y = c.p1.y - n.x * line_step;",
    "	c.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;",
    "	c.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;",
    "	return c;",
    "}",
    "float blendColour( float a, float b, float t ) {",
    // blend colours
    "	if ( blendingMode == BLENDING_LINEAR ) {",
    "		return blend( a, b, 1.0 - t );",
    "	} else if ( blendingMode == BLENDING_ADD ) {",
    "		return blend( a, min( 1.0, a + b ), t );",
    "	} else if ( blendingMode == BLENDING_MULTIPLY ) {",
    "		return blend( a, max( 0.0, a * b ), t );",
    "	} else if ( blendingMode == BLENDING_LIGHTER ) {",
    "		return blend( a, max( a, b ), t );",
    "	} else if ( blendingMode == BLENDING_DARKER ) {",
    "		return blend( a, min( a, b ), t );",
    "	} else {",
    "		return blend( a, b, 1.0 - t );",
    "	}",
    "}",
    "void main() {",
    "	if ( ! disable ) {",
    // setup
    "		vec2 p = vec2( vUV.x * width, vUV.y * height );",
    "		vec2 origin = vec2( 0, 0 );",
    "		float aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;",
    // get channel samples
    "		Cell cell_r = getReferenceCell( p, origin, rotateR, radius );",
    "		Cell cell_g = getReferenceCell( p, origin, rotateG, radius );",
    "		Cell cell_b = getReferenceCell( p, origin, rotateB, radius );",
    "		float r = getDotColour( cell_r, p, 0, rotateR, aa );",
    "		float g = getDotColour( cell_g, p, 1, rotateG, aa );",
    "		float b = getDotColour( cell_b, p, 2, rotateB, aa );",
    // blend with original
    "		vec4 colour = texture2D( tDiffuse, vUV );",
    "		r = blendColour( r, colour.r, blending );",
    "		g = blendColour( g, colour.g, blending );",
    "		b = blendColour( b, colour.b, blending );",
    "		if ( greyscale ) {",
    "			r = g = b = (r + b + g) / 3.0;",
    "		}",
    "		gl_FragColor = vec4( r, g, b, 1.0 );",
    "	} else {",
    "		gl_FragColor = texture2D( tDiffuse, vUV );",
    "	}",
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/SMAAShader.js
var SMAAEdgesShader = {
  defines: {
    SMAA_THRESHOLD: "0.1"
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader: [
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 3 ];",
    "void SMAAEdgeDetectionVS( vec2 texcoord ) {",
    "	vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );",
    // WebGL port note: Changed sign in W component
    "	vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );",
    // WebGL port note: Changed sign in W component
    "	vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );",
    // WebGL port note: Changed sign in W component
    "}",
    "void main() {",
    "	vUv = uv;",
    "	SMAAEdgeDetectionVS( vUv );",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 3 ];",
    "vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {",
    "	vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );",
    // Calculate color deltas:
    "	vec4 delta;",
    "	vec3 C = texture2D( colorTex, texcoord ).rgb;",
    "	vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;",
    "	vec3 t = abs( C - Cleft );",
    "	delta.x = max( max( t.r, t.g ), t.b );",
    "	vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;",
    "	t = abs( C - Ctop );",
    "	delta.y = max( max( t.r, t.g ), t.b );",
    // We do the usual threshold:
    "	vec2 edges = step( threshold, delta.xy );",
    // Then discard if there is no edge:
    "	if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )",
    "		discard;",
    // Calculate right and bottom deltas:
    "	vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;",
    "	t = abs( C - Cright );",
    "	delta.z = max( max( t.r, t.g ), t.b );",
    "	vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;",
    "	t = abs( C - Cbottom );",
    "	delta.w = max( max( t.r, t.g ), t.b );",
    // Calculate the maximum delta in the direct neighborhood:
    "	float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );",
    // Calculate left-left and top-top deltas:
    "	vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;",
    "	t = abs( C - Cleftleft );",
    "	delta.z = max( max( t.r, t.g ), t.b );",
    "	vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;",
    "	t = abs( C - Ctoptop );",
    "	delta.w = max( max( t.r, t.g ), t.b );",
    // Calculate the final maximum delta:
    "	maxDelta = max( max( maxDelta, delta.z ), delta.w );",
    // Local contrast adaptation in action:
    "	edges.xy *= step( 0.5 * maxDelta, delta.xy );",
    "	return vec4( edges, 0.0, 0.0 );",
    "}",
    "void main() {",
    "	gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );",
    "}"
  ].join("\n")
};
var SMAAWeightsShader = {
  defines: {
    SMAA_MAX_SEARCH_STEPS: "8",
    SMAA_AREATEX_MAX_DISTANCE: "16",
    SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
    SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )"
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    tArea: {
      value: null
    },
    tSearch: {
      value: null
    },
    resolution: {
      value: new Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader: [
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 3 ];",
    "varying vec2 vPixcoord;",
    "void SMAABlendingWeightCalculationVS( vec2 texcoord ) {",
    "	vPixcoord = texcoord / resolution;",
    // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
    "	vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );",
    // WebGL port note: Changed sign in Y and W components
    "	vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );",
    // WebGL port note: Changed sign in Y and W components
    // And these for the searches, they indicate the ends of the loops:
    "	vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );",
    "}",
    "void main() {",
    "	vUv = uv;",
    "	SMAABlendingWeightCalculationVS( vUv );",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )",
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tArea;",
    "uniform sampler2D tSearch;",
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[3];",
    "varying vec2 vPixcoord;",
    "#if __VERSION__ == 100",
    "vec2 round( vec2 x ) {",
    "	return sign( x ) * floor( abs( x ) + 0.5 );",
    "}",
    "#endif",
    "float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {",
    // Not required if searchTex accesses are set to point:
    // float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
    // e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
    //     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
    "	e.r = bias + e.r * scale;",
    "	return 255.0 * texture2D( searchTex, e, 0.0 ).r;",
    "}",
    "float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    /**
     * @PSEUDO_GATHER4
     * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
     * sample between edge, thus fetching four edges in a row.
     * Sampling with different offsets in each direction allows to disambiguate
     * which edges are active from the four fetched ones.
     */
    "	vec2 e = vec2( 0.0, 1.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    // WebGL port note: Changed while to for
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord -= vec2( 2.0, 0.0 ) * resolution;",
    "		if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
    "	}",
    // We correct the previous (-0.25, -0.125) offset we applied:
    "	texcoord.x += 0.25 * resolution.x;",
    // The searches are bias by 1, so adjust the coords accordingly:
    "	texcoord.x += resolution.x;",
    // Disambiguate the length added by the last step:
    "	texcoord.x += 2.0 * resolution.x;",
    // Undo last step
    "	texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);",
    "	return texcoord.x;",
    "}",
    "float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 0.0, 1.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    // WebGL port note: Changed while to for
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord += vec2( 2.0, 0.0 ) * resolution;",
    "		if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;",
    "	}",
    "	texcoord.x -= 0.25 * resolution.x;",
    "	texcoord.x -= resolution.x;",
    "	texcoord.x -= 2.0 * resolution.x;",
    "	texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );",
    "	return texcoord.x;",
    "}",
    "float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 1.0, 0.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    // WebGL port note: Changed while to for
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord += vec2( 0.0, 2.0 ) * resolution;",
    // WebGL port note: Changed sign
    "		if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
    "	}",
    "	texcoord.y -= 0.25 * resolution.y;",
    // WebGL port note: Changed sign
    "	texcoord.y -= resolution.y;",
    // WebGL port note: Changed sign
    "	texcoord.y -= 2.0 * resolution.y;",
    // WebGL port note: Changed sign
    "	texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );",
    // WebGL port note: Changed sign
    "	return texcoord.y;",
    "}",
    "float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {",
    "	vec2 e = vec2( 1.0, 0.0 );",
    "	for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {",
    // WebGL port note: Changed while to for
    "		e = texture2D( edgesTex, texcoord, 0.0 ).rg;",
    "		texcoord -= vec2( 0.0, 2.0 ) * resolution;",
    // WebGL port note: Changed sign
    "		if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;",
    "	}",
    "	texcoord.y += 0.25 * resolution.y;",
    // WebGL port note: Changed sign
    "	texcoord.y += resolution.y;",
    // WebGL port note: Changed sign
    "	texcoord.y += 2.0 * resolution.y;",
    // WebGL port note: Changed sign
    "	texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );",
    // WebGL port note: Changed sign
    "	return texcoord.y;",
    "}",
    "vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {",
    // Rounding prevents precision errors of bilinear filtering:
    "	vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;",
    // We do a scale and bias for mapping to texel space:
    "	texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );",
    // Move to proper place, according to the subpixel offset:
    "	texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;",
    "	return texture2D( areaTex, texcoord, 0.0 ).rg;",
    "}",
    "vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {",
    "	vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );",
    "	vec2 e = texture2D( edgesTex, texcoord ).rg;",
    "	if ( e.g > 0.0 ) {",
    // Edge at north
    "		vec2 d;",
    // Find the distance to the left:
    "		vec2 coords;",
    "		coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );",
    "		coords.y = offset[ 1 ].y;",
    // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)
    "		d.x = coords.x;",
    // Now fetch the left crossing edges, two at a time using bilinear
    // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
    // discern what value each edge has:
    "		float e1 = texture2D( edgesTex, coords, 0.0 ).r;",
    // Find the distance to the right:
    "		coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );",
    "		d.y = coords.x;",
    // We want the distances to be in pixel units (doing this here allow to
    // better interleave arithmetic and memory accesses):
    "		d = d / resolution.x - pixcoord.x;",
    // SMAAArea below needs a sqrt, as the areas texture is compressed
    // quadratically:
    "		vec2 sqrt_d = sqrt( abs( d ) );",
    // Fetch the right crossing edges:
    "		coords.y -= 1.0 * resolution.y;",
    // WebGL port note: Added
    "		float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;",
    // Ok, we know how this pattern looks like, now it is time for getting
    // the actual area:
    "		weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );",
    "	}",
    "	if ( e.r > 0.0 ) {",
    // Edge at west
    "		vec2 d;",
    // Find the distance to the top:
    "		vec2 coords;",
    "		coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );",
    "		coords.x = offset[ 0 ].x;",
    // offset[1].x = texcoord.x - 0.25 * resolution.x;
    "		d.x = coords.y;",
    // Fetch the top crossing edges:
    "		float e1 = texture2D( edgesTex, coords, 0.0 ).g;",
    // Find the distance to the bottom:
    "		coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );",
    "		d.y = coords.y;",
    // We want the distances to be in pixel units:
    "		d = d / resolution.y - pixcoord.y;",
    // SMAAArea below needs a sqrt, as the areas texture is compressed
    // quadratically:
    "		vec2 sqrt_d = sqrt( abs( d ) );",
    // Fetch the bottom crossing edges:
    "		coords.y -= 1.0 * resolution.y;",
    // WebGL port note: Added
    "		float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;",
    // Get the area for this direction:
    "		weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );",
    "	}",
    "	return weights;",
    "}",
    "void main() {",
    "	gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );",
    "}"
  ].join("\n")
};
var SMAABlendShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    tColor: {
      value: null
    },
    resolution: {
      value: new Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader: [
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 2 ];",
    "void SMAANeighborhoodBlendingVS( vec2 texcoord ) {",
    "	vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );",
    // WebGL port note: Changed sign in W component
    "	vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );",
    // WebGL port note: Changed sign in W component
    "}",
    "void main() {",
    "	vUv = uv;",
    "	SMAANeighborhoodBlendingVS( vUv );",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tColor;",
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "varying vec4 vOffset[ 2 ];",
    "vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {",
    // Fetch the blending weights for current pixel:
    "	vec4 a;",
    "	a.xz = texture2D( blendTex, texcoord ).xz;",
    "	a.y = texture2D( blendTex, offset[ 1 ].zw ).g;",
    "	a.w = texture2D( blendTex, offset[ 1 ].xy ).a;",
    // Is there any blending weight with a value greater than 0.0?
    "	if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {",
    "		return texture2D( colorTex, texcoord, 0.0 );",
    "	} else {",
    // Up to 4 lines can be crossing a pixel (one through each edge). We
    // favor blending by choosing the line with the maximum weight for each
    // direction:
    "		vec2 offset;",
    "		offset.x = a.a > a.b ? a.a : -a.b;",
    // left vs. right
    "		offset.y = a.g > a.r ? -a.g : a.r;",
    // top vs. bottom // WebGL port note: Changed signs
    // Then we go in the direction that has the maximum weight:
    "		if ( abs( offset.x ) > abs( offset.y )) {",
    // horizontal vs. vertical
    "			offset.y = 0.0;",
    "		} else {",
    "			offset.x = 0.0;",
    "		}",
    // Fetch the opposite color and lerp by hand:
    "		vec4 C = texture2D( colorTex, texcoord, 0.0 );",
    "		texcoord += sign( offset ) * resolution;",
    "		vec4 Cop = texture2D( colorTex, texcoord, 0.0 );",
    "		float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );",
    // WebGL port note: Added gamma correction
    "		C.xyz = pow(C.xyz, vec3(2.2));",
    "		Cop.xyz = pow(Cop.xyz, vec3(2.2));",
    "		vec4 mixed = mix(C, Cop, s);",
    "		mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));",
    "		return mixed;",
    "	}",
    "}",
    "void main() {",
    "	gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/FilmShader.js
var FilmShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    time: {
      value: 0
    },
    nIntensity: {
      value: 0.5
    },
    sIntensity: {
      value: 0.05
    },
    sCount: {
      value: 4096
    },
    grayscale: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#include <common>",
    // control parameter
    "uniform float time;",
    "uniform bool grayscale;",
    // noise effect intensity value (0 = no effect, 1 = full effect)
    "uniform float nIntensity;",
    // scanlines effect intensity value (0 = no effect, 1 = full effect)
    "uniform float sIntensity;",
    // scanlines effect count value (0 = no effect, 4096 = full effect)
    "uniform float sCount;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    // sample the source
    "	vec4 cTextureScreen = texture2D( tDiffuse, vUv );",
    // make some noise
    "	float dx = rand( vUv + time );",
    // add noise
    "	vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );",
    // get us a sine and cosine
    "	vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );",
    // add scanlines
    "	cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;",
    // interpolate between source and result by intensity
    "	cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );",
    // convert to grayscale if desired
    "	if( grayscale ) {",
    "		cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );",
    "	}",
    "	gl_FragColor =  vec4( cResult, cTextureScreen.a );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/CopyShader.js
var CopyShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    opacity: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	gl_FragColor = opacity * texel;", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/SSAOShader.js
var SSAOShader = {
  defines: {
    PERSPECTIVE_CAMERA: 1,
    KERNEL_SIZE: 32
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    tNormal: {
      value: null
    },
    tDepth: {
      value: null
    },
    tNoise: {
      value: null
    },
    kernel: {
      value: null
    },
    cameraNear: {
      value: null
    },
    cameraFar: {
      value: null
    },
    resolution: {
      value: new Vector2()
    },
    cameraProjectionMatrix: {
      value: new Matrix4()
    },
    cameraInverseProjectionMatrix: {
      value: new Matrix4()
    },
    kernelRadius: {
      value: 8
    },
    minDistance: {
      value: 5e-3
    },
    maxDistance: {
      value: 0.05
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tNormal;",
    "uniform sampler2D tDepth;",
    "uniform sampler2D tNoise;",
    "uniform vec3 kernel[ KERNEL_SIZE ];",
    "uniform vec2 resolution;",
    "uniform float cameraNear;",
    "uniform float cameraFar;",
    "uniform mat4 cameraProjectionMatrix;",
    "uniform mat4 cameraInverseProjectionMatrix;",
    "uniform float kernelRadius;",
    "uniform float minDistance;",
    // avoid artifacts caused by neighbour fragments with minimal depth difference
    "uniform float maxDistance;",
    // avoid the influence of fragments which are too far away
    "varying vec2 vUv;",
    "#include <packing>",
    "float getDepth( const in vec2 screenPosition ) {",
    "	return texture2D( tDepth, screenPosition ).x;",
    "}",
    "float getLinearDepth( const in vec2 screenPosition ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "		float fragCoordZ = texture2D( tDepth, screenPosition ).x;",
    "		float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );",
    "		return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );",
    "	#else",
    "		return texture2D( tDepth, screenPosition ).x;",
    "	#endif",
    "}",
    "float getViewZ( const in float depth ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "		return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );",
    "	#else",
    "		return orthographicDepthToViewZ( depth, cameraNear, cameraFar );",
    "	#endif",
    "}",
    "vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {",
    "	float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];",
    "	vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );",
    "	clipPosition *= clipW; // unprojection.",
    "	return ( cameraInverseProjectionMatrix * clipPosition ).xyz;",
    "}",
    "vec3 getViewNormal( const in vec2 screenPosition ) {",
    "	return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );",
    "}",
    "void main() {",
    "	float depth = getDepth( vUv );",
    "	float viewZ = getViewZ( depth );",
    "	vec3 viewPosition = getViewPosition( vUv, depth, viewZ );",
    "	vec3 viewNormal = getViewNormal( vUv );",
    " vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );",
    "	vec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;",
    // compute matrix used to reorient a kernel vector
    "	vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );",
    "	vec3 bitangent = cross( viewNormal, tangent );",
    "	mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );",
    " float occlusion = 0.0;",
    " for ( int i = 0; i < KERNEL_SIZE; i ++ ) {",
    "		vec3 sampleVector = kernelMatrix * kernel[ i ];",
    // reorient sample vector in view space
    "		vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );",
    // calculate sample point
    "		vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );",
    // project point and calculate NDC
    "		samplePointNDC /= samplePointNDC.w;",
    "		vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;",
    // compute uv coordinates
    "		float realDepth = getLinearDepth( samplePointUv );",
    // get linear depth from depth texture
    "		float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );",
    // compute linear depth of the sample view Z value
    "		float delta = sampleDepth - realDepth;",
    "		if ( delta > minDistance && delta < maxDistance ) {",
    // if fragment is before sample point, increase occlusion
    "			occlusion += 1.0;",
    "		}",
    "	}",
    "	occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );",
    "	gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );",
    "}"
  ].join("\n")
};
var SSAODepthShader = {
  defines: {
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: {
      value: null
    },
    cameraNear: {
      value: null
    },
    cameraFar: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDepth;", "uniform float cameraNear;", "uniform float cameraFar;", "varying vec2 vUv;", "#include <packing>", "float getLinearDepth( const in vec2 screenPosition ) {", "	#if PERSPECTIVE_CAMERA == 1", "		float fragCoordZ = texture2D( tDepth, screenPosition ).x;", "		float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );", "		return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );", "	#else", "		return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "void main() {", "	float depth = getLinearDepth( vUv );", "	gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );", "}"].join("\n")
};
var SSAOBlurShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2()
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "varying vec2 vUv;", "void main() {", "	vec2 texelSize = ( 1.0 / resolution );", "	float result = 0.0;", "	for ( int i = - 2; i <= 2; i ++ ) {", "		for ( int j = - 2; j <= 2; j ++ ) {", "			vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;", "			result += texture2D( tDiffuse, vUv + offset ).r;", "		}", "	}", "	gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/postprocessing/SSAOPass.js
var SSAOPass = class extends Pass {
  constructor(scene, camera, width, height) {
    super();
    this.width = width !== void 0 ? width : 512;
    this.height = height !== void 0 ? height : 512;
    this.clear = true;
    this.camera = camera;
    this.scene = scene;
    this.kernelRadius = 8;
    this.kernelSize = 32;
    this.kernel = [];
    this.noiseTexture = null;
    this.output = 0;
    this.minDistance = 5e-3;
    this.maxDistance = 0.1;
    this._visibilityCache = /* @__PURE__ */ new Map();
    this.generateSampleKernel();
    this.generateRandomKernelRotations();
    const depthTexture = new DepthTexture();
    depthTexture.format = DepthStencilFormat;
    depthTexture.type = UnsignedInt248Type;
    this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height);
    this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthTexture
    });
    this.ssaoRenderTarget = new WebGLRenderTarget(this.width, this.height);
    this.blurRenderTarget = this.ssaoRenderTarget.clone();
    if (SSAOShader === void 0) {
      console.error("THREE.SSAOPass: The pass relies on SSAOShader.");
    }
    this.ssaoMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAOShader.defines),
      uniforms: UniformsUtils.clone(SSAOShader.uniforms),
      vertexShader: SSAOShader.vertexShader,
      fragmentShader: SSAOShader.fragmentShader,
      blending: NoBlending
    });
    this.ssaoMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
    this.ssaoMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
    this.ssaoMaterial.uniforms["tDepth"].value = this.normalRenderTarget.depthTexture;
    this.ssaoMaterial.uniforms["tNoise"].value = this.noiseTexture;
    this.ssaoMaterial.uniforms["kernel"].value = this.kernel;
    this.ssaoMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.ssaoMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.ssaoMaterial.uniforms["resolution"].value.set(this.width, this.height);
    this.ssaoMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssaoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.normalMaterial = new MeshNormalMaterial();
    this.normalMaterial.blending = NoBlending;
    this.blurMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAOBlurShader.defines),
      uniforms: UniformsUtils.clone(SSAOBlurShader.uniforms),
      vertexShader: SSAOBlurShader.vertexShader,
      fragmentShader: SSAOBlurShader.fragmentShader
    });
    this.blurMaterial.uniforms["tDiffuse"].value = this.ssaoRenderTarget.texture;
    this.blurMaterial.uniforms["resolution"].value.set(this.width, this.height);
    this.depthRenderMaterial = new ShaderMaterial({
      defines: Object.assign({}, SSAODepthShader.defines),
      uniforms: UniformsUtils.clone(SSAODepthShader.uniforms),
      vertexShader: SSAODepthShader.vertexShader,
      fragmentShader: SSAODepthShader.fragmentShader,
      blending: NoBlending
    });
    this.depthRenderMaterial.uniforms["tDepth"].value = this.normalRenderTarget.depthTexture;
    this.depthRenderMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.depthRenderMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.copyMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(CopyShader.uniforms),
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      transparent: true,
      depthTest: false,
      depthWrite: false,
      blendSrc: DstColorFactor,
      blendDst: ZeroFactor,
      blendEquation: AddEquation,
      blendSrcAlpha: DstAlphaFactor,
      blendDstAlpha: ZeroFactor,
      blendEquationAlpha: AddEquation
    });
    this.fsQuad = new FullScreenQuad(null);
    this.originalClearColor = new Color();
  }
  dispose() {
    this.beautyRenderTarget.dispose();
    this.normalRenderTarget.dispose();
    this.ssaoRenderTarget.dispose();
    this.blurRenderTarget.dispose();
    this.normalMaterial.dispose();
    this.blurMaterial.dispose();
    this.copyMaterial.dispose();
    this.depthRenderMaterial.dispose();
    this.fsQuad.dispose();
  }
  render(renderer, writeBuffer) {
    if (renderer.capabilities.isWebGL2 === false)
      this.noiseTexture.format = LuminanceFormat;
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    renderer.render(this.scene, this.camera);
    this.overrideVisibility();
    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 7829503, 1);
    this.restoreVisibility();
    this.ssaoMaterial.uniforms["kernelRadius"].value = this.kernelRadius;
    this.ssaoMaterial.uniforms["minDistance"].value = this.minDistance;
    this.ssaoMaterial.uniforms["maxDistance"].value = this.maxDistance;
    this.renderPass(renderer, this.ssaoMaterial, this.ssaoRenderTarget);
    this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);
    switch (this.output) {
      case SSAOPass.OUTPUT.SSAO:
        this.copyMaterial.uniforms["tDiffuse"].value = this.ssaoRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Blur:
        this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Beauty:
        this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Depth:
        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Normal:
        this.copyMaterial.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSAOPass.OUTPUT.Default:
        this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
        this.copyMaterial.blending = CustomBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      default:
        console.warn("THREE.SSAOPass: Unknown output type.");
    }
  }
  renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    const originalClearAlpha = renderer.getClearAlpha();
    const originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  }
  setSize(width, height) {
    this.width = width;
    this.height = height;
    this.beautyRenderTarget.setSize(width, height);
    this.ssaoRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.blurRenderTarget.setSize(width, height);
    this.ssaoMaterial.uniforms["resolution"].value.set(width, height);
    this.ssaoMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssaoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.blurMaterial.uniforms["resolution"].value.set(width, height);
  }
  generateSampleKernel() {
    const kernelSize = this.kernelSize;
    const kernel = this.kernel;
    for (let i2 = 0; i2 < kernelSize; i2++) {
      const sample = new Vector3();
      sample.x = Math.random() * 2 - 1;
      sample.y = Math.random() * 2 - 1;
      sample.z = Math.random();
      sample.normalize();
      let scale = i2 / kernelSize;
      scale = MathUtils.lerp(0.1, 1, scale * scale);
      sample.multiplyScalar(scale);
      kernel.push(sample);
    }
  }
  generateRandomKernelRotations() {
    const width = 4, height = 4;
    if (SimplexNoise === void 0) {
      console.error("THREE.SSAOPass: The pass relies on SimplexNoise.");
    }
    const simplex = new SimplexNoise();
    const size2 = width * height;
    const data = new Float32Array(size2);
    for (let i2 = 0; i2 < size2; i2++) {
      const x = Math.random() * 2 - 1;
      const y = Math.random() * 2 - 1;
      const z = 0;
      data[i2] = simplex.noise3d(x, y, z);
    }
    this.noiseTexture = new DataTexture(data, width, height, RedFormat, FloatType);
    this.noiseTexture.wrapS = RepeatWrapping;
    this.noiseTexture.wrapT = RepeatWrapping;
    this.noiseTexture.needsUpdate = true;
  }
  overrideVisibility() {
    const scene = this.scene;
    const cache = this._visibilityCache;
    scene.traverse(function(object) {
      cache.set(object, object.visible);
      if (object.isPoints || object.isLine)
        object.visible = false;
    });
  }
  restoreVisibility() {
    const scene = this.scene;
    const cache = this._visibilityCache;
    scene.traverse(function(object) {
      const visible = cache.get(object);
      object.visible = visible;
    });
    cache.clear();
  }
};
SSAOPass.OUTPUT = {
  Default: 0,
  SSAO: 1,
  Blur: 2,
  Beauty: 3,
  Depth: 4,
  Normal: 5
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/BokehShader.js
var BokehShader = {
  defines: {
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tColor: {
      value: null
    },
    tDepth: {
      value: null
    },
    focus: {
      value: 1
    },
    aspect: {
      value: 1
    },
    aperture: {
      value: 0.025
    },
    maxblur: {
      value: 0.01
    },
    nearClip: {
      value: 1
    },
    farClip: {
      value: 1e3
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#include <common>",
    "varying vec2 vUv;",
    "uniform sampler2D tColor;",
    "uniform sampler2D tDepth;",
    "uniform float maxblur;",
    // max blur amount
    "uniform float aperture;",
    // aperture - bigger values for shallower depth of field
    "uniform float nearClip;",
    "uniform float farClip;",
    "uniform float focus;",
    "uniform float aspect;",
    "#include <packing>",
    "float getDepth( const in vec2 screenPosition ) {",
    "	#if DEPTH_PACKING == 1",
    "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );",
    "	#else",
    "	return texture2D( tDepth, screenPosition ).x;",
    "	#endif",
    "}",
    "float getViewZ( const in float depth ) {",
    "	#if PERSPECTIVE_CAMERA == 1",
    "	return perspectiveDepthToViewZ( depth, nearClip, farClip );",
    "	#else",
    "	return orthographicDepthToViewZ( depth, nearClip, farClip );",
    "	#endif",
    "}",
    "void main() {",
    "	vec2 aspectcorrect = vec2( 1.0, aspect );",
    "	float viewZ = getViewZ( getDepth( vUv ) );",
    "	float factor = ( focus + viewZ );",
    // viewZ is <= 0, so this is a difference equation
    "	vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );",
    "	vec2 dofblur9 = dofblur * 0.9;",
    "	vec2 dofblur7 = dofblur * 0.7;",
    "	vec2 dofblur4 = dofblur * 0.4;",
    "	vec4 col = vec4( 0.0 );",
    "	col += texture2D( tColor, vUv.xy );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
    "	col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );",
    "	gl_FragColor = col / 41.0;",
    "	gl_FragColor.a = 1.0;",
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/postprocessing/TexturePass.js
var TexturePass = function(map, opacity) {
  if (CopyShader === void 0)
    console.error("THREE.TexturePass relies on CopyShader");
  var shader = CopyShader;
  this.map = map;
  this.opacity = opacity !== void 0 ? opacity : 1;
  this.uniforms = UniformsUtils.clone(shader.uniforms);
  this.material = new ShaderMaterial({
    uniforms: this.uniforms,
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader,
    depthTest: false,
    depthWrite: false
  });
  this.needsSwap = false;
  this.fsQuad = new FullScreenQuad(null);
};
TexturePass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: TexturePass,
  render: function(renderer, writeBuffer, readBuffer) {
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    this.fsQuad.material = this.material;
    this.uniforms["opacity"].value = this.opacity;
    this.uniforms["tDiffuse"].value = this.map;
    this.material.transparent = this.opacity < 1;
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear)
      renderer.clear();
    this.fsQuad.render(renderer);
    renderer.autoClear = oldAutoClear;
  }
});

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/LuminosityShader.js
var LuminosityShader = {
  uniforms: {
    tDiffuse: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	float l = linearToRelativeLuminance( texel.rgb );", "	gl_FragColor = vec4( l, l, l, texel.w );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/ToneMapShader.js
var ToneMapShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    averageLuminance: {
      value: 1
    },
    luminanceMap: {
      value: null
    },
    maxLuminance: {
      value: 16
    },
    minLuminance: {
      value: 0.01
    },
    middleGrey: {
      value: 0.6
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#include <common>",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "uniform float middleGrey;",
    "uniform float minLuminance;",
    "uniform float maxLuminance;",
    "#ifdef ADAPTED_LUMINANCE",
    "	uniform sampler2D luminanceMap;",
    "#else",
    "	uniform float averageLuminance;",
    "#endif",
    "vec3 ToneMap( vec3 vColor ) {",
    "	#ifdef ADAPTED_LUMINANCE",
    // Get the calculated average luminance
    "		float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;",
    "	#else",
    "		float fLumAvg = averageLuminance;",
    "	#endif",
    // Calculate the luminance of the current pixel
    "	float fLumPixel = linearToRelativeLuminance( vColor );",
    // Apply the modified operator (Eq. 4)
    "	float fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );",
    "	float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);",
    "	return fLumCompressed * vColor;",
    "}",
    "void main() {",
    "	vec4 texel = texture2D( tDiffuse, vUv );",
    "	gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/postprocessing/AdaptiveToneMappingPass.js
var AdaptiveToneMappingPass = function(adaptive, resolution) {
  this.resolution = resolution !== void 0 ? resolution : 256;
  this.needsInit = true;
  this.adaptive = adaptive !== void 0 ? !!adaptive : true;
  this.luminanceRT = null;
  this.previousLuminanceRT = null;
  this.currentLuminanceRT = null;
  if (CopyShader === void 0)
    console.error("THREE.AdaptiveToneMappingPass relies on CopyShader");
  var copyShader = CopyShader;
  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
  this.materialCopy = new ShaderMaterial({
    uniforms: this.copyUniforms,
    vertexShader: copyShader.vertexShader,
    fragmentShader: copyShader.fragmentShader,
    blending: NoBlending,
    depthTest: false
  });
  if (LuminosityShader === void 0)
    console.error("THREE.AdaptiveToneMappingPass relies on LuminosityShader");
  this.materialLuminance = new ShaderMaterial({
    uniforms: UniformsUtils.clone(LuminosityShader.uniforms),
    vertexShader: LuminosityShader.vertexShader,
    fragmentShader: LuminosityShader.fragmentShader,
    blending: NoBlending
  });
  this.adaptLuminanceShader = {
    defines: {
      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2)).toFixed(1)
    },
    uniforms: {
      lastLum: {
        value: null
      },
      currentLum: {
        value: null
      },
      minLuminance: {
        value: 0.01
      },
      delta: {
        value: 0.016
      },
      tau: {
        value: 1
      }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: [
      "varying vec2 vUv;",
      "uniform sampler2D lastLum;",
      "uniform sampler2D currentLum;",
      "uniform float minLuminance;",
      "uniform float delta;",
      "uniform float tau;",
      "void main() {",
      "	vec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );",
      "	vec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );",
      "	float fLastLum = max( minLuminance, lastLum.r );",
      "	float fCurrentLum = max( minLuminance, currentLum.r );",
      //The adaption seems to work better in extreme lighting differences
      //if the input luminance is squared.
      "	fCurrentLum *= fCurrentLum;",
      // Adapt the luminance using Pattanaik's technique
      "	float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));",
      // "fAdaptedLum = sqrt(fAdaptedLum);",
      "	gl_FragColor.r = fAdaptedLum;",
      "}"
    ].join("\n")
  };
  this.materialAdaptiveLum = new ShaderMaterial({
    uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),
    vertexShader: this.adaptLuminanceShader.vertexShader,
    fragmentShader: this.adaptLuminanceShader.fragmentShader,
    defines: Object.assign({}, this.adaptLuminanceShader.defines),
    blending: NoBlending
  });
  if (ToneMapShader === void 0)
    console.error("THREE.AdaptiveToneMappingPass relies on ToneMapShader");
  this.materialToneMap = new ShaderMaterial({
    uniforms: UniformsUtils.clone(ToneMapShader.uniforms),
    vertexShader: ToneMapShader.vertexShader,
    fragmentShader: ToneMapShader.fragmentShader,
    blending: NoBlending
  });
  this.fsQuad = new FullScreenQuad(null);
};
AdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: AdaptiveToneMappingPass,
  render: function(renderer, writeBuffer, readBuffer, deltaTime) {
    if (this.needsInit) {
      this.reset(renderer);
      this.luminanceRT.texture.type = readBuffer.texture.type;
      this.previousLuminanceRT.texture.type = readBuffer.texture.type;
      this.currentLuminanceRT.texture.type = readBuffer.texture.type;
      this.needsInit = false;
    }
    if (this.adaptive) {
      this.fsQuad.material = this.materialLuminance;
      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;
      renderer.setRenderTarget(this.currentLuminanceRT);
      this.fsQuad.render(renderer);
      this.fsQuad.material = this.materialAdaptiveLum;
      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;
      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;
      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;
      renderer.setRenderTarget(this.luminanceRT);
      this.fsQuad.render(renderer);
      this.fsQuad.material = this.materialCopy;
      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;
      renderer.setRenderTarget(this.previousLuminanceRT);
      this.fsQuad.render(renderer);
    }
    this.fsQuad.material = this.materialToneMap;
    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear();
      this.fsQuad.render(renderer);
    }
  },
  reset: function() {
    if (this.luminanceRT) {
      this.luminanceRT.dispose();
    }
    if (this.currentLuminanceRT) {
      this.currentLuminanceRT.dispose();
    }
    if (this.previousLuminanceRT) {
      this.previousLuminanceRT.dispose();
    }
    var pars = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat
    };
    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);
    this.luminanceRT.texture.name = "AdaptiveToneMappingPass.l";
    this.luminanceRT.texture.generateMipmaps = false;
    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);
    this.previousLuminanceRT.texture.name = "AdaptiveToneMappingPass.pl";
    this.previousLuminanceRT.texture.generateMipmaps = false;
    pars.minFilter = LinearMipmapLinearFilter;
    pars.generateMipmaps = true;
    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);
    this.currentLuminanceRT.texture.name = "AdaptiveToneMappingPass.cl";
    if (this.adaptive) {
      this.materialToneMap.defines["ADAPTED_LUMINANCE"] = "";
      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;
    }
    this.fsQuad.material = new MeshBasicMaterial({
      color: 7829367
    });
    this.materialLuminance.needsUpdate = true;
    this.materialAdaptiveLum.needsUpdate = true;
    this.materialToneMap.needsUpdate = true;
  },
  setAdaptive: function(adaptive) {
    if (adaptive) {
      this.adaptive = true;
      this.materialToneMap.defines["ADAPTED_LUMINANCE"] = "";
      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;
    } else {
      this.adaptive = false;
      delete this.materialToneMap.defines["ADAPTED_LUMINANCE"];
      this.materialToneMap.uniforms.luminanceMap.value = null;
    }
    this.materialToneMap.needsUpdate = true;
  },
  setAdaptionRate: function(rate) {
    if (rate) {
      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);
    }
  },
  setMinLuminance: function(minLum) {
    if (minLum) {
      this.materialToneMap.uniforms.minLuminance.value = minLum;
      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;
    }
  },
  setMaxLuminance: function(maxLum) {
    if (maxLum) {
      this.materialToneMap.uniforms.maxLuminance.value = maxLum;
    }
  },
  setAverageLuminance: function(avgLum) {
    if (avgLum) {
      this.materialToneMap.uniforms.averageLuminance.value = avgLum;
    }
  },
  setMiddleGrey: function(middleGrey) {
    if (middleGrey) {
      this.materialToneMap.uniforms.middleGrey.value = middleGrey;
    }
  },
  dispose: function() {
    if (this.luminanceRT) {
      this.luminanceRT.dispose();
    }
    if (this.previousLuminanceRT) {
      this.previousLuminanceRT.dispose();
    }
    if (this.currentLuminanceRT) {
      this.currentLuminanceRT.dispose();
    }
    if (this.materialLuminance) {
      this.materialLuminance.dispose();
    }
    if (this.materialAdaptiveLum) {
      this.materialAdaptiveLum.dispose();
    }
    if (this.materialCopy) {
      this.materialCopy.dispose();
    }
    if (this.materialToneMap) {
      this.materialToneMap.dispose();
    }
  }
});

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/LuminosityHighPassShader.js
var LuminosityHighPassShader = {
  shaderID: "luminosityHighPass",
  uniforms: {
    tDiffuse: {
      value: null
    },
    luminosityThreshold: {
      value: 1
    },
    smoothWidth: {
      value: 1
    },
    defaultColor: {
      value: new Color(0)
    },
    defaultOpacity: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 defaultColor;", "uniform float defaultOpacity;", "uniform float luminosityThreshold;", "uniform float smoothWidth;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	vec3 luma = vec3( 0.299, 0.587, 0.114 );", "	float v = dot( texel.xyz, luma );", "	vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );", "	float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );", "	gl_FragColor = mix( outputColor, texel, alpha );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/postprocessing/UnrealBloomPass.js
var UnrealBloomPass = function(resolution, strength, radius, threshold) {
  this.strength = strength !== void 0 ? strength : 1;
  this.radius = radius;
  this.threshold = threshold;
  this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
  this.clearColor = new Color(0, 0, 0);
  var pars = {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat
  };
  this.renderTargetsHorizontal = [];
  this.renderTargetsVertical = [];
  this.nMips = 5;
  var resx = Math.round(this.resolution.x / 2);
  var resy = Math.round(this.resolution.y / 2);
  this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);
  this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
  this.renderTargetBright.texture.generateMipmaps = false;
  for (let i2 = 0; i2 < this.nMips; i2++) {
    var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);
    renderTargetHorizonal.texture.name = "UnrealBloomPass.h" + i2;
    renderTargetHorizonal.texture.generateMipmaps = false;
    this.renderTargetsHorizontal.push(renderTargetHorizonal);
    var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);
    renderTargetVertical.texture.name = "UnrealBloomPass.v" + i2;
    renderTargetVertical.texture.generateMipmaps = false;
    this.renderTargetsVertical.push(renderTargetVertical);
    resx = Math.round(resx / 2);
    resy = Math.round(resy / 2);
  }
  if (LuminosityHighPassShader === void 0)
    console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
  var highPassShader = LuminosityHighPassShader;
  this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);
  this.highPassUniforms["luminosityThreshold"].value = threshold;
  this.highPassUniforms["smoothWidth"].value = 0.01;
  this.materialHighPassFilter = new ShaderMaterial({
    uniforms: this.highPassUniforms,
    vertexShader: highPassShader.vertexShader,
    fragmentShader: highPassShader.fragmentShader,
    defines: {}
  });
  this.separableBlurMaterials = [];
  var kernelSizeArray = [3, 5, 7, 9, 11];
  var resx = Math.round(this.resolution.x / 2);
  var resy = Math.round(this.resolution.y / 2);
  for (let i2 = 0; i2 < this.nMips; i2++) {
    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i2]));
    this.separableBlurMaterials[i2].uniforms["texSize"].value = new Vector2(resx, resy);
    resx = Math.round(resx / 2);
    resy = Math.round(resy / 2);
  }
  this.compositeMaterial = this.getCompositeMaterial(this.nMips);
  this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
  this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
  this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
  this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
  this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;
  this.compositeMaterial.uniforms["bloomStrength"].value = strength;
  this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;
  this.compositeMaterial.needsUpdate = true;
  var bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];
  this.compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
  this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];
  this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
  if (CopyShader === void 0) {
    console.error("THREE.UnrealBloomPass relies on CopyShader");
  }
  var copyShader = CopyShader;
  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
  this.copyUniforms["opacity"].value = 1;
  this.materialCopy = new ShaderMaterial({
    uniforms: this.copyUniforms,
    vertexShader: copyShader.vertexShader,
    fragmentShader: copyShader.fragmentShader,
    blending: AdditiveBlending,
    depthTest: false,
    depthWrite: false,
    transparent: true
  });
  this.enabled = true;
  this.needsSwap = false;
  this._oldClearColor = new Color();
  this.oldClearAlpha = 1;
  this.basic = new MeshBasicMaterial();
  this.fsQuad = new FullScreenQuad(null);
};
UnrealBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: UnrealBloomPass,
  dispose: function() {
    for (let i2 = 0; i2 < this.renderTargetsHorizontal.length; i2++) {
      this.renderTargetsHorizontal[i2].dispose();
    }
    for (let i2 = 0; i2 < this.renderTargetsVertical.length; i2++) {
      this.renderTargetsVertical[i2].dispose();
    }
    this.renderTargetBright.dispose();
  },
  setSize: function(width, height) {
    var resx = Math.round(width / 2);
    var resy = Math.round(height / 2);
    this.renderTargetBright.setSize(resx, resy);
    for (let i2 = 0; i2 < this.nMips; i2++) {
      this.renderTargetsHorizontal[i2].setSize(resx, resy);
      this.renderTargetsVertical[i2].setSize(resx, resy);
      this.separableBlurMaterials[i2].uniforms["texSize"].value = new Vector2(resx, resy);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
    }
  },
  render: function(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    renderer.getClearColor(this._oldClearColor);
    this.oldClearAlpha = renderer.getClearAlpha();
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setClearColor(this.clearColor, 0);
    if (maskActive)
      renderer.state.buffers.stencil.setTest(false);
    if (this.renderToScreen) {
      this.fsQuad.material = this.basic;
      this.basic.map = readBuffer.texture;
      renderer.setRenderTarget(null);
      renderer.clear();
      this.fsQuad.render(renderer);
    }
    this.highPassUniforms["tDiffuse"].value = readBuffer.texture;
    this.highPassUniforms["luminosityThreshold"].value = this.threshold;
    this.fsQuad.material = this.materialHighPassFilter;
    renderer.setRenderTarget(this.renderTargetBright);
    renderer.clear();
    this.fsQuad.render(renderer);
    var inputRenderTarget = this.renderTargetBright;
    for (let i2 = 0; i2 < this.nMips; i2++) {
      this.fsQuad.material = this.separableBlurMaterials[i2];
      this.separableBlurMaterials[i2].uniforms["colorTexture"].value = inputRenderTarget.texture;
      this.separableBlurMaterials[i2].uniforms["direction"].value = UnrealBloomPass.BlurDirectionX;
      renderer.setRenderTarget(this.renderTargetsHorizontal[i2]);
      renderer.clear();
      this.fsQuad.render(renderer);
      this.separableBlurMaterials[i2].uniforms["colorTexture"].value = this.renderTargetsHorizontal[i2].texture;
      this.separableBlurMaterials[i2].uniforms["direction"].value = UnrealBloomPass.BlurDirectionY;
      renderer.setRenderTarget(this.renderTargetsVertical[i2]);
      renderer.clear();
      this.fsQuad.render(renderer);
      inputRenderTarget = this.renderTargetsVertical[i2];
    }
    this.fsQuad.material = this.compositeMaterial;
    this.compositeMaterial.uniforms["bloomStrength"].value = this.strength;
    this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
    this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
    renderer.clear();
    this.fsQuad.render(renderer);
    this.fsQuad.material = this.materialCopy;
    this.copyUniforms["tDiffuse"].value = this.renderTargetsHorizontal[0].texture;
    if (maskActive)
      renderer.state.buffers.stencil.setTest(true);
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(readBuffer);
      this.fsQuad.render(renderer);
    }
    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  },
  getSeperableBlurMaterial: function(kernelRadius) {
    return new ShaderMaterial({
      defines: {
        KERNEL_RADIUS: kernelRadius,
        SIGMA: kernelRadius
      },
      uniforms: {
        colorTexture: {
          value: null
        },
        texSize: {
          value: new Vector2(0.5, 0.5)
        },
        direction: {
          value: new Vector2(0.5, 0.5)
        }
      },
      vertexShader: "varying vec2 vUv;\nvoid main() {\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
      fragmentShader: "#include <common>varying vec2 vUv;\nuniform sampler2D colorTexture;\nuniform vec2 texSize;uniform vec2 direction;\nfloat gaussianPdf(in float x, in float sigma) {	return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;}void main() {\n	vec2 invSize = 1.0 / texSize;	float fSigma = float(SIGMA);	float weightSum = gaussianPdf(0.0, fSigma);	vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;	for( int i = 1; i < KERNEL_RADIUS; i ++ ) {		float x = float(i);		float w = gaussianPdf(x, fSigma);		vec2 uvOffset = direction * invSize * x;		vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;		vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;		diffuseSum += (sample1 + sample2) * w;		weightSum += 2.0 * w;	}	gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n}"
    });
  },
  getCompositeMaterial: function(nMips) {
    return new ShaderMaterial({
      defines: {
        NUM_MIPS: nMips
      },
      uniforms: {
        blurTexture1: {
          value: null
        },
        blurTexture2: {
          value: null
        },
        blurTexture3: {
          value: null
        },
        blurTexture4: {
          value: null
        },
        blurTexture5: {
          value: null
        },
        dirtTexture: {
          value: null
        },
        bloomStrength: {
          value: 1
        },
        bloomFactors: {
          value: null
        },
        bloomTintColors: {
          value: null
        },
        bloomRadius: {
          value: 0
        }
      },
      vertexShader: "varying vec2 vUv;\nvoid main() {\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
      fragmentShader: "varying vec2 vUv;uniform sampler2D blurTexture1;uniform sampler2D blurTexture2;uniform sampler2D blurTexture3;uniform sampler2D blurTexture4;uniform sampler2D blurTexture5;uniform sampler2D dirtTexture;uniform float bloomStrength;uniform float bloomRadius;uniform float bloomFactors[NUM_MIPS];uniform vec3 bloomTintColors[NUM_MIPS];float lerpBloomFactor(const in float factor) { 	float mirrorFactor = 1.2 - factor;	return mix(factor, mirrorFactor, bloomRadius);}void main() {	gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + 									 lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + 									 lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + 									 lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + 									 lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );}"
    });
  }
});
UnrealBloomPass.BlurDirectionX = new Vector2(1, 0);
UnrealBloomPass.BlurDirectionY = new Vector2(0, 1);

// node_modules/@react-three/rapier/node_modules/three-stdlib/postprocessing/CubeTexturePass.js
var CubeTexturePass = function(camera, envMap, opacity) {
  this.camera = camera;
  this.needsSwap = false;
  this.cubeShader = ShaderLib["cube"];
  this.cubeMesh = new Mesh(new BoxGeometry(10, 10, 10), new ShaderMaterial({
    uniforms: UniformsUtils.clone(this.cubeShader.uniforms),
    vertexShader: this.cubeShader.vertexShader,
    fragmentShader: this.cubeShader.fragmentShader,
    depthTest: false,
    depthWrite: false,
    side: BackSide
  }));
  Object.defineProperty(this.cubeMesh.material, "envMap", {
    get: function() {
      return this.uniforms.envMap.value;
    }
  });
  this.envMap = envMap;
  this.opacity = opacity !== void 0 ? opacity : 1;
  this.cubeScene = new Scene();
  this.cubeCamera = new PerspectiveCamera();
  this.cubeScene.add(this.cubeMesh);
};
CubeTexturePass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: CubeTexturePass,
  render: function(renderer, writeBuffer, readBuffer) {
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);
    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);
    this.cubeMesh.material.uniforms.envMap.value = this.envMap;
    this.cubeMesh.material.uniforms.flipEnvMap.value = this.envMap.isCubeTexture && this.envMap._needsFlipEnvMap ? -1 : 1;
    this.cubeMesh.material.uniforms.opacity.value = this.opacity;
    this.cubeMesh.material.transparent = this.opacity < 1;
    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.cubeScene, this.cubeCamera);
    renderer.autoClear = oldAutoClear;
  }
});

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/SAOShader.js
var SAOShader = {
  defines: {
    NUM_SAMPLES: 7,
    NUM_RINGS: 4,
    NORMAL_TEXTURE: 0,
    DIFFUSE_TEXTURE: 0,
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    tNormal: {
      value: null
    },
    size: {
      value: new Vector2(512, 512)
    },
    cameraNear: {
      value: 1
    },
    cameraFar: {
      value: 100
    },
    cameraProjectionMatrix: {
      value: new Matrix4()
    },
    cameraInverseProjectionMatrix: {
      value: new Matrix4()
    },
    scale: {
      value: 1
    },
    intensity: {
      value: 0.1
    },
    bias: {
      value: 0.5
    },
    minResolution: {
      value: 0
    },
    kernelRadius: {
      value: 100
    },
    randomSeed: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", "varying vec2 vUv;", "#if DIFFUSE_TEXTURE == 1", "uniform sampler2D tDiffuse;", "#endif", "uniform sampler2D tDepth;", "#if NORMAL_TEXTURE == 1", "uniform sampler2D tNormal;", "#endif", "uniform float cameraNear;", "uniform float cameraFar;", "uniform mat4 cameraProjectionMatrix;", "uniform mat4 cameraInverseProjectionMatrix;", "uniform float scale;", "uniform float intensity;", "uniform float bias;", "uniform float kernelRadius;", "uniform float minResolution;", "uniform vec2 size;", "uniform float randomSeed;", "// RGBA depth", "#include <packing>", "vec4 getDefaultColor( const in vec2 screenPosition ) {", "	#if DIFFUSE_TEXTURE == 1", "	return texture2D( tDiffuse, vUv );", "	#else", "	return vec4( 1.0 );", "	#endif", "}", "float getDepth( const in vec2 screenPosition ) {", "	#if DEPTH_PACKING == 1", "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "	#else", "	return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "float getViewZ( const in float depth ) {", "	#if PERSPECTIVE_CAMERA == 1", "	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );", "	#else", "	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );", "	#endif", "}", "vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {", "	float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];", "	vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );", "	clipPosition *= clipW; // unprojection.", "	return ( cameraInverseProjectionMatrix * clipPosition ).xyz;", "}", "vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {", "	#if NORMAL_TEXTURE == 1", "	return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );", "	#else", "	return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );", "	#endif", "}", "float scaleDividedByCameraFar;", "float minResolutionMultipliedByCameraFar;", "float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {", "	vec3 viewDelta = sampleViewPosition - centerViewPosition;", "	float viewDistance = length( viewDelta );", "	float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;", "	return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );", "}", "// moving costly divides into consts", "const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );", "const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );", "float getAmbientOcclusion( const in vec3 centerViewPosition ) {", "	// precompute some variables require in getOcclusion.", "	scaleDividedByCameraFar = scale / cameraFar;", "	minResolutionMultipliedByCameraFar = minResolution * cameraFar;", "	vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );", "	// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/", "	float angle = rand( vUv + randomSeed ) * PI2;", "	vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;", "	vec2 radiusStep = radius;", "	float occlusionSum = 0.0;", "	float weightSum = 0.0;", "	for( int i = 0; i < NUM_SAMPLES; i ++ ) {", "		vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;", "		radius += radiusStep;", "		angle += ANGLE_STEP;", "		float sampleDepth = getDepth( sampleUv );", "		if( sampleDepth >= ( 1.0 - EPSILON ) ) {", "			continue;", "		}", "		float sampleViewZ = getViewZ( sampleDepth );", "		vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );", "		occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );", "		weightSum += 1.0;", "	}", "	if( weightSum == 0.0 ) discard;", "	return occlusionSum * ( intensity / weightSum );", "}", "void main() {", "	float centerDepth = getDepth( vUv );", "	if( centerDepth >= ( 1.0 - EPSILON ) ) {", "		discard;", "	}", "	float centerViewZ = getViewZ( centerDepth );", "	vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );", "	float ambientOcclusion = getAmbientOcclusion( viewPosition );", "	gl_FragColor = getDefaultColor( vUv );", "	gl_FragColor.xyz *=  1.0 - ambientOcclusion;", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js
var DepthLimitedBlurShader = {
  defines: {
    KERNEL_RADIUS: 4,
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    size: {
      value: new Vector2(512, 512)
    },
    sampleUvOffsets: {
      value: [new Vector2(0, 0)]
    },
    sampleWeights: {
      value: [1]
    },
    tDepth: {
      value: null
    },
    cameraNear: {
      value: 10
    },
    cameraFar: {
      value: 1e3
    },
    depthCutoff: {
      value: 10
    }
  },
  vertexShader: ["#include <common>", "uniform vec2 size;", "varying vec2 vUv;", "varying vec2 vInvSize;", "void main() {", "	vUv = uv;", "	vInvSize = 1.0 / size;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["#include <common>", "#include <packing>", "uniform sampler2D tDiffuse;", "uniform sampler2D tDepth;", "uniform float cameraNear;", "uniform float cameraFar;", "uniform float depthCutoff;", "uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];", "uniform float sampleWeights[ KERNEL_RADIUS + 1 ];", "varying vec2 vUv;", "varying vec2 vInvSize;", "float getDepth( const in vec2 screenPosition ) {", "	#if DEPTH_PACKING == 1", "	return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );", "	#else", "	return texture2D( tDepth, screenPosition ).x;", "	#endif", "}", "float getViewZ( const in float depth ) {", "	#if PERSPECTIVE_CAMERA == 1", "	return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );", "	#else", "	return orthographicDepthToViewZ( depth, cameraNear, cameraFar );", "	#endif", "}", "void main() {", "	float depth = getDepth( vUv );", "	if( depth >= ( 1.0 - EPSILON ) ) {", "		discard;", "	}", "	float centerViewZ = -getViewZ( depth );", "	bool rBreak = false, lBreak = false;", "	float weightSum = sampleWeights[0];", "	vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;", "	for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {", "		float sampleWeight = sampleWeights[i];", "		vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;", "		vec2 sampleUv = vUv + sampleUvOffset;", "		float viewZ = -getViewZ( getDepth( sampleUv ) );", "		if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;", "		if( ! rBreak ) {", "			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;", "			weightSum += sampleWeight;", "		}", "		sampleUv = vUv - sampleUvOffset;", "		viewZ = -getViewZ( getDepth( sampleUv ) );", "		if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;", "		if( ! lBreak ) {", "			diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;", "			weightSum += sampleWeight;", "		}", "	}", "	gl_FragColor = diffuseSum / weightSum;", "}"].join("\n")
};
var BlurShaderUtils = {
  createSampleWeights: (kernelRadius, stdDev) => {
    const gaussian = (x, stdDev2) => {
      return Math.exp(-(x * x) / (2 * (stdDev2 * stdDev2))) / (Math.sqrt(2 * Math.PI) * stdDev2);
    };
    const weights = [];
    for (let i2 = 0; i2 <= kernelRadius; i2++) {
      weights.push(gaussian(i2, stdDev));
    }
    return weights;
  },
  createSampleOffsets: (kernelRadius, uvIncrement) => {
    const offsets = [];
    for (let i2 = 0; i2 <= kernelRadius; i2++) {
      offsets.push(uvIncrement.clone().multiplyScalar(i2));
    }
    return offsets;
  },
  configure: (shader, kernelRadius, stdDev, uvIncrement) => {
    shader.defines["KERNEL_RADIUS"] = kernelRadius;
    shader.uniforms["sampleUvOffsets"].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);
    shader.uniforms["sampleWeights"].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);
    shader.needsUpdate = true;
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/postprocessing/SAOPass.js
var SAOPass = function(scene, camera, depthTexture, useNormals, resolution) {
  this.scene = scene;
  this.camera = camera;
  this.clear = true;
  this.needsSwap = false;
  this.supportsDepthTextureExtension = depthTexture !== void 0 ? depthTexture : false;
  this.supportsNormalTexture = useNormals !== void 0 ? useNormals : false;
  this.originalClearColor = new Color();
  this._oldClearColor = new Color();
  this.oldClearAlpha = 1;
  this.params = {
    output: 0,
    saoBias: 0.5,
    saoIntensity: 0.18,
    saoScale: 1,
    saoKernelRadius: 100,
    saoMinResolution: 0,
    saoBlur: true,
    saoBlurRadius: 8,
    saoBlurStdDev: 4,
    saoBlurDepthCutoff: 0.01
  };
  this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);
  this.saoRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat
  });
  this.blurIntermediateRenderTarget = this.saoRenderTarget.clone();
  this.beautyRenderTarget = this.saoRenderTarget.clone();
  this.normalRenderTarget = new WebGLRenderTarget(this.resolution.x, this.resolution.y, {
    minFilter: NearestFilter,
    magFilter: NearestFilter,
    format: RGBAFormat
  });
  this.depthRenderTarget = this.normalRenderTarget.clone();
  if (this.supportsDepthTextureExtension) {
    var depthTexture = new DepthTexture();
    depthTexture.type = UnsignedShortType;
    this.beautyRenderTarget.depthTexture = depthTexture;
    this.beautyRenderTarget.depthBuffer = true;
  }
  this.depthMaterial = new MeshDepthMaterial();
  this.depthMaterial.depthPacking = RGBADepthPacking;
  this.depthMaterial.blending = NoBlending;
  this.normalMaterial = new MeshNormalMaterial();
  this.normalMaterial.blending = NoBlending;
  if (SAOShader === void 0) {
    console.error("THREE.SAOPass relies on SAOShader");
  }
  this.saoMaterial = new ShaderMaterial({
    defines: Object.assign({}, SAOShader.defines),
    fragmentShader: SAOShader.fragmentShader,
    vertexShader: SAOShader.vertexShader,
    uniforms: UniformsUtils.clone(SAOShader.uniforms)
  });
  this.saoMaterial.extensions.derivatives = true;
  this.saoMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
  this.saoMaterial.defines["NORMAL_TEXTURE"] = this.supportsNormalTexture ? 1 : 0;
  this.saoMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
  this.saoMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
  this.saoMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
  this.saoMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
  this.saoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
  this.saoMaterial.uniforms["cameraProjectionMatrix"].value = this.camera.projectionMatrix;
  this.saoMaterial.blending = NoBlending;
  if (DepthLimitedBlurShader === void 0) {
    console.error("THREE.SAOPass relies on DepthLimitedBlurShader");
  }
  this.vBlurMaterial = new ShaderMaterial({
    uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),
    defines: Object.assign({}, DepthLimitedBlurShader.defines),
    vertexShader: DepthLimitedBlurShader.vertexShader,
    fragmentShader: DepthLimitedBlurShader.fragmentShader
  });
  this.vBlurMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
  this.vBlurMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
  this.vBlurMaterial.uniforms["tDiffuse"].value = this.saoRenderTarget.texture;
  this.vBlurMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
  this.vBlurMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
  this.vBlurMaterial.blending = NoBlending;
  this.hBlurMaterial = new ShaderMaterial({
    uniforms: UniformsUtils.clone(DepthLimitedBlurShader.uniforms),
    defines: Object.assign({}, DepthLimitedBlurShader.defines),
    vertexShader: DepthLimitedBlurShader.vertexShader,
    fragmentShader: DepthLimitedBlurShader.fragmentShader
  });
  this.hBlurMaterial.defines["DEPTH_PACKING"] = this.supportsDepthTextureExtension ? 0 : 1;
  this.hBlurMaterial.defines["PERSPECTIVE_CAMERA"] = this.camera.isPerspectiveCamera ? 1 : 0;
  this.hBlurMaterial.uniforms["tDiffuse"].value = this.blurIntermediateRenderTarget.texture;
  this.hBlurMaterial.uniforms["tDepth"].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;
  this.hBlurMaterial.uniforms["size"].value.set(this.resolution.x, this.resolution.y);
  this.hBlurMaterial.blending = NoBlending;
  if (CopyShader === void 0) {
    console.error("THREE.SAOPass relies on CopyShader");
  }
  this.materialCopy = new ShaderMaterial({
    uniforms: UniformsUtils.clone(CopyShader.uniforms),
    vertexShader: CopyShader.vertexShader,
    fragmentShader: CopyShader.fragmentShader,
    blending: NoBlending
  });
  this.materialCopy.transparent = true;
  this.materialCopy.depthTest = false;
  this.materialCopy.depthWrite = false;
  this.materialCopy.blending = CustomBlending;
  this.materialCopy.blendSrc = DstColorFactor;
  this.materialCopy.blendDst = ZeroFactor;
  this.materialCopy.blendEquation = AddEquation;
  this.materialCopy.blendSrcAlpha = DstAlphaFactor;
  this.materialCopy.blendDstAlpha = ZeroFactor;
  this.materialCopy.blendEquationAlpha = AddEquation;
  if (UnpackDepthRGBAShader === void 0) {
    console.error("THREE.SAOPass relies on UnpackDepthRGBAShader");
  }
  this.depthCopy = new ShaderMaterial({
    uniforms: UniformsUtils.clone(UnpackDepthRGBAShader.uniforms),
    vertexShader: UnpackDepthRGBAShader.vertexShader,
    fragmentShader: UnpackDepthRGBAShader.fragmentShader,
    blending: NoBlending
  });
  this.fsQuad = new FullScreenQuad(null);
};
SAOPass.OUTPUT = {
  Beauty: 1,
  Default: 0,
  SAO: 2,
  Depth: 3,
  Normal: 4
};
SAOPass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: SAOPass,
  render: function(renderer, writeBuffer, readBuffer) {
    if (this.renderToScreen) {
      this.materialCopy.blending = NoBlending;
      this.materialCopy.uniforms["tDiffuse"].value = readBuffer.texture;
      this.materialCopy.needsUpdate = true;
      this.renderPass(renderer, this.materialCopy, null);
    }
    if (this.params.output === 1) {
      return;
    }
    renderer.getClearColor(this._oldClearColor);
    this.oldClearAlpha = renderer.getClearAlpha();
    var oldAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.setRenderTarget(this.depthRenderTarget);
    renderer.clear();
    this.saoMaterial.uniforms["bias"].value = this.params.saoBias;
    this.saoMaterial.uniforms["intensity"].value = this.params.saoIntensity;
    this.saoMaterial.uniforms["scale"].value = this.params.saoScale;
    this.saoMaterial.uniforms["kernelRadius"].value = this.params.saoKernelRadius;
    this.saoMaterial.uniforms["minResolution"].value = this.params.saoMinResolution;
    this.saoMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.saoMaterial.uniforms["cameraFar"].value = this.camera.far;
    var depthCutoff = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);
    this.vBlurMaterial.uniforms["depthCutoff"].value = depthCutoff;
    this.hBlurMaterial.uniforms["depthCutoff"].value = depthCutoff;
    this.vBlurMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.vBlurMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.hBlurMaterial.uniforms["cameraNear"].value = this.camera.near;
    this.hBlurMaterial.uniforms["cameraFar"].value = this.camera.far;
    this.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius);
    if (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) {
      BlurShaderUtils.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(0, 1));
      BlurShaderUtils.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new Vector2(1, 0));
      this.prevStdDev = this.params.saoBlurStdDev;
      this.prevNumSamples = this.params.saoBlurRadius;
    }
    renderer.setClearColor(0);
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    renderer.render(this.scene, this.camera);
    if (!this.supportsDepthTextureExtension) {
      this.renderOverride(renderer, this.depthMaterial, this.depthRenderTarget, 0, 1);
    }
    if (this.supportsNormalTexture) {
      this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 7829503, 1);
    }
    this.renderPass(renderer, this.saoMaterial, this.saoRenderTarget, 16777215, 1);
    if (this.params.saoBlur) {
      this.renderPass(renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 16777215, 1);
      this.renderPass(renderer, this.hBlurMaterial, this.saoRenderTarget, 16777215, 1);
    }
    var outputMaterial = this.materialCopy;
    if (this.params.output === 3) {
      if (this.supportsDepthTextureExtension) {
        this.materialCopy.uniforms["tDiffuse"].value = this.beautyRenderTarget.depthTexture;
        this.materialCopy.needsUpdate = true;
      } else {
        this.depthCopy.uniforms["tDiffuse"].value = this.depthRenderTarget.texture;
        this.depthCopy.needsUpdate = true;
        outputMaterial = this.depthCopy;
      }
    } else if (this.params.output === 4) {
      this.materialCopy.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
      this.materialCopy.needsUpdate = true;
    } else {
      this.materialCopy.uniforms["tDiffuse"].value = this.saoRenderTarget.texture;
      this.materialCopy.needsUpdate = true;
    }
    if (this.params.output === 0) {
      outputMaterial.blending = CustomBlending;
    } else {
      outputMaterial.blending = NoBlending;
    }
    this.renderPass(renderer, outputMaterial, this.renderToScreen ? null : readBuffer);
    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
    renderer.autoClear = oldAutoClear;
  },
  renderPass: function(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    var originalClearAlpha = renderer.getClearAlpha();
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  renderOverride: function(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    renderer.getClearColor(this.originalClearColor);
    var originalClearAlpha = renderer.getClearAlpha();
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  setSize: function(width, height) {
    this.beautyRenderTarget.setSize(width, height);
    this.saoRenderTarget.setSize(width, height);
    this.blurIntermediateRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.depthRenderTarget.setSize(width, height);
    this.saoMaterial.uniforms["size"].value.set(width, height);
    this.saoMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.saoMaterial.uniforms["cameraProjectionMatrix"].value = this.camera.projectionMatrix;
    this.saoMaterial.needsUpdate = true;
    this.vBlurMaterial.uniforms["size"].value.set(width, height);
    this.vBlurMaterial.needsUpdate = true;
    this.hBlurMaterial.uniforms["size"].value.set(width, height);
    this.hBlurMaterial.needsUpdate = true;
  }
});

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/AfterimageShader.js
var AfterimageShader = {
  uniforms: {
    damp: {
      value: 0.96
    },
    tOld: {
      value: null
    },
    tNew: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float damp;", "uniform sampler2D tOld;", "uniform sampler2D tNew;", "varying vec2 vUv;", "vec4 when_gt( vec4 x, float y ) {", "	return max( sign( x - y ), 0.0 );", "}", "void main() {", "	vec4 texelOld = texture2D( tOld, vUv );", "	vec4 texelNew = texture2D( tNew, vUv );", "	texelOld *= damp * when_gt( texelOld, 0.1 );", "	gl_FragColor = max(texelNew, texelOld);", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/DotScreenShader.js
var DotScreenShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    tSize: {
      value: new Vector2(256, 256)
    },
    center: {
      value: new Vector2(0.5, 0.5)
    },
    angle: {
      value: 1.57
    },
    scale: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform vec2 center;", "uniform float angle;", "uniform float scale;", "uniform vec2 tSize;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "float pattern() {", "	float s = sin( angle ), c = cos( angle );", "	vec2 tex = vUv * tSize - center;", "	vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;", "	return ( sin( point.x ) * sin( point.y ) ) * 4.0;", "}", "void main() {", "	vec4 color = texture2D( tDiffuse, vUv );", "	float average = ( color.r + color.g + color.b ) / 3.0;", "	gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/SSRShader.js
var SSRShader = {
  defines: {
    MAX_STEP: 0,
    isPerspectiveCamera: true,
    isDistanceAttenuation: true,
    isFresnel: true,
    isInfiniteThick: false,
    isSelective: false
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    tNormal: {
      value: null
    },
    tMetalness: {
      value: null
    },
    tDepth: {
      value: null
    },
    cameraNear: {
      value: null
    },
    cameraFar: {
      value: null
    },
    resolution: {
      value: new Vector2()
    },
    cameraProjectionMatrix: {
      value: new Matrix4()
    },
    cameraInverseProjectionMatrix: {
      value: new Matrix4()
    },
    opacity: {
      value: 0.5
    },
    maxDistance: {
      value: 180
    },
    cameraRange: {
      value: 0
    },
    surfDist: {
      value: 7e-3
    },
    thickTolerance: {
      value: 0.03
    }
  },
  vertexShader: (
    /* glsl */
    `

    varying vec2 vUv;

    void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `
  ),
  fragmentShader: (
    /* glsl */
    `
		// precision highp float;
		precision highp sampler2D;
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
		uniform sampler2D tMetalness;
		uniform sampler2D tDiffuse;
		uniform float cameraRange;
		uniform vec2 resolution;
		uniform float opacity;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float maxDistance;
		uniform float surfDist;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		uniform float thickTolerance;
		#include <packing>
		float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
			//x0: point, x1: linePointA, x2: linePointB
			//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
			return length(cross(x0-x1,x0-x2))/length(x2-x1);
		}
		float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){
			// https://mathworld.wolfram.com/Point-PlaneDistance.html
			//// https://en.wikipedia.org/wiki/Plane_(geometry)
			//// http://paulbourke.net/geometry/pointlineplane/
			float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;
			float x0=point.x,y0=point.y,z0=point.z;
			float x=planePoint.x,y=planePoint.y,z=planePoint.z;
			float d=-(a*x+b*y+c*z);
			float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);
			return distance;
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			#ifdef isPerspectiveCamera
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view
		}
		vec3 getViewNormal( const in vec2 uv ) {
			return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );
		}
		vec2 viewPositionToXY(vec3 viewPosition){
			vec2 xy;
			vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);
			xy=clip.xy;//clip
			float clipW=clip.w;
			xy/=clipW;//NDC
			xy=(xy+1.)/2.;//uv
			xy*=resolution;//screen
			return xy;
		}
		void main(){
			#ifdef isSelective
				float metalness=texture2D(tMetalness,vUv).r;
				if(metalness==0.) return;
			#endif

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
			if(-viewZ>=cameraFar) return;

			float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];
			vec3 viewPosition=getViewPosition( vUv, depth, clipW );

			vec2 d0=gl_FragCoord.xy;
			vec2 d1;

			vec3 viewNormal=getViewNormal( vUv );

			#ifdef isPerspectiveCamera
				vec3 viewIncidenceDir=normalize(viewPosition);
				vec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);
			#else
				vec3 viewIncidenceDir=vec3(0,0,-1);
				vec3 viewReflectDir=reflect(viewIncidenceDir,viewNormal);
			#endif

			float maxReflectRayLen=maxDistance/dot(-viewIncidenceDir,viewNormal);
			// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
			// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
			// maxDistance/maxReflectRayLen=cos(theta)
			// maxDistance/maxReflectRayLen==dot(a,b)
			// maxReflectRayLen==maxDistance/dot(a,b)

			vec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;
			#ifdef isPerspectiveCamera
				if(d1viewPosition.z>-cameraNear){
					//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
					float t=(-cameraNear-viewPosition.z)/viewReflectDir.z;
					d1viewPosition=viewPosition+viewReflectDir*t;
				}
			#endif
			d1=viewPositionToXY(d1viewPosition);

			float totalLen=length(d1-d0);
			float xLen=d1.x-d0.x;
			float yLen=d1.y-d0.y;
			float totalStep=max(abs(xLen),abs(yLen));
			float xSpan=xLen/totalStep;
			float ySpan=yLen/totalStep;
			for(float i=0.;i<MAX_STEP;i++){
				if(i>=totalStep) break;
				vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);
				if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;
				float s=length(xy-d0)/totalLen;
				vec2 uv=xy/resolution;

				float d = getDepth(uv);
				float vZ = getViewZ( d );
				if(-vZ>=cameraFar) continue;
				float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];
				vec3 vP=getViewPosition( uv, d, cW );

				#ifdef isPerspectiveCamera
					// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
					float recipVPZ=1./viewPosition.z;
					float viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));
					float sD=surfDist*cW;
				#else
					float viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);
					float sD=surfDist;
				#endif
				if(viewReflectRayZ-sD>vZ) continue;

				#ifdef isInfiniteThick
					if(viewReflectRayZ+thickTolerance*clipW<vP.z) break;
				#endif
				float away=pointToLineDistance(vP,viewPosition,d1viewPosition);

				float op=opacity;

				if(away<sD){
					vec3 vN=getViewNormal( uv );
					if(dot(viewReflectDir,vN)>=0.) continue;
					float distance=pointPlaneDistance(vP,viewPosition,viewNormal);
					if(distance>maxDistance) break;
					#ifdef isDistanceAttenuation
						float ratio=1.-(distance/maxDistance);
						float attenuation=ratio*ratio;
						op=opacity*attenuation;
					#endif
					#ifdef isFresnel
						float fresnel=(dot(viewIncidenceDir,viewReflectDir)+1.)/2.;
						op*=fresnel;
					#endif
					vec4 reflectColor=texture2D(tDiffuse,uv);
					gl_FragColor.xyz=reflectColor.xyz;
					gl_FragColor.a=op;
					break;
				}
			}
		}
	`
  )
};
var SSRDepthShader = {
  defines: {
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: {
      value: null
    },
    cameraNear: {
      value: null
    },
    cameraFar: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `

    varying vec2 vUv;

    void main() {

    	vUv = uv;
    	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `
  ),
  fragmentShader: (
    /* glsl */
    `

    uniform sampler2D tDepth;

    uniform float cameraNear;
    uniform float cameraFar;

    varying vec2 vUv;

    #include <packing>

		float getLinearDepth( const in vec2 uv ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, uv ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, uv ).x;

			#endif

		}

    void main() {

    	float depth = getLinearDepth( vUv );
			float d = 1.0 - depth;
			// d=(d-.999)*1000.;
    	gl_FragColor = vec4( vec3( d ), 1.0 );

    }

  `
  )
};
var SSRBlurShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2()
    },
    opacity: {
      value: 0.5
    }
  },
  vertexShader: (
    /* glsl */
    `

    varying vec2 vUv;

    void main() {

    	vUv = uv;
    	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  `
  ),
  fragmentShader: (
    /* glsl */
    `

    uniform sampler2D tDiffuse;
    uniform vec2 resolution;
    varying vec2 vUv;
    void main() {
			//reverse engineering from PhotoShop blur filter, then change coefficient

    	vec2 texelSize = ( 1.0 / resolution );

			vec4 c=texture2D(tDiffuse,vUv);

			vec2 offset;

			offset=(vec2(-1,0))*texelSize;
			vec4 cl=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(1,0))*texelSize;
			vec4 cr=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,-1))*texelSize;
			vec4 cb=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,1))*texelSize;
			vec4 ct=texture2D(tDiffuse,vUv+offset);

			// float coeCenter=.5;
			// float coeSide=.125;
			float coeCenter=.2;
			float coeSide=.2;
			float a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;
			vec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;
			gl_FragColor=vec4(rgb,a);

		}
	`
  )
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/postprocessing/SSRPass.js
var SSRPass = function({
  renderer,
  scene,
  camera,
  width,
  height,
  selects,
  encoding,
  isPerspectiveCamera = true,
  isBouncing = false,
  morphTargets = false,
  groundReflector
}) {
  this.width = width !== void 0 ? width : 512;
  this.height = height !== void 0 ? height : 512;
  this.clear = true;
  this.renderer = renderer;
  this.scene = scene;
  this.camera = camera;
  this.groundReflector = groundReflector;
  this.opacity = SSRShader.uniforms.opacity.value;
  this.output = 0;
  this.maxDistance = SSRShader.uniforms.maxDistance.value;
  this.surfDist = SSRShader.uniforms.surfDist.value;
  this.encoding = encoding;
  this.tempColor = new Color();
  this._selects = selects;
  this.isSelective = Array.isArray(this._selects);
  Object.defineProperty(this, "selects", {
    get() {
      return this._selects;
    },
    set(val) {
      if (this._selects === val)
        return;
      this._selects = val;
      if (Array.isArray(val)) {
        this.isSelective = true;
        this.ssrMaterial.defines.isSelective = true;
        this.ssrMaterial.needsUpdate = true;
      } else {
        this.isSelective = false;
        this.ssrMaterial.defines.isSelective = false;
        this.ssrMaterial.needsUpdate = true;
      }
    }
  });
  this._isBouncing = isBouncing;
  Object.defineProperty(this, "isBouncing", {
    get() {
      return this._isBouncing;
    },
    set(val) {
      if (this._isBouncing === val)
        return;
      this._isBouncing = val;
      if (val) {
        this.ssrMaterial.uniforms["tDiffuse"].value = this.prevRenderTarget.texture;
      } else {
        this.ssrMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
      }
    }
  });
  this.isBlur = true;
  this._isDistanceAttenuation = SSRShader.defines.isDistanceAttenuation;
  Object.defineProperty(this, "isDistanceAttenuation", {
    get() {
      return this._isDistanceAttenuation;
    },
    set(val) {
      if (this._isDistanceAttenuation === val)
        return;
      this._isDistanceAttenuation = val;
      this.ssrMaterial.defines.isDistanceAttenuation = val;
      this.ssrMaterial.needsUpdate = true;
    }
  });
  this._isFresnel = SSRShader.defines.isFresnel;
  Object.defineProperty(this, "isFresnel", {
    get() {
      return this._isFresnel;
    },
    set(val) {
      if (this._isFresnel === val)
        return;
      this._isFresnel = val;
      this.ssrMaterial.defines.isFresnel = val;
      this.ssrMaterial.needsUpdate = true;
    }
  });
  this._isInfiniteThick = SSRShader.defines.isInfiniteThick;
  Object.defineProperty(this, "isInfiniteThick", {
    get() {
      return this._isInfiniteThick;
    },
    set(val) {
      if (this._isInfiniteThick === val)
        return;
      this._isInfiniteThick = val;
      this.ssrMaterial.defines.isInfiniteThick = val;
      this.ssrMaterial.needsUpdate = true;
    }
  });
  this.thickTolerance = SSRShader.uniforms.thickTolerance.value;
  var depthTexture = new DepthTexture();
  depthTexture.type = UnsignedShortType;
  depthTexture.minFilter = NearestFilter;
  depthTexture.maxFilter = NearestFilter;
  this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat,
    depthTexture,
    depthBuffer: true
  });
  this.prevRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat
  });
  this.normalRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: NearestFilter,
    magFilter: NearestFilter,
    format: RGBAFormat,
    type: HalfFloatType
  });
  this.metalnessRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: NearestFilter,
    magFilter: NearestFilter,
    format: RGBAFormat
  });
  this.ssrRenderTarget = new WebGLRenderTarget(this.width, this.height, {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBAFormat
  });
  this.blurRenderTarget = this.ssrRenderTarget.clone();
  this.blurRenderTarget2 = this.ssrRenderTarget.clone();
  if (SSRShader === void 0) {
    console.error("THREE.SSRPass: The pass relies on SSRShader.");
  }
  this.ssrMaterial = new ShaderMaterial({
    defines: Object.assign({
      MAX_STEP: Math.sqrt(window.innerWidth * window.innerWidth + window.innerHeight * window.innerHeight)
    }, SSRShader.defines),
    uniforms: UniformsUtils.clone(SSRShader.uniforms),
    vertexShader: SSRShader.vertexShader,
    fragmentShader: SSRShader.fragmentShader,
    blending: NoBlending
  });
  if (!isPerspectiveCamera) {
    this.ssrMaterial.defines.isPerspectiveCamera = isPerspectiveCamera;
    this.ssrMaterial.needsUpdate = true;
  }
  this.ssrMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
  this.ssrMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
  this.ssrMaterial.defines.isSelective = this.isSelective;
  this.ssrMaterial.needsUpdate = true;
  this.ssrMaterial.uniforms["tMetalness"].value = this.metalnessRenderTarget.texture;
  this.ssrMaterial.uniforms["tDepth"].value = this.beautyRenderTarget.depthTexture;
  this.ssrMaterial.uniforms["cameraNear"].value = this.camera.near;
  this.ssrMaterial.uniforms["cameraFar"].value = this.camera.far;
  this.ssrMaterial.uniforms["surfDist"].value = this.surfDist;
  this.ssrMaterial.uniforms["resolution"].value.set(this.width, this.height);
  this.ssrMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
  this.ssrMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
  this.normalMaterial = new MeshNormalMaterial({
    morphTargets
  });
  this.normalMaterial.blending = NoBlending;
  this.metalnessOnMaterial = new MeshBasicMaterial({
    color: "white"
  });
  this.metalnessOffMaterial = new MeshBasicMaterial({
    color: "black"
  });
  this.blurMaterial = new ShaderMaterial({
    defines: Object.assign({}, SSRBlurShader.defines),
    uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),
    vertexShader: SSRBlurShader.vertexShader,
    fragmentShader: SSRBlurShader.fragmentShader
  });
  this.blurMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
  this.blurMaterial.uniforms["resolution"].value.set(this.width, this.height);
  this.blurMaterial2 = new ShaderMaterial({
    defines: Object.assign({}, SSRBlurShader.defines),
    uniforms: UniformsUtils.clone(SSRBlurShader.uniforms),
    vertexShader: SSRBlurShader.vertexShader,
    fragmentShader: SSRBlurShader.fragmentShader
  });
  this.blurMaterial2.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
  this.blurMaterial2.uniforms["resolution"].value.set(this.width, this.height);
  this.depthRenderMaterial = new ShaderMaterial({
    defines: Object.assign({}, SSRDepthShader.defines),
    uniforms: UniformsUtils.clone(SSRDepthShader.uniforms),
    vertexShader: SSRDepthShader.vertexShader,
    fragmentShader: SSRDepthShader.fragmentShader,
    blending: NoBlending
  });
  this.depthRenderMaterial.uniforms["tDepth"].value = this.beautyRenderTarget.depthTexture;
  this.depthRenderMaterial.uniforms["cameraNear"].value = this.camera.near;
  this.depthRenderMaterial.uniforms["cameraFar"].value = this.camera.far;
  this.copyMaterial = new ShaderMaterial({
    uniforms: UniformsUtils.clone(CopyShader.uniforms),
    vertexShader: CopyShader.vertexShader,
    fragmentShader: CopyShader.fragmentShader,
    transparent: true,
    depthTest: false,
    depthWrite: false,
    blendSrc: SrcAlphaFactor,
    blendDst: OneMinusSrcAlphaFactor,
    blendEquation: AddEquation,
    blendSrcAlpha: SrcAlphaFactor,
    blendDstAlpha: OneMinusSrcAlphaFactor,
    blendEquationAlpha: AddEquation
    // premultipliedAlpha:true,
  });
  this.fsQuad = new FullScreenQuad(null);
  this.originalClearColor = new Color();
};
SSRPass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: SSRPass,
  dispose: function() {
    this.beautyRenderTarget.dispose();
    this.prevRenderTarget.dispose();
    this.normalRenderTarget.dispose();
    this.metalnessRenderTarget.dispose();
    this.ssrRenderTarget.dispose();
    this.blurRenderTarget.dispose();
    this.blurRenderTarget2.dispose();
    this.normalMaterial.dispose();
    this.metalnessOnMaterial.dispose();
    this.metalnessOffMaterial.dispose();
    this.blurMaterial.dispose();
    this.blurMaterial2.dispose();
    this.copyMaterial.dispose();
    this.depthRenderMaterial.dispose();
    this.fsQuad.dispose();
  },
  render: function(renderer, writeBuffer) {
    if (this.encoding)
      this.beautyRenderTarget.texture.encoding = this.encoding;
    renderer.setRenderTarget(this.beautyRenderTarget);
    renderer.clear();
    if (this.groundReflector) {
      this.groundReflector.doRender(this.renderer, this.scene, this.camera);
      this.groundReflector.visible = true;
    }
    renderer.render(this.scene, this.camera);
    if (this.groundReflector)
      this.groundReflector.visible = false;
    this.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0, 0);
    if (this.isSelective) {
      this.renderMetalness(renderer, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0);
    }
    this.ssrMaterial.uniforms["opacity"].value = this.opacity;
    this.ssrMaterial.uniforms["maxDistance"].value = this.maxDistance;
    this.ssrMaterial.uniforms["surfDist"].value = this.surfDist;
    this.ssrMaterial.uniforms["thickTolerance"].value = this.thickTolerance;
    this.renderPass(renderer, this.ssrMaterial, this.ssrRenderTarget);
    if (this.isBlur) {
      this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);
      this.renderPass(renderer, this.blurMaterial2, this.blurRenderTarget2);
    }
    switch (this.output) {
      case SSRPass.OUTPUT.Default:
        if (this.isBouncing) {
          this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          if (this.isBlur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          this.copyMaterial.uniforms["tDiffuse"].value = this.prevRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        } else {
          this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
          if (this.isBlur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        }
        break;
      case SSRPass.OUTPUT.SSR:
        if (this.isBlur)
          this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
        else
          this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        if (this.isBouncing) {
          if (this.isBlur)
            this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget2.texture;
          else
            this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
          this.copyMaterial.blending = NoBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
          this.copyMaterial.uniforms["tDiffuse"].value = this.ssrRenderTarget.texture;
          this.copyMaterial.blending = NormalBlending;
          this.renderPass(renderer, this.copyMaterial, this.prevRenderTarget);
        }
        break;
      case SSRPass.OUTPUT.Beauty:
        this.copyMaterial.uniforms["tDiffuse"].value = this.beautyRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSRPass.OUTPUT.Depth:
        this.renderPass(renderer, this.depthRenderMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSRPass.OUTPUT.Normal:
        this.copyMaterial.uniforms["tDiffuse"].value = this.normalRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      case SSRPass.OUTPUT.Metalness:
        this.copyMaterial.uniforms["tDiffuse"].value = this.metalnessRenderTarget.texture;
        this.copyMaterial.blending = NoBlending;
        this.renderPass(renderer, this.copyMaterial, this.renderToScreen ? null : writeBuffer);
        break;
      default:
        console.warn("THREE.SSRPass: Unknown output type.");
    }
  },
  renderPass: function(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.fsQuad.material = passMaterial;
    this.fsQuad.render(renderer);
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  renderOverride: function(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.overrideMaterial = overrideMaterial;
    renderer.render(this.scene, this.camera);
    this.scene.overrideMaterial = null;
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  renderMetalness: function(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {
    this.originalClearColor.copy(renderer.getClearColor(this.tempColor));
    var originalClearAlpha = renderer.getClearAlpha(this.tempColor);
    var originalAutoClear = renderer.autoClear;
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = false;
    clearColor = overrideMaterial.clearColor || clearColor;
    clearAlpha = overrideMaterial.clearAlpha || clearAlpha;
    if (clearColor !== void 0 && clearColor !== null) {
      renderer.setClearColor(clearColor);
      renderer.setClearAlpha(clearAlpha || 0);
      renderer.clear();
    }
    this.scene.traverseVisible((child) => {
      child._SSRPassMaterialBack = child.material;
      if (this._selects.includes(child)) {
        child.material = this.metalnessOnMaterial;
      } else {
        child.material = this.metalnessOffMaterial;
      }
    });
    renderer.render(this.scene, this.camera);
    this.scene.traverseVisible((child) => {
      child.material = child._SSRPassMaterialBack;
    });
    renderer.autoClear = originalAutoClear;
    renderer.setClearColor(this.originalClearColor);
    renderer.setClearAlpha(originalClearAlpha);
  },
  setSize: function(width, height) {
    this.width = width;
    this.height = height;
    this.ssrMaterial.defines.MAX_STEP = Math.sqrt(width * width + height * height);
    this.ssrMaterial.needsUpdate = true;
    this.beautyRenderTarget.setSize(width, height);
    this.prevRenderTarget.setSize(width, height);
    this.ssrRenderTarget.setSize(width, height);
    this.normalRenderTarget.setSize(width, height);
    this.metalnessRenderTarget.setSize(width, height);
    this.blurRenderTarget.setSize(width, height);
    this.blurRenderTarget2.setSize(width, height);
    this.ssrMaterial.uniforms["resolution"].value.set(width, height);
    this.ssrMaterial.uniforms["cameraProjectionMatrix"].value.copy(this.camera.projectionMatrix);
    this.ssrMaterial.uniforms["cameraInverseProjectionMatrix"].value.copy(this.camera.projectionMatrixInverse);
    this.blurMaterial.uniforms["resolution"].value.set(width, height);
    this.blurMaterial2.uniforms["resolution"].value.set(width, height);
  }
});
SSRPass.OUTPUT = {
  Default: 0,
  SSR: 1,
  Beauty: 3,
  Depth: 4,
  Normal: 5,
  Metalness: 7
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/postprocessing/SSAARenderPass.js
var SSAARenderPass = function(scene, camera, clearColor, clearAlpha) {
  this.scene = scene;
  this.camera = camera;
  this.sampleLevel = 4;
  this.unbiased = true;
  this.clearColor = clearColor !== void 0 ? clearColor : 0;
  this.clearAlpha = clearAlpha !== void 0 ? clearAlpha : 0;
  this._oldClearColor = new Color();
  if (CopyShader === void 0)
    console.error("THREE.SSAARenderPass relies on CopyShader");
  var copyShader = CopyShader;
  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
  this.copyMaterial = new ShaderMaterial({
    uniforms: this.copyUniforms,
    vertexShader: copyShader.vertexShader,
    fragmentShader: copyShader.fragmentShader,
    premultipliedAlpha: true,
    transparent: true,
    blending: AdditiveBlending,
    depthTest: false,
    depthWrite: false
  });
  this.fsQuad = new FullScreenQuad(this.copyMaterial);
};
SSAARenderPass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: SSAARenderPass,
  dispose: function() {
    if (this.sampleRenderTarget) {
      this.sampleRenderTarget.dispose();
      this.sampleRenderTarget = null;
    }
  },
  setSize: function(width, height) {
    if (this.sampleRenderTarget)
      this.sampleRenderTarget.setSize(width, height);
  },
  render: function(renderer, writeBuffer, readBuffer) {
    if (!this.sampleRenderTarget) {
      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        format: RGBAFormat
      });
      this.sampleRenderTarget.texture.name = "SSAARenderPass.sample";
    }
    var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];
    var autoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.getClearColor(this._oldClearColor);
    var oldClearAlpha = renderer.getClearAlpha();
    var baseSampleWeight = 1 / jitterOffsets.length;
    var roundingRange = 1 / 32;
    this.copyUniforms["tDiffuse"].value = this.sampleRenderTarget.texture;
    var width = readBuffer.width, height = readBuffer.height;
    for (let i2 = 0; i2 < jitterOffsets.length; i2++) {
      var jitterOffset = jitterOffsets[i2];
      if (this.camera.setViewOffset) {
        this.camera.setViewOffset(
          width,
          height,
          jitterOffset[0] * 0.0625,
          jitterOffset[1] * 0.0625,
          // 0.0625 = 1 / 16
          width,
          height
        );
      }
      var sampleWeight = baseSampleWeight;
      if (this.unbiased) {
        var uniformCenteredDistribution = -0.5 + (i2 + 0.5) / jitterOffsets.length;
        sampleWeight += roundingRange * uniformCenteredDistribution;
      }
      this.copyUniforms["opacity"].value = sampleWeight;
      renderer.setClearColor(this.clearColor, this.clearAlpha);
      renderer.setRenderTarget(this.sampleRenderTarget);
      renderer.clear();
      renderer.render(this.scene, this.camera);
      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
      if (i2 === 0) {
        renderer.setClearColor(0, 0);
        renderer.clear();
      }
      this.fsQuad.render(renderer);
    }
    if (this.camera.clearViewOffset)
      this.camera.clearViewOffset();
    renderer.autoClear = autoClear;
    renderer.setClearColor(this._oldClearColor, oldClearAlpha);
  }
});
SSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];

// node_modules/@react-three/rapier/node_modules/three-stdlib/postprocessing/TAARenderPass.js
var TAARenderPass = function(scene, camera, clearColor, clearAlpha) {
  if (SSAARenderPass === void 0) {
    console.error("THREE.TAARenderPass relies on SSAARenderPass");
  }
  SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);
  this.sampleLevel = 0;
  this.accumulate = false;
};
TAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;
TAARenderPass.prototype = Object.assign(Object.create(SSAARenderPass.prototype), {
  constructor: TAARenderPass,
  render: function(renderer, writeBuffer, readBuffer, deltaTime) {
    if (!this.accumulate) {
      SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);
      this.accumulateIndex = -1;
      return;
    }
    var jitterOffsets = TAARenderPass.JitterVectors[5];
    if (!this.sampleRenderTarget) {
      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);
      this.sampleRenderTarget.texture.name = "TAARenderPass.sample";
    }
    if (!this.holdRenderTarget) {
      this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);
      this.holdRenderTarget.texture.name = "TAARenderPass.hold";
    }
    if (this.accumulate && this.accumulateIndex === -1) {
      SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);
      this.accumulateIndex = 0;
    }
    var autoClear = renderer.autoClear;
    renderer.autoClear = false;
    var sampleWeight = 1 / jitterOffsets.length;
    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {
      this.copyUniforms["opacity"].value = sampleWeight;
      this.copyUniforms["tDiffuse"].value = writeBuffer.texture;
      var numSamplesPerFrame = Math.pow(2, this.sampleLevel);
      for (let i2 = 0; i2 < numSamplesPerFrame; i2++) {
        var j2 = this.accumulateIndex;
        var jitterOffset = jitterOffsets[j2];
        if (this.camera.setViewOffset) {
          this.camera.setViewOffset(
            readBuffer.width,
            readBuffer.height,
            jitterOffset[0] * 0.0625,
            jitterOffset[1] * 0.0625,
            // 0.0625 = 1 / 16
            readBuffer.width,
            readBuffer.height
          );
        }
        renderer.setRenderTarget(writeBuffer);
        renderer.clear();
        renderer.render(this.scene, this.camera);
        renderer.setRenderTarget(this.sampleRenderTarget);
        if (this.accumulateIndex === 0)
          renderer.clear();
        this.fsQuad.render(renderer);
        this.accumulateIndex++;
        if (this.accumulateIndex >= jitterOffsets.length)
          break;
      }
      if (this.camera.clearViewOffset)
        this.camera.clearViewOffset();
    }
    var accumulationWeight = this.accumulateIndex * sampleWeight;
    if (accumulationWeight > 0) {
      this.copyUniforms["opacity"].value = 1;
      this.copyUniforms["tDiffuse"].value = this.sampleRenderTarget.texture;
      renderer.setRenderTarget(writeBuffer);
      renderer.clear();
      this.fsQuad.render(renderer);
    }
    if (accumulationWeight < 1) {
      this.copyUniforms["opacity"].value = 1 - accumulationWeight;
      this.copyUniforms["tDiffuse"].value = this.holdRenderTarget.texture;
      renderer.setRenderTarget(writeBuffer);
      if (accumulationWeight === 0)
        renderer.clear();
      this.fsQuad.render(renderer);
    }
    renderer.autoClear = autoClear;
  }
});

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/ConvolutionShader.js
var ConvolutionShader = {
  defines: {
    KERNEL_SIZE_FLOAT: "25.0",
    KERNEL_SIZE_INT: "25"
  },
  uniforms: {
    tDiffuse: {
      value: null
    },
    uImageIncrement: {
      value: new Vector2(1953125e-9, 0)
    },
    cKernel: {
      value: []
    }
  },
  vertexShader: ["uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "	vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float cKernel[ KERNEL_SIZE_INT ];", "uniform sampler2D tDiffuse;", "uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "	vec2 imageCoord = vUv;", "	vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );", "	for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {", "		sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];", "		imageCoord += uImageIncrement;", "	}", "	gl_FragColor = sum;", "}"].join("\n"),
  buildKernel: function(sigma) {
    function gauss(x, sigma2) {
      return Math.exp(-(x * x) / (2 * sigma2 * sigma2));
    }
    const kMaxKernelSize = 25;
    const kernelSize = Math.min(2 * Math.ceil(sigma * 3) + 1, kMaxKernelSize);
    const halfWidth = (kernelSize - 1) * 0.5;
    const values = new Array(kernelSize);
    let sum = 0;
    for (let i2 = 0; i2 < kernelSize; ++i2) {
      values[i2] = gauss(i2 - halfWidth, sigma);
      sum += values[i2];
    }
    for (let i2 = 0; i2 < kernelSize; ++i2)
      values[i2] /= sum;
    return values;
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/GLTFLoader.js
var _q = new Quaternion();

// node_modules/@react-three/rapier/node_modules/three-stdlib/webxr/OculusHandPointerModel.js
var YAXIS = new Vector3(0, 1, 0);
var ZAXIS = new Vector3(0, 0, 1);

// node_modules/@react-three/rapier/node_modules/three-stdlib/webxr/VRButton.js
var VRButton = class {
  static createButton(renderer, sessionInit = {}) {
    const button = document.createElement("button");
    function showEnterVR() {
      let currentSession = null;
      async function onSessionStarted(session) {
        session.addEventListener("end", onSessionEnded);
        await renderer.xr.setSession(session);
        button.textContent = "EXIT VR";
        currentSession = session;
      }
      function onSessionEnded() {
        currentSession.removeEventListener("end", onSessionEnded);
        button.textContent = "ENTER VR";
        currentSession = null;
      }
      button.style.display = "";
      button.style.cursor = "pointer";
      button.style.left = "calc(50% - 50px)";
      button.style.width = "100px";
      button.textContent = "ENTER VR";
      button.onmouseenter = () => {
        button.style.opacity = "1.0";
      };
      button.onmouseleave = () => {
        button.style.opacity = "0.5";
      };
      button.onclick = () => {
        if (currentSession === null) {
          var _xr;
          const optionalFeatures = [sessionInit.optionalFeatures, "local-floor", "bounded-floor", "hand-tracking"].flat().filter(Boolean);
          (_xr = navigator.xr) === null || _xr === void 0 ? void 0 : _xr.requestSession("immersive-vr", {
            ...sessionInit,
            optionalFeatures
          }).then(onSessionStarted);
        } else {
          currentSession.end();
        }
      };
    }
    function disableButton() {
      button.style.display = "";
      button.style.cursor = "auto";
      button.style.left = "calc(50% - 75px)";
      button.style.width = "150px";
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }
    function showWebXRNotFound() {
      disableButton();
      button.textContent = "VR NOT SUPPORTED";
    }
    function stylizeElement(element2) {
      element2.style.position = "absolute";
      element2.style.bottom = "20px";
      element2.style.padding = "12px 6px";
      element2.style.border = "1px solid #fff";
      element2.style.borderRadius = "4px";
      element2.style.background = "rgba(0,0,0,0.1)";
      element2.style.color = "#fff";
      element2.style.font = "normal 13px sans-serif";
      element2.style.textAlign = "center";
      element2.style.opacity = "0.5";
      element2.style.outline = "none";
      element2.style.zIndex = "999";
    }
    if ("xr" in navigator) {
      stylizeElement(button);
      button.id = "VRButton";
      button.style.display = "none";
      navigator.xr.isSessionSupported("immersive-vr").then((supported) => {
        supported ? showEnterVR() : showWebXRNotFound();
        if (supported && VRButton.xrSessionIsGranted) {
          button.click();
        }
      });
      return button;
    } else {
      const message = document.createElement("a");
      if (window.isSecureContext === false) {
        message.href = document.location.href.replace(/^http:/, "https:");
        message.innerHTML = "WEBXR NEEDS HTTPS";
      } else {
        message.href = "https://immersiveweb.dev/";
        message.innerHTML = "WEBXR NOT AVAILABLE";
      }
      message.style.left = "calc(50% - 90px)";
      message.style.width = "180px";
      message.style.textDecoration = "none";
      stylizeElement(message);
      return message;
    }
  }
  static registerSessionGrantedListener() {
    if ("xr" in navigator) {
      navigator.xr.addEventListener("sessiongranted", () => {
        VRButton.xrSessionIsGranted = true;
      });
    }
  }
};
_defineProperty(VRButton, "xrSessionIsGranted", false);

// node_modules/@react-three/rapier/node_modules/three-stdlib/libs/MotionControllers.js
var MotionControllerConstants = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
var defaultComponentValues = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: MotionControllerConstants.ComponentState.DEFAULT
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/webxr/XRHandPrimitiveModel.js
var _matrix = new Matrix4();
var _vector3 = new Vector3();

// node_modules/@react-three/rapier/node_modules/three-stdlib/geometries/ParametricGeometry.js
var ParametricGeometry = class extends BufferGeometry {
  constructor(func = (u, v, target) => target.set(u, v, Math.cos(u) * Math.sin(v)), slices = 8, stacks = 8) {
    super();
    this.type = "ParametricGeometry";
    this.parameters = {
      func,
      slices,
      stacks
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const EPS = 1e-5;
    const normal = new Vector3();
    const p0 = new Vector3(), p1 = new Vector3();
    const pu = new Vector3(), pv = new Vector3();
    const sliceCount = slices + 1;
    for (let i2 = 0; i2 <= stacks; i2++) {
      const v = i2 / stacks;
      for (let j2 = 0; j2 <= slices; j2++) {
        const u = j2 / slices;
        func(u, v, p0);
        vertices.push(p0.x, p0.y, p0.z);
        if (u - EPS >= 0) {
          func(u - EPS, v, p1);
          pu.subVectors(p0, p1);
        } else {
          func(u + EPS, v, p1);
          pu.subVectors(p1, p0);
        }
        if (v - EPS >= 0) {
          func(u, v - EPS, p1);
          pv.subVectors(p0, p1);
        } else {
          func(u, v + EPS, p1);
          pv.subVectors(p1, p0);
        }
        normal.crossVectors(pu, pv).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u, v);
      }
    }
    for (let i2 = 0; i2 < stacks; i2++) {
      for (let j2 = 0; j2 < slices; j2++) {
        const a2 = i2 * sliceCount + j2;
        const b2 = i2 * sliceCount + j2 + 1;
        const c = (i2 + 1) * sliceCount + j2 + 1;
        const d = (i2 + 1) * sliceCount + j2;
        indices.push(a2, b2, d);
        indices.push(b2, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/geometries/ParametricGeometries.js
var ParametricGeometries = {
  klein: function(v, u, target) {
    u *= Math.PI;
    v *= 2 * Math.PI;
    u = u * 2;
    let x, z;
    if (u < Math.PI) {
      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(u) * Math.cos(v);
      z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);
    } else {
      x = 3 * Math.cos(u) * (1 + Math.sin(u)) + 2 * (1 - Math.cos(u) / 2) * Math.cos(v + Math.PI);
      z = -8 * Math.sin(u);
    }
    const y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v);
    target.set(x, y, z);
  },
  plane: function(width, height) {
    return function(u, v, target) {
      const x = u * width;
      const y = 0;
      const z = v * height;
      target.set(x, y, z);
    };
  },
  mobius: function(u, t2, target) {
    u = u - 0.5;
    const v = 2 * Math.PI * t2;
    const a2 = 2;
    const x = Math.cos(v) * (a2 + u * Math.cos(v / 2));
    const y = Math.sin(v) * (a2 + u * Math.cos(v / 2));
    const z = u * Math.sin(v / 2);
    target.set(x, y, z);
  },
  mobius3d: function(u, t2, target) {
    u *= Math.PI;
    t2 *= 2 * Math.PI;
    u = u * 2;
    const phi = u / 2;
    const major = 2.25, a2 = 0.125, b2 = 0.65;
    let x = a2 * Math.cos(t2) * Math.cos(phi) - b2 * Math.sin(t2) * Math.sin(phi);
    const z = a2 * Math.cos(t2) * Math.sin(phi) + b2 * Math.sin(t2) * Math.cos(phi);
    const y = (major + x) * Math.sin(u);
    x = (major + x) * Math.cos(u);
    target.set(x, y, z);
  }
};
ParametricGeometries.TubeGeometry = class TubeGeometry extends ParametricGeometry {
  constructor(path, segments = 64, radius = 1, segmentsRadius = 8, closed = false) {
    const numpoints = segments + 1;
    const frames = path.computeFrenetFrames(segments, closed), tangents = frames.tangents, normals = frames.normals, binormals = frames.binormals;
    const position = new Vector3();
    function ParametricTube(u, v, target) {
      v *= 2 * Math.PI;
      const i2 = Math.floor(u * (numpoints - 1));
      path.getPointAt(u, position);
      const normal = normals[i2];
      const binormal = binormals[i2];
      const cx = -radius * Math.cos(v);
      const cy = radius * Math.sin(v);
      position.x += cx * normal.x + cy * binormal.x;
      position.y += cx * normal.y + cy * binormal.y;
      position.z += cx * normal.z + cy * binormal.z;
      target.copy(position);
    }
    super(ParametricTube, segments, segmentsRadius);
    this.tangents = tangents;
    this.normals = normals;
    this.binormals = binormals;
    this.path = path;
    this.segments = segments;
    this.radius = radius;
    this.segmentsRadius = segmentsRadius;
    this.closed = closed;
  }
};
ParametricGeometries.TorusKnotGeometry = class TorusKnotGeometry extends ParametricGeometries.TubeGeometry {
  constructor(radius = 200, tube = 40, segmentsT = 64, segmentsR = 8, p = 2, q = 3) {
    class TorusKnotCurve extends Curve {
      getPoint(t2, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        t2 *= Math.PI * 2;
        const r = 0.5;
        const x = (1 + r * Math.cos(q * t2)) * Math.cos(p * t2);
        const y = (1 + r * Math.cos(q * t2)) * Math.sin(p * t2);
        const z = r * Math.sin(q * t2);
        return point.set(x, y, z).multiplyScalar(radius);
      }
    }
    const segments = segmentsT;
    const radiusSegments = segmentsR;
    const extrudePath = new TorusKnotCurve();
    super(extrudePath, segments, tube, radiusSegments, true, false);
    this.radius = radius;
    this.tube = tube;
    this.segmentsT = segmentsT;
    this.segmentsR = segmentsR;
    this.p = p;
    this.q = q;
  }
};
ParametricGeometries.SphereGeometry = class SphereGeometry2 extends ParametricGeometry {
  constructor(size2, u, v) {
    function sphere(u2, v2, target) {
      u2 *= Math.PI;
      v2 *= 2 * Math.PI;
      const x = size2 * Math.sin(u2) * Math.cos(v2);
      const y = size2 * Math.sin(u2) * Math.sin(v2);
      const z = size2 * Math.cos(u2);
      target.set(x, y, z);
    }
    super(sphere, u, v);
  }
};
ParametricGeometries.PlaneGeometry = class PlaneGeometry2 extends ParametricGeometry {
  constructor(width, depth, segmentsWidth, segmentsDepth) {
    function plane(u, v, target) {
      const x = u * width;
      const y = 0;
      const z = v * depth;
      target.set(x, y, z);
    }
    super(plane, segmentsWidth, segmentsDepth);
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/geometries/RoundedBoxGeometry.js
var tempNormal = new Vector3();

// node_modules/@react-three/rapier/node_modules/three-stdlib/csm/CSMFrustum.js
var inverseProjectionMatrix = new Matrix4();
var CSMFrustum = class {
  constructor(data) {
    data = data || {};
    this.vertices = {
      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],
      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]
    };
    if (data.projectionMatrix !== void 0) {
      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);
    }
  }
  setFromProjectionMatrix(projectionMatrix, maxFar) {
    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;
    inverseProjectionMatrix.copy(projectionMatrix).invert();
    this.vertices.near[0].set(1, 1, -1);
    this.vertices.near[1].set(1, -1, -1);
    this.vertices.near[2].set(-1, -1, -1);
    this.vertices.near[3].set(-1, 1, -1);
    this.vertices.near.forEach(function(v) {
      v.applyMatrix4(inverseProjectionMatrix);
    });
    this.vertices.far[0].set(1, 1, 1);
    this.vertices.far[1].set(1, -1, 1);
    this.vertices.far[2].set(-1, -1, 1);
    this.vertices.far[3].set(-1, 1, 1);
    this.vertices.far.forEach(function(v) {
      v.applyMatrix4(inverseProjectionMatrix);
      const absZ = Math.abs(v.z);
      if (isOrthographic) {
        v.z *= Math.min(maxFar / absZ, 1);
      } else {
        v.multiplyScalar(Math.min(maxFar / absZ, 1));
      }
    });
    return this.vertices;
  }
  split(breaks, target) {
    while (breaks.length > target.length) {
      target.push(new CSMFrustum());
    }
    target.length = breaks.length;
    for (let i2 = 0; i2 < breaks.length; i2++) {
      const cascade = target[i2];
      if (i2 === 0) {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.near[j2].copy(this.vertices.near[j2]);
        }
      } else {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.near[j2].lerpVectors(this.vertices.near[j2], this.vertices.far[j2], breaks[i2 - 1]);
        }
      }
      if (i2 === breaks.length - 1) {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.far[j2].copy(this.vertices.far[j2]);
        }
      } else {
        for (let j2 = 0; j2 < 4; j2++) {
          cascade.vertices.far[j2].lerpVectors(this.vertices.near[j2], this.vertices.far[j2], breaks[i2]);
        }
      }
    }
  }
  toSpace(cameraMatrix, target) {
    for (let i2 = 0; i2 < 4; i2++) {
      target.vertices.near[i2].copy(this.vertices.near[i2]).applyMatrix4(cameraMatrix);
      target.vertices.far[i2].copy(this.vertices.far[i2]).applyMatrix4(cameraMatrix);
    }
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/csm/CSMShader.js
var CSMShader = {
  lights_fragment_begin: (
    /* glsl */
    `
GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
	vec2 cascade;
	float cascadeCenter;
	float closestEdge;
	float margin;
	float csmx;
	float csmy;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );

	  	#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
			// NOTE: Depth gets larger away from the camera.
			// cascade.x is closer, cascade.y is further
			cascade = CSM_cascades[ i ];
			cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
			closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
			margin = 0.25 * pow( closestEdge, 2.0 );
			csmx = cascade.x - margin / 2.0;
			csmy = cascade.y + margin / 2.0;
			if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

				float dist = min( linearDepth - csmx, csmy - linearDepth );
				float ratio = clamp( dist / margin, 0.0, 1.0 );

				vec3 prevColor = directLight.color;
				directionalLightShadow = directionalLightShadows[ i ];
				directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
				directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

				ReflectedLight prevLight = reflectedLight;
				RE_Direct( directLight, geometry, material, reflectedLight );

				bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
				float blendRatio = shouldBlend ? ratio : 1.0;

				reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
				reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
				reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
				reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

			}
	  	#endif

	}
	#pragma unroll_loop_end
	#else

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, geometry, directLight );

			#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

			directionalLightShadow = directionalLightShadows[ i ];
			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );

			#endif

		}
		#pragma unroll_loop_end

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, geometry, directLight );

			RE_Direct( directLight, geometry, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`
  ),
  lights_pars_begin: (
    /* glsl */
    `
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[CSM_CASCADES];
uniform float cameraNear;
uniform float shadowFar;
#endif
	` + ShaderChunk.lights_pars_begin
  )
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/csm/CSM.js
var _cameraToLightMatrix = new Matrix4();
var _lightSpaceFrustum = new CSMFrustum();
var _center = new Vector3();
var _bbox = new Box3();

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/ACESFilmicToneMappingShader.js
var ACESFilmicToneMappingShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    exposure: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#define saturate(a) clamp( a, 0.0, 1.0 )",
    "uniform sampler2D tDiffuse;",
    "uniform float exposure;",
    "varying vec2 vUv;",
    "vec3 RRTAndODTFit( vec3 v ) {",
    "	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;",
    "	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;",
    "	return a / b;",
    "}",
    "vec3 ACESFilmicToneMapping( vec3 color ) {",
    // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
    "	const mat3 ACESInputMat = mat3(",
    "		vec3( 0.59719, 0.07600, 0.02840 ),",
    // transposed from source
    "		vec3( 0.35458, 0.90834, 0.13383 ),",
    "		vec3( 0.04823, 0.01566, 0.83777 )",
    "	);",
    // ODT_SAT => XYZ => D60_2_D65 => sRGB
    "	const mat3 ACESOutputMat = mat3(",
    "		vec3(  1.60475, -0.10208, -0.00327 ),",
    // transposed from source
    "		vec3( -0.53108,  1.10813, -0.07276 ),",
    "		vec3( -0.07367, -0.00605,  1.07602 )",
    "	);",
    "	color = ACESInputMat * color;",
    // Apply RRT and ODT
    "	color = RRTAndODTFit( color );",
    "	color = ACESOutputMat * color;",
    // Clamp to [0, 1]
    "	return saturate( color );",
    "}",
    "void main() {",
    "	vec4 tex = texture2D( tDiffuse, vUv );",
    "	tex.rgb *= exposure / 0.6;",
    // pre-exposed, outside of the tone mapping function
    "	gl_FragColor = vec4( ACESFilmicToneMapping( tex.rgb ), tex.a );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/BasicShader.js
var BasicShader = {
  uniforms: {},
  vertexShader: ["void main() {", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["void main() {", "	gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/BleachBypassShader.js
var BleachBypassShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    opacity: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 base = texture2D( tDiffuse, vUv );", "	vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );", "	float lum = dot( lumCoeff, base.rgb );", "	vec3 blend = vec3( lum );", "	float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );", "	vec3 result1 = 2.0 * base.rgb * blend;", "	vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );", "	vec3 newColor = mix( result1, result2, L );", "	float A2 = opacity * base.a;", "	vec3 mixRGB = A2 * newColor.rgb;", "	mixRGB += ( ( 1.0 - A2 ) * base.rgb );", "	gl_FragColor = vec4( mixRGB, base.a );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/BlendShader.js
var BlendShader = {
  uniforms: {
    tDiffuse1: {
      value: null
    },
    tDiffuse2: {
      value: null
    },
    mixRatio: {
      value: 0.5
    },
    opacity: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float opacity;", "uniform float mixRatio;", "uniform sampler2D tDiffuse1;", "uniform sampler2D tDiffuse2;", "varying vec2 vUv;", "void main() {", "	vec4 texel1 = texture2D( tDiffuse1, vUv );", "	vec4 texel2 = texture2D( tDiffuse2, vUv );", "	gl_FragColor = opacity * mix( texel1, texel2, mixRatio );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/BrightnessContrastShader.js
var BrightnessContrastShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    brightness: {
      value: 0
    },
    contrast: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float brightness;", "uniform float contrast;", "varying vec2 vUv;", "void main() {", "	gl_FragColor = texture2D( tDiffuse, vUv );", "	gl_FragColor.rgb += brightness;", "	if (contrast > 0.0) {", "		gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;", "	} else {", "		gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;", "	}", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/ColorCorrectionShader.js
var ColorCorrectionShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    powRGB: {
      value: new Vector3(2, 2, 2)
    },
    mulRGB: {
      value: new Vector3(1, 1, 1)
    },
    addRGB: {
      value: new Vector3(0, 0, 0)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 powRGB;", "uniform vec3 mulRGB;", "uniform vec3 addRGB;", "varying vec2 vUv;", "void main() {", "	gl_FragColor = texture2D( tDiffuse, vUv );", "	gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/ColorifyShader.js
var ColorifyShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    color: {
      value: new Color(16777215)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform vec3 color;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 texel = texture2D( tDiffuse, vUv );", "	vec3 luma = vec3( 0.299, 0.587, 0.114 );", "	float v = dot( texel.xyz, luma );", "	gl_FragColor = vec4( v * color, texel.w );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/DOFMipMapShader.js
var DOFMipMapShader = {
  uniforms: {
    tColor: {
      value: null
    },
    tDepth: {
      value: null
    },
    focus: {
      value: 1
    },
    maxblur: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float focus;", "uniform float maxblur;", "uniform sampler2D tColor;", "uniform sampler2D tDepth;", "varying vec2 vUv;", "void main() {", "	vec4 depth = texture2D( tDepth, vUv );", "	float factor = depth.x - focus;", "	vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );", "	gl_FragColor = col;", "	gl_FragColor.a = 1.0;", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/FXAAShader.js
var FXAAShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["precision highp float;", "", "uniform sampler2D tDiffuse;", "", "uniform vec2 resolution;", "", "varying vec2 vUv;", "", "// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)", "", "//----------------------------------------------------------------------------------", "// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag", "// SDK Version: v3.00", "// Email:       gameworks@nvidia.com", "// Site:        http://developer.nvidia.com/", "//", "// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.", "//", "// Redistribution and use in source and binary forms, with or without", "// modification, are permitted provided that the following conditions", "// are met:", "//  * Redistributions of source code must retain the above copyright", "//    notice, this list of conditions and the following disclaimer.", "//  * Redistributions in binary form must reproduce the above copyright", "//    notice, this list of conditions and the following disclaimer in the", "//    documentation and/or other materials provided with the distribution.", "//  * Neither the name of NVIDIA CORPORATION nor the names of its", "//    contributors may be used to endorse or promote products derived", "//    from this software without specific prior written permission.", "//", "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY", "// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", "// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR", "// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR", "// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,", "// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,", "// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR", "// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY", "// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT", "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE", "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", "//", "//----------------------------------------------------------------------------------", "", "#define FXAA_PC 1", "#define FXAA_GLSL_100 1", "#define FXAA_QUALITY_PRESET 12", "", "#define FXAA_GREEN_AS_LUMA 1", "", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_PC_CONSOLE", "    //", "    // The console algorithm for PC is included", "    // for developers targeting really low spec machines.", "    // Likely better to just run FXAA_PC, and use a really low preset.", "    //", "    #define FXAA_PC_CONSOLE 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_120", "    #define FXAA_GLSL_120 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_130", "    #define FXAA_GLSL_130 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_3", "    #define FXAA_HLSL_3 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_4", "    #define FXAA_HLSL_4 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_5", "    #define FXAA_HLSL_5 0", "#endif", "/*==========================================================================*/", "#ifndef FXAA_GREEN_AS_LUMA", "    //", "    // For those using non-linear color,", "    // and either not able to get luma in alpha, or not wanting to,", "    // this enables FXAA to run using green as a proxy for luma.", "    // So with this enabled, no need to pack luma in alpha.", "    //", "    // This will turn off AA on anything which lacks some amount of green.", "    // Pure red and blue or combination of only R and B, will get no AA.", "    //", "    // Might want to lower the settings for both,", "    //    fxaaConsoleEdgeThresholdMin", "    //    fxaaQualityEdgeThresholdMin", "    // In order to insure AA does not get turned off on colors", "    // which contain a minor amount of green.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_GREEN_AS_LUMA 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_EARLY_EXIT", "    //", "    // Controls algorithm's early exit path.", "    // On PS3 turning this ON adds 2 cycles to the shader.", "    // On 360 turning this OFF adds 10ths of a millisecond to the shader.", "    // Turning this off on console will result in a more blurry image.", "    // So this defaults to on.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_EARLY_EXIT 1", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_DISCARD", "    //", "    // Only valid for PC OpenGL currently.", "    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.", "    //", "    // 1 = Use discard on pixels which don't need AA.", "    //     For APIs which enable concurrent TEX+ROP from same surface.", "    // 0 = Return unchanged color on pixels which don't need AA.", "    //", "    #define FXAA_DISCARD 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_FAST_PIXEL_OFFSET", "    //", "    // Used for GLSL 120 only.", "    //", "    // 1 = GL API supports fast pixel offsets", "    // 0 = do not use fast pixel offsets", "    //", "    #ifdef GL_EXT_gpu_shader4", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifndef FXAA_FAST_PIXEL_OFFSET", "        #define FXAA_FAST_PIXEL_OFFSET 0", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GATHER4_ALPHA", "    //", "    // 1 = API supports gather4 on alpha channel.", "    // 0 = API does not support gather4 on alpha channel.", "    //", "    #if (FXAA_HLSL_5 == 1)", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifndef FXAA_GATHER4_ALPHA", "        #define FXAA_GATHER4_ALPHA 0", "    #endif", "#endif", "", "", "/*============================================================================", "                        FXAA QUALITY - TUNING KNOBS", "------------------------------------------------------------------------------", "NOTE the other tuning knobs are now in the shader function inputs!", "============================================================================*/", "#ifndef FXAA_QUALITY_PRESET", "    //", "    // Choose the quality preset.", "    // This needs to be compiled into the shader as it effects code.", "    // Best option to include multiple presets is to", "    // in each shader define the preset, then include this file.", "    //", "    // OPTIONS", "    // -----------------------------------------------------------------------", "    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)", "    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)", "    // 39       - no dither, very expensive", "    //", "    // NOTES", "    // -----------------------------------------------------------------------", "    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)", "    // 13 = about same speed as FXAA 3.9 and better than 12", "    // 23 = closest to FXAA 3.9 visually and performance wise", "    //  _ = the lowest digit is directly related to performance", "    // _  = the highest digit is directly related to style", "    //", "    #define FXAA_QUALITY_PRESET 12", "#endif", "", "", "/*============================================================================", "", "                           FXAA QUALITY - PRESETS", "", "============================================================================*/", "", "/*============================================================================", "                     FXAA QUALITY - MEDIUM DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 10)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 3.0", "    #define FXAA_QUALITY_P2 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 11)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 3.0", "    #define FXAA_QUALITY_P3 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 12)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 4.0", "    #define FXAA_QUALITY_P4 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 13)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 4.0", "    #define FXAA_QUALITY_P5 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 14)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 4.0", "    #define FXAA_QUALITY_P6 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 15)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 12.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - LOW DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 20)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 2.0", "    #define FXAA_QUALITY_P2 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 21)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 22)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 23)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 24)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 3.0", "    #define FXAA_QUALITY_P6 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 25)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 26)", "    #define FXAA_QUALITY_PS 9", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 4.0", "    #define FXAA_QUALITY_P8 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 27)", "    #define FXAA_QUALITY_PS 10", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 4.0", "    #define FXAA_QUALITY_P9 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 28)", "    #define FXAA_QUALITY_PS 11", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 4.0", "    #define FXAA_QUALITY_P10 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 29)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - EXTREME QUALITY", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 39)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.0", "    #define FXAA_QUALITY_P2 1.0", "    #define FXAA_QUALITY_P3 1.0", "    #define FXAA_QUALITY_P4 1.0", "    #define FXAA_QUALITY_P5 1.5", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "", "", "/*============================================================================", "", "                                API PORTING", "", "============================================================================*/", "#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)", "    #define FxaaBool bool", "    #define FxaaDiscard discard", "    #define FxaaFloat float", "    #define FxaaFloat2 vec2", "    #define FxaaFloat3 vec3", "    #define FxaaFloat4 vec4", "    #define FxaaHalf float", "    #define FxaaHalf2 vec2", "    #define FxaaHalf3 vec3", "    #define FxaaHalf4 vec4", "    #define FxaaInt2 ivec2", "    #define FxaaSat(x) clamp(x, 0.0, 1.0)", "    #define FxaaTex sampler2D", "#else", "    #define FxaaBool bool", "    #define FxaaDiscard clip(-1)", "    #define FxaaFloat float", "    #define FxaaFloat2 float2", "    #define FxaaFloat3 float3", "    #define FxaaFloat4 float4", "    #define FxaaHalf half", "    #define FxaaHalf2 half2", "    #define FxaaHalf3 half3", "    #define FxaaHalf4 half4", "    #define FxaaSat(x) saturate(x)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_100 == 1)", "  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)", "  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_120 == 1)", "    // Requires,", "    //  #version 120", "    // And at least,", "    //  #extension GL_EXT_gpu_shader4 : enable", "    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)", "    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)", "    #if (FXAA_FAST_PIXEL_OFFSET == 1)", "        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)", "    #else", "        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)", "    #endif", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_130 == 1)", '    // Requires "#version 130" or better', "    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_3 == 1)", "    #define FxaaInt2 float2", "    #define FxaaTex sampler2D", "    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))", "    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_4 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_5 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)", "    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)", "    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)", "    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)", "#endif", "", "", "/*============================================================================", "                   GREEN AS LUMA OPTION SUPPORT FUNCTION", "============================================================================*/", "#if (FXAA_GREEN_AS_LUMA == 0)", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }", "#else", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }", "#endif", "", "", "", "", "/*============================================================================", "", "                             FXAA3 QUALITY - PC", "", "============================================================================*/", "#if (FXAA_PC == 1)", "/*--------------------------------------------------------------------------*/", "FxaaFloat4 FxaaPixelShader(", "    //", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy} = center of pixel", "    FxaaFloat2 pos,", "    //", "    // Used only for FXAA Console, and not used on the 360 version.", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy_} = upper left of pixel", "    // {_zw} = lower right of pixel", "    FxaaFloat4 fxaaConsolePosPos,", "    //", "    // Input color texture.", "    // {rgb_} = color in linear or perceptual color space", "    // if (FXAA_GREEN_AS_LUMA == 0)", "    //     {__a} = luma in perceptual color space (not linear)", "    FxaaTex tex,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", '    // For everything but 360, just use the same input here as for "tex".', "    // For 360, same texture, just alias with a 2nd sampler.", "    // This sampler needs to have an exponent bias of -1.", "    FxaaTex fxaaConsole360TexExpBiasNegOne,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", '    // For everything but 360, just use the same input here as for "tex".', "    // For 360, same texture, just alias with a 3nd sampler.", "    // This sampler needs to have an exponent bias of -2.", "    FxaaTex fxaaConsole360TexExpBiasNegTwo,", "    //", "    // Only used on FXAA Quality.", "    // This must be from a constant/uniform.", "    // {x_} = 1.0/screenWidthInPixels", "    // {_y} = 1.0/screenHeightInPixels", "    FxaaFloat2 fxaaQualityRcpFrame,", "    //", "    // Only used on FXAA Console.", "    // This must be from a constant/uniform.", "    // This effects sub-pixel AA quality and inversely sharpness.", "    //   Where N ranges between,", "    //     N = 0.50 (default)", "    //     N = 0.33 (sharper)", "    // {x__} = -N/screenWidthInPixels", "    // {_y_} = -N/screenHeightInPixels", "    // {_z_} =  N/screenWidthInPixels", "    // {__w} =  N/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt,", "    //", "    // Only used on FXAA Console.", "    // Not used on 360, but used on PS3 and PC.", "    // This must be from a constant/uniform.", "    // {x__} = -2.0/screenWidthInPixels", "    // {_y_} = -2.0/screenHeightInPixels", "    // {_z_} =  2.0/screenWidthInPixels", "    // {__w} =  2.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt2,", "    //", "    // Only used on FXAA Console.", "    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.", "    // This must be from a constant/uniform.", "    // {x__} =  8.0/screenWidthInPixels", "    // {_y_} =  8.0/screenHeightInPixels", "    // {_z_} = -4.0/screenWidthInPixels", "    // {__w} = -4.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsole360RcpFrameOpt2,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_SUBPIX define.", "    // It is here now to allow easier tuning.", "    // Choose the amount of sub-pixel aliasing removal.", "    // This can effect sharpness.", "    //   1.00 - upper limit (softer)", "    //   0.75 - default amount of filtering", "    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)", "    //   0.25 - almost off", "    //   0.00 - completely off", "    FxaaFloat fxaaQualitySubpix,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // The minimum amount of local contrast required to apply algorithm.", "    //   0.333 - too little (faster)", "    //   0.250 - low quality", "    //   0.166 - default", "    //   0.125 - high quality", "    //   0.063 - overkill (slower)", "    FxaaFloat fxaaQualityEdgeThreshold,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    //   0.0833 - upper limit (default, the start of visible unfiltered edges)", "    //   0.0625 - high quality (faster)", "    //   0.0312 - visible limit (slower)", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaQualityEdgeThresholdMin,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only three safe values here: 2 and 4 and 8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // For all other platforms can be a non-power of two.", "    //   8.0 is sharper (default!!!)", "    //   4.0 is softer", "    //   2.0 is really soft (good only for vector graphics inputs)", "    FxaaFloat fxaaConsoleEdgeSharpness,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only two safe values here: 1/4 and 1/8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // The console setting has a different mapping than the quality setting.", "    // Other platforms can use other values.", "    //   0.125 leaves less aliasing, but is softer (default!!!)", "    //   0.25 leaves more aliasing, and is sharper", "    FxaaFloat fxaaConsoleEdgeThreshold,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    // The console setting has a different mapping than the quality setting.", "    // This only applies when FXAA_EARLY_EXIT is 1.", "    // This does not apply to PS3,", "    // PS3 was simplified to avoid more shader instructions.", "    //   0.06 - faster but more aliasing in darks", "    //   0.05 - default", "    //   0.04 - slower and less aliasing in darks", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaConsoleEdgeThresholdMin,", "    //", "    // Extra constants for 360 FXAA Console only.", "    // Use zeros or anything else for other platforms.", "    // These must be in physical constant registers and NOT immediates.", "    // Immediates will result in compiler un-optimizing.", "    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)", "    FxaaFloat4 fxaaConsole360ConstDir", ") {", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posM;", "    posM.x = pos.x;", "    posM.y = pos.y;", "    #if (FXAA_GATHER4_ALPHA == 1)", "        #if (FXAA_DISCARD == 0)", "            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "            #if (FXAA_GREEN_AS_LUMA == 0)", "                #define lumaM rgbyM.w", "            #else", "                #define lumaM rgbyM.y", "            #endif", "        #endif", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));", "        #else", "            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));", "        #endif", "        #if (FXAA_DISCARD == 1)", "            #define lumaM luma4A.w", "        #endif", "        #define lumaE luma4A.z", "        #define lumaS luma4A.x", "        #define lumaSE luma4A.y", "        #define lumaNW luma4B.w", "        #define lumaN luma4B.z", "        #define lumaW luma4B.x", "    #else", "        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            #define lumaM rgbyM.w", "        #else", "            #define lumaM rgbyM.y", "        #endif", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));", "        #endif", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat maxSM = max(lumaS, lumaM);", "    FxaaFloat minSM = min(lumaS, lumaM);", "    FxaaFloat maxESM = max(lumaE, maxSM);", "    FxaaFloat minESM = min(lumaE, minSM);", "    FxaaFloat maxWN = max(lumaN, lumaW);", "    FxaaFloat minWN = min(lumaN, lumaW);", "    FxaaFloat rangeMax = max(maxWN, maxESM);", "    FxaaFloat rangeMin = min(minWN, minESM);", "    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;", "    FxaaFloat range = rangeMax - rangeMin;", "    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);", "    FxaaBool earlyExit = range < rangeMaxClamped;", "/*--------------------------------------------------------------------------*/", "    if(earlyExit)", "        #if (FXAA_DISCARD == 1)", "            FxaaDiscard;", "        #else", "            return rgbyM;", "        #endif", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_GATHER4_ALPHA == 0)", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "        #endif", "    #else", "        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));", "        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNS = lumaN + lumaS;", "    FxaaFloat lumaWE = lumaW + lumaE;", "    FxaaFloat subpixRcpRange = 1.0/range;", "    FxaaFloat subpixNSWE = lumaNS + lumaWE;", "    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;", "    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNESE = lumaNE + lumaSE;", "    FxaaFloat lumaNWNE = lumaNW + lumaNE;", "    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;", "    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNWSW = lumaNW + lumaSW;", "    FxaaFloat lumaSWSE = lumaSW + lumaSE;", "    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);", "    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);", "    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;", "    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;", "    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;", "    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;", "    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;", "    FxaaBool horzSpan = edgeHorz >= edgeVert;", "    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;", "/*--------------------------------------------------------------------------*/", "    if(!horzSpan) lumaN = lumaW;", "    if(!horzSpan) lumaS = lumaE;", "    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;", "    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat gradientN = lumaN - lumaM;", "    FxaaFloat gradientS = lumaS - lumaM;", "    FxaaFloat lumaNN = lumaN + lumaM;", "    FxaaFloat lumaSS = lumaS + lumaM;", "    FxaaBool pairN = abs(gradientN) >= abs(gradientS);", "    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));", "    if(pairN) lengthSign = -lengthSign;", "    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posB;", "    posB.x = posM.x;", "    posB.y = posM.y;", "    FxaaFloat2 offNP;", "    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;", "    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;", "    if(!horzSpan) posB.x += lengthSign * 0.5;", "    if( horzSpan) posB.y += lengthSign * 0.5;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posN;", "    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;", "    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat2 posP;", "    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;", "    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;", "    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));", "    FxaaFloat subpixE = subpixC * subpixC;", "    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));", "/*--------------------------------------------------------------------------*/", "    if(!pairN) lumaNN = lumaSS;", "    FxaaFloat gradientScaled = gradient * 1.0/4.0;", "    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;", "    FxaaFloat subpixF = subpixD * subpixE;", "    FxaaBool lumaMLTZero = lumaMM < 0.0;", "/*--------------------------------------------------------------------------*/", "    lumaEndN -= lumaNN * 0.5;", "    lumaEndP -= lumaNN * 0.5;", "    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;", "    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;", "    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;", "    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;", "    FxaaBool doneNP = (!doneN) || (!doneP);", "    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;", "    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;", "/*--------------------------------------------------------------------------*/", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 3)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 4)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 5)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 6)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;", "/*--------------------------------------------------------------------------*/", "                        #if (FXAA_QUALITY_PS > 7)", "                        if(doneNP) {", "                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                            doneN = abs(lumaEndN) >= gradientScaled;", "                            doneP = abs(lumaEndP) >= gradientScaled;", "                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;", "                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;", "                            doneNP = (!doneN) || (!doneP);", "                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;", "                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_QUALITY_PS > 8)", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 9)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 10)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 11)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 12)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "    #endif", "/*--------------------------------------------------------------------------*/", "                        }", "                        #endif", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "/*--------------------------------------------------------------------------*/", "    FxaaFloat dstN = posM.x - posN.x;", "    FxaaFloat dstP = posP.x - posM.x;", "    if(!horzSpan) dstN = posM.y - posN.y;", "    if(!horzSpan) dstP = posP.y - posM.y;", "/*--------------------------------------------------------------------------*/", "    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;", "    FxaaFloat spanLength = (dstP + dstN);", "    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;", "    FxaaFloat spanLengthRcp = 1.0/spanLength;", "/*--------------------------------------------------------------------------*/", "    FxaaBool directionN = dstN < dstP;", "    FxaaFloat dst = min(dstN, dstP);", "    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;", "    FxaaFloat subpixG = subpixF * subpixF;", "    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;", "    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;", "    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);", "    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;", "    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;", "    #if (FXAA_DISCARD == 1)", "        return FxaaTexTop(tex, posM);", "    #else", "        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);", "    #endif", "}", "/*==========================================================================*/", "#endif", "", "void main() {", "  gl_FragColor = FxaaPixelShader(", "    vUv,", "    vec4(0.0),", "    tDiffuse,", "    tDiffuse,", "    tDiffuse,", "    resolution,", "    vec4(0.0),", "    vec4(0.0),", "    vec4(0.0),", "    0.75,", "    0.166,", "    0.0833,", "    0.0,", "    0.0,", "    0.0,", "    vec4(0.0)", "  );", "", "  // TODO avoid querying texture twice for same texel", "  gl_FragColor.a = texture2D(tDiffuse, vUv).a;", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/FocusShader.js
var FocusShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    screenWidth: {
      value: 1024
    },
    screenHeight: {
      value: 1024
    },
    sampleDistance: {
      value: 0.94
    },
    waveFactor: {
      value: 125e-5
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float screenWidth;", "uniform float screenHeight;", "uniform float sampleDistance;", "uniform float waveFactor;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 color, org, tmp, add;", "	float sample_dist, f;", "	vec2 vin;", "	vec2 uv = vUv;", "	add = color = org = texture2D( tDiffuse, uv );", "	vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );", "	sample_dist = dot( vin, vin ) * 2.0;", "	f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;", "	vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );", "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );", "	if( tmp.b < color.b ) color = tmp;", "	color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );", "	color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );", "	gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/FreiChenShader.js
var FreiChenShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    aspect: {
      value: new Vector2(512, 512)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "uniform vec2 aspect;",
    "vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);",
    "mat3 G[9];",
    // hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45
    "const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );",
    "const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );",
    "const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );",
    "const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );",
    "const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );",
    "const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );",
    "const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );",
    "const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );",
    "const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );",
    "void main(void)",
    "{",
    "	G[0] = g0,",
    "	G[1] = g1,",
    "	G[2] = g2,",
    "	G[3] = g3,",
    "	G[4] = g4,",
    "	G[5] = g5,",
    "	G[6] = g6,",
    "	G[7] = g7,",
    "	G[8] = g8;",
    "	mat3 I;",
    "	float cnv[9];",
    "	vec3 sample;",
    /* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */
    "	for (float i=0.0; i<3.0; i++) {",
    "		for (float j=0.0; j<3.0; j++) {",
    "			sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;",
    "			I[int(i)][int(j)] = length(sample);",
    "		}",
    "	}",
    /* calculate the convolution values for all the masks */
    "	for (int i=0; i<9; i++) {",
    "		float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);",
    "		cnv[i] = dp3 * dp3;",
    "	}",
    "	float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);",
    "	float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);",
    "	gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);",
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/FresnelShader.js
var FresnelShader = {
  uniforms: {
    mRefractionRatio: {
      value: 1.02
    },
    mFresnelBias: {
      value: 0.1
    },
    mFresnelPower: {
      value: 2
    },
    mFresnelScale: {
      value: 1
    },
    tCube: {
      value: null
    }
  },
  vertexShader: ["uniform float mRefractionRatio;", "uniform float mFresnelBias;", "uniform float mFresnelScale;", "uniform float mFresnelPower;", "varying vec3 vReflect;", "varying vec3 vRefract[3];", "varying float vReflectionFactor;", "void main() {", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "	vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );", "	vec3 I = worldPosition.xyz - cameraPosition;", "	vReflect = reflect( I, worldNormal );", "	vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );", "	vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );", "	vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );", "	vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );", "	gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
  fragmentShader: ["uniform samplerCube tCube;", "varying vec3 vReflect;", "varying vec3 vRefract[3];", "varying float vReflectionFactor;", "void main() {", "	vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );", "	vec4 refractedColor = vec4( 1.0 );", "	refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;", "	refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;", "	refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;", "	gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/GammaCorrectionShader.js
var GammaCorrectionShader = {
  uniforms: {
    tDiffuse: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 tex = texture2D( tDiffuse, vUv );", "	gl_FragColor = LinearTosRGB( tex );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/GodRaysShader.js
var GodRaysDepthMaskShader = {
  uniforms: {
    tInput: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", " vUv = uv;", " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["varying vec2 vUv;", "uniform sampler2D tInput;", "void main() {", "	gl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );", "}"].join("\n")
};
var GodRaysGenerateShader = {
  uniforms: {
    tInput: {
      value: null
    },
    fStepSize: {
      value: 1
    },
    vSunPositionScreenSpace: {
      value: new Vector3()
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", " vUv = uv;", " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#define TAPS_PER_PASS 6.0",
    "varying vec2 vUv;",
    "uniform sampler2D tInput;",
    "uniform vec3 vSunPositionScreenSpace;",
    "uniform float fStepSize;",
    // filter step size
    "void main() {",
    // delta from current pixel to "sun" position
    "	vec2 delta = vSunPositionScreenSpace.xy - vUv;",
    "	float dist = length( delta );",
    // Step vector (uv space)
    "	vec2 stepv = fStepSize * delta / dist;",
    // Number of iterations between pixel and sun
    "	float iters = dist/fStepSize;",
    "	vec2 uv = vUv.xy;",
    "	float col = 0.0;",
    // This breaks ANGLE in Chrome 22
    //	- see http://code.google.com/p/chromium/issues/detail?id=153105
    /*
    // Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),
    // so i've just left the loop
    "for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {",
    // Accumulate samples, making sure we dont walk past the light source.
    // The check for uv.y < 1 would not be necessary with "border" UV wrap
    // mode, with a black border color. I don't think this is currently
    // exposed by three.js. As a result there might be artifacts when the
    // sun is to the left, right or bottom of screen as these cases are
    // not specifically handled.
    "	col += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );",
    "	uv += stepv;",
    "}",
    */
    // Unrolling loop manually makes it work in ANGLE
    "	float f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );",
    // used to fade out godrays
    "	if ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    "	if ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;",
    "	uv += stepv;",
    // Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out
    // objectionable artifacts, in particular near the sun position. The side
    // effect is that the result is darker than it should be around the sun, as
    // TAPS_PER_PASS is greater than the number of samples actually accumulated.
    // When the result is inverted (in the shader 'godrays_combine', this produces
    // a slight bright spot at the position of the sun, even when it is occluded.
    "	gl_FragColor = vec4( col/TAPS_PER_PASS );",
    "	gl_FragColor.a = 1.0;",
    "}"
  ].join("\n")
};
var GodRaysCombineShader = {
  uniforms: {
    tColors: {
      value: null
    },
    tGodRays: {
      value: null
    },
    fGodRayIntensity: {
      value: 0.69
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "varying vec2 vUv;",
    "uniform sampler2D tColors;",
    "uniform sampler2D tGodRays;",
    "uniform float fGodRayIntensity;",
    "void main() {",
    // Since THREE.MeshDepthMaterial renders foreground objects white and background
    // objects black, the god-rays will be white streaks. Therefore value is inverted
    // before being combined with tColors
    "	gl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );",
    "	gl_FragColor.a = 1.0;",
    "}"
  ].join("\n")
};
var GodRaysFakeSunShader = {
  uniforms: {
    vSunPositionScreenSpace: {
      value: new Vector3()
    },
    fAspect: {
      value: 1
    },
    sunColor: {
      value: new Color(16772608)
    },
    bgColor: {
      value: new Color(0)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "varying vec2 vUv;",
    "uniform vec3 vSunPositionScreenSpace;",
    "uniform float fAspect;",
    "uniform vec3 sunColor;",
    "uniform vec3 bgColor;",
    "void main() {",
    "	vec2 diff = vUv - vSunPositionScreenSpace.xy;",
    // Correct for aspect ratio
    "	diff.x *= fAspect;",
    "	float prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );",
    "	prop = 0.35 * pow( 1.0 - prop, 3.0 );",
    "	gl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;",
    "	gl_FragColor.w = 1.0;",
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/HorizontalBlurShader.js
var HorizontalBlurShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    h: {
      value: 1 / 512
    }
  },
  vertexShader: (
    /* glsl */
    `
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `
  )
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/HorizontalTiltShiftShader.js
var HorizontalTiltShiftShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    h: {
      value: 1 / 512
    },
    r: {
      value: 0.35
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float h;", "uniform float r;", "varying vec2 vUv;", "void main() {", "	vec4 sum = vec4( 0.0 );", "	float hh = h * abs( r - vUv.y );", "	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;", "	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;", "	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;", "	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;", "	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;", "	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;", "	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;", "	gl_FragColor = sum;", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/HueSaturationShader.js
var HueSaturationShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    hue: {
      value: 0
    },
    saturation: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform float hue;",
    "uniform float saturation;",
    "varying vec2 vUv;",
    "void main() {",
    "	gl_FragColor = texture2D( tDiffuse, vUv );",
    // hue
    "	float angle = hue * 3.14159265;",
    "	float s = sin(angle), c = cos(angle);",
    "	vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;",
    "	float len = length(gl_FragColor.rgb);",
    "	gl_FragColor.rgb = vec3(",
    "		dot(gl_FragColor.rgb, weights.xyz),",
    "		dot(gl_FragColor.rgb, weights.zxy),",
    "		dot(gl_FragColor.rgb, weights.yzx)",
    "	);",
    // saturation
    "	float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;",
    "	if (saturation > 0.0) {",
    "		gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));",
    "	} else {",
    "		gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);",
    "	}",
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/KaleidoShader.js
var KaleidoShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    sides: {
      value: 6
    },
    angle: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float sides;", "uniform float angle;", "varying vec2 vUv;", "void main() {", "	vec2 p = vUv - 0.5;", "	float r = length(p);", "	float a = atan(p.y, p.x) + angle;", "	float tau = 2. * 3.1416 ;", "	a = mod(a, tau/sides);", "	a = abs(a - tau/sides/2.) ;", "	p = r * vec2(cos(a), sin(a));", "	vec4 color = texture2D(tDiffuse, p + 0.5);", "	gl_FragColor = color;", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/MirrorShader.js
var MirrorShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    side: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform int side;", "varying vec2 vUv;", "void main() {", "	vec2 p = vUv;", "	if (side == 0){", "		if (p.x > 0.5) p.x = 1.0 - p.x;", "	}else if (side == 1){", "		if (p.x < 0.5) p.x = 1.0 - p.x;", "	}else if (side == 2){", "		if (p.y < 0.5) p.y = 1.0 - p.y;", "	}else if (side == 3){", "		if (p.y > 0.5) p.y = 1.0 - p.y;", "	} ", "	vec4 color = texture2D(tDiffuse, p);", "	gl_FragColor = color;", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/NormalMapShader.js
var NormalMapShader = {
  uniforms: {
    heightMap: {
      value: null
    },
    resolution: {
      value: new Vector2(512, 512)
    },
    scale: {
      value: new Vector2(1, 1)
    },
    height: {
      value: 0.05
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float height;", "uniform vec2 resolution;", "uniform sampler2D heightMap;", "varying vec2 vUv;", "void main() {", "	float val = texture2D( heightMap, vUv ).x;", "	float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;", "	float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;", "	gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/ParallaxShader.js
var ParallaxShader = {
  // Ordered from fastest to best quality.
  modes: {
    none: "NO_PARALLAX",
    basic: "USE_BASIC_PARALLAX",
    steep: "USE_STEEP_PARALLAX",
    occlusion: "USE_OCLUSION_PARALLAX",
    // a.k.a. POM
    relief: "USE_RELIEF_PARALLAX"
  },
  uniforms: {
    bumpMap: {
      value: null
    },
    map: {
      value: null
    },
    parallaxScale: {
      value: null
    },
    parallaxMinLayers: {
      value: null
    },
    parallaxMaxLayers: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "varying vec3 vViewPosition;", "varying vec3 vNormal;", "void main() {", "	vUv = uv;", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	vViewPosition = -mvPosition.xyz;", "	vNormal = normalize( normalMatrix * normal );", "	gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D bumpMap;",
    "uniform sampler2D map;",
    "uniform float parallaxScale;",
    "uniform float parallaxMinLayers;",
    "uniform float parallaxMaxLayers;",
    "varying vec2 vUv;",
    "varying vec3 vViewPosition;",
    "varying vec3 vNormal;",
    "#ifdef USE_BASIC_PARALLAX",
    "	vec2 parallaxMap( in vec3 V ) {",
    "		float initialHeight = texture2D( bumpMap, vUv ).r;",
    // No Offset Limitting: messy, floating output at grazing angles.
    //"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;",
    // Offset Limiting
    "		vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;",
    "		return vUv - texCoordOffset;",
    "	}",
    "#else",
    "	vec2 parallaxMap( in vec3 V ) {",
    // Determine number of layers from angle between V and N
    "		float numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );",
    "		float layerHeight = 1.0 / numLayers;",
    "		float currentLayerHeight = 0.0;",
    // Shift of texture coordinates for each iteration
    "		vec2 dtex = parallaxScale * V.xy / V.z / numLayers;",
    "		vec2 currentTextureCoords = vUv;",
    "		float heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
    // while ( heightFromTexture > currentLayerHeight )
    // Infinite loops are not well supported. Do a "large" finite
    // loop, but not too large, as it slows down some compilers.
    "		for ( int i = 0; i < 30; i += 1 ) {",
    "			if ( heightFromTexture <= currentLayerHeight ) {",
    "				break;",
    "			}",
    "			currentLayerHeight += layerHeight;",
    // Shift texture coordinates along vector V
    "			currentTextureCoords -= dtex;",
    "			heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
    "		}",
    "		#ifdef USE_STEEP_PARALLAX",
    "			return currentTextureCoords;",
    "		#elif defined( USE_RELIEF_PARALLAX )",
    "			vec2 deltaTexCoord = dtex / 2.0;",
    "			float deltaHeight = layerHeight / 2.0;",
    // Return to the mid point of previous layer
    "			currentTextureCoords += deltaTexCoord;",
    "			currentLayerHeight -= deltaHeight;",
    // Binary search to increase precision of Steep Parallax Mapping
    "			const int numSearches = 5;",
    "			for ( int i = 0; i < numSearches; i += 1 ) {",
    "				deltaTexCoord /= 2.0;",
    "				deltaHeight /= 2.0;",
    "				heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;",
    // Shift along or against vector V
    "				if( heightFromTexture > currentLayerHeight ) {",
    // Below the surface
    "					currentTextureCoords -= deltaTexCoord;",
    "					currentLayerHeight += deltaHeight;",
    "				} else {",
    // above the surface
    "					currentTextureCoords += deltaTexCoord;",
    "					currentLayerHeight -= deltaHeight;",
    "				}",
    "			}",
    "			return currentTextureCoords;",
    "		#elif defined( USE_OCLUSION_PARALLAX )",
    "			vec2 prevTCoords = currentTextureCoords + dtex;",
    // Heights for linear interpolation
    "			float nextH = heightFromTexture - currentLayerHeight;",
    "			float prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;",
    // Proportions for linear interpolation
    "			float weight = nextH / ( nextH - prevH );",
    // Interpolation of texture coordinates
    "			return prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );",
    "		#else",
    // NO_PARALLAX
    "			return vUv;",
    "		#endif",
    "	}",
    "#endif",
    "vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {",
    "	vec2 texDx = dFdx( vUv );",
    "	vec2 texDy = dFdy( vUv );",
    "	vec3 vSigmaX = dFdx( surfPosition );",
    "	vec3 vSigmaY = dFdy( surfPosition );",
    "	vec3 vR1 = cross( vSigmaY, surfNormal );",
    "	vec3 vR2 = cross( surfNormal, vSigmaX );",
    "	float fDet = dot( vSigmaX, vR1 );",
    "	vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );",
    "	vec3 vProjVtex;",
    "	vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;",
    "	vProjVtex.z = dot( surfNormal, viewPosition );",
    "	return parallaxMap( vProjVtex );",
    "}",
    "void main() {",
    "	vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );",
    "	gl_FragColor = texture2D( map, mapUv );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/PixelShader.js
var PixelShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: null
    },
    pixelSize: {
      value: 1
    }
  },
  vertexShader: ["varying highp vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float pixelSize;", "uniform vec2 resolution;", "varying highp vec2 vUv;", "void main(){", "vec2 dxy = pixelSize / resolution;", "vec2 coord = dxy * floor( vUv / dxy );", "gl_FragColor = texture2D(tDiffuse, coord);", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/RGBShiftShader.js
var RGBShiftShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    amount: {
      value: 5e-3
    },
    angle: {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float amount;", "uniform float angle;", "varying vec2 vUv;", "void main() {", "	vec2 offset = amount * vec2( cos(angle), sin(angle));", "	vec4 cr = texture2D(tDiffuse, vUv + offset);", "	vec4 cga = texture2D(tDiffuse, vUv);", "	vec4 cb = texture2D(tDiffuse, vUv - offset);", "	gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/SepiaShader.js
var SepiaShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    amount: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float amount;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 color = texture2D( tDiffuse, vUv );", "	vec3 c = color.rgb;", "	color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );", "	color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );", "	color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );", "	gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/SobelOperatorShader.js
var SobelOperatorShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    resolution: {
      value: new Vector2()
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform sampler2D tDiffuse;",
    "uniform vec2 resolution;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );",
    // kernel definition (in glsl matrices are filled in column-major order)
    "	const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );",
    // x direction kernel
    "	const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );",
    // y direction kernel
    // fetch the 3x3 neighbourhood of a fragment
    // first column
    "	float tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;",
    "	float tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;",
    "	float tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;",
    // second column
    "	float tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;",
    "	float tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;",
    "	float tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;",
    // third column
    "	float tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;",
    "	float tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;",
    "	float tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;",
    // gradient value in x direction
    "	float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ",
    "		Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ",
    "		Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ",
    // gradient value in y direction
    "	float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ",
    "		Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ",
    "		Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ",
    // magnitute of the total gradient
    "	float G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );",
    "	gl_FragColor = vec4( vec3( G ), 1 );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/SubsurfaceScatteringShader.js
function replaceAll(string, find, replace) {
  return string.split(find).join(replace);
}
var meshphong_frag_head = ShaderChunk["meshphong_frag"].slice(0, ShaderChunk["meshphong_frag"].indexOf("void main() {"));
var meshphong_frag_body = ShaderChunk["meshphong_frag"].slice(ShaderChunk["meshphong_frag"].indexOf("void main() {"));
var SubsurfaceScatteringShader = {
  uniforms: UniformsUtils.merge([ShaderLib["phong"].uniforms, {
    thicknessMap: {
      value: null
    },
    thicknessColor: {
      value: new Color(16777215)
    },
    thicknessDistortion: {
      value: 0.1
    },
    thicknessAmbient: {
      value: 0
    },
    thicknessAttenuation: {
      value: 0.1
    },
    thicknessPower: {
      value: 2
    },
    thicknessScale: {
      value: 10
    }
  }]),
  vertexShader: ["#define USE_UV", ShaderChunk["meshphong_vert"]].join("\n"),
  fragmentShader: ["#define USE_UV", "#define SUBSURFACE", meshphong_frag_head, "uniform sampler2D thicknessMap;", "uniform float thicknessPower;", "uniform float thicknessScale;", "uniform float thicknessDistortion;", "uniform float thicknessAmbient;", "uniform float thicknessAttenuation;", "uniform vec3 thicknessColor;", "void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {", "	vec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;", "	vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));", "	float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;", "	vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;", "	reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;", "}", meshphong_frag_body.replace("#include <lights_fragment_begin>", replaceAll(ShaderChunk["lights_fragment_begin"], "RE_Direct( directLight, geometry, material, reflectedLight );", ["RE_Direct( directLight, geometry, material, reflectedLight );", "#if defined( SUBSURFACE ) && defined( USE_UV )", " RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);", "#endif"].join("\n")))].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/TechnicolorShader.js
var TechnicolorShader = {
  uniforms: {
    tDiffuse: {
      value: null
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "	vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );", "	vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);", "	gl_FragColor = newTex;", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/ToonShader.js
var ToonShader1 = {
  uniforms: {
    uDirLightPos: {
      value: new Vector3()
    },
    uDirLightColor: {
      value: new Color(15658734)
    },
    uAmbientLightColor: {
      value: new Color(328965)
    },
    uBaseColor: {
      value: new Color(16777215)
    }
  },
  vertexShader: ["varying vec3 vNormal;", "varying vec3 vRefract;", "void main() {", "	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	vec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );", "	vNormal = normalize( normalMatrix * normal );", "	vec3 I = worldPosition.xyz - cameraPosition;", "	vRefract = refract( normalize( I ), worldNormal, 1.02 );", "	gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"),
  fragmentShader: ["uniform vec3 uBaseColor;", "uniform vec3 uDirLightPos;", "uniform vec3 uDirLightColor;", "uniform vec3 uAmbientLightColor;", "varying vec3 vNormal;", "varying vec3 vRefract;", "void main() {", "	float directionalLightWeighting = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);", "	vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;", "	float intensity = smoothstep( - 0.5, 1.0, pow( length(lightWeighting), 20.0 ) );", "	intensity += length(lightWeighting) * 0.2;", "	float cameraWeighting = dot( normalize( vNormal ), vRefract );", "	intensity += pow( 1.0 - length( cameraWeighting ), 6.0 );", "	intensity = intensity * 0.2 + 0.3;", "	if ( intensity < 0.50 ) {", "		gl_FragColor = vec4( 2.0 * intensity * uBaseColor, 1.0 );", "	} else {", "		gl_FragColor = vec4( 1.0 - 2.0 * ( 1.0 - intensity ) * ( 1.0 - uBaseColor ), 1.0 );", "}", "}"].join("\n")
};
var ToonShader2 = {
  uniforms: {
    uDirLightPos: {
      value: new Vector3()
    },
    uDirLightColor: {
      value: new Color(15658734)
    },
    uAmbientLightColor: {
      value: new Color(328965)
    },
    uBaseColor: {
      value: new Color(15658734)
    },
    uLineColor1: {
      value: new Color(8421504)
    },
    uLineColor2: {
      value: new Color(0)
    },
    uLineColor3: {
      value: new Color(0)
    },
    uLineColor4: {
      value: new Color(0)
    }
  },
  vertexShader: ["varying vec3 vNormal;", "void main() {", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "	vNormal = normalize( normalMatrix * normal );", "}"].join("\n"),
  fragmentShader: ["uniform vec3 uBaseColor;", "uniform vec3 uLineColor1;", "uniform vec3 uLineColor2;", "uniform vec3 uLineColor3;", "uniform vec3 uLineColor4;", "uniform vec3 uDirLightPos;", "uniform vec3 uDirLightColor;", "uniform vec3 uAmbientLightColor;", "varying vec3 vNormal;", "void main() {", "	float camera = max( dot( normalize( vNormal ), vec3( 0.0, 0.0, 1.0 ) ), 0.4);", "	float light = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);", "	gl_FragColor = vec4( uBaseColor, 1.0 );", "	if ( length(uAmbientLightColor + uDirLightColor * light) < 1.00 ) {", "		gl_FragColor *= vec4( uLineColor1, 1.0 );", "	}", "	if ( length(uAmbientLightColor + uDirLightColor * camera) < 0.50 ) {", "		gl_FragColor *= vec4( uLineColor2, 1.0 );", "	}", "}"].join("\n")
};
var ToonShaderHatching = {
  uniforms: {
    uDirLightPos: {
      value: new Vector3()
    },
    uDirLightColor: {
      value: new Color(15658734)
    },
    uAmbientLightColor: {
      value: new Color(328965)
    },
    uBaseColor: {
      value: new Color(16777215)
    },
    uLineColor1: {
      value: new Color(0)
    },
    uLineColor2: {
      value: new Color(0)
    },
    uLineColor3: {
      value: new Color(0)
    },
    uLineColor4: {
      value: new Color(0)
    }
  },
  vertexShader: ["varying vec3 vNormal;", "void main() {", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "	vNormal = normalize( normalMatrix * normal );", "}"].join("\n"),
  fragmentShader: ["uniform vec3 uBaseColor;", "uniform vec3 uLineColor1;", "uniform vec3 uLineColor2;", "uniform vec3 uLineColor3;", "uniform vec3 uLineColor4;", "uniform vec3 uDirLightPos;", "uniform vec3 uDirLightColor;", "uniform vec3 uAmbientLightColor;", "varying vec3 vNormal;", "void main() {", "	float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);", "	vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;", "	gl_FragColor = vec4( uBaseColor, 1.0 );", "	if ( length(lightWeighting) < 1.00 ) {", "		if ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {", "			gl_FragColor = vec4( uLineColor1, 1.0 );", "		}", "	}", "	if ( length(lightWeighting) < 0.75 ) {", "		if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {", "			gl_FragColor = vec4( uLineColor2, 1.0 );", "		}", "	}", "	if ( length(lightWeighting) < 0.50 ) {", "		if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "			gl_FragColor = vec4( uLineColor3, 1.0 );", "		}", "	}", "	if ( length(lightWeighting) < 0.3465 ) {", "		if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {", "			gl_FragColor = vec4( uLineColor4, 1.0 );", "	}", "	}", "}"].join("\n")
};
var ToonShaderDotted = {
  uniforms: {
    uDirLightPos: {
      value: new Vector3()
    },
    uDirLightColor: {
      value: new Color(15658734)
    },
    uAmbientLightColor: {
      value: new Color(328965)
    },
    uBaseColor: {
      value: new Color(16777215)
    },
    uLineColor1: {
      value: new Color(0)
    }
  },
  vertexShader: ["varying vec3 vNormal;", "void main() {", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "	vNormal = normalize( normalMatrix * normal );", "}"].join("\n"),
  fragmentShader: ["uniform vec3 uBaseColor;", "uniform vec3 uLineColor1;", "uniform vec3 uLineColor2;", "uniform vec3 uLineColor3;", "uniform vec3 uLineColor4;", "uniform vec3 uDirLightPos;", "uniform vec3 uDirLightColor;", "uniform vec3 uAmbientLightColor;", "varying vec3 vNormal;", "void main() {", "float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);", "vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;", "gl_FragColor = vec4( uBaseColor, 1.0 );", "if ( length(lightWeighting) < 1.00 ) {", "		if ( ( mod(gl_FragCoord.x, 4.001) + mod(gl_FragCoord.y, 4.0) ) > 6.00 ) {", "			gl_FragColor = vec4( uLineColor1, 1.0 );", "		}", "	}", "	if ( length(lightWeighting) < 0.50 ) {", "		if ( ( mod(gl_FragCoord.x + 2.0, 4.001) + mod(gl_FragCoord.y + 2.0, 4.0) ) > 6.00 ) {", "			gl_FragColor = vec4( uLineColor1, 1.0 );", "		}", "	}", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/TriangleBlurShader.js
var TriangleBlurShader = {
  uniforms: {
    texture: {
      value: null
    },
    delta: {
      value: new Vector2(1, 1)
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "#include <common>",
    "#define ITERATIONS 10.0",
    "uniform sampler2D texture;",
    "uniform vec2 delta;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec4 color = vec4( 0.0 );",
    "	float total = 0.0;",
    // randomize the lookup values to hide the fixed number of samples
    "	float offset = rand( vUv );",
    "	for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {",
    "		float percent = ( t + offset - 0.5 ) / ITERATIONS;",
    "		float weight = 1.0 - abs( percent );",
    "		color += texture2D( texture, vUv + delta * percent ) * weight;",
    "		total += weight;",
    "	}",
    "	gl_FragColor = color / total;",
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/VerticalBlurShader.js
var VerticalBlurShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    v: {
      value: 1 / 512
    }
  },
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `
  ),
  fragmentShader: (
    /* glsl */
    `

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `
  )
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/VerticalTiltShiftShader.js
var VerticalTiltShiftShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    v: {
      value: 1 / 512
    },
    r: {
      value: 0.35
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float v;", "uniform float r;", "varying vec2 vUv;", "void main() {", "	vec4 sum = vec4( 0.0 );", "	float vv = v * abs( r - vUv.y );", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;", "	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;", "	gl_FragColor = sum;", "}"].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/VignetteShader.js
var VignetteShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    offset: {
      value: 1
    },
    darkness: {
      value: 1
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform float offset;",
    "uniform float darkness;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    // Eskil's vignette
    "	vec4 texel = texture2D( tDiffuse, vUv );",
    "	vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );",
    "	gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );",
    /*
    // alternative version from glfx.js
    // this one makes more "dusty" look (as opposed to "burned")
    "	vec4 color = texture2D( tDiffuse, vUv );",
    "	float dist = distance( vUv, vec2( 0.5 ) );",
    "	color.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );",
    "	gl_FragColor = color;",
    */
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/VolumeShader.js
var VolumeRenderShader1 = {
  uniforms: {
    u_size: {
      value: new Vector3(1, 1, 1)
    },
    u_renderstyle: {
      value: 0
    },
    u_renderthreshold: {
      value: 0.5
    },
    u_clim: {
      value: new Vector2(1, 1)
    },
    u_data: {
      value: null
    },
    u_cmdata: {
      value: null
    }
  },
  vertexShader: [
    "		varying vec4 v_nearpos;",
    "		varying vec4 v_farpos;",
    "		varying vec3 v_position;",
    "		void main() {",
    // Prepare transforms to map to "camera view". See also:
    // https://threejs.org/docs/#api/renderers/webgl/WebGLProgram
    "				mat4 viewtransformf = modelViewMatrix;",
    "				mat4 viewtransformi = inverse(modelViewMatrix);",
    // Project local vertex coordinate to camera position. Then do a step
    // backward (in cam coords) to the near clipping plane, and project back. Do
    // the same for the far clipping plane. This gives us all the information we
    // need to calculate the ray and truncate it to the viewing cone.
    "				vec4 position4 = vec4(position, 1.0);",
    "				vec4 pos_in_cam = viewtransformf * position4;",
    // Intersection of ray and near clipping plane (z = -1 in clip coords)
    "				pos_in_cam.z = -pos_in_cam.w;",
    "				v_nearpos = viewtransformi * pos_in_cam;",
    // Intersection of ray and far clipping plane (z = +1 in clip coords)
    "				pos_in_cam.z = pos_in_cam.w;",
    "				v_farpos = viewtransformi * pos_in_cam;",
    // Set varyings and output pos
    "				v_position = position;",
    "				gl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;",
    "		}"
  ].join("\n"),
  fragmentShader: [
    "		precision highp float;",
    "		precision mediump sampler3D;",
    "		uniform vec3 u_size;",
    "		uniform int u_renderstyle;",
    "		uniform float u_renderthreshold;",
    "		uniform vec2 u_clim;",
    "		uniform sampler3D u_data;",
    "		uniform sampler2D u_cmdata;",
    "		varying vec3 v_position;",
    "		varying vec4 v_nearpos;",
    "		varying vec4 v_farpos;",
    // The maximum distance through our rendering volume is sqrt(3).
    "		const int MAX_STEPS = 887;	// 887 for 512^3, 1774 for 1024^3",
    "		const int REFINEMENT_STEPS = 4;",
    "		const float relative_step_size = 1.0;",
    "		const vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);",
    "		const vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);",
    "		const vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);",
    "		const float shininess = 40.0;",
    "		void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);",
    "		void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);",
    "		float sample1(vec3 texcoords);",
    "		vec4 apply_colormap(float val);",
    "		vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);",
    "		void main() {",
    // Normalize clipping plane info
    "				vec3 farpos = v_farpos.xyz / v_farpos.w;",
    "				vec3 nearpos = v_nearpos.xyz / v_nearpos.w;",
    // Calculate unit vector pointing in the view direction through this fragment.
    "				vec3 view_ray = normalize(nearpos.xyz - farpos.xyz);",
    // Compute the (negative) distance to the front surface or near clipping plane.
    // v_position is the back face of the cuboid, so the initial distance calculated in the dot
    // product below is the distance from near clip plane to the back of the cuboid
    "				float distance = dot(nearpos - v_position, view_ray);",
    "				distance = max(distance, min((-0.5 - v_position.x) / view_ray.x,",
    "																		(u_size.x - 0.5 - v_position.x) / view_ray.x));",
    "				distance = max(distance, min((-0.5 - v_position.y) / view_ray.y,",
    "																		(u_size.y - 0.5 - v_position.y) / view_ray.y));",
    "				distance = max(distance, min((-0.5 - v_position.z) / view_ray.z,",
    "																		(u_size.z - 0.5 - v_position.z) / view_ray.z));",
    // Now we have the starting position on the front surface
    "				vec3 front = v_position + view_ray * distance;",
    // Decide how many steps to take
    "				int nsteps = int(-distance / relative_step_size + 0.5);",
    "				if ( nsteps < 1 )",
    "						discard;",
    // Get starting location and step vector in texture coordinates
    "				vec3 step = ((v_position - front) / u_size) / float(nsteps);",
    "				vec3 start_loc = front / u_size;",
    // For testing: show the number of steps. This helps to establish
    // whether the rays are correctly oriented
    //'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);',
    //'return;',
    "				if (u_renderstyle == 0)",
    "						cast_mip(start_loc, step, nsteps, view_ray);",
    "				else if (u_renderstyle == 1)",
    "						cast_iso(start_loc, step, nsteps, view_ray);",
    "				if (gl_FragColor.a < 0.05)",
    "						discard;",
    "		}",
    "		float sample1(vec3 texcoords) {",
    "				/* Sample float value from a 3D texture. Assumes intensity data. */",
    "				return texture(u_data, texcoords.xyz).r;",
    "		}",
    "		vec4 apply_colormap(float val) {",
    "				val = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);",
    "				return texture2D(u_cmdata, vec2(val, 0.5));",
    "		}",
    "		void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {",
    "				float max_val = -1e6;",
    "				int max_i = 100;",
    "				vec3 loc = start_loc;",
    // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with
    // non-constant expression. So we use a hard-coded max, and an additional condition
    // inside the loop.
    "				for (int iter=0; iter<MAX_STEPS; iter++) {",
    "						if (iter >= nsteps)",
    "								break;",
    // Sample from the 3D texture
    "						float val = sample1(loc);",
    // Apply MIP operation
    "						if (val > max_val) {",
    "								max_val = val;",
    "								max_i = iter;",
    "						}",
    // Advance location deeper into the volume
    "						loc += step;",
    "				}",
    // Refine location, gives crispier images
    "				vec3 iloc = start_loc + step * (float(max_i) - 0.5);",
    "				vec3 istep = step / float(REFINEMENT_STEPS);",
    "				for (int i=0; i<REFINEMENT_STEPS; i++) {",
    "						max_val = max(max_val, sample1(iloc));",
    "						iloc += istep;",
    "				}",
    // Resolve final color
    "				gl_FragColor = apply_colormap(max_val);",
    "		}",
    "		void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {",
    "				gl_FragColor = vec4(0.0);	// init transparent",
    "				vec4 color3 = vec4(0.0);	// final color",
    "				vec3 dstep = 1.5 / u_size;	// step to sample derivative",
    "				vec3 loc = start_loc;",
    "				float low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);",
    // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with
    // non-constant expression. So we use a hard-coded max, and an additional condition
    // inside the loop.
    "				for (int iter=0; iter<MAX_STEPS; iter++) {",
    "						if (iter >= nsteps)",
    "								break;",
    // Sample from the 3D texture
    "						float val = sample1(loc);",
    "						if (val > low_threshold) {",
    // Take the last interval in smaller steps
    "								vec3 iloc = loc - 0.5 * step;",
    "								vec3 istep = step / float(REFINEMENT_STEPS);",
    "								for (int i=0; i<REFINEMENT_STEPS; i++) {",
    "										val = sample1(iloc);",
    "										if (val > u_renderthreshold) {",
    "												gl_FragColor = add_lighting(val, iloc, dstep, view_ray);",
    "												return;",
    "										}",
    "										iloc += istep;",
    "								}",
    "						}",
    // Advance location deeper into the volume
    "						loc += step;",
    "				}",
    "		}",
    "		vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)",
    "		{",
    // Calculate color by incorporating lighting
    // View direction
    "				vec3 V = normalize(view_ray);",
    // calculate normal vector from gradient
    "				vec3 N;",
    "				float val1, val2;",
    "				val1 = sample1(loc + vec3(-step[0], 0.0, 0.0));",
    "				val2 = sample1(loc + vec3(+step[0], 0.0, 0.0));",
    "				N[0] = val1 - val2;",
    "				val = max(max(val1, val2), val);",
    "				val1 = sample1(loc + vec3(0.0, -step[1], 0.0));",
    "				val2 = sample1(loc + vec3(0.0, +step[1], 0.0));",
    "				N[1] = val1 - val2;",
    "				val = max(max(val1, val2), val);",
    "				val1 = sample1(loc + vec3(0.0, 0.0, -step[2]));",
    "				val2 = sample1(loc + vec3(0.0, 0.0, +step[2]));",
    "				N[2] = val1 - val2;",
    "				val = max(max(val1, val2), val);",
    "				float gm = length(N); // gradient magnitude",
    "				N = normalize(N);",
    // Flip normal so it points towards viewer
    "				float Nselect = float(dot(N, V) > 0.0);",
    "				N = (2.0 * Nselect - 1.0) * N;	// ==	Nselect * N - (1.0-Nselect)*N;",
    // Init colors
    "				vec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);",
    "				vec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);",
    "				vec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);",
    // note: could allow multiple lights
    "				for (int i=0; i<1; i++)",
    "				{",
    // Get light direction (make sure to prevent zero devision)
    "						vec3 L = normalize(view_ray);	//lightDirs[i];",
    "						float lightEnabled = float( length(L) > 0.0 );",
    "						L = normalize(L + (1.0 - lightEnabled));",
    // Calculate lighting properties
    "						float lambertTerm = clamp(dot(N, L), 0.0, 1.0);",
    "						vec3 H = normalize(L+V); // Halfway vector",
    "						float specularTerm = pow(max(dot(H, N), 0.0), shininess);",
    // Calculate mask
    "						float mask1 = lightEnabled;",
    // Calculate colors
    "						ambient_color +=	mask1 * ambient_color;	// * gl_LightSource[i].ambient;",
    "						diffuse_color +=	mask1 * lambertTerm;",
    "						specular_color += mask1 * specularTerm * specular_color;",
    "				}",
    // Calculate final color by componing different components
    "				vec4 final_color;",
    "				vec4 color = apply_colormap(val);",
    "				final_color = color * (ambient_color + diffuse_color) + specular_color;",
    "				final_color.a = color.a;",
    "				return final_color;",
    "		}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/shaders/WaterRefractionShader.js
var WaterRefractionShader = {
  uniforms: {
    color: {
      value: null
    },
    time: {
      value: 0
    },
    tDiffuse: {
      value: null
    },
    tDudv: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: ["uniform mat4 textureMatrix;", "varying vec2 vUv;", "varying vec4 vUvRefraction;", "void main() {", "	vUv = uv;", "	vUvRefraction = textureMatrix * vec4( position, 1.0 );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: [
    "uniform vec3 color;",
    "uniform float time;",
    "uniform sampler2D tDiffuse;",
    "uniform sampler2D tDudv;",
    "varying vec2 vUv;",
    "varying vec4 vUvRefraction;",
    "float blendOverlay( float base, float blend ) {",
    "	return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );",
    "}",
    "vec3 blendOverlay( vec3 base, vec3 blend ) {",
    "	return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );",
    "}",
    "void main() {",
    " float waveStrength = 0.1;",
    " float waveSpeed = 0.03;",
    // simple distortion (ripple) via dudv map (see https://www.youtube.com/watch?v=6B7IF6GOu7s)
    "	vec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;",
    "	distortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );",
    "	vec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;",
    // new uv coords
    " vec4 uv = vec4( vUvRefraction );",
    " uv.xy += distortion;",
    "	vec4 base = texture2DProj( tDiffuse, uv );",
    "	gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );",
    "}"
  ].join("\n")
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/interactive/InteractiveGroup.js
var _pointer = new Vector2();

// node_modules/@react-three/rapier/node_modules/three-stdlib/interactive/SelectionHelper.js
var SelectionHelper = (() => {
  class SelectionHelper2 {
    constructor(selectionBox, renderer, cssClassName) {
      this.element = document.createElement("div");
      this.element.classList.add(cssClassName);
      this.element.style.pointerEvents = "none";
      this.renderer = renderer;
      this.startPoint = new Vector2();
      this.pointTopLeft = new Vector2();
      this.pointBottomRight = new Vector2();
      this.isDown = false;
      this.renderer.domElement.addEventListener("pointerdown", (event) => {
        this.isDown = true;
        this.onSelectStart(event);
      });
      this.renderer.domElement.addEventListener("pointermove", (event) => {
        if (this.isDown) {
          this.onSelectMove(event);
        }
      });
      this.renderer.domElement.addEventListener("pointerup", (event) => {
        this.isDown = false;
        this.onSelectOver(event);
      });
    }
    onSelectStart(event) {
      this.renderer.domElement.parentElement.appendChild(this.element);
      this.element.style.left = `${event.clientX}px`;
      this.element.style.top = `${event.clientY}px`;
      this.element.style.width = "0px";
      this.element.style.height = "0px";
      this.startPoint.x = event.clientX;
      this.startPoint.y = event.clientY;
    }
    onSelectMove(event) {
      this.pointBottomRight.x = Math.max(this.startPoint.x, event.clientX);
      this.pointBottomRight.y = Math.max(this.startPoint.y, event.clientY);
      this.pointTopLeft.x = Math.min(this.startPoint.x, event.clientX);
      this.pointTopLeft.y = Math.min(this.startPoint.y, event.clientY);
      this.element.style.left = `${this.pointTopLeft.x}px`;
      this.element.style.top = `${this.pointTopLeft.y}px`;
      this.element.style.width = `${this.pointBottomRight.x - this.pointTopLeft.x}px`;
      this.element.style.height = `${this.pointBottomRight.y - this.pointTopLeft.y}px`;
    }
    onSelectOver() {
      this.element.parentElement.removeChild(this.element);
    }
  }
  return SelectionHelper2;
})();

// node_modules/@react-three/rapier/node_modules/three-stdlib/interactive/SelectionBox.js
var SelectionBox = (() => {
  const frustum = new Frustum();
  const center = new Vector3();
  const tmpPoint = new Vector3();
  const vecNear = new Vector3();
  const vecTopLeft = new Vector3();
  const vecTopRight = new Vector3();
  const vecDownRight = new Vector3();
  const vecDownLeft = new Vector3();
  const vecFarTopLeft = new Vector3();
  const vecFarTopRight = new Vector3();
  const vecFarDownRight = new Vector3();
  const vecFarDownLeft = new Vector3();
  const vectemp1 = new Vector3();
  const vectemp2 = new Vector3();
  const vectemp3 = new Vector3();
  class SelectionBox2 {
    constructor(camera, scene, deep) {
      this.camera = camera;
      this.scene = scene;
      this.startPoint = new Vector3();
      this.endPoint = new Vector3();
      this.collection = [];
      this.deep = deep || Number.MAX_VALUE;
    }
    select(startPoint, endPoint) {
      this.startPoint = startPoint || this.startPoint;
      this.endPoint = endPoint || this.endPoint;
      this.collection = [];
      this.updateFrustum(this.startPoint, this.endPoint);
      this.searchChildInFrustum(frustum, this.scene);
      return this.collection;
    }
    updateFrustum(startPoint, endPoint) {
      startPoint = startPoint || this.startPoint;
      endPoint = endPoint || this.endPoint;
      if (startPoint.x === endPoint.x) {
        endPoint.x += Number.EPSILON;
      }
      if (startPoint.y === endPoint.y) {
        endPoint.y += Number.EPSILON;
      }
      this.camera.updateProjectionMatrix();
      this.camera.updateMatrixWorld();
      if (this.camera.isPerspectiveCamera) {
        tmpPoint.copy(startPoint);
        tmpPoint.x = Math.min(startPoint.x, endPoint.x);
        tmpPoint.y = Math.max(startPoint.y, endPoint.y);
        endPoint.x = Math.max(startPoint.x, endPoint.x);
        endPoint.y = Math.min(startPoint.y, endPoint.y);
        vecNear.setFromMatrixPosition(this.camera.matrixWorld);
        vecTopLeft.copy(tmpPoint);
        vecTopRight.set(endPoint.x, tmpPoint.y, 0);
        vecDownRight.copy(endPoint);
        vecDownLeft.set(tmpPoint.x, endPoint.y, 0);
        vecTopLeft.unproject(this.camera);
        vecTopRight.unproject(this.camera);
        vecDownRight.unproject(this.camera);
        vecDownLeft.unproject(this.camera);
        vectemp1.copy(vecTopLeft).sub(vecNear);
        vectemp2.copy(vecTopRight).sub(vecNear);
        vectemp3.copy(vecDownRight).sub(vecNear);
        vectemp1.normalize();
        vectemp2.normalize();
        vectemp3.normalize();
        vectemp1.multiplyScalar(this.deep);
        vectemp2.multiplyScalar(this.deep);
        vectemp3.multiplyScalar(this.deep);
        vectemp1.add(vecNear);
        vectemp2.add(vecNear);
        vectemp3.add(vecNear);
        var planes = frustum.planes;
        planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);
        planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);
        planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);
        planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);
        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);
        planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);
        planes[5].normal.multiplyScalar(-1);
      } else if (this.camera.isOrthographicCamera) {
        const left = Math.min(startPoint.x, endPoint.x);
        const top = Math.max(startPoint.y, endPoint.y);
        const right = Math.max(startPoint.x, endPoint.x);
        const down = Math.min(startPoint.y, endPoint.y);
        vecTopLeft.set(left, top, -1);
        vecTopRight.set(right, top, -1);
        vecDownRight.set(right, down, -1);
        vecDownLeft.set(left, down, -1);
        vecFarTopLeft.set(left, top, 1);
        vecFarTopRight.set(right, top, 1);
        vecFarDownRight.set(right, down, 1);
        vecFarDownLeft.set(left, down, 1);
        vecTopLeft.unproject(this.camera);
        vecTopRight.unproject(this.camera);
        vecDownRight.unproject(this.camera);
        vecDownLeft.unproject(this.camera);
        vecFarTopLeft.unproject(this.camera);
        vecFarTopRight.unproject(this.camera);
        vecFarDownRight.unproject(this.camera);
        vecFarDownLeft.unproject(this.camera);
        var planes = frustum.planes;
        planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);
        planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);
        planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);
        planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);
        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);
        planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);
        planes[5].normal.multiplyScalar(-1);
      } else {
        console.error("THREE.SelectionBox: Unsupported camera type.");
      }
    }
    searchChildInFrustum(frustum2, object) {
      if (object.isMesh || object.isLine || object.isPoints) {
        if (object.material !== void 0) {
          if (object.geometry.boundingSphere === null)
            object.geometry.computeBoundingSphere();
          center.copy(object.geometry.boundingSphere.center);
          center.applyMatrix4(object.matrixWorld);
          if (frustum2.containsPoint(center)) {
            this.collection.push(object);
          }
        }
      }
      if (object.children.length > 0) {
        for (let x = 0; x < object.children.length; x++) {
          this.searchChildInFrustum(frustum2, object.children[x]);
        }
      }
    }
  }
  return SelectionBox2;
})();

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/FBXLoader.js
var tempEuler = new Euler();
var tempVec = new Vector3();

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/FontLoader.js
var Font = class {
  constructor(data) {
    _defineProperty(this, "data", void 0);
    this.data = data;
  }
  generateShapes(text, size2 = 100, _options) {
    const shapes = [];
    const options = {
      letterSpacing: 0,
      lineHeight: 1,
      ..._options
    };
    const paths = createPaths(text, size2, this.data, options);
    for (let p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes(false));
    }
    return shapes;
  }
};
_defineProperty(Font, "isFont", void 0);
_defineProperty(Font, "type", void 0);
function createPaths(text, size2, data, options) {
  const chars = Array.from(text);
  const scale = size2 / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i2 = 0; i2 < chars.length; i2++) {
    const char = chars[i2];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height * options.lineHeight;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      if (ret) {
        offsetX += ret.offsetX + options.letterSpacing;
        paths.push(ret.path);
      }
    }
  }
  return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i2 = 0, l = outline.length; i2 < l; ) {
      const action = outline[i2++];
      switch (action) {
        case "m":
          x = parseInt(outline[i2++]) * scale + offsetX;
          y = parseInt(outline[i2++]) * scale + offsetY;
          path.moveTo(x, y);
          break;
        case "l":
          x = parseInt(outline[i2++]) * scale + offsetX;
          y = parseInt(outline[i2++]) * scale + offsetY;
          path.lineTo(x, y);
          break;
        case "q":
          cpx = parseInt(outline[i2++]) * scale + offsetX;
          cpy = parseInt(outline[i2++]) * scale + offsetY;
          cpx1 = parseInt(outline[i2++]) * scale + offsetX;
          cpy1 = parseInt(outline[i2++]) * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = parseInt(outline[i2++]) * scale + offsetX;
          cpy = parseInt(outline[i2++]) * scale + offsetY;
          cpx1 = parseInt(outline[i2++]) * scale + offsetX;
          cpy1 = parseInt(outline[i2++]) * scale + offsetY;
          cpx2 = parseInt(outline[i2++]) * scale + offsetX;
          cpy2 = parseInt(outline[i2++]) * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return {
    offsetX: glyph.ha * scale,
    path
  };
}

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/XLoader.js
var XLoader = function() {
  var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = function() {
    function defineProperties(target, props) {
      for (let i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var XboneInf = function XboneInf2() {
    classCallCheck(this, XboneInf2);
    this.boneName = "";
    this.BoneIndex = 0;
    this.Indeces = [];
    this.Weights = [];
    this.initMatrix = null;
    this.OffsetMatrix = null;
  };
  var XAnimationInfo = function XAnimationInfo2() {
    classCallCheck(this, XAnimationInfo2);
    this.animeName = "";
    this.boneName = "";
    this.targetBone = null;
    this.keyType = 4;
    this.frameStartLv = 0;
    this.keyFrames = [];
    this.InverseMx = null;
  };
  var XAnimationObj = function() {
    function XAnimationObj2(_flags) {
      classCallCheck(this, XAnimationObj2);
      this.fps = 30;
      this.name = "xanimation";
      this.length = 0;
      this.hierarchy = [];
      this.putFlags = _flags;
      if (this.putFlags.putPos === void 0) {
        this.putFlags.putPos = true;
      }
      if (this.putFlags.putRot === void 0) {
        this.putFlags.putRot = true;
      }
      if (this.putFlags.putScl === void 0) {
        this.putFlags.putScl = true;
      }
    }
    createClass(XAnimationObj2, [{
      key: "make",
      value: function make(XAnimationInfoArray) {
        for (let i2 = 0; i2 < XAnimationInfoArray.length; i2++) {
          this.hierarchy.push(this.makeBonekeys(XAnimationInfoArray[i2]));
        }
        this.length = this.hierarchy[0].keys[this.hierarchy[0].keys.length - 1].time;
      }
    }, {
      key: "clone",
      value: function clone() {
        return Object.assign({}, this);
      }
    }, {
      key: "makeBonekeys",
      value: function makeBonekeys(XAnimationInfo2) {
        var refObj = {};
        refObj.name = XAnimationInfo2.boneName;
        refObj.parent = "";
        refObj.keys = this.keyFrameRefactor(XAnimationInfo2);
        refObj.copy = function() {
          return Object.assign({}, this);
        };
        return refObj;
      }
    }, {
      key: "keyFrameRefactor",
      value: function keyFrameRefactor(XAnimationInfo2) {
        var keys = [];
        for (let i2 = 0; i2 < XAnimationInfo2.keyFrames.length; i2++) {
          var keyframe = {};
          keyframe.time = XAnimationInfo2.keyFrames[i2].time * this.fps;
          if (XAnimationInfo2.keyFrames[i2].pos && this.putFlags.putPos) {
            keyframe.pos = XAnimationInfo2.keyFrames[i2].pos;
          }
          if (XAnimationInfo2.keyFrames[i2].rot && this.putFlags.putRot) {
            keyframe.rot = XAnimationInfo2.keyFrames[i2].rot;
          }
          if (XAnimationInfo2.keyFrames[i2].scl && this.putFlags.putScl) {
            keyframe.scl = XAnimationInfo2.keyFrames[i2].scl;
          }
          if (XAnimationInfo2.keyFrames[i2].matrix) {
            keyframe.matrix = XAnimationInfo2.keyFrames[i2].matrix;
            if (this.putFlags.putPos) {
              keyframe.pos = new Vector3().setFromMatrixPosition(keyframe.matrix);
            }
            if (this.putFlags.putRot) {
              keyframe.rot = new Quaternion().setFromRotationMatrix(keyframe.matrix);
            }
            if (this.putFlags.putScl) {
              keyframe.scl = new Vector3().setFromMatrixScale(keyframe.matrix);
            }
          }
          keys.push(keyframe);
        }
        return keys;
      }
    }]);
    return XAnimationObj2;
  }();
  var XKeyFrameInfo = function XKeyFrameInfo2() {
    classCallCheck(this, XKeyFrameInfo2);
    this.index = 0;
    this.Frame = 0;
    this.time = 0;
    this.matrix = null;
  };
  var XLoader2 = function() {
    function XLoader3(manager) {
      Loader.call(this, manager);
      classCallCheck(this, XLoader3);
      this.debug = false;
      this.texloader = new TextureLoader(this.manager);
      this.url = "";
      this._putMatLength = 0;
      this._nowMat = null;
      this._nowFrameName = "";
      this.frameHierarchie = [];
      this.Hierarchies = {};
      this.HieStack = [];
      this._currentObject = {};
      this._currentFrame = {};
      this._data = null;
      this.onLoad = null;
      this.IsUvYReverse = true;
      this.Meshes = [];
      this.animations = [];
      this.animTicksPerSecond = 30;
      this._currentGeo = null;
      this._currentAnime = null;
      this._currentAnimeFrames = null;
    }
    createClass(XLoader3, [{
      key: "_setArgOption",
      value: function _setArgOption(_arg) {
        var _start3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        if (!_arg) {
          return;
        }
        for (let i2 = _start3; i2 < _arg.length; i2++) {
          switch (i2) {
            case 0:
              this.url = _arg[i2];
              break;
            case 1:
              this.options = _arg[i2];
              break;
          }
        }
        if (this.options === void 0) {
          this.options = {};
        }
      }
    }, {
      key: "load",
      value: function load(_arg, onLoad, onProgress, onError) {
        var _this = this;
        this._setArgOption(_arg);
        var loader = new FileLoader2(this.manager);
        loader.setPath(this.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(this.url, function(response) {
          try {
            _this.parse(response, onLoad);
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            _this.manager.itemError(_this.url);
          }
        }, onProgress, onError);
      }
    }, {
      key: "_readLine",
      value: function _readLine(line) {
        var readed = 0;
        while (true) {
          var find = -1;
          find = line.indexOf("//", readed);
          if (find === -1) {
            find = line.indexOf("#", readed);
          }
          if (find > -1 && find < 2) {
            var foundNewLine = -1;
            foundNewLine = line.indexOf("\r\n", readed);
            if (foundNewLine > 0) {
              readed = foundNewLine + 2;
            } else {
              foundNewLine = line.indexOf("\r", readed);
              if (foundNewLine > 0) {
                readed = foundNewLine + 1;
              } else {
                readed = line.indexOf("\n", readed) + 1;
              }
            }
          } else {
            break;
          }
        }
        return line.substr(readed);
      }
    }, {
      key: "_readLine",
      value: function _readLine(line) {
        var readed = 0;
        while (true) {
          var find = -1;
          find = line.indexOf("//", readed);
          if (find === -1) {
            find = line.indexOf("#", readed);
          }
          if (find > -1 && find < 2) {
            var foundNewLine = -1;
            foundNewLine = line.indexOf("\r\n", readed);
            if (foundNewLine > 0) {
              readed = foundNewLine + 2;
            } else {
              foundNewLine = line.indexOf("\r", readed);
              if (foundNewLine > 0) {
                readed = foundNewLine + 1;
              } else {
                readed = line.indexOf("\n", readed) + 1;
              }
            }
          } else {
            break;
          }
        }
        return line.substr(readed);
      }
    }, {
      key: "_isBinary",
      value: function _isBinary(binData) {
        var reader = new DataView(binData);
        var face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
        var n_faces = reader.getUint32(80, true);
        var expect = 80 + 32 / 8 + n_faces * face_size;
        if (expect === reader.byteLength) {
          return true;
        }
        var fileLength = reader.byteLength;
        for (let index = 0; index < fileLength; index++) {
          if (reader.getUint8(index, false) > 127) {
            return true;
          }
        }
        return false;
      }
    }, {
      key: "_ensureBinary",
      value: function _ensureBinary(buf) {
        if (typeof buf === "string") {
          var array_buffer = new Uint8Array(buf.length);
          for (let i2 = 0; i2 < buf.length; i2++) {
            array_buffer[i2] = buf.charCodeAt(i2) & 255;
          }
          return array_buffer.buffer || array_buffer;
        } else {
          return buf;
        }
      }
    }, {
      key: "_ensureString",
      value: function _ensureString(buf) {
        if (typeof buf !== "string") {
          return LoaderUtils.decodeText(new Uint8Array(buf));
        } else {
          return buf;
        }
      }
    }, {
      key: "parse",
      value: function _parse(data, onLoad) {
        var binData = this._ensureBinary(data);
        this._data = this._ensureString(data);
        this.onLoad = onLoad;
        return this._isBinary(binData) ? this._parseBinary(binData) : this._parseASCII();
      }
    }, {
      key: "_parseBinary",
      value: function _parseBinary(data) {
        return this._parseASCII(LoaderUtils.decodeText(new Uint8Array(data)));
      }
    }, {
      key: "_parseASCII",
      value: function _parseASCII() {
        var path;
        if (this.resourcePath !== "") {
          path = this.resourcePath;
        } else if (this.path !== "") {
          path = this.path;
        } else {
          path = LoaderUtils.extractUrlBase(this.url);
        }
        this.texloader.setPath(path).setCrossOrigin(this.crossOrigin);
        var endRead = 16;
        this.Hierarchies.children = [];
        this._hierarchieParse(this.Hierarchies, endRead);
        this._changeRoot();
        this._currentObject = this.Hierarchies.children.shift();
        this._mainloop();
      }
    }, {
      key: "_hierarchieParse",
      value: function _hierarchieParse(_parent, _end3) {
        var endRead = _end3;
        while (true) {
          var find1 = this._data.indexOf("{", endRead) + 1;
          var findEnd = this._data.indexOf("}", endRead);
          var findNext = this._data.indexOf("{", find1) + 1;
          if (find1 > 0 && findEnd > find1) {
            var _currentObject = {};
            _currentObject.children = [];
            var nameData = this._readLine(this._data.substr(endRead, find1 - endRead - 1)).trim();
            var word = nameData.split(/ /g);
            if (word.length > 0) {
              _currentObject.type = word[0];
              if (word.length >= 2) {
                _currentObject.name = word[1];
              } else {
                _currentObject.name = word[0] + this.Hierarchies.children.length;
              }
            } else {
              _currentObject.name = nameData;
              _currentObject.type = "";
            }
            if (_currentObject.type === "Animation") {
              _currentObject.data = this._data.substr(findNext, findEnd - findNext).trim();
              var refs = this._hierarchieParse(_currentObject, findEnd + 1);
              endRead = refs.end;
              _currentObject.children = refs.parent.children;
            } else {
              var DataEnder = this._data.lastIndexOf(";", findNext > 0 ? Math.min(findNext, findEnd) : findEnd);
              _currentObject.data = this._data.substr(find1, DataEnder - find1).trim();
              if (findNext <= 0 || findEnd < findNext) {
                endRead = findEnd + 1;
              } else {
                var nextStart = Math.max(DataEnder + 1, find1);
                var _refs = this._hierarchieParse(_currentObject, nextStart);
                endRead = _refs.end;
                _currentObject.children = _refs.parent.children;
              }
            }
            _currentObject.parent = _parent;
            if (_currentObject.type != "template") {
              _parent.children.push(_currentObject);
            }
          } else {
            endRead = find1 === -1 ? this._data.length : findEnd + 1;
            break;
          }
        }
        return {
          parent: _parent,
          end: endRead
        };
      }
    }, {
      key: "_mainloop",
      value: function _mainloop() {
        var _this2 = this;
        this._mainProc();
        if (this._currentObject.parent || this._currentObject.children.length > 0 || !this._currentObject.worked) {
          setTimeout(function() {
            _this2._mainloop();
          }, 1);
        } else {
          setTimeout(function() {
            _this2.onLoad({
              models: _this2.Meshes,
              animations: _this2.animations
            });
          }, 1);
        }
      }
    }, {
      key: "_mainProc",
      value: function _mainProc() {
        var breakFlag = false;
        while (true) {
          if (!this._currentObject.worked) {
            switch (this._currentObject.type) {
              case "template":
                break;
              case "AnimTicksPerSecond":
                this.animTicksPerSecond = parseInt(this._currentObject.data);
                break;
              case "Frame":
                this._setFrame();
                break;
              case "FrameTransformMatrix":
                this._setFrameTransformMatrix();
                break;
              case "Mesh":
                this._changeRoot();
                this._currentGeo = {};
                this._currentGeo.name = this._currentObject.name.trim();
                this._currentGeo.parentName = this._getParentName(this._currentObject).trim();
                this._currentGeo.VertexSetedBoneCount = [];
                this._currentGeo.GeometryData = {
                  vertices: [],
                  normals: [],
                  uvs: [],
                  skinIndices: [],
                  skinWeights: [],
                  indices: [],
                  materialIndices: []
                };
                this._currentGeo.Materials = [];
                this._currentGeo.normalVectors = [];
                this._currentGeo.BoneInfs = [];
                this._currentGeo.baseFrame = this._currentFrame;
                this._makeBoneFrom_CurrentFrame();
                this._readVertexDatas();
                breakFlag = true;
                break;
              case "MeshNormals":
                this._readVertexDatas();
                break;
              case "MeshTextureCoords":
                this._setMeshTextureCoords();
                break;
              case "VertexDuplicationIndices":
                break;
              case "MeshMaterialList":
                this._setMeshMaterialList();
                break;
              case "Material":
                this._setMaterial();
                break;
              case "SkinWeights":
                this._setSkinWeights();
                break;
              case "AnimationSet":
                this._changeRoot();
                this._currentAnime = {};
                this._currentAnime.name = this._currentObject.name.trim();
                this._currentAnime.AnimeFrames = [];
                break;
              case "Animation":
                if (this._currentAnimeFrames) {
                  this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);
                }
                this._currentAnimeFrames = new XAnimationInfo();
                this._currentAnimeFrames.boneName = this._currentObject.data.trim();
                break;
              case "AnimationKey":
                this._readAnimationKey();
                breakFlag = true;
                break;
            }
            this._currentObject.worked = true;
          }
          if (this._currentObject.children.length > 0) {
            this._currentObject = this._currentObject.children.shift();
            if (this.debug) {
              console.log("processing " + this._currentObject.name);
            }
            if (breakFlag)
              break;
          } else {
            if (this._currentObject.worked) {
              if (this._currentObject.parent && !this._currentObject.parent.parent) {
                this._changeRoot();
              }
            }
            if (this._currentObject.parent) {
              this._currentObject = this._currentObject.parent;
            } else {
              breakFlag = true;
            }
            if (breakFlag)
              break;
          }
        }
        return;
      }
    }, {
      key: "_changeRoot",
      value: function _changeRoot() {
        if (this._currentGeo != null && this._currentGeo.name) {
          this._makeOutputGeometry();
        }
        this._currentGeo = {};
        if (this._currentAnime != null && this._currentAnime.name) {
          if (this._currentAnimeFrames) {
            this._currentAnime.AnimeFrames.push(this._currentAnimeFrames);
            this._currentAnimeFrames = null;
          }
          this._makeOutputAnimation();
        }
        this._currentAnime = {};
      }
    }, {
      key: "_getParentName",
      value: function _getParentName(_obj2) {
        if (_obj2.parent) {
          if (_obj2.parent.name) {
            return _obj2.parent.name;
          } else {
            return this._getParentName(_obj2.parent);
          }
        } else {
          return "";
        }
      }
    }, {
      key: "_setFrame",
      value: function _setFrame() {
        this._nowFrameName = this._currentObject.name.trim();
        this._currentFrame = {};
        this._currentFrame.name = this._nowFrameName;
        this._currentFrame.children = [];
        if (this._currentObject.parent && this._currentObject.parent.name) {
          this._currentFrame.parentName = this._currentObject.parent.name;
        }
        this.frameHierarchie.push(this._nowFrameName);
        this.HieStack[this._nowFrameName] = this._currentFrame;
      }
    }, {
      key: "_setFrameTransformMatrix",
      value: function _setFrameTransformMatrix() {
        this._currentFrame.FrameTransformMatrix = new Matrix4();
        var data = this._currentObject.data.split(",");
        this._ParseMatrixData(this._currentFrame.FrameTransformMatrix, data);
        this._makeBoneFrom_CurrentFrame();
      }
    }, {
      key: "_makeBoneFrom_CurrentFrame",
      value: function _makeBoneFrom_CurrentFrame() {
        if (!this._currentFrame.FrameTransformMatrix) {
          return;
        }
        var b2 = new Bone();
        b2.name = this._currentFrame.name;
        b2.applyMatrix4(this._currentFrame.FrameTransformMatrix);
        b2.matrixWorld = b2.matrix;
        b2.FrameTransformMatrix = this._currentFrame.FrameTransformMatrix;
        this._currentFrame.putBone = b2;
        if (this._currentFrame.parentName) {
          for (let frame in this.HieStack) {
            if (this.HieStack[frame].name === this._currentFrame.parentName) {
              this.HieStack[frame].putBone.add(this._currentFrame.putBone);
            }
          }
        }
      }
    }, {
      key: "_readVertexDatas",
      value: function _readVertexDatas() {
        var endRead = 0;
        var mode = 0;
        var mode_local = 0;
        var maxLength = 0;
        while (true) {
          var changeMode = false;
          if (mode_local === 0) {
            var refO = this._readInt1(endRead);
            endRead = refO.endRead;
            mode_local = 1;
            maxLength = this._currentObject.data.indexOf(";;", endRead) + 1;
            if (maxLength <= 0) {
              maxLength = this._currentObject.data.length;
            }
          } else {
            var find = 0;
            switch (mode) {
              case 0:
                find = this._currentObject.data.indexOf(",", endRead) + 1;
                break;
              case 1:
                find = this._currentObject.data.indexOf(";,", endRead) + 1;
                break;
            }
            if (find === 0 || find > maxLength) {
              find = maxLength;
              mode_local = 0;
              changeMode = true;
            }
            switch (this._currentObject.type) {
              case "Mesh":
                switch (mode) {
                  case 0:
                    this._readVertex1(this._currentObject.data.substr(endRead, find - endRead));
                    break;
                  case 1:
                    this._readFace1(this._currentObject.data.substr(endRead, find - endRead));
                    break;
                }
                break;
              case "MeshNormals":
                switch (mode) {
                  case 0:
                    this._readNormalVector1(this._currentObject.data.substr(endRead, find - endRead));
                    break;
                }
                break;
            }
            endRead = find + 1;
            if (changeMode) {
              mode++;
            }
          }
          if (endRead >= this._currentObject.data.length) {
            break;
          }
        }
      }
    }, {
      key: "_readInt1",
      value: function _readInt1(start) {
        var find = this._currentObject.data.indexOf(";", start);
        return {
          refI: parseInt(this._currentObject.data.substr(start, find - start)),
          endRead: find + 1
        };
      }
    }, {
      key: "_readVertex1",
      value: function _readVertex1(line) {
        var data = this._readLine(line.trim()).substr(0, line.length - 2).split(";");
        this._currentGeo.GeometryData.vertices.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]));
        this._currentGeo.GeometryData.skinIndices.push(0, 0, 0, 0);
        this._currentGeo.GeometryData.skinWeights.push(1, 0, 0, 0);
        this._currentGeo.VertexSetedBoneCount.push(0);
      }
    }, {
      key: "_readFace1",
      value: function _readFace1(line) {
        var data = this._readLine(line.trim()).substr(2, line.length - 4).split(",");
        this._currentGeo.GeometryData.indices.push(parseInt(data[0], 10), parseInt(data[1], 10), parseInt(data[2], 10));
      }
    }, {
      key: "_readNormalVector1",
      value: function _readNormalVector1(line) {
        var data = this._readLine(line.trim()).substr(0, line.length - 2).split(";");
        this._currentGeo.GeometryData.normals.push(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2]));
      }
    }, {
      key: "_buildGeometry",
      value: function _buildGeometry() {
        var bufferGeometry = new BufferGeometry();
        var position = [];
        var normals = [];
        var uvs = [];
        var skinIndices = [];
        var skinWeights = [];
        var data = this._currentGeo.GeometryData;
        for (let i2 = 0, l = data.indices.length; i2 < l; i2++) {
          var stride2 = data.indices[i2] * 2;
          var stride3 = data.indices[i2] * 3;
          var stride4 = data.indices[i2] * 4;
          position.push(data.vertices[stride3], data.vertices[stride3 + 1], data.vertices[stride3 + 2]);
          normals.push(data.normals[stride3], data.normals[stride3 + 1], data.normals[stride3 + 2]);
          skinIndices.push(data.skinIndices[stride4], data.skinIndices[stride4 + 1], data.skinIndices[stride4 + 2], data.skinIndices[stride4 + 3]);
          skinWeights.push(data.skinWeights[stride4], data.skinWeights[stride4 + 1], data.skinWeights[stride4 + 2], data.skinWeights[stride4 + 3]);
          uvs.push(data.uvs[stride2], data.uvs[stride2 + 1]);
        }
        bufferGeometry.setAttribute("position", new Float32BufferAttribute(position, 3));
        bufferGeometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        bufferGeometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        bufferGeometry.setAttribute("skinIndex", new Uint16BufferAttribute(skinIndices, 4));
        bufferGeometry.setAttribute("skinWeight", new Float32BufferAttribute(skinWeights, 4));
        this._computeGroups(bufferGeometry, data.materialIndices);
        return bufferGeometry;
      }
    }, {
      key: "_computeGroups",
      value: function _computeGroups(bufferGeometry, materialIndices) {
        var group;
        var groups = [];
        var materialIndex = void 0;
        for (let i2 = 0; i2 < materialIndices.length; i2++) {
          var currentMaterialIndex = materialIndices[i2];
          if (currentMaterialIndex !== materialIndex) {
            materialIndex = currentMaterialIndex;
            if (group !== void 0) {
              group.count = i2 * 3 - group.start;
              groups.push(group);
            }
            group = {
              start: i2 * 3,
              materialIndex
            };
          }
        }
        if (group !== void 0) {
          group.count = i * 3 - group.start;
          groups.push(group);
        }
        bufferGeometry.groups = groups;
      }
    }, {
      key: "_setMeshTextureCoords",
      value: function _setMeshTextureCoords() {
        var endRead = 0;
        var mode = 0;
        var mode_local = 0;
        while (true) {
          switch (mode) {
            case 0:
              if (mode_local === 0) {
                var refO = this._readInt1(0);
                endRead = refO.endRead;
                mode_local = 1;
              } else {
                var find = this._currentObject.data.indexOf(",", endRead) + 1;
                if (find === 0) {
                  find = this._currentObject.data.length;
                  mode = 2;
                  mode_local = 0;
                }
                var line = this._currentObject.data.substr(endRead, find - endRead);
                var data = this._readLine(line.trim()).split(";");
                if (this.IsUvYReverse) {
                  this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), 1 - parseFloat(data[1]));
                } else {
                  this._currentGeo.GeometryData.uvs.push(parseFloat(data[0]), parseFloat(data[1]));
                }
                endRead = find + 1;
              }
              break;
          }
          if (endRead >= this._currentObject.data.length) {
            break;
          }
        }
      }
    }, {
      key: "_setMeshMaterialList",
      value: function _setMeshMaterialList() {
        var endRead = 0;
        var mode = 0;
        var mode_local = 0;
        while (true) {
          if (mode_local < 2) {
            var refO = this._readInt1(endRead);
            endRead = refO.endRead;
            mode_local++;
          } else {
            var find = this._currentObject.data.indexOf(";", endRead);
            if (find === -1) {
              find = this._currentObject.data.length;
              mode = 3;
              mode_local = 0;
            }
            var line = this._currentObject.data.substr(endRead, find - endRead);
            var data = this._readLine(line.trim()).split(",");
            for (let i2 = 0; i2 < data.length; i2++) {
              this._currentGeo.GeometryData.materialIndices[i2] = parseInt(data[i2]);
            }
            endRead = this._currentObject.data.length;
          }
          if (endRead >= this._currentObject.data.length || mode >= 3) {
            break;
          }
        }
      }
    }, {
      key: "_setMaterial",
      value: function _setMaterial() {
        var _nowMat = new MeshPhongMaterial({
          color: Math.random() * 16777215
        });
        _nowMat.side = FrontSide;
        _nowMat.name = this._currentObject.name;
        var endRead = 0;
        var find = this._currentObject.data.indexOf(";;", endRead);
        var line = this._currentObject.data.substr(endRead, find - endRead);
        var data = this._readLine(line.trim()).split(";");
        _nowMat.color.r = parseFloat(data[0]);
        _nowMat.color.g = parseFloat(data[1]);
        _nowMat.color.b = parseFloat(data[2]);
        endRead = find + 2;
        find = this._currentObject.data.indexOf(";", endRead);
        line = this._currentObject.data.substr(endRead, find - endRead);
        _nowMat.shininess = parseFloat(this._readLine(line));
        endRead = find + 1;
        find = this._currentObject.data.indexOf(";;", endRead);
        line = this._currentObject.data.substr(endRead, find - endRead);
        var data2 = this._readLine(line.trim()).split(";");
        _nowMat.specular.r = parseFloat(data2[0]);
        _nowMat.specular.g = parseFloat(data2[1]);
        _nowMat.specular.b = parseFloat(data2[2]);
        endRead = find + 2;
        find = this._currentObject.data.indexOf(";;", endRead);
        if (find === -1) {
          find = this._currentObject.data.length;
        }
        line = this._currentObject.data.substr(endRead, find - endRead);
        var data3 = this._readLine(line.trim()).split(";");
        _nowMat.emissive.r = parseFloat(data3[0]);
        _nowMat.emissive.g = parseFloat(data3[1]);
        _nowMat.emissive.b = parseFloat(data3[2]);
        var localObject = null;
        while (true) {
          if (this._currentObject.children.length > 0) {
            localObject = this._currentObject.children.shift();
            if (this.debug) {
              console.log("processing " + localObject.name);
            }
            var fileName = localObject.data.substr(1, localObject.data.length - 2);
            switch (localObject.type) {
              case "TextureFilename":
                _nowMat.map = this.texloader.load(fileName);
                break;
              case "BumpMapFilename":
                _nowMat.bumpMap = this.texloader.load(fileName);
                _nowMat.bumpScale = 0.05;
                break;
              case "NormalMapFilename":
                _nowMat.normalMap = this.texloader.load(fileName);
                _nowMat.normalScale = new Vector2(2, 2);
                break;
              case "EmissiveMapFilename":
                _nowMat.emissiveMap = this.texloader.load(fileName);
                break;
              case "LightMapFilename":
                _nowMat.lightMap = this.texloader.load(fileName);
                break;
            }
          } else {
            break;
          }
        }
        this._currentGeo.Materials.push(_nowMat);
      }
    }, {
      key: "_setSkinWeights",
      value: function _setSkinWeights() {
        var boneInf = new XboneInf();
        var endRead = 0;
        var find = this._currentObject.data.indexOf(";", endRead);
        var line = this._currentObject.data.substr(endRead, find - endRead);
        endRead = find + 1;
        boneInf.boneName = line.substr(1, line.length - 2);
        boneInf.BoneIndex = this._currentGeo.BoneInfs.length;
        find = this._currentObject.data.indexOf(";", endRead);
        endRead = find + 1;
        find = this._currentObject.data.indexOf(";", endRead);
        line = this._currentObject.data.substr(endRead, find - endRead);
        var data = this._readLine(line.trim()).split(",");
        for (let i2 = 0; i2 < data.length; i2++) {
          boneInf.Indeces.push(parseInt(data[i2]));
        }
        endRead = find + 1;
        find = this._currentObject.data.indexOf(";", endRead);
        line = this._currentObject.data.substr(endRead, find - endRead);
        var data2 = this._readLine(line.trim()).split(",");
        for (let _i = 0; _i < data2.length; _i++) {
          boneInf.Weights.push(parseFloat(data2[_i]));
        }
        endRead = find + 1;
        find = this._currentObject.data.indexOf(";", endRead);
        if (find <= 0) {
          find = this._currentObject.data.length;
        }
        line = this._currentObject.data.substr(endRead, find - endRead);
        var data3 = this._readLine(line.trim()).split(",");
        boneInf.OffsetMatrix = new Matrix4();
        this._ParseMatrixData(boneInf.OffsetMatrix, data3);
        this._currentGeo.BoneInfs.push(boneInf);
      }
    }, {
      key: "_makePutBoneList",
      value: function _makePutBoneList(_RootName, _bones) {
        var putting = false;
        for (let frame in this.HieStack) {
          if (this.HieStack[frame].name === _RootName || putting) {
            putting = true;
            var b2 = new Bone();
            b2.name = this.HieStack[frame].name;
            b2.applyMatrix4(this.HieStack[frame].FrameTransformMatrix);
            b2.matrixWorld = b2.matrix;
            b2.FrameTransformMatrix = this.HieStack[frame].FrameTransformMatrix;
            b2.pos = new Vector3().setFromMatrixPosition(b2.FrameTransformMatrix).toArray();
            b2.rotq = new Quaternion().setFromRotationMatrix(b2.FrameTransformMatrix).toArray();
            b2.scl = new Vector3().setFromMatrixScale(b2.FrameTransformMatrix).toArray();
            if (this.HieStack[frame].parentName && this.HieStack[frame].parentName.length > 0) {
              for (let i2 = 0; i2 < _bones.length; i2++) {
                if (this.HieStack[frame].parentName === _bones[i2].name) {
                  _bones[i2].add(b2);
                  b2.parent = i2;
                  break;
                }
              }
            }
            _bones.push(b2);
          }
        }
      }
    }, {
      key: "_makeOutputGeometry",
      value: function _makeOutputGeometry() {
        var mesh = null;
        if (this._currentGeo.BoneInfs.length > 0) {
          var putBones = [];
          this._makePutBoneList(this._currentGeo.baseFrame.parentName, putBones);
          for (let bi = 0; bi < this._currentGeo.BoneInfs.length; bi++) {
            var boneIndex = 0;
            for (let bb = 0; bb < putBones.length; bb++) {
              if (putBones[bb].name === this._currentGeo.BoneInfs[bi].boneName) {
                boneIndex = bb;
                putBones[bb].OffsetMatrix = new Matrix4();
                putBones[bb].OffsetMatrix.copy(this._currentGeo.BoneInfs[bi].OffsetMatrix);
                break;
              }
            }
            for (let vi = 0; vi < this._currentGeo.BoneInfs[bi].Indeces.length; vi++) {
              var nowVertexID = this._currentGeo.BoneInfs[bi].Indeces[vi];
              var nowVal = this._currentGeo.BoneInfs[bi].Weights[vi];
              var stride = nowVertexID * 4;
              switch (this._currentGeo.VertexSetedBoneCount[nowVertexID]) {
                case 0:
                  this._currentGeo.GeometryData.skinIndices[stride] = boneIndex;
                  this._currentGeo.GeometryData.skinWeights[stride] = nowVal;
                  break;
                case 1:
                  this._currentGeo.GeometryData.skinIndices[stride + 1] = boneIndex;
                  this._currentGeo.GeometryData.skinWeights[stride + 1] = nowVal;
                  break;
                case 2:
                  this._currentGeo.GeometryData.skinIndices[stride + 2] = boneIndex;
                  this._currentGeo.GeometryData.skinWeights[stride + 2] = nowVal;
                  break;
                case 3:
                  this._currentGeo.GeometryData.skinIndices[stride + 3] = boneIndex;
                  this._currentGeo.GeometryData.skinWeights[stride + 3] = nowVal;
                  break;
              }
              this._currentGeo.VertexSetedBoneCount[nowVertexID]++;
              if (this._currentGeo.VertexSetedBoneCount[nowVertexID] > 4) {
                console.log("warn! over 4 bone weight! :" + nowVertexID);
              }
            }
          }
          for (let sk = 0; sk < this._currentGeo.Materials.length; sk++) {
            this._currentGeo.Materials[sk].skinning = true;
          }
          var offsetList = [];
          for (let _bi = 0; _bi < putBones.length; _bi++) {
            if (putBones[_bi].OffsetMatrix) {
              offsetList.push(putBones[_bi].OffsetMatrix);
            } else {
              offsetList.push(new Matrix4());
            }
          }
          var bufferGeometry = this._buildGeometry();
          mesh = new SkinnedMesh(bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);
          this._initSkeleton(mesh, putBones, offsetList);
        } else {
          var _bufferGeometry = this._buildGeometry();
          mesh = new Mesh(_bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);
        }
        mesh.name = this._currentGeo.name;
        var worldBaseMx = new Matrix4();
        var currentMxFrame = this._currentGeo.baseFrame.putBone;
        if (currentMxFrame && currentMxFrame.parent) {
          while (true) {
            currentMxFrame = currentMxFrame.parent;
            if (currentMxFrame) {
              worldBaseMx.multiply(currentMxFrame.FrameTransformMatrix);
            } else {
              break;
            }
          }
          mesh.applyMatrix4(worldBaseMx);
        }
        this.Meshes.push(mesh);
      }
    }, {
      key: "_initSkeleton",
      value: function _initSkeleton(mesh, boneList, boneInverses) {
        var bones = [], bone, gbone;
        var i2, il;
        for (i2 = 0, il = boneList.length; i2 < il; i2++) {
          gbone = boneList[i2];
          bone = new Bone();
          bones.push(bone);
          bone.name = gbone.name;
          bone.position.fromArray(gbone.pos);
          bone.quaternion.fromArray(gbone.rotq);
          if (gbone.scl !== void 0)
            bone.scale.fromArray(gbone.scl);
        }
        for (i2 = 0, il = boneList.length; i2 < il; i2++) {
          gbone = boneList[i2];
          if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== void 0) {
            bones[gbone.parent].add(bones[i2]);
          } else {
            mesh.add(bones[i2]);
          }
        }
        mesh.updateMatrixWorld(true);
        var skeleton = new Skeleton(bones, boneInverses);
        mesh.bind(skeleton, mesh.matrixWorld);
      }
    }, {
      key: "_readAnimationKey",
      value: function _readAnimationKey() {
        var endRead = 0;
        var find = this._currentObject.data.indexOf(";", endRead);
        var line = this._currentObject.data.substr(endRead, find - endRead);
        endRead = find + 1;
        var nowKeyType = parseInt(this._readLine(line));
        find = this._currentObject.data.indexOf(";", endRead);
        endRead = find + 1;
        line = this._currentObject.data.substr(endRead);
        var data = this._readLine(line.trim()).split(";;,");
        for (let i2 = 0; i2 < data.length; i2++) {
          var data2 = data[i2].split(";");
          var keyInfo = new XKeyFrameInfo();
          keyInfo.type = nowKeyType;
          keyInfo.Frame = parseInt(data2[0]);
          keyInfo.index = this._currentAnimeFrames.keyFrames.length;
          keyInfo.time = keyInfo.Frame;
          if (nowKeyType != 4) {
            var frameFound = false;
            for (let mm = 0; mm < this._currentAnimeFrames.keyFrames.length; mm++) {
              if (this._currentAnimeFrames.keyFrames[mm].Frame === keyInfo.Frame) {
                keyInfo = this._currentAnimeFrames.keyFrames[mm];
                frameFound = true;
                break;
              }
            }
            var frameValue = data2[2].split(",");
            switch (nowKeyType) {
              case 0:
                keyInfo.rot = new Quaternion(parseFloat(frameValue[1]), parseFloat(frameValue[2]), parseFloat(frameValue[3]), parseFloat(frameValue[0]) * -1);
                break;
              case 1:
                keyInfo.scl = new Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));
                break;
              case 2:
                keyInfo.pos = new Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));
                break;
            }
            if (!frameFound) {
              this._currentAnimeFrames.keyFrames.push(keyInfo);
            }
          } else {
            keyInfo.matrix = new Matrix4();
            this._ParseMatrixData(keyInfo.matrix, data2[2].split(","));
            this._currentAnimeFrames.keyFrames.push(keyInfo);
          }
        }
      }
    }, {
      key: "_makeOutputAnimation",
      value: function _makeOutputAnimation() {
        var animationObj = new XAnimationObj(this.options);
        animationObj.fps = this.animTicksPerSecond;
        animationObj.name = this._currentAnime.name;
        animationObj.make(this._currentAnime.AnimeFrames);
        this.animations.push(animationObj);
      }
    }, {
      key: "assignAnimation",
      value: function assignAnimation(_model, _animation) {
        var model = _model;
        var animation = _animation;
        if (!model) {
          model = this.Meshes[0];
        }
        if (!animation) {
          animation = this.animations[0];
        }
        if (!model || !animation) {
          return null;
        }
        var put = {};
        put.fps = animation.fps;
        put.name = animation.name;
        put.length = animation.length;
        put.hierarchy = [];
        for (let b2 = 0; b2 < model.skeleton.bones.length; b2++) {
          var findAnimation = false;
          for (let i2 = 0; i2 < animation.hierarchy.length; i2++) {
            if (model.skeleton.bones[b2].name === animation.hierarchy[i2].name) {
              findAnimation = true;
              var c_key = animation.hierarchy[i2].copy();
              c_key.parent = -1;
              if (model.skeleton.bones[b2].parent && model.skeleton.bones[b2].parent.type === "Bone") {
                for (let bb = 0; bb < put.hierarchy.length; bb++) {
                  if (put.hierarchy[bb].name === model.skeleton.bones[b2].parent.name) {
                    c_key.parent = bb;
                    c_key.parentName = model.skeleton.bones[b2].parent.name;
                  }
                }
              }
              put.hierarchy.push(c_key);
              break;
            }
          }
          if (!findAnimation) {
            var _c_key = animation.hierarchy[0].copy();
            _c_key.name = model.skeleton.bones[b2].name;
            _c_key.parent = -1;
            for (let k = 0; k < _c_key.keys.length; k++) {
              if (_c_key.keys[k].pos) {
                _c_key.keys[k].pos.set(0, 0, 0);
              }
              if (_c_key.keys[k].scl) {
                _c_key.keys[k].scl.set(1, 1, 1);
              }
              if (_c_key.keys[k].rot) {
                _c_key.keys[k].rot.set(0, 0, 0, 1);
              }
            }
            put.hierarchy.push(_c_key);
          }
        }
        if (!model.geometry.animations) {
          model.geometry.animations = [];
        }
        model.geometry.animations.push(AnimationClip.parseAnimation(put, model.skeleton.bones));
        if (!model.animationMixer) {
          model.animationMixer = new AnimationMixer(model);
        }
        return put;
      }
    }, {
      key: "_ParseMatrixData",
      value: function _ParseMatrixData(targetMatrix, data) {
        targetMatrix.set(parseFloat(data[0]), parseFloat(data[4]), parseFloat(data[8]), parseFloat(data[12]), parseFloat(data[1]), parseFloat(data[5]), parseFloat(data[9]), parseFloat(data[13]), parseFloat(data[2]), parseFloat(data[6]), parseFloat(data[10]), parseFloat(data[14]), parseFloat(data[3]), parseFloat(data[7]), parseFloat(data[11]), parseFloat(data[15]));
      }
    }]);
    return XLoader3;
  }();
  return XLoader2;
}();

// node_modules/@react-three/rapier/node_modules/three-stdlib/utils/WorkerPool.js
var WorkerPool = class {
  constructor(pool = 4) {
    this.pool = pool;
    this.queue = [];
    this.workers = [];
    this.workersResolve = [];
    this.workerStatus = 0;
  }
  _initWorker(workerId) {
    if (!this.workers[workerId]) {
      const worker = this.workerCreator();
      worker.addEventListener("message", this._onMessage.bind(this, workerId));
      this.workers[workerId] = worker;
    }
  }
  _getIdleWorker() {
    for (let i2 = 0; i2 < this.pool; i2++)
      if (!(this.workerStatus & 1 << i2))
        return i2;
    return -1;
  }
  _onMessage(workerId, msg) {
    const resolve = this.workersResolve[workerId];
    resolve && resolve(msg);
    if (this.queue.length) {
      const {
        resolve: resolve2,
        msg: msg2,
        transfer
      } = this.queue.shift();
      this.workersResolve[workerId] = resolve2;
      this.workers[workerId].postMessage(msg2, transfer);
    } else {
      this.workerStatus ^= 1 << workerId;
    }
  }
  setWorkerCreator(workerCreator) {
    this.workerCreator = workerCreator;
  }
  setWorkerLimit(pool) {
    this.pool = pool;
  }
  postMessage(msg, transfer) {
    return new Promise((resolve) => {
      const workerId = this._getIdleWorker();
      if (workerId !== -1) {
        this._initWorker(workerId);
        this.workerStatus |= 1 << workerId;
        this.workersResolve[workerId] = resolve;
        this.workers[workerId].postMessage(msg, transfer);
      } else {
        this.queue.push({
          resolve,
          msg,
          transfer
        });
      }
    });
  }
  dispose() {
    this.workers.forEach((worker) => worker.terminate());
    this.workersResolve.length = 0;
    this.workers.length = 0;
    this.queue.length = 0;
    this.workerStatus = 0;
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/KTX2Loader.js
var _taskCache = /* @__PURE__ */ new WeakMap();
var _activeLoaders = 0;
var _zstd;
var KTX2Loader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerPool = new WorkerPool();
    this.workerSourceURL = "";
    this.workerConfig = null;
    if (typeof MSC_TRANSCODER !== "undefined") {
      console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
    }
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(num) {
    this.workerPool.setWorkerLimit(num);
    return this;
  }
  detectSupport(renderer) {
    this.workerConfig = {
      astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
      etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    };
    if (renderer.capabilities.isWebGL2) {
      this.workerConfig.etc1Supported = false;
    }
    return this;
  }
  init() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader2(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = jsLoader.loadAsync("basis_transcoder.js");
      const binaryLoader = new FileLoader2(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = KTX2Loader.BasisWorker.toString();
        const body = ["/* constants */", "let _EngineFormat = " + JSON.stringify(KTX2Loader.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(KTX2Loader.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(KTX2Loader.BasisFormat), "/* basis_transcoder.js */", jsContent2, "/* worker */", fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
        this.workerPool.setWorkerCreator(() => {
          const worker = new Worker(this.workerSourceURL);
          const transcoderBinary = this.transcoderBinary.slice(0);
          worker.postMessage({
            type: "init",
            config: this.workerConfig,
            transcoderBinary
          }, [transcoderBinary]);
          return worker;
        });
      });
      if (_activeLoaders > 0) {
        console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances.");
      }
      _activeLoaders++;
    }
    return this.transcoderPending;
  }
  load(url, onLoad, onProgress, onError) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    const loader = new FileLoader2(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer2) => {
      if (_taskCache.has(buffer2)) {
        const cachedTask = _taskCache.get(buffer2);
        return cachedTask.promise.then(onLoad).catch(onError);
      }
      this._createTexture(buffer2).then((texture2) => onLoad ? onLoad(texture2) : null).catch(onError);
    }, onProgress, onError);
  }
  _createTextureFrom(transcodeResult) {
    const {
      mipmaps,
      width,
      height,
      format,
      type: type2,
      error,
      dfdTransferFn,
      dfdFlags
    } = transcodeResult;
    if (type2 === "error")
      return Promise.reject(error);
    const texture2 = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);
    texture2.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
    texture2.magFilter = LinearFilter;
    texture2.generateMipmaps = false;
    texture2.needsUpdate = true;
    texture2.encoding = dfdTransferFn === KHR_DF_TRANSFER_SRGB ? sRGBEncoding : LinearEncoding;
    texture2.premultiplyAlpha = !!(dfdFlags & KHR_DF_FLAG_ALPHA_PREMULTIPLIED);
    return texture2;
  }
  /**
   * @param {ArrayBuffer} buffer
   * @param {object?} config
   * @return {Promise<CompressedTexture|DataTexture|Data3DTexture>}
   */
  _createTexture(buffer2, config = {}) {
    const container = read(new Uint8Array(buffer2));
    if (container.vkFormat !== VK_FORMAT_UNDEFINED) {
      return createDataTexture(container);
    }
    const taskConfig = config;
    const texturePending = this.init().then(() => {
      return this.workerPool.postMessage({
        type: "transcode",
        buffer: buffer2,
        taskConfig
      }, [buffer2]);
    }).then((e) => this._createTextureFrom(e.data));
    _taskCache.set(buffer2, {
      promise: texturePending
    });
    return texturePending;
  }
  dispose() {
    this.workerPool.dispose();
    if (this.workerSourceURL)
      URL.revokeObjectURL(this.workerSourceURL);
    _activeLoaders--;
    return this;
  }
};
KTX2Loader.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
KTX2Loader.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
KTX2Loader.EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format
};
KTX2Loader.BasisWorker = function() {
  let config;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  self.addEventListener("message", function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config = message.config;
        init(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const {
              width,
              height,
              hasAlpha,
              mipmaps,
              format,
              dfdTransferFn,
              dfdFlags
            } = transcode(message.buffer);
            const buffers = [];
            for (let i2 = 0; i2 < mipmaps.length; ++i2) {
              buffers.push(mipmaps[i2].data.buffer);
            }
            self.postMessage({
              type: "transcode",
              id: message.id,
              width,
              height,
              hasAlpha,
              mipmaps,
              format,
              dfdTransferFn,
              dfdFlags
            }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({
              type: "error",
              id: message.id,
              error: error.message
            });
          }
        });
        break;
    }
  });
  function init(wasmBinary) {
    transcoderPending = new Promise((resolve) => {
      BasisModule = {
        wasmBinary,
        onRuntimeInitialized: resolve
      };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
      if (BasisModule.KTX2File === void 0) {
        console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
      }
    });
  }
  function transcode(buffer2) {
    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer2));
    function cleanup() {
      ktx2File.close();
      ktx2File.delete();
    }
    if (!ktx2File.isValid()) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    }
    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
    const width = ktx2File.getWidth();
    const height = ktx2File.getHeight();
    const levels = ktx2File.getLevels();
    const hasAlpha = ktx2File.getHasAlpha();
    const dfdTransferFn = ktx2File.getDFDTransferFunc();
    const dfdFlags = ktx2File.getDFDFlags();
    const {
      transcoderFormat,
      engineFormat
    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levels) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid texture");
    }
    if (!ktx2File.startTranscoding()) {
      cleanup();
      throw new Error("THREE.KTX2Loader: .startTranscoding failed");
    }
    const mipmaps = [];
    for (let mip = 0; mip < levels; mip++) {
      const levelInfo = ktx2File.getImageLevelInfo(mip, 0, 0);
      const mipWidth = levelInfo.origWidth;
      const mipHeight = levelInfo.origHeight;
      const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, 0, 0, transcoderFormat));
      const status = ktx2File.transcodeImage(dst, mip, 0, 0, transcoderFormat, 0, -1, -1);
      if (!status) {
        cleanup();
        throw new Error("THREE.KTX2Loader: .transcodeImage failed.");
      }
      mipmaps.push({
        data: dst,
        width: mipWidth,
        height: mipHeight
      });
    }
    cleanup();
    return {
      width,
      height,
      hasAlpha,
      mipmaps,
      format: engineFormat,
      dfdTransferFn,
      dfdFlags
    };
  }
  const FORMAT_OPTIONS = [{
    if: "astcSupported",
    basisFormat: [BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
    priorityETC1S: Infinity,
    priorityUASTC: 1,
    needsPowerOfTwo: false
  }, {
    if: "bptcSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
    priorityETC1S: 3,
    priorityUASTC: 2,
    needsPowerOfTwo: false
  }, {
    if: "dxtSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
    priorityETC1S: 4,
    priorityUASTC: 5,
    needsPowerOfTwo: false
  }, {
    if: "etc2Supported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
    priorityETC1S: 1,
    priorityUASTC: 3,
    needsPowerOfTwo: false
  }, {
    if: "etc1Supported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1],
    engineFormat: [EngineFormat.RGB_ETC1_Format],
    priorityETC1S: 2,
    priorityUASTC: 4,
    needsPowerOfTwo: false
  }, {
    if: "pvrtcSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
    priorityETC1S: 5,
    priorityUASTC: 6,
    needsPowerOfTwo: true
  }];
  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b2) {
    return a2.priorityETC1S - b2.priorityETC1S;
  });
  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b2) {
    return a2.priorityUASTC - b2.priorityUASTC;
  });
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    let transcoderFormat;
    let engineFormat;
    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
    for (let i2 = 0; i2 < options.length; i2++) {
      const opt = options[i2];
      if (!config[opt.if])
        continue;
      if (!opt.basisFormat.includes(basisFormat))
        continue;
      if (hasAlpha && opt.transcoderFormat.length < 2)
        continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height)))
        continue;
      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      return {
        transcoderFormat,
        engineFormat
      };
    }
    console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.");
    transcoderFormat = TranscoderFormat.RGBA32;
    engineFormat = EngineFormat.RGBAFormat;
    return {
      transcoderFormat,
      engineFormat
    };
  }
  function isPowerOfTwo(value) {
    if (value <= 2)
      return true;
    return (value & value - 1) === 0 && value !== 0;
  }
};
var FORMAT_MAP = {
  [VK_FORMAT_R32G32B32A32_SFLOAT]: RGBAFormat,
  [VK_FORMAT_R16G16B16A16_SFLOAT]: RGBAFormat,
  [VK_FORMAT_R8G8B8A8_UNORM]: RGBAFormat,
  [VK_FORMAT_R8G8B8A8_SRGB]: RGBAFormat,
  [VK_FORMAT_R32G32_SFLOAT]: RGFormat,
  [VK_FORMAT_R16G16_SFLOAT]: RGFormat,
  [VK_FORMAT_R8G8_UNORM]: RGFormat,
  [VK_FORMAT_R8G8_SRGB]: RGFormat,
  [VK_FORMAT_R32_SFLOAT]: RedFormat,
  [VK_FORMAT_R16_SFLOAT]: RedFormat,
  [VK_FORMAT_R8_SRGB]: RedFormat,
  [VK_FORMAT_R8_UNORM]: RedFormat
};
var TYPE_MAP = {
  [VK_FORMAT_R32G32B32A32_SFLOAT]: FloatType,
  [VK_FORMAT_R16G16B16A16_SFLOAT]: HalfFloatType,
  [VK_FORMAT_R8G8B8A8_UNORM]: UnsignedByteType,
  [VK_FORMAT_R8G8B8A8_SRGB]: UnsignedByteType,
  [VK_FORMAT_R32G32_SFLOAT]: FloatType,
  [VK_FORMAT_R16G16_SFLOAT]: HalfFloatType,
  [VK_FORMAT_R8G8_UNORM]: UnsignedByteType,
  [VK_FORMAT_R8G8_SRGB]: UnsignedByteType,
  [VK_FORMAT_R32_SFLOAT]: FloatType,
  [VK_FORMAT_R16_SFLOAT]: HalfFloatType,
  [VK_FORMAT_R8_SRGB]: UnsignedByteType,
  [VK_FORMAT_R8_UNORM]: UnsignedByteType
};
var ENCODING_MAP = {
  [VK_FORMAT_R8G8B8A8_SRGB]: sRGBEncoding,
  [VK_FORMAT_R8G8_SRGB]: sRGBEncoding,
  [VK_FORMAT_R8_SRGB]: sRGBEncoding
};
async function createDataTexture(container) {
  const {
    vkFormat,
    pixelWidth,
    pixelHeight,
    pixelDepth
  } = container;
  if (FORMAT_MAP[vkFormat] === void 0) {
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  }
  const level = container.levels[0];
  let levelData;
  let view;
  if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {
    levelData = level.levelData;
  } else if (container.supercompressionScheme === KHR_SUPERCOMPRESSION_ZSTD) {
    if (!_zstd) {
      _zstd = new Promise(async (resolve) => {
        const zstd = new Q();
        await zstd.init();
        resolve(zstd);
      });
    }
    levelData = (await _zstd).decode(level.levelData, level.uncompressedByteLength);
  } else {
    throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
  }
  if (TYPE_MAP[vkFormat] === FloatType) {
    view = new Float32Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT);
  } else if (TYPE_MAP[vkFormat] === HalfFloatType) {
    view = new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT);
  } else {
    view = levelData;
  }
  const texture2 = pixelDepth === 0 ? new DataTexture(view, pixelWidth, pixelHeight) : new Data3DTexture(view, pixelWidth, pixelHeight, pixelDepth);
  texture2.type = TYPE_MAP[vkFormat];
  texture2.format = FORMAT_MAP[vkFormat];
  texture2.encoding = ENCODING_MAP[vkFormat] || LinearEncoding;
  texture2.needsUpdate = true;
  return Promise.resolve(texture2);
}

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/AssimpLoader.js
var AssimpLoader = function(manager) {
  Loader.call(this, manager);
};
AssimpLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: AssimpLoader,
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var path = scope.path === "" ? LoaderUtils.extractUrlBase(url) : scope.path;
    var loader = new FileLoader2(scope.manager);
    loader.setPath(scope.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer2) {
      try {
        onLoad(scope.parse(buffer2, path));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  },
  parse: function(buffer2, path) {
    var textureLoader = new TextureLoader(this.manager);
    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    var Virtulous = {};
    Virtulous.KeyFrame = function(time, matrix3) {
      this.time = time;
      this.matrix = matrix3.clone();
      this.position = new Vector3();
      this.quaternion = new Quaternion();
      this.scale = new Vector3(1, 1, 1);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
      this.clone = function() {
        var n = new Virtulous.KeyFrame(this.time, this.matrix);
        return n;
      };
      this.lerp = function(nextKey, time2) {
        time2 -= this.time;
        var dist = nextKey.time - this.time;
        var l = time2 / dist;
        var l2 = 1 - l;
        var keypos = this.position;
        var keyrot = this.quaternion;
        var key2pos = nextKey.position;
        var key2rot = nextKey.quaternion;
        Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;
        Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;
        Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;
        Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);
        Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);
        return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);
      };
    };
    Virtulous.KeyFrame.tempAniPos = new Vector3();
    Virtulous.KeyFrame.tempAniQuat = new Quaternion();
    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);
    Virtulous.KeyFrame.tempAniMatrix = new Matrix4();
    Virtulous.KeyFrameTrack = function() {
      this.keys = [];
      this.target = null;
      this.time = 0;
      this.length = 0;
      this._accelTable = {};
      this.fps = 20;
      this.addKey = function(key) {
        this.keys.push(key);
      };
      this.init = function() {
        this.sortKeys();
        if (this.keys.length > 0)
          this.length = this.keys[this.keys.length - 1].time;
        else
          this.length = 0;
        if (!this.fps)
          return;
        for (let j2 = 0; j2 < this.length * this.fps; j2++) {
          for (let i2 = 0; i2 < this.keys.length; i2++) {
            if (this.keys[i2].time == j2) {
              this._accelTable[j2] = i2;
              break;
            } else if (this.keys[i2].time < j2 / this.fps && this.keys[i2 + 1] && this.keys[i2 + 1].time >= j2 / this.fps) {
              this._accelTable[j2] = i2;
              break;
            }
          }
        }
      };
      this.parseFromThree = function(data) {
        var fps = data.fps;
        this.target = data.node;
        var track = data.hierarchy[0].keys;
        for (let i2 = 0; i2 < track.length; i2++) {
          this.addKey(new Virtulous.KeyFrame(i2 / fps || track[i2].time, track[i2].targets[0].data));
        }
        this.init();
      };
      this.parseFromCollada = function(data) {
        var track = data.keys;
        var fps = this.fps;
        for (let i2 = 0; i2 < track.length; i2++) {
          this.addKey(new Virtulous.KeyFrame(i2 / fps || track[i2].time, track[i2].matrix));
        }
        this.init();
      };
      this.sortKeys = function() {
        this.keys.sort(this.keySortFunc);
      };
      this.keySortFunc = function(a2, b2) {
        return a2.time - b2.time;
      };
      this.clone = function() {
        var t2 = new Virtulous.KeyFrameTrack();
        t2.target = this.target;
        t2.time = this.time;
        t2.length = this.length;
        for (let i2 = 0; i2 < this.keys.length; i2++) {
          t2.addKey(this.keys[i2].clone());
        }
        t2.init();
        return t2;
      };
      this.reTarget = function(root, compareitor) {
        if (!compareitor)
          compareitor = Virtulous.TrackTargetNodeNameCompare;
        this.target = compareitor(root, this.target);
      };
      this.keySearchAccel = function(time) {
        time *= this.fps;
        time = Math.floor(time);
        return this._accelTable[time] || 0;
      };
      this.setTime = function(time) {
        time = Math.abs(time);
        if (this.length)
          time = time % this.length + 0.05;
        var key0 = null;
        var key1 = null;
        for (let i2 = this.keySearchAccel(time); i2 < this.keys.length; i2++) {
          if (this.keys[i2].time == time) {
            key0 = this.keys[i2];
            key1 = this.keys[i2];
            break;
          } else if (this.keys[i2].time < time && this.keys[i2 + 1] && this.keys[i2 + 1].time > time) {
            key0 = this.keys[i2];
            key1 = this.keys[i2 + 1];
            break;
          } else if (this.keys[i2].time < time && i2 == this.keys.length - 1) {
            key0 = this.keys[i2];
            key1 = this.keys[0].clone();
            key1.time += this.length + 0.05;
            break;
          }
        }
        if (key0 && key1 && key0 !== key1) {
          this.target.matrixAutoUpdate = false;
          this.target.matrix.copy(key0.lerp(key1, time));
          this.target.matrixWorldNeedsUpdate = true;
          return;
        }
        if (key0 && key1 && key0 == key1) {
          this.target.matrixAutoUpdate = false;
          this.target.matrix.copy(key0.matrix);
          this.target.matrixWorldNeedsUpdate = true;
          return;
        }
      };
    };
    Virtulous.TrackTargetNodeNameCompare = function(root, target) {
      function find(node, name) {
        if (node.name == name)
          return node;
        for (let i2 = 0; i2 < node.children.length; i2++) {
          var r = find(node.children[i2], name);
          if (r)
            return r;
        }
        return null;
      }
      return find(root, target.name);
    };
    Virtulous.Animation = function() {
      this.tracks = [];
      this.length = 0;
      this.addTrack = function(track) {
        this.tracks.push(track);
        this.length = Math.max(track.length, this.length);
      };
      this.setTime = function(time) {
        this.time = time;
        for (let i2 = 0; i2 < this.tracks.length; i2++)
          this.tracks[i2].setTime(time);
      };
      this.clone = function(target, compareitor) {
        if (!compareitor)
          compareitor = Virtulous.TrackTargetNodeNameCompare;
        var n = new Virtulous.Animation();
        n.target = target;
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          var track = this.tracks[i2].clone();
          track.reTarget(target, compareitor);
          n.addTrack(track);
        }
        return n;
      };
    };
    var ASSBIN_CHUNK_AICAMERA = 4660;
    var ASSBIN_CHUNK_AILIGHT = 4661;
    var ASSBIN_CHUNK_AITEXTURE = 4662;
    var ASSBIN_CHUNK_AIMESH = 4663;
    var ASSBIN_CHUNK_AINODEANIM = 4664;
    var ASSBIN_CHUNK_AISCENE = 4665;
    var ASSBIN_CHUNK_AIBONE = 4666;
    var ASSBIN_CHUNK_AIANIMATION = 4667;
    var ASSBIN_CHUNK_AINODE = 4668;
    var ASSBIN_CHUNK_AIMATERIAL = 4669;
    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 4670;
    var ASSBIN_MESH_HAS_POSITIONS = 1;
    var ASSBIN_MESH_HAS_NORMALS = 2;
    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 4;
    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 256;
    var ASSBIN_MESH_HAS_COLOR_BASE = 65536;
    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;
    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;
    var aiLightSource_DIRECTIONAL = 1;
    var aiLightSource_SPOT = 3;
    var aiTextureType_DIFFUSE = 1;
    var aiTextureType_NORMALS = 6;
    var aiTextureType_OPACITY = 8;
    var aiTextureType_LIGHTMAP = 10;
    var BONESPERVERT = 4;
    function ASSBIN_MESH_HAS_TEXCOORD(n) {
      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;
    }
    function ASSBIN_MESH_HAS_COLOR(n) {
      return ASSBIN_MESH_HAS_COLOR_BASE << n;
    }
    function markBones(scene) {
      for (let i2 in scene.mMeshes) {
        var mesh = scene.mMeshes[i2];
        for (let k in mesh.mBones) {
          var boneNode = scene.findNode(mesh.mBones[k].mName);
          if (boneNode)
            boneNode.isBone = true;
        }
      }
    }
    function cloneTreeToBones(root, scene) {
      var rootBone = new Bone();
      rootBone.matrix.copy(root.matrix);
      rootBone.matrixWorld.copy(root.matrixWorld);
      rootBone.position.copy(root.position);
      rootBone.quaternion.copy(root.quaternion);
      rootBone.scale.copy(root.scale);
      scene.nodeCount++;
      rootBone.name = "bone_" + root.name + scene.nodeCount.toString();
      if (!scene.nodeToBoneMap[root.name])
        scene.nodeToBoneMap[root.name] = [];
      scene.nodeToBoneMap[root.name].push(rootBone);
      for (let i2 in root.children) {
        var child = cloneTreeToBones(root.children[i2], scene);
        rootBone.add(child);
      }
      return rootBone;
    }
    function sortWeights(indexes, weights) {
      var pairs = [];
      for (let i2 = 0; i2 < indexes.length; i2++) {
        pairs.push({
          i: indexes[i2],
          w: weights[i2]
        });
      }
      pairs.sort(function(a2, b2) {
        return b2.w - a2.w;
      });
      while (pairs.length < 4) {
        pairs.push({
          i: 0,
          w: 0
        });
      }
      if (pairs.length > 4)
        pairs.length = 4;
      var sum = 0;
      for (let i2 = 0; i2 < 4; i2++) {
        sum += pairs[i2].w * pairs[i2].w;
      }
      sum = Math.sqrt(sum);
      for (let i2 = 0; i2 < 4; i2++) {
        pairs[i2].w = pairs[i2].w / sum;
        indexes[i2] = pairs[i2].i;
        weights[i2] = pairs[i2].w;
      }
    }
    function findMatchingBone(root, name) {
      if (root.name.indexOf("bone_" + name) == 0)
        return root;
      for (let i2 in root.children) {
        var ret = findMatchingBone(root.children[i2], name);
        if (ret)
          return ret;
      }
      return void 0;
    }
    function aiMesh() {
      this.mPrimitiveTypes = 0;
      this.mNumVertices = 0;
      this.mNumFaces = 0;
      this.mNumBones = 0;
      this.mMaterialIndex = 0;
      this.mVertices = [];
      this.mNormals = [];
      this.mTangents = [];
      this.mBitangents = [];
      this.mColors = [[]];
      this.mTextureCoords = [[]];
      this.mFaces = [];
      this.mBones = [];
      this.hookupSkeletons = function(scene) {
        if (this.mBones.length == 0)
          return;
        var allBones = [];
        var offsetMatrix = [];
        var skeletonRoot = scene.findNode(this.mBones[0].mName);
        while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {
          skeletonRoot = skeletonRoot.mParent;
        }
        var threeSkeletonRoot = skeletonRoot.toTHREE(scene);
        var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);
        this.threeNode.add(threeSkeletonRootBone);
        for (let i2 = 0; i2 < this.mBones.length; i2++) {
          var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i2].mName);
          if (bone) {
            var tbone = bone;
            allBones.push(tbone);
            offsetMatrix.push(this.mBones[i2].mOffsetMatrix.toTHREE());
          } else {
            var skeletonRoot = scene.findNode(this.mBones[i2].mName);
            if (!skeletonRoot)
              return;
            var threeSkeletonRoot = skeletonRoot.toTHREE(scene);
            var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);
            this.threeNode.add(threeSkeletonRootBone);
            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i2].mName);
            var tbone = bone;
            allBones.push(tbone);
            offsetMatrix.push(this.mBones[i2].mOffsetMatrix.toTHREE());
          }
        }
        var skeleton = new Skeleton(allBones, offsetMatrix);
        this.threeNode.bind(skeleton, new Matrix4());
        this.threeNode.material.skinning = true;
      };
      this.toTHREE = function(scene) {
        if (this.threeNode)
          return this.threeNode;
        var geometry = new BufferGeometry();
        var mat;
        if (scene.mMaterials[this.mMaterialIndex])
          mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);
        else
          mat = new MeshLambertMaterial();
        geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));
        geometry.setAttribute("position", new BufferAttribute(this.mVertexBuffer, 3));
        if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {
          geometry.setAttribute("normal", new BufferAttribute(this.mNormalBuffer, 3));
        }
        if (this.mColorBuffer && this.mColorBuffer.length > 0) {
          geometry.setAttribute("color", new BufferAttribute(this.mColorBuffer, 4));
        }
        if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {
          geometry.setAttribute("uv", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));
        }
        if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {
          geometry.setAttribute("uv1", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));
        }
        if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {
          geometry.setAttribute("tangents", new BufferAttribute(this.mTangentBuffer, 3));
        }
        if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {
          geometry.setAttribute("bitangents", new BufferAttribute(this.mBitangentBuffer, 3));
        }
        if (this.mBones.length > 0) {
          var weights = [];
          var bones = [];
          for (let i2 = 0; i2 < this.mBones.length; i2++) {
            for (let j2 = 0; j2 < this.mBones[i2].mWeights.length; j2++) {
              var weight = this.mBones[i2].mWeights[j2];
              if (weight) {
                if (!weights[weight.mVertexId])
                  weights[weight.mVertexId] = [];
                if (!bones[weight.mVertexId])
                  bones[weight.mVertexId] = [];
                weights[weight.mVertexId].push(weight.mWeight);
                bones[weight.mVertexId].push(parseInt(i2));
              }
            }
          }
          for (let i2 in bones) {
            sortWeights(bones[i2], weights[i2]);
          }
          var _weights = [];
          var _bones = [];
          for (let i2 = 0; i2 < weights.length; i2++) {
            for (let j2 = 0; j2 < 4; j2++) {
              if (weights[i2] && bones[i2]) {
                _weights.push(weights[i2][j2]);
                _bones.push(bones[i2][j2]);
              } else {
                _weights.push(0);
                _bones.push(0);
              }
            }
          }
          geometry.setAttribute("skinWeight", new BufferAttribute(new Float32Array(_weights), BONESPERVERT));
          geometry.setAttribute("skinIndex", new BufferAttribute(new Float32Array(_bones), BONESPERVERT));
        }
        var mesh;
        if (this.mBones.length == 0)
          mesh = new Mesh(geometry, mat);
        if (this.mBones.length > 0) {
          mesh = new SkinnedMesh(geometry, mat);
          mesh.normalizeSkinWeights();
        }
        this.threeNode = mesh;
        return mesh;
      };
    }
    function aiFace() {
      this.mNumIndices = 0;
      this.mIndices = [];
    }
    function aiVector3D() {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.toTHREE = function() {
        return new Vector3(this.x, this.y, this.z);
      };
    }
    function aiColor3D() {
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      this.toTHREE = function() {
        return new Color(this.r, this.g, this.b);
      };
    }
    function aiQuaternion() {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
      this.toTHREE = function() {
        return new Quaternion(this.x, this.y, this.z, this.w);
      };
    }
    function aiVertexWeight() {
      this.mVertexId = 0;
      this.mWeight = 0;
    }
    function aiString() {
      this.data = [];
      this.toString = function() {
        var str = "";
        this.data.forEach(function(i2) {
          str += String.fromCharCode(i2);
        });
        return str.replace(/[^\x20-\x7E]+/g, "");
      };
    }
    function aiVectorKey() {
      this.mTime = 0;
      this.mValue = null;
    }
    function aiQuatKey() {
      this.mTime = 0;
      this.mValue = null;
    }
    function aiNode() {
      this.mName = "";
      this.mTransformation = [];
      this.mNumChildren = 0;
      this.mNumMeshes = 0;
      this.mMeshes = [];
      this.mChildren = [];
      this.toTHREE = function(scene) {
        if (this.threeNode)
          return this.threeNode;
        var o = new Object3D();
        o.name = this.mName;
        o.matrix = this.mTransformation.toTHREE();
        for (let i2 = 0; i2 < this.mChildren.length; i2++) {
          o.add(this.mChildren[i2].toTHREE(scene));
        }
        for (let i2 = 0; i2 < this.mMeshes.length; i2++) {
          o.add(scene.mMeshes[this.mMeshes[i2]].toTHREE(scene));
        }
        this.threeNode = o;
        o.matrix.decompose(o.position, o.quaternion, o.scale);
        return o;
      };
    }
    function aiBone() {
      this.mName = "";
      this.mNumWeights = 0;
      this.mOffsetMatrix = 0;
    }
    function aiMaterialProperty() {
      this.mKey = "";
      this.mSemantic = 0;
      this.mIndex = 0;
      this.mData = [];
      this.mDataLength = 0;
      this.mType = 0;
      this.dataAsColor = function() {
        var array = new Uint8Array(this.mData).buffer;
        var reader = new DataView(array);
        var r = reader.getFloat32(0, true);
        var g = reader.getFloat32(4, true);
        var b2 = reader.getFloat32(8, true);
        return new Color(r, g, b2);
      };
      this.dataAsFloat = function() {
        var array = new Uint8Array(this.mData).buffer;
        var reader = new DataView(array);
        var r = reader.getFloat32(0, true);
        return r;
      };
      this.dataAsBool = function() {
        var array = new Uint8Array(this.mData).buffer;
        var reader = new DataView(array);
        var r = reader.getFloat32(0, true);
        return !!r;
      };
      this.dataAsString = function() {
        var s = new aiString();
        s.data = this.mData;
        return s.toString();
      };
      this.dataAsMap = function() {
        var s = new aiString();
        s.data = this.mData;
        var path2 = s.toString();
        path2 = path2.replace(/\\/g, "/");
        if (path2.indexOf("/") != -1) {
          path2 = path2.substr(path2.lastIndexOf("/") + 1);
        }
        return textureLoader.load(path2);
      };
    }
    var namePropMapping = {
      "?mat.name": "name",
      "$mat.shadingm": "shading",
      "$mat.twosided": "twoSided",
      "$mat.wireframe": "wireframe",
      "$clr.ambient": "ambient",
      "$clr.diffuse": "color",
      "$clr.specular": "specular",
      "$clr.emissive": "emissive",
      "$clr.transparent": "transparent",
      "$clr.reflective": "reflect",
      "$mat.shininess": "shininess",
      "$mat.reflectivity": "reflectivity",
      "$mat.refracti": "refraction",
      "$tex.file": "map"
    };
    var nameTypeMapping = {
      "?mat.name": "string",
      "$mat.shadingm": "bool",
      "$mat.twosided": "bool",
      "$mat.wireframe": "bool",
      "$clr.ambient": "color",
      "$clr.diffuse": "color",
      "$clr.specular": "color",
      "$clr.emissive": "color",
      "$clr.transparent": "color",
      "$clr.reflective": "color",
      "$mat.shininess": "float",
      "$mat.reflectivity": "float",
      "$mat.refracti": "float",
      "$tex.file": "map"
    };
    function aiMaterial() {
      this.mNumAllocated = 0;
      this.mNumProperties = 0;
      this.mProperties = [];
      this.toTHREE = function() {
        var mat = new MeshPhongMaterial();
        for (let i2 = 0; i2 < this.mProperties.length; i2++) {
          if (nameTypeMapping[this.mProperties[i2].mKey] == "float") {
            mat[namePropMapping[this.mProperties[i2].mKey]] = this.mProperties[i2].dataAsFloat();
          }
          if (nameTypeMapping[this.mProperties[i2].mKey] == "color") {
            mat[namePropMapping[this.mProperties[i2].mKey]] = this.mProperties[i2].dataAsColor();
          }
          if (nameTypeMapping[this.mProperties[i2].mKey] == "bool") {
            mat[namePropMapping[this.mProperties[i2].mKey]] = this.mProperties[i2].dataAsBool();
          }
          if (nameTypeMapping[this.mProperties[i2].mKey] == "string") {
            mat[namePropMapping[this.mProperties[i2].mKey]] = this.mProperties[i2].dataAsString();
          }
          if (nameTypeMapping[this.mProperties[i2].mKey] == "map") {
            var prop = this.mProperties[i2];
            if (prop.mSemantic == aiTextureType_DIFFUSE)
              mat.map = this.mProperties[i2].dataAsMap();
            if (prop.mSemantic == aiTextureType_NORMALS)
              mat.normalMap = this.mProperties[i2].dataAsMap();
            if (prop.mSemantic == aiTextureType_LIGHTMAP)
              mat.lightMap = this.mProperties[i2].dataAsMap();
            if (prop.mSemantic == aiTextureType_OPACITY)
              mat.alphaMap = this.mProperties[i2].dataAsMap();
          }
        }
        mat.ambient.r = 0.53;
        mat.ambient.g = 0.53;
        mat.ambient.b = 0.53;
        mat.color.r = 1;
        mat.color.g = 1;
        mat.color.b = 1;
        return mat;
      };
    }
    function veclerp(v12, v2, l) {
      var v = new Vector3();
      var lm1 = 1 - l;
      v.x = v12.x * l + v2.x * lm1;
      v.y = v12.y * l + v2.y * lm1;
      v.z = v12.z * l + v2.z * lm1;
      return v;
    }
    function quatlerp(q1, q2, l) {
      return q1.clone().slerp(q2, 1 - l);
    }
    function sampleTrack(keys, time, lne, lerp) {
      if (keys.length == 1)
        return keys[0].mValue.toTHREE();
      var dist = Infinity;
      var key = null;
      var nextKey = null;
      for (let i2 = 0; i2 < keys.length; i2++) {
        var timeDist = Math.abs(keys[i2].mTime - time);
        if (timeDist < dist && keys[i2].mTime <= time) {
          dist = timeDist;
          key = keys[i2];
          nextKey = keys[i2 + 1];
        }
      }
      if (!key) {
        return null;
      } else if (nextKey) {
        var dT = nextKey.mTime - key.mTime;
        var T = key.mTime - time;
        var l = T / dT;
        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);
      } else {
        nextKey = keys[0].clone();
        nextKey.mTime += lne;
        var dT = nextKey.mTime - key.mTime;
        var T = key.mTime - time;
        var l = T / dT;
        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);
      }
    }
    function aiNodeAnim() {
      this.mNodeName = "";
      this.mNumPositionKeys = 0;
      this.mNumRotationKeys = 0;
      this.mNumScalingKeys = 0;
      this.mPositionKeys = [];
      this.mRotationKeys = [];
      this.mScalingKeys = [];
      this.mPreState = "";
      this.mPostState = "";
      this.init = function(tps) {
        if (!tps)
          tps = 1;
        function t2(t3) {
          t3.mTime /= tps;
        }
        this.mPositionKeys.forEach(t2);
        this.mRotationKeys.forEach(t2);
        this.mScalingKeys.forEach(t2);
      };
      this.sortKeys = function() {
        function comp(a2, b2) {
          return a2.mTime - b2.mTime;
        }
        this.mPositionKeys.sort(comp);
        this.mRotationKeys.sort(comp);
        this.mScalingKeys.sort(comp);
      };
      this.getLength = function() {
        return Math.max(Math.max.apply(null, this.mPositionKeys.map(function(a2) {
          return a2.mTime;
        })), Math.max.apply(null, this.mRotationKeys.map(function(a2) {
          return a2.mTime;
        })), Math.max.apply(null, this.mScalingKeys.map(function(a2) {
          return a2.mTime;
        })));
      };
      this.toTHREE = function(o) {
        this.sortKeys();
        var length2 = this.getLength();
        var track = new Virtulous.KeyFrameTrack();
        for (let i2 = 0; i2 < length2; i2 += 0.05) {
          var matrix3 = new Matrix4();
          var time = i2;
          var pos = sampleTrack(this.mPositionKeys, time, length2, veclerp);
          var scale = sampleTrack(this.mScalingKeys, time, length2, veclerp);
          var rotation = sampleTrack(this.mRotationKeys, time, length2, quatlerp);
          matrix3.compose(pos, rotation, scale);
          var key = new Virtulous.KeyFrame(time, matrix3);
          track.addKey(key);
        }
        track.target = o.findNode(this.mNodeName).toTHREE();
        var tracks = [track];
        if (o.nodeToBoneMap[this.mNodeName]) {
          for (let i2 = 0; i2 < o.nodeToBoneMap[this.mNodeName].length; i2++) {
            var t2 = track.clone();
            t2.target = o.nodeToBoneMap[this.mNodeName][i2];
            tracks.push(t2);
          }
        }
        return tracks;
      };
    }
    function aiAnimation() {
      this.mName = "";
      this.mDuration = 0;
      this.mTicksPerSecond = 0;
      this.mNumChannels = 0;
      this.mChannels = [];
      this.toTHREE = function(root) {
        var animationHandle = new Virtulous.Animation();
        for (let i2 in this.mChannels) {
          this.mChannels[i2].init(this.mTicksPerSecond);
          var tracks = this.mChannels[i2].toTHREE(root);
          for (let j2 in tracks) {
            tracks[j2].init();
            animationHandle.addTrack(tracks[j2]);
          }
        }
        animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function(e) {
          return e.length;
        }));
        return animationHandle;
      };
    }
    function aiTexture() {
      this.mWidth = 0;
      this.mHeight = 0;
      this.texAchFormatHint = [];
      this.pcData = [];
    }
    function aiLight() {
      this.mName = "";
      this.mType = 0;
      this.mAttenuationConstant = 0;
      this.mAttenuationLinear = 0;
      this.mAttenuationQuadratic = 0;
      this.mAngleInnerCone = 0;
      this.mAngleOuterCone = 0;
      this.mColorDiffuse = null;
      this.mColorSpecular = null;
      this.mColorAmbient = null;
    }
    function aiCamera() {
      this.mName = "";
      this.mPosition = null;
      this.mLookAt = null;
      this.mUp = null;
      this.mHorizontalFOV = 0;
      this.mClipPlaneNear = 0;
      this.mClipPlaneFar = 0;
      this.mAspect = 0;
    }
    function aiScene() {
      this.versionMajor = 0;
      this.versionMinor = 0;
      this.versionRevision = 0;
      this.compileFlags = 0;
      this.mFlags = 0;
      this.mNumMeshes = 0;
      this.mNumMaterials = 0;
      this.mNumAnimations = 0;
      this.mNumTextures = 0;
      this.mNumLights = 0;
      this.mNumCameras = 0;
      this.mRootNode = null;
      this.mMeshes = [];
      this.mMaterials = [];
      this.mAnimations = [];
      this.mLights = [];
      this.mCameras = [];
      this.nodeToBoneMap = {};
      this.findNode = function(name, root) {
        if (!root) {
          root = this.mRootNode;
        }
        if (root.mName == name) {
          return root;
        }
        for (let i2 = 0; i2 < root.mChildren.length; i2++) {
          var ret = this.findNode(name, root.mChildren[i2]);
          if (ret)
            return ret;
        }
        return null;
      };
      this.toTHREE = function() {
        this.nodeCount = 0;
        markBones(this);
        var o = this.mRootNode.toTHREE(this);
        for (let i2 in this.mMeshes)
          this.mMeshes[i2].hookupSkeletons(this);
        if (this.mAnimations.length > 0) {
          var a2 = this.mAnimations[0].toTHREE(this);
        }
        return {
          object: o,
          animation: a2
        };
      };
    }
    function aiMatrix4() {
      this.elements = [[], [], [], []];
      this.toTHREE = function() {
        var m = new Matrix4();
        for (let i2 = 0; i2 < 4; ++i2) {
          for (let i22 = 0; i22 < 4; ++i22) {
            m.elements[i2 * 4 + i22] = this.elements[i22][i2];
          }
        }
        return m;
      };
    }
    var littleEndian = true;
    function readFloat(dataview) {
      var val = dataview.getFloat32(dataview.readOffset, littleEndian);
      dataview.readOffset += 4;
      return val;
    }
    function Read_double(dataview) {
      var val = dataview.getFloat64(dataview.readOffset, littleEndian);
      dataview.readOffset += 8;
      return val;
    }
    function Read_uint8_t(dataview) {
      var val = dataview.getUint8(dataview.readOffset);
      dataview.readOffset += 1;
      return val;
    }
    function Read_uint16_t(dataview) {
      var val = dataview.getUint16(dataview.readOffset, littleEndian);
      dataview.readOffset += 2;
      return val;
    }
    function Read_unsigned_int(dataview) {
      var val = dataview.getUint32(dataview.readOffset, littleEndian);
      dataview.readOffset += 4;
      return val;
    }
    function Read_uint32_t(dataview) {
      var val = dataview.getUint32(dataview.readOffset, littleEndian);
      dataview.readOffset += 4;
      return val;
    }
    function Read_aiVector3D(stream) {
      var v = new aiVector3D();
      v.x = readFloat(stream);
      v.y = readFloat(stream);
      v.z = readFloat(stream);
      return v;
    }
    function Read_aiColor3D(stream) {
      var c = new aiColor3D();
      c.r = readFloat(stream);
      c.g = readFloat(stream);
      c.b = readFloat(stream);
      return c;
    }
    function Read_aiQuaternion(stream) {
      var v = new aiQuaternion();
      v.w = readFloat(stream);
      v.x = readFloat(stream);
      v.y = readFloat(stream);
      v.z = readFloat(stream);
      return v;
    }
    function Read_aiString(stream) {
      var s = new aiString();
      var stringlengthbytes = Read_unsigned_int(stream);
      stream.ReadBytes(s.data, 1, stringlengthbytes);
      return s.toString();
    }
    function Read_aiVertexWeight(stream) {
      var w = new aiVertexWeight();
      w.mVertexId = Read_unsigned_int(stream);
      w.mWeight = readFloat(stream);
      return w;
    }
    function Read_aiMatrix4x4(stream) {
      var m = new aiMatrix4();
      for (let i2 = 0; i2 < 4; ++i2) {
        for (let i22 = 0; i22 < 4; ++i22) {
          m.elements[i2][i22] = readFloat(stream);
        }
      }
      return m;
    }
    function Read_aiVectorKey(stream) {
      var v = new aiVectorKey();
      v.mTime = Read_double(stream);
      v.mValue = Read_aiVector3D(stream);
      return v;
    }
    function Read_aiQuatKey(stream) {
      var v = new aiQuatKey();
      v.mTime = Read_double(stream);
      v.mValue = Read_aiQuaternion(stream);
      return v;
    }
    function ReadArray_aiVertexWeight(stream, data, size2) {
      for (let i2 = 0; i2 < size2; i2++)
        data[i2] = Read_aiVertexWeight(stream);
    }
    function ReadArray_aiVectorKey(stream, data, size2) {
      for (let i2 = 0; i2 < size2; i2++)
        data[i2] = Read_aiVectorKey(stream);
    }
    function ReadArray_aiQuatKey(stream, data, size2) {
      for (let i2 = 0; i2 < size2; i2++)
        data[i2] = Read_aiQuatKey(stream);
    }
    function ReadBounds(stream, T, n) {
      return stream.Seek(sizeof(T) * n, aiOrigin_CUR);
    }
    function ai_assert(bool2) {
      if (!bool2)
        throw "asset failed";
    }
    function ReadBinaryNode(stream, parent, depth) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);
      Read_uint32_t(stream);
      var node = new aiNode();
      node.mParent = parent;
      node.mDepth = depth;
      node.mName = Read_aiString(stream);
      node.mTransformation = Read_aiMatrix4x4(stream);
      node.mNumChildren = Read_unsigned_int(stream);
      node.mNumMeshes = Read_unsigned_int(stream);
      if (node.mNumMeshes) {
        node.mMeshes = [];
        for (let i2 = 0; i2 < node.mNumMeshes; ++i2) {
          node.mMeshes[i2] = Read_unsigned_int(stream);
        }
      }
      if (node.mNumChildren) {
        node.mChildren = [];
        for (let i2 = 0; i2 < node.mNumChildren; ++i2) {
          var node2 = ReadBinaryNode(stream, node, depth++);
          node.mChildren[i2] = node2;
        }
      }
      return node;
    }
    function ReadBinaryBone(stream, b2) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);
      Read_uint32_t(stream);
      b2.mName = Read_aiString(stream);
      b2.mNumWeights = Read_unsigned_int(stream);
      b2.mOffsetMatrix = Read_aiMatrix4x4(stream);
      if (shortened) {
        ReadBounds(stream, b2.mWeights, b2.mNumWeights);
      } else {
        b2.mWeights = [];
        ReadArray_aiVertexWeight(stream, b2.mWeights, b2.mNumWeights);
      }
      return b2;
    }
    function ReadBinaryMesh(stream, mesh) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);
      Read_uint32_t(stream);
      mesh.mPrimitiveTypes = Read_unsigned_int(stream);
      mesh.mNumVertices = Read_unsigned_int(stream);
      mesh.mNumFaces = Read_unsigned_int(stream);
      mesh.mNumBones = Read_unsigned_int(stream);
      mesh.mMaterialIndex = Read_unsigned_int(stream);
      mesh.mNumUVComponents = [];
      var c = Read_unsigned_int(stream);
      if (c & ASSBIN_MESH_HAS_POSITIONS) {
        if (shortened) {
          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);
        } else {
          mesh.mVertices = [];
          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
        }
      }
      if (c & ASSBIN_MESH_HAS_NORMALS) {
        if (shortened) {
          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);
        } else {
          mesh.mNormals = [];
          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
        }
      }
      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {
        if (shortened) {
          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);
          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);
        } else {
          mesh.mTangents = [];
          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
          mesh.mBitangents = [];
          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);
          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);
        }
      }
      for (let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {
        if (!(c & ASSBIN_MESH_HAS_COLOR(n)))
          break;
        if (shortened) {
          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);
        } else {
          mesh.mColors[n] = [];
          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);
          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);
        }
      }
      mesh.mTexCoordsBuffers = [];
      for (let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {
        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n)))
          break;
        mesh.mNumUVComponents[n] = Read_unsigned_int(stream);
        if (shortened) {
          ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);
        } else {
          mesh.mTextureCoords[n] = [];
          mesh.mTexCoordsBuffers[n] = [];
          for (let uv2 = 0; uv2 < mesh.mNumVertices; uv2++) {
            mesh.mTexCoordsBuffers[n].push(readFloat(stream));
            mesh.mTexCoordsBuffers[n].push(readFloat(stream));
            readFloat(stream);
          }
        }
      }
      if (shortened) {
        Read_unsigned_int(stream);
      } else {
        mesh.mFaces = [];
        mesh.mIndexArray = [];
        for (let i2 = 0; i2 < mesh.mNumFaces; ++i2) {
          var f = mesh.mFaces[i2] = new aiFace();
          f.mNumIndices = Read_uint16_t(stream);
          f.mIndices = [];
          for (let a2 = 0; a2 < f.mNumIndices; ++a2) {
            if (mesh.mNumVertices < 1 << 16) {
              f.mIndices[a2] = Read_uint16_t(stream);
            } else {
              f.mIndices[a2] = Read_unsigned_int(stream);
            }
          }
          if (f.mNumIndices === 3) {
            mesh.mIndexArray.push(f.mIndices[0]);
            mesh.mIndexArray.push(f.mIndices[1]);
            mesh.mIndexArray.push(f.mIndices[2]);
          } else if (f.mNumIndices === 4) {
            mesh.mIndexArray.push(f.mIndices[0]);
            mesh.mIndexArray.push(f.mIndices[1]);
            mesh.mIndexArray.push(f.mIndices[2]);
            mesh.mIndexArray.push(f.mIndices[2]);
            mesh.mIndexArray.push(f.mIndices[3]);
            mesh.mIndexArray.push(f.mIndices[0]);
          } else {
            throw new Error("Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.");
          }
        }
      }
      if (mesh.mNumBones) {
        mesh.mBones = [];
        for (let a2 = 0; a2 < mesh.mNumBones; ++a2) {
          mesh.mBones[a2] = new aiBone();
          ReadBinaryBone(stream, mesh.mBones[a2]);
        }
      }
    }
    function ReadBinaryMaterialProperty(stream, prop) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);
      Read_uint32_t(stream);
      prop.mKey = Read_aiString(stream);
      prop.mSemantic = Read_unsigned_int(stream);
      prop.mIndex = Read_unsigned_int(stream);
      prop.mDataLength = Read_unsigned_int(stream);
      prop.mType = Read_unsigned_int(stream);
      prop.mData = [];
      stream.ReadBytes(prop.mData, 1, prop.mDataLength);
    }
    function ReadBinaryMaterial(stream, mat) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);
      Read_uint32_t(stream);
      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);
      if (mat.mNumProperties) {
        if (mat.mProperties) {
          delete mat.mProperties;
        }
        mat.mProperties = [];
        for (let i2 = 0; i2 < mat.mNumProperties; ++i2) {
          mat.mProperties[i2] = new aiMaterialProperty();
          ReadBinaryMaterialProperty(stream, mat.mProperties[i2]);
        }
      }
    }
    function ReadBinaryNodeAnim(stream, nd) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);
      Read_uint32_t(stream);
      nd.mNodeName = Read_aiString(stream);
      nd.mNumPositionKeys = Read_unsigned_int(stream);
      nd.mNumRotationKeys = Read_unsigned_int(stream);
      nd.mNumScalingKeys = Read_unsigned_int(stream);
      nd.mPreState = Read_unsigned_int(stream);
      nd.mPostState = Read_unsigned_int(stream);
      if (nd.mNumPositionKeys) {
        if (shortened) {
          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);
        } else {
          nd.mPositionKeys = [];
          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);
        }
      }
      if (nd.mNumRotationKeys) {
        if (shortened) {
          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);
        } else {
          nd.mRotationKeys = [];
          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);
        }
      }
      if (nd.mNumScalingKeys) {
        if (shortened) {
          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);
        } else {
          nd.mScalingKeys = [];
          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);
        }
      }
    }
    function ReadBinaryAnim(stream, anim) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);
      Read_uint32_t(stream);
      anim.mName = Read_aiString(stream);
      anim.mDuration = Read_double(stream);
      anim.mTicksPerSecond = Read_double(stream);
      anim.mNumChannels = Read_unsigned_int(stream);
      if (anim.mNumChannels) {
        anim.mChannels = [];
        for (let a2 = 0; a2 < anim.mNumChannels; ++a2) {
          anim.mChannels[a2] = new aiNodeAnim();
          ReadBinaryNodeAnim(stream, anim.mChannels[a2]);
        }
      }
    }
    function ReadBinaryTexture(stream, tex) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);
      Read_uint32_t(stream);
      tex.mWidth = Read_unsigned_int(stream);
      tex.mHeight = Read_unsigned_int(stream);
      stream.ReadBytes(tex.achFormatHint, 1, 4);
      if (!shortened) {
        if (!tex.mHeight) {
          tex.pcData = [];
          stream.ReadBytes(tex.pcData, 1, tex.mWidth);
        } else {
          tex.pcData = [];
          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);
        }
      }
    }
    function ReadBinaryLight(stream, l) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);
      Read_uint32_t(stream);
      l.mName = Read_aiString(stream);
      l.mType = Read_unsigned_int(stream);
      if (l.mType != aiLightSource_DIRECTIONAL) {
        l.mAttenuationConstant = readFloat(stream);
        l.mAttenuationLinear = readFloat(stream);
        l.mAttenuationQuadratic = readFloat(stream);
      }
      l.mColorDiffuse = Read_aiColor3D(stream);
      l.mColorSpecular = Read_aiColor3D(stream);
      l.mColorAmbient = Read_aiColor3D(stream);
      if (l.mType == aiLightSource_SPOT) {
        l.mAngleInnerCone = readFloat(stream);
        l.mAngleOuterCone = readFloat(stream);
      }
    }
    function ReadBinaryCamera(stream, cam) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);
      Read_uint32_t(stream);
      cam.mName = Read_aiString(stream);
      cam.mPosition = Read_aiVector3D(stream);
      cam.mLookAt = Read_aiVector3D(stream);
      cam.mUp = Read_aiVector3D(stream);
      cam.mHorizontalFOV = readFloat(stream);
      cam.mClipPlaneNear = readFloat(stream);
      cam.mClipPlaneFar = readFloat(stream);
      cam.mAspect = readFloat(stream);
    }
    function ReadBinaryScene(stream, scene) {
      var chunkID = Read_uint32_t(stream);
      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);
      Read_uint32_t(stream);
      scene.mFlags = Read_unsigned_int(stream);
      scene.mNumMeshes = Read_unsigned_int(stream);
      scene.mNumMaterials = Read_unsigned_int(stream);
      scene.mNumAnimations = Read_unsigned_int(stream);
      scene.mNumTextures = Read_unsigned_int(stream);
      scene.mNumLights = Read_unsigned_int(stream);
      scene.mNumCameras = Read_unsigned_int(stream);
      scene.mRootNode = new aiNode();
      scene.mRootNode = ReadBinaryNode(stream, null, 0);
      if (scene.mNumMeshes) {
        scene.mMeshes = [];
        for (let i2 = 0; i2 < scene.mNumMeshes; ++i2) {
          scene.mMeshes[i2] = new aiMesh();
          ReadBinaryMesh(stream, scene.mMeshes[i2]);
        }
      }
      if (scene.mNumMaterials) {
        scene.mMaterials = [];
        for (let i2 = 0; i2 < scene.mNumMaterials; ++i2) {
          scene.mMaterials[i2] = new aiMaterial();
          ReadBinaryMaterial(stream, scene.mMaterials[i2]);
        }
      }
      if (scene.mNumAnimations) {
        scene.mAnimations = [];
        for (let i2 = 0; i2 < scene.mNumAnimations; ++i2) {
          scene.mAnimations[i2] = new aiAnimation();
          ReadBinaryAnim(stream, scene.mAnimations[i2]);
        }
      }
      if (scene.mNumTextures) {
        scene.mTextures = [];
        for (let i2 = 0; i2 < scene.mNumTextures; ++i2) {
          scene.mTextures[i2] = new aiTexture();
          ReadBinaryTexture(stream, scene.mTextures[i2]);
        }
      }
      if (scene.mNumLights) {
        scene.mLights = [];
        for (let i2 = 0; i2 < scene.mNumLights; ++i2) {
          scene.mLights[i2] = new aiLight();
          ReadBinaryLight(stream, scene.mLights[i2]);
        }
      }
      if (scene.mNumCameras) {
        scene.mCameras = [];
        for (let i2 = 0; i2 < scene.mNumCameras; ++i2) {
          scene.mCameras[i2] = new aiCamera();
          ReadBinaryCamera(stream, scene.mCameras[i2]);
        }
      }
    }
    var aiOrigin_CUR = 0;
    var aiOrigin_BEG = 1;
    function extendStream(stream) {
      stream.readOffset = 0;
      stream.Seek = function(off, ori) {
        if (ori == aiOrigin_CUR) {
          stream.readOffset += off;
        }
        if (ori == aiOrigin_BEG) {
          stream.readOffset = off;
        }
      };
      stream.ReadBytes = function(buff, size2, n) {
        var bytes = size2 * n;
        for (let i2 = 0; i2 < bytes; i2++)
          buff[i2] = Read_uint8_t(this);
      };
      stream.subArray32 = function(start, end) {
        var buff = this.buffer;
        var newbuff = buff.slice(start, end);
        return new Float32Array(newbuff);
      };
      stream.subArrayUint16 = function(start, end) {
        var buff = this.buffer;
        var newbuff = buff.slice(start, end);
        return new Uint16Array(newbuff);
      };
      stream.subArrayUint8 = function(start, end) {
        var buff = this.buffer;
        var newbuff = buff.slice(start, end);
        return new Uint8Array(newbuff);
      };
      stream.subArrayUint32 = function(start, end) {
        var buff = this.buffer;
        var newbuff = buff.slice(start, end);
        return new Uint32Array(newbuff);
      };
    }
    var shortened, compressed;
    function InternReadFile(pFiledata) {
      var pScene = new aiScene();
      var stream = new DataView(pFiledata);
      extendStream(stream);
      stream.Seek(44, aiOrigin_CUR);
      pScene.versionMajor = Read_unsigned_int(stream);
      pScene.versionMinor = Read_unsigned_int(stream);
      pScene.versionRevision = Read_unsigned_int(stream);
      pScene.compileFlags = Read_unsigned_int(stream);
      shortened = Read_uint16_t(stream) > 0;
      compressed = Read_uint16_t(stream) > 0;
      if (shortened)
        throw "Shortened binaries are not supported!";
      stream.Seek(256, aiOrigin_CUR);
      stream.Seek(128, aiOrigin_CUR);
      stream.Seek(64, aiOrigin_CUR);
      if (compressed) {
        var uncompressedSize = Read_uint32_t(stream);
        var compressedSize = stream.FileSize() - stream.Tell();
        var compressedData = [];
        stream.Read(compressedData, 1, compressedSize);
        var uncompressedData = [];
        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize);
        var buff = new ArrayBuffer(uncompressedData);
        ReadBinaryScene(buff, pScene);
      } else {
        ReadBinaryScene(stream, pScene);
      }
      return pScene.toTHREE();
    }
    return InternReadFile(buffer2);
  }
});

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/BasisTextureLoader.js
var _taskCache2 = /* @__PURE__ */ new WeakMap();
var BasisTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.workerConfig = null;
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  detectSupport(renderer) {
    this.workerConfig = {
      astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
      etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    };
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader2(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setWithCredentials(this.withCredentials);
    const texture2 = new CompressedTexture();
    loader.load(url, (buffer2) => {
      if (_taskCache2.has(buffer2)) {
        const cachedTask = _taskCache2.get(buffer2);
        return cachedTask.promise.then(onLoad).catch(onError);
      }
      this._createTexture([buffer2]).then(function(_texture) {
        texture2.copy(_texture);
        texture2.needsUpdate = true;
        if (onLoad)
          onLoad(texture2);
      }).catch(onError);
    }, onProgress, onError);
    return texture2;
  }
  /** Low-level transcoding API, exposed for use by KTX2Loader. */
  parseInternalAsync(options) {
    const {
      levels
    } = options;
    const buffers = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < levels.length; i2++) {
      buffers.add(levels[i2].data.buffer);
    }
    return this._createTexture(Array.from(buffers), {
      ...options,
      lowLevel: true
    });
  }
  /**
   * @param {ArrayBuffer[]} buffers
   * @param {object?} config
   * @return {Promise<CompressedTexture>}
   */
  _createTexture(buffers, config = {}) {
    let worker;
    let taskID;
    const taskConfig = config;
    let taskCost = 0;
    for (let i2 = 0; i2 < buffers.length; i2++) {
      taskCost += buffers[i2].byteLength;
    }
    const texturePending = this._allocateWorker(taskCost).then((_worker) => {
      worker = _worker;
      taskID = this.workerNextTaskID++;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = {
          resolve,
          reject
        };
        worker.postMessage({
          type: "transcode",
          id: taskID,
          buffers,
          taskConfig
        }, buffers);
      });
    }).then((message) => {
      const {
        mipmaps,
        width,
        height,
        format
      } = message;
      const texture2 = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);
      texture2.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
      texture2.magFilter = LinearFilter;
      texture2.generateMipmaps = false;
      texture2.needsUpdate = true;
      return texture2;
    });
    texturePending.catch(() => true).then(() => {
      if (worker && taskID) {
        worker._taskLoad -= taskCost;
        delete worker._callbacks[taskID];
      }
    });
    _taskCache2.set(buffers[0], {
      promise: texturePending
    });
    return texturePending;
  }
  _initTranscoder() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader2(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = new Promise((resolve, reject) => {
        jsLoader.load("basis_transcoder.js", resolve, void 0, reject);
      });
      const binaryLoader = new FileLoader2(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = new Promise((resolve, reject) => {
        binaryLoader.load("basis_transcoder.wasm", resolve, void 0, reject);
      });
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = BasisTextureLoader.BasisWorker.toString();
        const body = ["/* constants */", "let _EngineFormat = " + JSON.stringify(BasisTextureLoader.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(BasisTextureLoader.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(BasisTextureLoader.BasisFormat), "/* basis_transcoder.js */", jsContent2, "/* worker */", fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
      });
    }
    return this.transcoderPending;
  }
  _allocateWorker(taskCost) {
    return this._initTranscoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskLoad = 0;
        worker2.postMessage({
          type: "init",
          config: this.workerConfig,
          transcoderBinary: this.transcoderBinary
        });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "transcode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.BasisTextureLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a2, b2) {
          return a2._taskLoad > b2._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  dispose() {
    for (let i2 = 0; i2 < this.workerPool.length; i2++) {
      this.workerPool[i2].terminate();
    }
    this.workerPool.length = 0;
    return this;
  }
};
BasisTextureLoader.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
BasisTextureLoader.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
BasisTextureLoader.EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format
};
BasisTextureLoader.BasisWorker = function() {
  let config;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config = message.config;
        init(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const {
              width,
              height,
              hasAlpha,
              mipmaps,
              format
            } = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]);
            const buffers = [];
            for (let i2 = 0; i2 < mipmaps.length; ++i2) {
              buffers.push(mipmaps[i2].data.buffer);
            }
            self.postMessage({
              type: "transcode",
              id: message.id,
              width,
              height,
              hasAlpha,
              mipmaps,
              format
            }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({
              type: "error",
              id: message.id,
              error: error.message
            });
          }
        });
        break;
    }
  };
  function init(wasmBinary) {
    transcoderPending = new Promise((resolve) => {
      BasisModule = {
        wasmBinary,
        onRuntimeInitialized: resolve
      };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
    });
  }
  function transcodeLowLevel(taskConfig) {
    const {
      basisFormat,
      width,
      height,
      hasAlpha
    } = taskConfig;
    const {
      transcoderFormat,
      engineFormat
    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);
    assert(BasisModule.isFormatSupported(transcoderFormat), "THREE.BasisTextureLoader: Unsupported format.");
    const mipmaps = [];
    if (basisFormat === BasisFormat.ETC1S) {
      const transcoder = new BasisModule.LowLevelETC1SImageTranscoder();
      const {
        endpointCount,
        endpointsData,
        selectorCount,
        selectorsData,
        tablesData
      } = taskConfig.globalData;
      try {
        let ok;
        ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);
        assert(ok, "THREE.BasisTextureLoader: decodePalettes() failed.");
        ok = transcoder.decodeTables(tablesData);
        assert(ok, "THREE.BasisTextureLoader: decodeTables() failed.");
        for (let i2 = 0; i2 < taskConfig.levels.length; i2++) {
          const level = taskConfig.levels[i2];
          const imageDesc = taskConfig.globalData.imageDescs[i2];
          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);
          const dst = new Uint8Array(dstByteLength);
          ok = transcoder.transcodeImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength, imageDesc.alphaSliceByteOffset, imageDesc.alphaSliceByteLength, imageDesc.imageFlags, hasAlpha, false, 0, 0);
          assert(ok, "THREE.BasisTextureLoader: transcodeImage() failed for level " + level.index + ".");
          mipmaps.push({
            data: dst,
            width: level.width,
            height: level.height
          });
        }
      } finally {
        transcoder.delete();
      }
    } else {
      for (let i2 = 0; i2 < taskConfig.levels.length; i2++) {
        const level = taskConfig.levels[i2];
        const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);
        const dst = new Uint8Array(dstByteLength);
        const ok = BasisModule.transcodeUASTCImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, 0, level.data.byteLength, 0, hasAlpha, false, 0, 0, -1, -1);
        assert(ok, "THREE.BasisTextureLoader: transcodeUASTCImage() failed for level " + level.index + ".");
        mipmaps.push({
          data: dst,
          width: level.width,
          height: level.height
        });
      }
    }
    return {
      width,
      height,
      hasAlpha,
      mipmaps,
      format: engineFormat
    };
  }
  function transcode(buffer2) {
    const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer2));
    const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
    const width = basisFile.getImageWidth(0, 0);
    const height = basisFile.getImageHeight(0, 0);
    const levels = basisFile.getNumLevels(0);
    const hasAlpha = basisFile.getHasAlpha();
    function cleanup() {
      basisFile.close();
      basisFile.delete();
    }
    const {
      transcoderFormat,
      engineFormat
    } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levels) {
      cleanup();
      throw new Error("THREE.BasisTextureLoader:	Invalid texture");
    }
    if (!basisFile.startTranscoding()) {
      cleanup();
      throw new Error("THREE.BasisTextureLoader: .startTranscoding failed");
    }
    const mipmaps = [];
    for (let mip = 0; mip < levels; mip++) {
      const mipWidth = basisFile.getImageWidth(0, mip);
      const mipHeight = basisFile.getImageHeight(0, mip);
      const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));
      const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);
      if (!status) {
        cleanup();
        throw new Error("THREE.BasisTextureLoader: .transcodeImage failed.");
      }
      mipmaps.push({
        data: dst,
        width: mipWidth,
        height: mipHeight
      });
    }
    cleanup();
    return {
      width,
      height,
      hasAlpha,
      mipmaps,
      format: engineFormat
    };
  }
  const FORMAT_OPTIONS = [{
    if: "astcSupported",
    basisFormat: [BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
    priorityETC1S: Infinity,
    priorityUASTC: 1,
    needsPowerOfTwo: false
  }, {
    if: "bptcSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
    priorityETC1S: 3,
    priorityUASTC: 2,
    needsPowerOfTwo: false
  }, {
    if: "dxtSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
    priorityETC1S: 4,
    priorityUASTC: 5,
    needsPowerOfTwo: false
  }, {
    if: "etc2Supported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
    priorityETC1S: 1,
    priorityUASTC: 3,
    needsPowerOfTwo: false
  }, {
    if: "etc1Supported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],
    engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],
    priorityETC1S: 2,
    priorityUASTC: 4,
    needsPowerOfTwo: false
  }, {
    if: "pvrtcSupported",
    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
    priorityETC1S: 5,
    priorityUASTC: 6,
    needsPowerOfTwo: true
  }];
  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b2) {
    return a2.priorityETC1S - b2.priorityETC1S;
  });
  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a2, b2) {
    return a2.priorityUASTC - b2.priorityUASTC;
  });
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    let transcoderFormat;
    let engineFormat;
    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
    for (let i2 = 0; i2 < options.length; i2++) {
      const opt = options[i2];
      if (!config[opt.if])
        continue;
      if (!opt.basisFormat.includes(basisFormat))
        continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height)))
        continue;
      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      return {
        transcoderFormat,
        engineFormat
      };
    }
    console.warn("THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.");
    transcoderFormat = TranscoderFormat.RGBA32;
    engineFormat = EngineFormat.RGBAFormat;
    return {
      transcoderFormat,
      engineFormat
    };
  }
  function assert(ok, message) {
    if (!ok)
      throw new Error(message);
  }
  function getWidthInBlocks(transcoderFormat, width) {
    return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));
  }
  function getHeightInBlocks(transcoderFormat, height) {
    return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));
  }
  function getTranscodedImageByteLength(transcoderFormat, width, height) {
    const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);
    if (BasisModule.formatIsUncompressed(transcoderFormat)) {
      return width * height * blockByteLength;
    }
    if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {
      const paddedWidth = width + 3 & ~3;
      const paddedHeight = height + 3 & ~3;
      return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;
    }
    return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;
  }
  function isPowerOfTwo(value) {
    if (value <= 2)
      return true;
    return (value & value - 1) === 0 && value !== 0;
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/LDrawLoader.js
var _tempVec0 = new Vector3();
var _tempVec1 = new Vector3();
var _ray = new Ray();

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/lwo/LWO3Parser.js
function LWO3Parser(IFFParser2) {
  this.IFF = IFFParser2;
}
LWO3Parser.prototype = {
  constructor: LWO3Parser,
  parseBlock: function() {
    this.IFF.debugger.offset = this.IFF.reader.offset;
    this.IFF.debugger.closeForms();
    var blockID = this.IFF.reader.getIDTag();
    var length2 = this.IFF.reader.getUint32();
    this.IFF.debugger.dataOffset = this.IFF.reader.offset;
    this.IFF.debugger.length = length2;
    switch (blockID) {
      case "FORM":
        this.IFF.parseForm(length2);
        break;
      case "ICON":
      case "VMPA":
      case "BBOX":
      case "NORM":
      case "PRE ":
      case "POST":
      case "KEY ":
      case "SPAN":
      case "TIME":
      case "CLRS":
      case "CLRA":
      case "FILT":
      case "DITH":
      case "CONT":
      case "BRIT":
      case "SATR":
      case "HUE ":
      case "GAMM":
      case "NEGA":
      case "IFLT":
      case "PFLT":
      case "PROJ":
      case "AXIS":
      case "AAST":
      case "PIXB":
      case "STCK":
      case "VALU":
      case "PNAM":
      case "INAM":
      case "GRST":
      case "GREN":
      case "GRPT":
      case "FKEY":
      case "IKEY":
      case "CSYS":
      case "OPAQ":
      case "CMAP":
      case "NLOC":
      case "NZOM":
      case "NVER":
      case "NSRV":
      case "NCRD":
      case "NMOD":
      case "NSEL":
      case "NPRW":
      case "NPLA":
      case "VERS":
      case "ENUM":
      case "TAG ":
      case "CGMD":
      case "CGTY":
      case "CGST":
      case "CGEN":
      case "CGTS":
      case "CGTE":
      case "OSMP":
      case "OMDE":
      case "OUTR":
      case "FLAG":
      case "TRNL":
      case "SHRP":
      case "RFOP":
      case "RSAN":
      case "TROP":
      case "RBLR":
      case "TBLR":
      case "CLRH":
      case "CLRF":
      case "ADTR":
      case "GLOW":
      case "LINE":
      case "ALPH":
      case "VCOL":
      case "ENAB":
        this.IFF.debugger.skipped = true;
        this.IFF.reader.skip(length2);
        break;
      case "IPIX":
      case "IMIP":
      case "IMOD":
      case "AMOD":
      case "IINV":
      case "INCR":
      case "IAXS":
      case "IFOT":
      case "ITIM":
      case "IWRL":
      case "IUTI":
      case "IINX":
      case "IINY":
      case "IINZ":
      case "IREF":
        if (length2 === 4)
          this.IFF.currentNode[blockID] = this.IFF.reader.getInt32();
        else
          this.IFF.reader.skip(length2);
        break;
      case "OTAG":
        this.IFF.parseObjectTag();
        break;
      case "LAYR":
        this.IFF.parseLayer(length2);
        break;
      case "PNTS":
        this.IFF.parsePoints(length2);
        break;
      case "VMAP":
        this.IFF.parseVertexMapping(length2);
        break;
      case "POLS":
        this.IFF.parsePolygonList(length2);
        break;
      case "TAGS":
        this.IFF.parseTagStrings(length2);
        break;
      case "PTAG":
        this.IFF.parsePolygonTagMapping(length2);
        break;
      case "VMAD":
        this.IFF.parseVertexMapping(length2, true);
        break;
      case "DESC":
        this.IFF.currentForm.description = this.IFF.reader.getString();
        break;
      case "TEXT":
      case "CMNT":
      case "NCOM":
        this.IFF.currentForm.comment = this.IFF.reader.getString();
        break;
      case "NAME":
        this.IFF.currentForm.channelName = this.IFF.reader.getString();
        break;
      case "WRAP":
        this.IFF.currentForm.wrap = {
          w: this.IFF.reader.getUint16(),
          h: this.IFF.reader.getUint16()
        };
        break;
      case "IMAG":
        var index = this.IFF.reader.getVariableLengthIndex();
        this.IFF.currentForm.imageIndex = index;
        break;
      case "OREF":
        this.IFF.currentForm.referenceObject = this.IFF.reader.getString();
        break;
      case "ROID":
        this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();
        break;
      case "SSHN":
        this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();
        break;
      case "AOVN":
        this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();
        break;
      case "NSTA":
        this.IFF.currentForm.disabled = this.IFF.reader.getUint16();
        break;
      case "NRNM":
        this.IFF.currentForm.realName = this.IFF.reader.getString();
        break;
      case "NNME":
        this.IFF.currentForm.refName = this.IFF.reader.getString();
        this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm;
        break;
      case "INME":
        if (!this.IFF.currentForm.nodeName)
          this.IFF.currentForm.nodeName = [];
        this.IFF.currentForm.nodeName.push(this.IFF.reader.getString());
        break;
      case "IINN":
        if (!this.IFF.currentForm.inputNodeName)
          this.IFF.currentForm.inputNodeName = [];
        this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString());
        break;
      case "IINM":
        if (!this.IFF.currentForm.inputName)
          this.IFF.currentForm.inputName = [];
        this.IFF.currentForm.inputName.push(this.IFF.reader.getString());
        break;
      case "IONM":
        if (!this.IFF.currentForm.inputOutputName)
          this.IFF.currentForm.inputOutputName = [];
        this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString());
        break;
      case "FNAM":
        this.IFF.currentForm.fileName = this.IFF.reader.getString();
        break;
      case "CHAN":
        if (length2 === 4)
          this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();
        else
          this.IFF.reader.skip(length2);
        break;
      case "SMAN":
        var maxSmoothingAngle = this.IFF.reader.getFloat32();
        this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true;
        break;
      case "COLR":
        this.IFF.currentSurface.attributes.Color = {
          value: this.IFF.reader.getFloat32Array(3)
        };
        this.IFF.reader.skip(2);
        break;
      case "LUMI":
        this.IFF.currentSurface.attributes.Luminosity = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "SPEC":
        this.IFF.currentSurface.attributes.Specular = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "DIFF":
        this.IFF.currentSurface.attributes.Diffuse = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "REFL":
        this.IFF.currentSurface.attributes.Reflection = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "GLOS":
        this.IFF.currentSurface.attributes.Glossiness = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "TRAN":
        this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "BUMP":
        this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "SIDE":
        this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();
        break;
      case "RIMG":
        this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();
        break;
      case "RIND":
        this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "TIMG":
        this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();
        break;
      case "IMAP":
        this.IFF.currentSurface.attributes.imageMapIndex = this.IFF.reader.getUint32();
        break;
      case "IUVI":
        this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length2);
        break;
      case "IUTL":
        this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();
        break;
      case "IVTL":
        this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();
        break;
      default:
        this.IFF.parseUnknownCHUNK(blockID, length2);
    }
    if (blockID != "FORM") {
      this.IFF.debugger.node = 1;
      this.IFF.debugger.nodeID = blockID;
      this.IFF.debugger.log();
    }
    if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {
      this.IFF.currentForm = this.IFF.parentForm;
    }
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/lwo/LWO2Parser.js
function LWO2Parser(IFFParser2) {
  this.IFF = IFFParser2;
}
LWO2Parser.prototype = {
  constructor: LWO2Parser,
  parseBlock: function() {
    this.IFF.debugger.offset = this.IFF.reader.offset;
    this.IFF.debugger.closeForms();
    var blockID = this.IFF.reader.getIDTag();
    var length2 = this.IFF.reader.getUint32();
    if (length2 > this.IFF.reader.dv.byteLength - this.IFF.reader.offset) {
      this.IFF.reader.offset -= 4;
      length2 = this.IFF.reader.getUint16();
    }
    this.IFF.debugger.dataOffset = this.IFF.reader.offset;
    this.IFF.debugger.length = length2;
    switch (blockID) {
      case "FORM":
        this.IFF.parseForm(length2);
        break;
      case "ICON":
      case "VMPA":
      case "BBOX":
      case "NORM":
      case "PRE ":
      case "POST":
      case "KEY ":
      case "SPAN":
      case "TIME":
      case "CLRS":
      case "CLRA":
      case "FILT":
      case "DITH":
      case "CONT":
      case "BRIT":
      case "SATR":
      case "HUE ":
      case "GAMM":
      case "NEGA":
      case "IFLT":
      case "PFLT":
      case "PROJ":
      case "AXIS":
      case "AAST":
      case "PIXB":
      case "AUVO":
      case "STCK":
      case "PROC":
      case "VALU":
      case "FUNC":
      case "PNAM":
      case "INAM":
      case "GRST":
      case "GREN":
      case "GRPT":
      case "FKEY":
      case "IKEY":
      case "CSYS":
      case "OPAQ":
      case "CMAP":
      case "NLOC":
      case "NZOM":
      case "NVER":
      case "NSRV":
      case "NVSK":
      case "NCRD":
      case "WRPW":
      case "WRPH":
      case "NMOD":
      case "NPRW":
      case "NPLA":
      case "NODS":
      case "VERS":
      case "ENUM":
      case "TAG ":
      case "OPAC":
      case "CGMD":
      case "CGTY":
      case "CGST":
      case "CGEN":
      case "CGTS":
      case "CGTE":
      case "OSMP":
      case "OMDE":
      case "OUTR":
      case "FLAG":
      case "TRNL":
      case "GLOW":
      case "GVAL":
      case "SHRP":
      case "RFOP":
      case "RSAN":
      case "TROP":
      case "RBLR":
      case "TBLR":
      case "CLRH":
      case "CLRF":
      case "ADTR":
      case "LINE":
      case "ALPH":
      case "VCOL":
      case "ENAB":
        this.IFF.debugger.skipped = true;
        this.IFF.reader.skip(length2);
        break;
      case "SURF":
        this.IFF.parseSurfaceLwo2(length2);
        break;
      case "CLIP":
        this.IFF.parseClipLwo2(length2);
        break;
      case "IPIX":
      case "IMIP":
      case "IMOD":
      case "AMOD":
      case "IINV":
      case "INCR":
      case "IAXS":
      case "IFOT":
      case "ITIM":
      case "IWRL":
      case "IUTI":
      case "IINX":
      case "IINY":
      case "IINZ":
      case "IREF":
        if (length2 === 4)
          this.IFF.currentNode[blockID] = this.IFF.reader.getInt32();
        else
          this.IFF.reader.skip(length2);
        break;
      case "OTAG":
        this.IFF.parseObjectTag();
        break;
      case "LAYR":
        this.IFF.parseLayer(length2);
        break;
      case "PNTS":
        this.IFF.parsePoints(length2);
        break;
      case "VMAP":
        this.IFF.parseVertexMapping(length2);
        break;
      case "AUVU":
      case "AUVN":
        this.IFF.reader.skip(length2 - 1);
        this.IFF.reader.getVariableLengthIndex();
        break;
      case "POLS":
        this.IFF.parsePolygonList(length2);
        break;
      case "TAGS":
        this.IFF.parseTagStrings(length2);
        break;
      case "PTAG":
        this.IFF.parsePolygonTagMapping(length2);
        break;
      case "VMAD":
        this.IFF.parseVertexMapping(length2, true);
        break;
      case "DESC":
        this.IFF.currentForm.description = this.IFF.reader.getString();
        break;
      case "TEXT":
      case "CMNT":
      case "NCOM":
        this.IFF.currentForm.comment = this.IFF.reader.getString();
        break;
      case "NAME":
        this.IFF.currentForm.channelName = this.IFF.reader.getString();
        break;
      case "WRAP":
        this.IFF.currentForm.wrap = {
          w: this.IFF.reader.getUint16(),
          h: this.IFF.reader.getUint16()
        };
        break;
      case "IMAG":
        var index = this.IFF.reader.getVariableLengthIndex();
        this.IFF.currentForm.imageIndex = index;
        break;
      case "OREF":
        this.IFF.currentForm.referenceObject = this.IFF.reader.getString();
        break;
      case "ROID":
        this.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();
        break;
      case "SSHN":
        this.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();
        break;
      case "AOVN":
        this.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();
        break;
      case "NSTA":
        this.IFF.currentForm.disabled = this.IFF.reader.getUint16();
        break;
      case "NRNM":
        this.IFF.currentForm.realName = this.IFF.reader.getString();
        break;
      case "NNME":
        this.IFF.currentForm.refName = this.IFF.reader.getString();
        this.IFF.currentSurface.nodes[this.IFF.currentForm.refName] = this.IFF.currentForm;
        break;
      case "INME":
        if (!this.IFF.currentForm.nodeName)
          this.IFF.currentForm.nodeName = [];
        this.IFF.currentForm.nodeName.push(this.IFF.reader.getString());
        break;
      case "IINN":
        if (!this.IFF.currentForm.inputNodeName)
          this.IFF.currentForm.inputNodeName = [];
        this.IFF.currentForm.inputNodeName.push(this.IFF.reader.getString());
        break;
      case "IINM":
        if (!this.IFF.currentForm.inputName)
          this.IFF.currentForm.inputName = [];
        this.IFF.currentForm.inputName.push(this.IFF.reader.getString());
        break;
      case "IONM":
        if (!this.IFF.currentForm.inputOutputName)
          this.IFF.currentForm.inputOutputName = [];
        this.IFF.currentForm.inputOutputName.push(this.IFF.reader.getString());
        break;
      case "FNAM":
        this.IFF.currentForm.fileName = this.IFF.reader.getString();
        break;
      case "CHAN":
        if (length2 === 4)
          this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();
        else
          this.IFF.reader.skip(length2);
        break;
      case "SMAN":
        var maxSmoothingAngle = this.IFF.reader.getFloat32();
        this.IFF.currentSurface.attributes.smooth = maxSmoothingAngle < 0 ? false : true;
        break;
      case "COLR":
        this.IFF.currentSurface.attributes.Color = {
          value: this.IFF.reader.getFloat32Array(3)
        };
        this.IFF.reader.skip(2);
        break;
      case "LUMI":
        this.IFF.currentSurface.attributes.Luminosity = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "SPEC":
        this.IFF.currentSurface.attributes.Specular = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "DIFF":
        this.IFF.currentSurface.attributes.Diffuse = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "REFL":
        this.IFF.currentSurface.attributes.Reflection = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "GLOS":
        this.IFF.currentSurface.attributes.Glossiness = {
          value: this.IFF.reader.getFloat32()
        };
        this.IFF.reader.skip(2);
        break;
      case "TRAN":
        this.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "BUMP":
        this.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "SIDE":
        this.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();
        break;
      case "RIMG":
        this.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();
        break;
      case "RIND":
        this.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();
        this.IFF.reader.skip(2);
        break;
      case "TIMG":
        this.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();
        break;
      case "IMAP":
        this.IFF.reader.skip(2);
        break;
      case "TMAP":
        this.IFF.debugger.skipped = true;
        this.IFF.reader.skip(length2);
        break;
      case "IUVI":
        this.IFF.currentNode.UVChannel = this.IFF.reader.getString(length2);
        break;
      case "IUTL":
        this.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();
        break;
      case "IVTL":
        this.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();
        break;
      case "BLOK":
        break;
      default:
        this.IFF.parseUnknownCHUNK(blockID, length2);
    }
    if (blockID != "FORM") {
      this.IFF.debugger.node = 1;
      this.IFF.debugger.nodeID = blockID;
      this.IFF.debugger.log();
    }
    if (this.IFF.reader.offset >= this.IFF.currentFormEnd) {
      this.IFF.currentForm = this.IFF.parentForm;
    }
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/lwo/IFFParser.js
function IFFParser() {
  this.debugger = new Debugger();
}
IFFParser.prototype = {
  constructor: IFFParser,
  parse: function(buffer2) {
    this.reader = new DataViewReader(buffer2);
    this.tree = {
      materials: {},
      layers: [],
      tags: [],
      textures: []
    };
    this.currentLayer = this.tree;
    this.currentForm = this.tree;
    this.parseTopForm();
    if (this.tree.format === void 0)
      return;
    if (this.tree.format === "LWO2") {
      this.parser = new LWO2Parser(this);
      while (!this.reader.endOfFile())
        this.parser.parseBlock();
    } else if (this.tree.format === "LWO3") {
      this.parser = new LWO3Parser(this);
      while (!this.reader.endOfFile())
        this.parser.parseBlock();
    }
    this.debugger.offset = this.reader.offset;
    this.debugger.closeForms();
    return this.tree;
  },
  parseTopForm() {
    this.debugger.offset = this.reader.offset;
    var topForm = this.reader.getIDTag();
    if (topForm !== "FORM") {
      console.warn("LWOLoader: Top-level FORM missing.");
      return;
    }
    var length2 = this.reader.getUint32();
    this.debugger.dataOffset = this.reader.offset;
    this.debugger.length = length2;
    var type2 = this.reader.getIDTag();
    if (type2 === "LWO2") {
      this.tree.format = type2;
    } else if (type2 === "LWO3") {
      this.tree.format = type2;
    }
    this.debugger.node = 0;
    this.debugger.nodeID = type2;
    this.debugger.log();
    return;
  },
  ///
  // FORM PARSING METHODS
  ///
  // Forms are organisational and can contain any number of sub chunks and sub forms
  // FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }
  parseForm(length2) {
    var type2 = this.reader.getIDTag();
    switch (type2) {
      case "ISEQ":
      case "ANIM":
      case "STCC":
      case "VPVL":
      case "VPRM":
      case "NROT":
      case "WRPW":
      case "WRPH":
      case "FUNC":
      case "FALL":
      case "OPAC":
      case "GRAD":
      case "ENVS":
      case "VMOP":
      case "VMBG":
      case "OMAX":
      case "STEX":
      case "CKBG":
      case "CKEY":
      case "VMLA":
      case "VMLB":
        this.debugger.skipped = true;
        this.skipForm(length2);
        break;
      case "META":
      case "NNDS":
      case "NODS":
      case "NDTA":
      case "ADAT":
      case "AOVS":
      case "BLOK":
      case "IBGC":
      case "IOPC":
      case "IIMG":
      case "TXTR":
        this.debugger.length = 4;
        this.debugger.skipped = true;
        break;
      case "IFAL":
      case "ISCL":
      case "IPOS":
      case "IROT":
      case "IBMP":
      case "IUTD":
      case "IVTD":
        this.parseTextureNodeAttribute(type2);
        break;
      case "ENVL":
        this.parseEnvelope(length2);
        break;
      case "CLIP":
        if (this.tree.format === "LWO2") {
          this.parseForm(length2);
        } else {
          this.parseClip(length2);
        }
        break;
      case "STIL":
        this.parseImage();
        break;
      case "XREF":
        this.reader.skip(8);
        this.currentForm.referenceTexture = {
          index: this.reader.getUint32(),
          refName: this.reader.getString()
          // internal unique ref
        };
        break;
      case "IMST":
        this.parseImageStateForm(length2);
        break;
      case "SURF":
        this.parseSurfaceForm(length2);
        break;
      case "VALU":
        this.parseValueForm(length2);
        break;
      case "NTAG":
        this.parseSubNode(length2);
        break;
      case "ATTR":
      case "SATR":
        this.setupForm("attributes", length2);
        break;
      case "NCON":
        this.parseConnections(length2);
        break;
      case "SSHA":
        this.parentForm = this.currentForm;
        this.currentForm = this.currentSurface;
        this.setupForm("surfaceShader", length2);
        break;
      case "SSHD":
        this.setupForm("surfaceShaderData", length2);
        break;
      case "ENTR":
        this.parseEntryForm(length2);
        break;
      case "IMAP":
        this.parseImageMap(length2);
        break;
      case "TAMP":
        this.parseXVAL("amplitude", length2);
        break;
      case "TMAP":
        this.setupForm("textureMap", length2);
        break;
      case "CNTR":
        this.parseXVAL3("center", length2);
        break;
      case "SIZE":
        this.parseXVAL3("scale", length2);
        break;
      case "ROTA":
        this.parseXVAL3("rotation", length2);
        break;
      default:
        this.parseUnknownForm(type2, length2);
    }
    this.debugger.node = 0;
    this.debugger.nodeID = type2;
    this.debugger.log();
  },
  setupForm(type2, length2) {
    if (!this.currentForm)
      this.currentForm = this.currentNode;
    this.currentFormEnd = this.reader.offset + length2;
    this.parentForm = this.currentForm;
    if (!this.currentForm[type2]) {
      this.currentForm[type2] = {};
      this.currentForm = this.currentForm[type2];
    } else {
      console.warn("LWOLoader: form already exists on parent: ", type2, this.currentForm);
      this.currentForm = this.currentForm[type2];
    }
  },
  skipForm(length2) {
    this.reader.skip(length2 - 4);
  },
  parseUnknownForm(type2, length2) {
    console.warn("LWOLoader: unknown FORM encountered: " + type2, length2);
    printBuffer(this.reader.dv.buffer, this.reader.offset, length2 - 4);
    this.reader.skip(length2 - 4);
  },
  parseSurfaceForm(length2) {
    this.reader.skip(8);
    var name = this.reader.getString();
    var surface = {
      attributes: {},
      // LWO2 style non-node attributes will go here
      connections: {},
      name,
      inputName: name,
      nodes: {},
      source: this.reader.getString()
    };
    this.tree.materials[name] = surface;
    this.currentSurface = surface;
    this.parentForm = this.tree.materials;
    this.currentForm = surface;
    this.currentFormEnd = this.reader.offset + length2;
  },
  parseSurfaceLwo2(length2) {
    var name = this.reader.getString();
    var surface = {
      attributes: {},
      // LWO2 style non-node attributes will go here
      connections: {},
      name,
      nodes: {},
      source: this.reader.getString()
    };
    this.tree.materials[name] = surface;
    this.currentSurface = surface;
    this.parentForm = this.tree.materials;
    this.currentForm = surface;
    this.currentFormEnd = this.reader.offset + length2;
  },
  parseSubNode(length2) {
    this.reader.skip(8);
    var name = this.reader.getString();
    var node = {
      name
    };
    this.currentForm = node;
    this.currentNode = node;
    this.currentFormEnd = this.reader.offset + length2;
  },
  // collect attributes from all nodes at the top level of a surface
  parseConnections(length2) {
    this.currentFormEnd = this.reader.offset + length2;
    this.parentForm = this.currentForm;
    this.currentForm = this.currentSurface.connections;
  },
  // surface node attribute data, e.g. specular, roughness etc
  parseEntryForm(length2) {
    this.reader.skip(8);
    var name = this.reader.getString();
    this.currentForm = this.currentNode.attributes;
    this.setupForm(name, length2);
  },
  // parse values from material - doesn't match up to other LWO3 data types
  // sub form of entry form
  parseValueForm() {
    this.reader.skip(8);
    var valueType = this.reader.getString();
    if (valueType === "double") {
      this.currentForm.value = this.reader.getUint64();
    } else if (valueType === "int") {
      this.currentForm.value = this.reader.getUint32();
    } else if (valueType === "vparam") {
      this.reader.skip(24);
      this.currentForm.value = this.reader.getFloat64();
    } else if (valueType === "vparam3") {
      this.reader.skip(24);
      this.currentForm.value = this.reader.getFloat64Array(3);
    }
  },
  // holds various data about texture node image state
  // Data other thanmipMapLevel unknown
  parseImageStateForm() {
    this.reader.skip(8);
    this.currentForm.mipMapLevel = this.reader.getFloat32();
  },
  // LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)
  parseImageMap(length2) {
    this.currentFormEnd = this.reader.offset + length2;
    this.parentForm = this.currentForm;
    if (!this.currentForm.maps)
      this.currentForm.maps = [];
    var map = {};
    this.currentForm.maps.push(map);
    this.currentForm = map;
    this.reader.skip(10);
  },
  parseTextureNodeAttribute(type2) {
    this.reader.skip(28);
    this.reader.skip(20);
    switch (type2) {
      case "ISCL":
        this.currentNode.scale = this.reader.getFloat32Array(3);
        break;
      case "IPOS":
        this.currentNode.position = this.reader.getFloat32Array(3);
        break;
      case "IROT":
        this.currentNode.rotation = this.reader.getFloat32Array(3);
        break;
      case "IFAL":
        this.currentNode.falloff = this.reader.getFloat32Array(3);
        break;
      case "IBMP":
        this.currentNode.amplitude = this.reader.getFloat32();
        break;
      case "IUTD":
        this.currentNode.uTiles = this.reader.getFloat32();
        break;
      case "IVTD":
        this.currentNode.vTiles = this.reader.getFloat32();
        break;
    }
    this.reader.skip(2);
  },
  // ENVL forms are currently ignored
  parseEnvelope(length2) {
    this.reader.skip(length2 - 4);
  },
  ///
  // CHUNK PARSING METHODS
  ///
  // clips can either be defined inside a surface node, or at the top
  // level and they have a different format in each case
  parseClip(length2) {
    var tag = this.reader.getIDTag();
    if (tag === "FORM") {
      this.reader.skip(16);
      this.currentNode.fileName = this.reader.getString();
      return;
    }
    this.reader.setOffset(this.reader.offset - 4);
    this.currentFormEnd = this.reader.offset + length2;
    this.parentForm = this.currentForm;
    this.reader.skip(8);
    var texture2 = {
      index: this.reader.getUint32()
    };
    this.tree.textures.push(texture2);
    this.currentForm = texture2;
  },
  parseClipLwo2(length2) {
    var texture2 = {
      index: this.reader.getUint32(),
      fileName: ""
    };
    while (true) {
      var tag = this.reader.getIDTag();
      var n_length = this.reader.getUint16();
      if (tag === "STIL") {
        texture2.fileName = this.reader.getString();
        break;
      }
      if (n_length >= length2) {
        break;
      }
    }
    this.tree.textures.push(texture2);
    this.currentForm = texture2;
  },
  parseImage() {
    this.reader.skip(8);
    this.currentForm.fileName = this.reader.getString();
  },
  parseXVAL(type2, length2) {
    var endOffset = this.reader.offset + length2 - 4;
    this.reader.skip(8);
    this.currentForm[type2] = this.reader.getFloat32();
    this.reader.setOffset(endOffset);
  },
  parseXVAL3(type2, length2) {
    var endOffset = this.reader.offset + length2 - 4;
    this.reader.skip(8);
    this.currentForm[type2] = {
      x: this.reader.getFloat32(),
      y: this.reader.getFloat32(),
      z: this.reader.getFloat32()
    };
    this.reader.setOffset(endOffset);
  },
  // Tags associated with an object
  // OTAG { type[ID4], tag-string[S0] }
  parseObjectTag() {
    if (!this.tree.objectTags)
      this.tree.objectTags = {};
    this.tree.objectTags[this.reader.getIDTag()] = {
      tagString: this.reader.getString()
    };
  },
  // Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.
  // LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]
  parseLayer(length2) {
    var layer = {
      number: this.reader.getUint16(),
      flags: this.reader.getUint16(),
      // If the least significant bit of flags is set, the layer is hidden.
      pivot: this.reader.getFloat32Array(3),
      // Note: this seems to be superflous, as the geometry is translated when pivot is present
      name: this.reader.getString()
    };
    this.tree.layers.push(layer);
    this.currentLayer = layer;
    var parsedLength = 16 + stringOffset(this.currentLayer.name);
    this.currentLayer.parent = parsedLength < length2 ? this.reader.getUint16() : -1;
  },
  // VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors
  // Converting from left to right handed coordinate system:
  // x -> -x and switch material FrontSide -> BackSide
  parsePoints(length2) {
    this.currentPoints = [];
    for (let i2 = 0; i2 < length2 / 4; i2 += 3) {
      this.currentPoints.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());
    }
  },
  // parse VMAP or VMAD
  // Associates a set of floating-point vectors with a set of points.
  // VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }
  // VMAD Associates a set of floating-point vectors with the vertices of specific polygons.
  // Similar to VMAP UVs, but associates with polygon vertices rather than points
  // to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,
  // if they exist. The vector values in the VMAD will then replace those in the
  // corresponding VMAP, but only for calculations involving the specified polygons.
  // VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }
  parseVertexMapping(length2, discontinuous) {
    var finalOffset = this.reader.offset + length2;
    var channelName = this.reader.getString();
    if (this.reader.offset === finalOffset) {
      this.currentForm.UVChannel = channelName;
      return;
    }
    this.reader.setOffset(this.reader.offset - stringOffset(channelName));
    var type2 = this.reader.getIDTag();
    this.reader.getUint16();
    var name = this.reader.getString();
    var remainingLength = length2 - 6 - stringOffset(name);
    switch (type2) {
      case "TXUV":
        this.parseUVMapping(name, finalOffset, discontinuous);
        break;
      case "MORF":
      case "SPOT":
        this.parseMorphTargets(name, finalOffset, type2);
        break;
      case "APSL":
      case "NORM":
      case "WGHT":
      case "MNVW":
      case "PICK":
      case "RGB ":
      case "RGBA":
        this.reader.skip(remainingLength);
        break;
      default:
        console.warn("LWOLoader: unknown vertex map type: " + type2);
        this.reader.skip(remainingLength);
    }
  },
  parseUVMapping(name, finalOffset, discontinuous) {
    var uvIndices = [];
    var polyIndices = [];
    var uvs = [];
    while (this.reader.offset < finalOffset) {
      uvIndices.push(this.reader.getVariableLengthIndex());
      if (discontinuous)
        polyIndices.push(this.reader.getVariableLengthIndex());
      uvs.push(this.reader.getFloat32(), this.reader.getFloat32());
    }
    if (discontinuous) {
      if (!this.currentLayer.discontinuousUVs)
        this.currentLayer.discontinuousUVs = {};
      this.currentLayer.discontinuousUVs[name] = {
        uvIndices,
        polyIndices,
        uvs
      };
    } else {
      if (!this.currentLayer.uvs)
        this.currentLayer.uvs = {};
      this.currentLayer.uvs[name] = {
        uvIndices,
        uvs
      };
    }
  },
  parseMorphTargets(name, finalOffset, type2) {
    var indices = [];
    var points = [];
    type2 = type2 === "MORF" ? "relative" : "absolute";
    while (this.reader.offset < finalOffset) {
      indices.push(this.reader.getVariableLengthIndex());
      points.push(this.reader.getFloat32(), this.reader.getFloat32(), -this.reader.getFloat32());
    }
    if (!this.currentLayer.morphTargets)
      this.currentLayer.morphTargets = {};
    this.currentLayer.morphTargets[name] = {
      indices,
      points,
      type: type2
    };
  },
  // A list of polygons for the current layer.
  // POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }
  parsePolygonList(length2) {
    var finalOffset = this.reader.offset + length2;
    var type2 = this.reader.getIDTag();
    var indices = [];
    var polygonDimensions = [];
    while (this.reader.offset < finalOffset) {
      var numverts = this.reader.getUint16();
      numverts = numverts & 1023;
      polygonDimensions.push(numverts);
      for (let j2 = 0; j2 < numverts; j2++)
        indices.push(this.reader.getVariableLengthIndex());
    }
    var geometryData = {
      type: type2,
      vertexIndices: indices,
      polygonDimensions,
      points: this.currentPoints
    };
    if (polygonDimensions[0] === 1)
      geometryData.type = "points";
    else if (polygonDimensions[0] === 2)
      geometryData.type = "lines";
    this.currentLayer.geometry = geometryData;
  },
  // Lists the tag strings that can be associated with polygons by the PTAG chunk.
  // TAGS { tag-string[S0] * }
  parseTagStrings(length2) {
    this.tree.tags = this.reader.getStringArray(length2);
  },
  // Associates tags of a given type with polygons in the most recent POLS chunk.
  // PTAG { type[ID4], ( poly[VX], tag[U2] ) * }
  parsePolygonTagMapping(length2) {
    var finalOffset = this.reader.offset + length2;
    var type2 = this.reader.getIDTag();
    if (type2 === "SURF") {
      this.parseMaterialIndices(finalOffset);
    } else {
      this.reader.skip(length2 - 4);
    }
  },
  parseMaterialIndices(finalOffset) {
    this.currentLayer.geometry.materialIndices = [];
    while (this.reader.offset < finalOffset) {
      var polygonIndex = this.reader.getVariableLengthIndex();
      var materialIndex = this.reader.getUint16();
      this.currentLayer.geometry.materialIndices.push(polygonIndex, materialIndex);
    }
  },
  parseUnknownCHUNK(blockID, length2) {
    console.warn("LWOLoader: unknown chunk type: " + blockID + " length: " + length2);
    var data = this.reader.getString(length2);
    this.currentForm[blockID] = data;
  }
};
function DataViewReader(buffer2) {
  this.dv = new DataView(buffer2);
  this.offset = 0;
}
DataViewReader.prototype = {
  constructor: DataViewReader,
  size: function() {
    return this.dv.buffer.byteLength;
  },
  setOffset(offset) {
    if (offset > 0 && offset < this.dv.buffer.byteLength) {
      this.offset = offset;
    } else {
      console.error("LWOLoader: invalid buffer offset");
    }
  },
  endOfFile: function() {
    if (this.offset >= this.size())
      return true;
    return false;
  },
  skip: function(length2) {
    this.offset += length2;
  },
  getUint8: function() {
    var value = this.dv.getUint8(this.offset);
    this.offset += 1;
    return value;
  },
  getUint16: function() {
    var value = this.dv.getUint16(this.offset);
    this.offset += 2;
    return value;
  },
  getInt32: function() {
    var value = this.dv.getInt32(this.offset, false);
    this.offset += 4;
    return value;
  },
  getUint32: function() {
    var value = this.dv.getUint32(this.offset, false);
    this.offset += 4;
    return value;
  },
  getUint64: function() {
    var low, high;
    high = this.getUint32();
    low = this.getUint32();
    return high * 4294967296 + low;
  },
  getFloat32: function() {
    var value = this.dv.getFloat32(this.offset, false);
    this.offset += 4;
    return value;
  },
  getFloat32Array: function(size2) {
    var a2 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a2.push(this.getFloat32());
    }
    return a2;
  },
  getFloat64: function() {
    var value = this.dv.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  },
  getFloat64Array: function(size2) {
    var a2 = [];
    for (let i2 = 0; i2 < size2; i2++) {
      a2.push(this.getFloat64());
    }
    return a2;
  },
  // get variable-length index data type
  // VX ::= index[U2] | (index + 0xFF000000)[U4]
  // If the index value is less than 65,280 (0xFF00),then VX === U2
  // otherwise VX === U4 with bits 24-31 set
  // When reading an index, if the first byte encountered is 255 (0xFF), then
  // the four-byte form is being used and the first byte should be discarded or masked out.
  getVariableLengthIndex() {
    var firstByte = this.getUint8();
    if (firstByte === 255) {
      return this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();
    }
    return firstByte * 256 + this.getUint8();
  },
  // An ID tag is a sequence of 4 bytes containing 7-bit ASCII values
  getIDTag() {
    return this.getString(4);
  },
  getString: function(size2) {
    if (size2 === 0)
      return;
    var a2 = [];
    if (size2) {
      for (let i2 = 0; i2 < size2; i2++) {
        a2[i2] = this.getUint8();
      }
    } else {
      var currentChar;
      var len = 0;
      while (currentChar !== 0) {
        currentChar = this.getUint8();
        if (currentChar !== 0)
          a2.push(currentChar);
        len++;
      }
      if (!isEven(len + 1))
        this.getUint8();
    }
    return LoaderUtils.decodeText(new Uint8Array(a2));
  },
  getStringArray: function(size2) {
    var a2 = this.getString(size2);
    a2 = a2.split("\0");
    return a2.filter(Boolean);
  }
};
function Debugger() {
  this.active = false;
  this.depth = 0;
  this.formList = [];
}
Debugger.prototype = {
  constructor: Debugger,
  enable: function() {
    this.active = true;
  },
  log: function() {
    if (!this.active)
      return;
    var nodeType;
    switch (this.node) {
      case 0:
        nodeType = "FORM";
        break;
      case 1:
        nodeType = "CHK";
        break;
      case 2:
        nodeType = "S-CHK";
        break;
    }
    console.log("| ".repeat(this.depth) + nodeType, this.nodeID, `( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`, this.node == 0 ? " {" : "", this.skipped ? "SKIPPED" : "", this.node == 0 && this.skipped ? "}" : "");
    if (this.node == 0 && !this.skipped) {
      this.depth += 1;
      this.formList.push(this.dataOffset + this.length);
    }
    this.skipped = false;
  },
  closeForms: function() {
    if (!this.active)
      return;
    for (let i2 = this.formList.length - 1; i2 >= 0; i2--) {
      if (this.offset >= this.formList[i2]) {
        this.depth -= 1;
        console.log("| ".repeat(this.depth) + "}");
        this.formList.splice(-1, 1);
      }
    }
  }
};
function isEven(num) {
  return num % 2;
}
function stringOffset(string) {
  return string.length + 1 + (isEven(string.length + 1) ? 1 : 0);
}
function printBuffer(buffer2, from, to) {
  console.log(LoaderUtils.decodeText(new Uint8Array(buffer2, from, to)));
}

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/OBJLoader.js
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _ab = new Vector3();
var _cb = new Vector3();

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/KTXLoader.js
var HEADER_LEN = 12 + 13 * 4;

// node_modules/@react-three/rapier/node_modules/three-stdlib/loaders/RGBMLoader.js
var UPNG = {};
UPNG.toRGBA8 = function(out) {
  var w = out.width, h = out.height;
  if (out.tabs.acTL == null)
    return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];
  var frms = [];
  if (out.frames[0].data == null)
    out.frames[0].data = out.data;
  var len = w * h * 4, img = new Uint8Array(len), empty = new Uint8Array(len), prev = new Uint8Array(len);
  for (var i2 = 0; i2 < out.frames.length; i2++) {
    var frm = out.frames[i2];
    var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;
    var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);
    if (i2 != 0)
      for (var j2 = 0; j2 < len; j2++)
        prev[j2] = img[j2];
    if (frm.blend == 0)
      UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);
    else if (frm.blend == 1)
      UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);
    frms.push(img.buffer.slice(0));
    if (frm.dispose == 1)
      UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);
    else if (frm.dispose == 2)
      for (var j2 = 0; j2 < len; j2++)
        img[j2] = prev[j2];
  }
  return frms;
};
UPNG.toRGBA8.decodeImage = function(data, w, h, out) {
  var area = w * h, bpp = UPNG.decode._getBPP(out);
  var bpl = Math.ceil(w * bpp / 8);
  var bf = new Uint8Array(area * 4), bf32 = new Uint32Array(bf.buffer);
  var ctype = out.ctype, depth = out.depth;
  var rs = UPNG._bin.readUshort;
  if (ctype == 6) {
    var qarea = area << 2;
    if (depth == 8) {
      for (var i2 = 0; i2 < qarea; i2 += 4) {
        bf[i2] = data[i2];
        bf[i2 + 1] = data[i2 + 1];
        bf[i2 + 2] = data[i2 + 2];
        bf[i2 + 3] = data[i2 + 3];
      }
    }
    if (depth == 16) {
      for (var i2 = 0; i2 < qarea; i2++) {
        bf[i2] = data[i2 << 1];
      }
    }
  } else if (ctype == 2) {
    var ts = out.tabs["tRNS"];
    if (ts == null) {
      if (depth == 8) {
        for (var i2 = 0; i2 < area; i2++) {
          var ti = i2 * 3;
          bf32[i2] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
        }
      }
      if (depth == 16) {
        for (var i2 = 0; i2 < area; i2++) {
          var ti = i2 * 6;
          bf32[i2] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
        }
      }
    } else {
      var tr = ts[0], tg = ts[1], tb = ts[2];
      if (depth == 8) {
        for (var i2 = 0; i2 < area; i2++) {
          var qi = i2 << 2, ti = i2 * 3;
          bf32[i2] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];
          if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb)
            bf[qi + 3] = 0;
        }
      }
      if (depth == 16) {
        for (var i2 = 0; i2 < area; i2++) {
          var qi = i2 << 2, ti = i2 * 6;
          bf32[i2] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];
          if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb)
            bf[qi + 3] = 0;
        }
      }
    }
  } else if (ctype == 3) {
    var p = out.tabs["PLTE"], ap = out.tabs["tRNS"], tl = ap ? ap.length : 0;
    if (depth == 1) {
      for (var y = 0; y < h; y++) {
        var s0 = y * bpl, t0 = y * w;
        for (var i2 = 0; i2 < w; i2++) {
          var qi = t0 + i2 << 2, j2 = data[s0 + (i2 >> 3)] >> 7 - ((i2 & 7) << 0) & 1, cj = 3 * j2;
          bf[qi] = p[cj];
          bf[qi + 1] = p[cj + 1];
          bf[qi + 2] = p[cj + 2];
          bf[qi + 3] = j2 < tl ? ap[j2] : 255;
        }
      }
    }
    if (depth == 2) {
      for (var y = 0; y < h; y++) {
        var s0 = y * bpl, t0 = y * w;
        for (var i2 = 0; i2 < w; i2++) {
          var qi = t0 + i2 << 2, j2 = data[s0 + (i2 >> 2)] >> 6 - ((i2 & 3) << 1) & 3, cj = 3 * j2;
          bf[qi] = p[cj];
          bf[qi + 1] = p[cj + 1];
          bf[qi + 2] = p[cj + 2];
          bf[qi + 3] = j2 < tl ? ap[j2] : 255;
        }
      }
    }
    if (depth == 4) {
      for (var y = 0; y < h; y++) {
        var s0 = y * bpl, t0 = y * w;
        for (var i2 = 0; i2 < w; i2++) {
          var qi = t0 + i2 << 2, j2 = data[s0 + (i2 >> 1)] >> 4 - ((i2 & 1) << 2) & 15, cj = 3 * j2;
          bf[qi] = p[cj];
          bf[qi + 1] = p[cj + 1];
          bf[qi + 2] = p[cj + 2];
          bf[qi + 3] = j2 < tl ? ap[j2] : 255;
        }
      }
    }
    if (depth == 8) {
      for (var i2 = 0; i2 < area; i2++) {
        var qi = i2 << 2, j2 = data[i2], cj = 3 * j2;
        bf[qi] = p[cj];
        bf[qi + 1] = p[cj + 1];
        bf[qi + 2] = p[cj + 2];
        bf[qi + 3] = j2 < tl ? ap[j2] : 255;
      }
    }
  } else if (ctype == 4) {
    if (depth == 8) {
      for (var i2 = 0; i2 < area; i2++) {
        var qi = i2 << 2, di = i2 << 1, gr = data[di];
        bf[qi] = gr;
        bf[qi + 1] = gr;
        bf[qi + 2] = gr;
        bf[qi + 3] = data[di + 1];
      }
    }
    if (depth == 16) {
      for (var i2 = 0; i2 < area; i2++) {
        var qi = i2 << 2, di = i2 << 2, gr = data[di];
        bf[qi] = gr;
        bf[qi + 1] = gr;
        bf[qi + 2] = gr;
        bf[qi + 3] = data[di + 2];
      }
    }
  } else if (ctype == 0) {
    var tr = out.tabs["tRNS"] ? out.tabs["tRNS"] : -1;
    for (var y = 0; y < h; y++) {
      var off = y * bpl, to = y * w;
      if (depth == 1) {
        for (var x = 0; x < w; x++) {
          var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1), al = gr == tr * 255 ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      } else if (depth == 2) {
        for (var x = 0; x < w; x++) {
          var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      } else if (depth == 4) {
        for (var x = 0; x < w; x++) {
          var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      } else if (depth == 8) {
        for (var x = 0; x < w; x++) {
          var gr = data[off + x], al = gr == tr ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      } else if (depth == 16) {
        for (var x = 0; x < w; x++) {
          var gr = data[off + (x << 1)], al = rs(data, off + (x << 1)) == tr ? 0 : 255;
          bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;
        }
      }
    }
  }
  return bf;
};
UPNG.decode = function(buff) {
  var data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;
  var out = {
    tabs: {},
    frames: []
  };
  var dd = new Uint8Array(data.length), doff = 0;
  var fd, foff = 0;
  var text, keyw, bfr;
  var mgck = [137, 80, 78, 71, 13, 10, 26, 10];
  for (var i2 = 0; i2 < 8; i2++)
    if (data[i2] != mgck[i2])
      throw new Error("The input is not a PNG file!");
  while (offset < data.length) {
    var len = bin.readUint(data, offset);
    offset += 4;
    var type2 = bin.readASCII(data, offset, 4);
    offset += 4;
    if (type2 == "IHDR") {
      UPNG.decode._IHDR(data, offset, out);
    } else if (type2 == "CgBI") {
      out.tabs[type2] = data.slice(offset, offset + 4);
    } else if (type2 == "IDAT") {
      for (var i2 = 0; i2 < len; i2++)
        dd[doff + i2] = data[offset + i2];
      doff += len;
    } else if (type2 == "acTL") {
      out.tabs[type2] = {
        num_frames: rUi(data, offset),
        num_plays: rUi(data, offset + 4)
      };
      fd = new Uint8Array(data.length);
    } else if (type2 == "fcTL") {
      if (foff != 0) {
        var fr = out.frames[out.frames.length - 1];
        fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
        foff = 0;
      }
      var rct = {
        x: rUi(data, offset + 12),
        y: rUi(data, offset + 16),
        width: rUi(data, offset + 4),
        height: rUi(data, offset + 8)
      };
      var del = rUs(data, offset + 22);
      del = rUs(data, offset + 20) / (del == 0 ? 100 : del);
      var frm = {
        rect: rct,
        delay: Math.round(del * 1e3),
        dispose: data[offset + 24],
        blend: data[offset + 25]
      };
      out.frames.push(frm);
    } else if (type2 == "fdAT") {
      for (var i2 = 0; i2 < len - 4; i2++)
        fd[foff + i2] = data[offset + i2 + 4];
      foff += len - 4;
    } else if (type2 == "pHYs") {
      out.tabs[type2] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];
    } else if (type2 == "cHRM") {
      out.tabs[type2] = [];
      for (var i2 = 0; i2 < 8; i2++)
        out.tabs[type2].push(bin.readUint(data, offset + i2 * 4));
    } else if (type2 == "tEXt" || type2 == "zTXt") {
      if (out.tabs[type2] == null)
        out.tabs[type2] = {};
      var nz = bin.nextZero(data, offset);
      keyw = bin.readASCII(data, offset, nz - offset);
      var tl = offset + len - nz - 1;
      if (type2 == "tEXt") {
        text = bin.readASCII(data, nz + 1, tl);
      } else {
        bfr = UPNG.decode._inflate(data.slice(nz + 2, nz + 2 + tl));
        text = bin.readUTF8(bfr, 0, bfr.length);
      }
      out.tabs[type2][keyw] = text;
    } else if (type2 == "iTXt") {
      if (out.tabs[type2] == null)
        out.tabs[type2] = {};
      var nz = 0, off = offset;
      nz = bin.nextZero(data, off);
      keyw = bin.readASCII(data, off, nz - off);
      off = nz + 1;
      var cflag = data[off];
      off += 2;
      nz = bin.nextZero(data, off);
      bin.readASCII(data, off, nz - off);
      off = nz + 1;
      nz = bin.nextZero(data, off);
      bin.readUTF8(data, off, nz - off);
      off = nz + 1;
      var tl = len - (off - offset);
      if (cflag == 0) {
        text = bin.readUTF8(data, off, tl);
      } else {
        bfr = UPNG.decode._inflate(data.slice(off, off + tl));
        text = bin.readUTF8(bfr, 0, bfr.length);
      }
      out.tabs[type2][keyw] = text;
    } else if (type2 == "PLTE") {
      out.tabs[type2] = bin.readBytes(data, offset, len);
    } else if (type2 == "hIST") {
      var pl = out.tabs["PLTE"].length / 3;
      out.tabs[type2] = [];
      for (var i2 = 0; i2 < pl; i2++)
        out.tabs[type2].push(rUs(data, offset + i2 * 2));
    } else if (type2 == "tRNS") {
      if (out.ctype == 3)
        out.tabs[type2] = bin.readBytes(data, offset, len);
      else if (out.ctype == 0)
        out.tabs[type2] = rUs(data, offset);
      else if (out.ctype == 2)
        out.tabs[type2] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
    } else if (type2 == "gAMA") {
      out.tabs[type2] = bin.readUint(data, offset) / 1e5;
    } else if (type2 == "sRGB") {
      out.tabs[type2] = data[offset];
    } else if (type2 == "bKGD") {
      if (out.ctype == 0 || out.ctype == 4) {
        out.tabs[type2] = [rUs(data, offset)];
      } else if (out.ctype == 2 || out.ctype == 6) {
        out.tabs[type2] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];
      } else if (out.ctype == 3) {
        out.tabs[type2] = data[offset];
      }
    } else if (type2 == "IEND") {
      break;
    }
    offset += len;
    bin.readUint(data, offset);
    offset += 4;
  }
  if (foff != 0) {
    var fr = out.frames[out.frames.length - 1];
    fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);
  }
  out.data = UPNG.decode._decompress(out, dd, out.width, out.height);
  delete out.compress;
  delete out.interlace;
  delete out.filter;
  return out;
};
UPNG.decode._decompress = function(out, dd, w, h) {
  var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), buff = new Uint8Array((bpl + 1 + out.interlace) * h);
  if (out.tabs["CgBI"])
    dd = UPNG.inflateRaw(dd, buff);
  else
    dd = UPNG.decode._inflate(dd, buff);
  if (out.interlace == 0)
    dd = UPNG.decode._filterZero(dd, out, 0, w, h);
  else if (out.interlace == 1)
    dd = UPNG.decode._readInterlace(dd, out);
  return dd;
};
UPNG.decode._inflate = function(data, buff) {
  var out = UPNG["inflateRaw"](new Uint8Array(data.buffer, 2, data.length - 6), buff);
  return out;
};
UPNG.inflateRaw = function() {
  var H = {};
  H.H = {};
  H.H.N = function(N, W) {
    var R2 = Uint8Array, i2 = 0, m = 0, J = 0, h = 0, Q2 = 0, X = 0, u = 0, w = 0, d = 0, v, C;
    if (N[0] == 3 && N[1] == 0)
      return W ? W : new R2(0);
    var V = H.H, n = V.b, A = V.e, l = V.R, M = V.n, I = V.A, e = V.Z, b2 = V.m, Z = W == null;
    if (Z)
      W = new R2(N.length >>> 2 << 5);
    while (i2 == 0) {
      i2 = n(N, d, 1);
      m = n(N, d + 1, 2);
      d += 3;
      if (m == 0) {
        if ((d & 7) != 0)
          d += 8 - (d & 7);
        var D = (d >>> 3) + 4, q = N[D - 4] | N[D - 3] << 8;
        if (Z)
          W = H.H.W(W, w + q);
        W.set(new R2(N.buffer, N.byteOffset + D, q), w);
        d = D + q << 3;
        w += q;
        continue;
      }
      if (Z)
        W = H.H.W(W, w + (1 << 17));
      if (m == 1) {
        v = b2.J;
        C = b2.h;
        X = (1 << 9) - 1;
        u = (1 << 5) - 1;
      }
      if (m == 2) {
        J = A(N, d, 5) + 257;
        h = A(N, d + 5, 5) + 1;
        Q2 = A(N, d + 10, 4) + 4;
        d += 14;
        var j2 = 1;
        for (var c = 0; c < 38; c += 2) {
          b2.Q[c] = 0;
          b2.Q[c + 1] = 0;
        }
        for (var c = 0; c < Q2; c++) {
          var K = A(N, d + c * 3, 3);
          b2.Q[(b2.X[c] << 1) + 1] = K;
          if (K > j2)
            j2 = K;
        }
        d += 3 * Q2;
        M(b2.Q, j2);
        I(b2.Q, j2, b2.u);
        v = b2.w;
        C = b2.d;
        d = l(b2.u, (1 << j2) - 1, J + h, N, d, b2.v);
        var r = V.V(b2.v, 0, J, b2.C);
        X = (1 << r) - 1;
        var S = V.V(b2.v, J, h, b2.D);
        u = (1 << S) - 1;
        M(b2.C, r);
        I(b2.C, r, v);
        M(b2.D, S);
        I(b2.D, S, C);
      }
      while (true) {
        var T = v[e(N, d) & X];
        d += T & 15;
        var p = T >>> 4;
        if (p >>> 8 == 0) {
          W[w++] = p;
        } else if (p == 256) {
          break;
        } else {
          var z = w + p - 254;
          if (p > 264) {
            var _ = b2.q[p - 257];
            z = w + (_ >>> 3) + A(N, d, _ & 7);
            d += _ & 7;
          }
          var $ = C[e(N, d) & u];
          d += $ & 15;
          var s = $ >>> 4, Y = b2.c[s], a2 = (Y >>> 4) + n(N, d, Y & 15);
          d += Y & 15;
          while (w < z) {
            W[w] = W[w++ - a2];
            W[w] = W[w++ - a2];
            W[w] = W[w++ - a2];
            W[w] = W[w++ - a2];
          }
          w = z;
        }
      }
    }
    return W.length == w ? W : W.slice(0, w);
  };
  H.H.W = function(N, W) {
    var R2 = N.length;
    if (W <= R2)
      return N;
    var V = new Uint8Array(R2 << 1);
    V.set(N, 0);
    return V;
  };
  H.H.R = function(N, W, R2, V, n, A) {
    var l = H.H.e, M = H.H.Z, I = 0;
    while (I < R2) {
      var e = N[M(V, n) & W];
      n += e & 15;
      var b2 = e >>> 4;
      if (b2 <= 15) {
        A[I] = b2;
        I++;
      } else {
        var Z = 0, m = 0;
        if (b2 == 16) {
          m = 3 + l(V, n, 2);
          n += 2;
          Z = A[I - 1];
        } else if (b2 == 17) {
          m = 3 + l(V, n, 3);
          n += 3;
        } else if (b2 == 18) {
          m = 11 + l(V, n, 7);
          n += 7;
        }
        var J = I + m;
        while (I < J) {
          A[I] = Z;
          I++;
        }
      }
    }
    return n;
  };
  H.H.V = function(N, W, R2, V) {
    var n = 0, A = 0, l = V.length >>> 1;
    while (A < R2) {
      var M = N[A + W];
      V[A << 1] = 0;
      V[(A << 1) + 1] = M;
      if (M > n)
        n = M;
      A++;
    }
    while (A < l) {
      V[A << 1] = 0;
      V[(A << 1) + 1] = 0;
      A++;
    }
    return n;
  };
  H.H.n = function(N, W) {
    var R2 = H.H.m, V = N.length, n, A, l, M, I, e = R2.j;
    for (var M = 0; M <= W; M++)
      e[M] = 0;
    for (M = 1; M < V; M += 2)
      e[N[M]]++;
    var b2 = R2.K;
    n = 0;
    e[0] = 0;
    for (A = 1; A <= W; A++) {
      n = n + e[A - 1] << 1;
      b2[A] = n;
    }
    for (l = 0; l < V; l += 2) {
      I = N[l + 1];
      if (I != 0) {
        N[l] = b2[I];
        b2[I]++;
      }
    }
  };
  H.H.A = function(N, W, R2) {
    var V = N.length, n = H.H.m, A = n.r;
    for (var l = 0; l < V; l += 2) {
      if (N[l + 1] != 0) {
        var M = l >> 1, I = N[l + 1], e = M << 4 | I, b2 = W - I, Z = N[l] << b2, m = Z + (1 << b2);
        while (Z != m) {
          var J = A[Z] >>> 15 - W;
          R2[J] = e;
          Z++;
        }
      }
    }
  };
  H.H.l = function(N, W) {
    var R2 = H.H.m.r, V = 15 - W;
    for (var n = 0; n < N.length; n += 2) {
      var A = N[n] << W - N[n + 1];
      N[n] = R2[A] >>> V;
    }
  };
  H.H.M = function(N, W, R2) {
    R2 = R2 << (W & 7);
    var V = W >>> 3;
    N[V] |= R2;
    N[V + 1] |= R2 >>> 8;
  };
  H.H.I = function(N, W, R2) {
    R2 = R2 << (W & 7);
    var V = W >>> 3;
    N[V] |= R2;
    N[V + 1] |= R2 >>> 8;
    N[V + 2] |= R2 >>> 16;
  };
  H.H.e = function(N, W, R2) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R2) - 1;
  };
  H.H.b = function(N, W, R2) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R2) - 1;
  };
  H.H.Z = function(N, W) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);
  };
  H.H.i = function(N, W) {
    return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);
  };
  H.H.m = function() {
    var N = Uint16Array, W = Uint32Array;
    return {
      K: new N(16),
      j: new N(16),
      X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
      S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],
      T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],
      q: new N(32),
      p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],
      z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],
      c: new W(32),
      J: new N(512),
      _: [],
      h: new N(32),
      $: [],
      w: new N(32768),
      C: [],
      v: [],
      d: new N(32768),
      D: [],
      u: new N(512),
      Q: [],
      r: new N(1 << 15),
      s: new W(286),
      Y: new W(30),
      a: new W(19),
      t: new W(15e3),
      k: new N(1 << 16),
      g: new N(1 << 15)
    };
  }();
  (function() {
    var N = H.H.m, W = 1 << 15;
    for (var R2 = 0; R2 < W; R2++) {
      var V = R2;
      V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;
      V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;
      V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;
      V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;
      N.r[R2] = (V >>> 16 | V << 16) >>> 17;
    }
    function n(A, l, M) {
      while (l-- != 0)
        A.push(0, M);
    }
    for (var R2 = 0; R2 < 32; R2++) {
      N.q[R2] = N.S[R2] << 3 | N.T[R2];
      N.c[R2] = N.p[R2] << 4 | N.z[R2];
    }
    n(N._, 144, 8);
    n(N._, 255 - 143, 9);
    n(N._, 279 - 255, 7);
    n(N._, 287 - 279, 8);
    H.H.n(N._, 9);
    H.H.A(N._, 9, N.J);
    H.H.l(N._, 9);
    n(N.$, 32, 5);
    H.H.n(N.$, 5);
    H.H.A(N.$, 5, N.h);
    H.H.l(N.$, 5);
    n(N.Q, 19, 0);
    n(N.C, 286, 0);
    n(N.D, 30, 0);
    n(N.v, 320, 0);
  })();
  return H.H.N;
}();
UPNG.decode._readInterlace = function(data, out) {
  var w = out.width, h = out.height;
  var bpp = UPNG.decode._getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w * bpp / 8);
  var img = new Uint8Array(h * bpl);
  var di = 0;
  var starting_row = [0, 0, 4, 0, 2, 0, 1];
  var starting_col = [0, 4, 0, 2, 0, 1, 0];
  var row_increment = [8, 8, 8, 4, 4, 2, 2];
  var col_increment = [8, 8, 4, 4, 2, 2, 1];
  var pass = 0;
  while (pass < 7) {
    var ri = row_increment[pass], ci = col_increment[pass];
    var sw = 0, sh = 0;
    var cr = starting_row[pass];
    while (cr < h) {
      cr += ri;
      sh++;
    }
    var cc = starting_col[pass];
    while (cc < w) {
      cc += ci;
      sw++;
    }
    var bpll = Math.ceil(sw * bpp / 8);
    UPNG.decode._filterZero(data, out, di, sw, sh);
    var y = 0, row = starting_row[pass];
    var val;
    while (row < h) {
      var col = starting_col[pass];
      var cdi = di + y * bpll << 3;
      while (col < w) {
        if (bpp == 1) {
          val = data[cdi >> 3];
          val = val >> 7 - (cdi & 7) & 1;
          img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);
        }
        if (bpp == 2) {
          val = data[cdi >> 3];
          val = val >> 6 - (cdi & 7) & 3;
          img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);
        }
        if (bpp == 4) {
          val = data[cdi >> 3];
          val = val >> 4 - (cdi & 7) & 15;
          img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);
        }
        if (bpp >= 8) {
          var ii = row * bpl + col * cbpp;
          for (var j2 = 0; j2 < cbpp; j2++)
            img[ii + j2] = data[(cdi >> 3) + j2];
        }
        cdi += bpp;
        col += ci;
      }
      y++;
      row += ri;
    }
    if (sw * sh != 0)
      di += sh * (1 + bpll);
    pass = pass + 1;
  }
  return img;
};
UPNG.decode._getBPP = function(out) {
  var noc = [1, null, 3, 1, 2, null, 4][out.ctype];
  return noc * out.depth;
};
UPNG.decode._filterZero = function(data, out, off, w, h) {
  var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), paeth = UPNG.decode._paeth;
  bpp = Math.ceil(bpp / 8);
  var i2, di, type2 = data[off], x = 0;
  if (type2 > 1)
    data[off] = [0, 0, 1][type2 - 2];
  if (type2 == 3)
    for (x = bpp; x < bpl; x++)
      data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;
  for (var y = 0; y < h; y++) {
    i2 = off + y * bpl;
    di = i2 + y + 1;
    type2 = data[di - 1];
    x = 0;
    if (type2 == 0) {
      for (; x < bpl; x++)
        data[i2 + x] = data[di + x];
    } else if (type2 == 1) {
      for (; x < bpp; x++)
        data[i2 + x] = data[di + x];
      for (; x < bpl; x++)
        data[i2 + x] = data[di + x] + data[i2 + x - bpp];
    } else if (type2 == 2) {
      for (; x < bpl; x++)
        data[i2 + x] = data[di + x] + data[i2 + x - bpl];
    } else if (type2 == 3) {
      for (; x < bpp; x++)
        data[i2 + x] = data[di + x] + (data[i2 + x - bpl] >>> 1);
      for (; x < bpl; x++)
        data[i2 + x] = data[di + x] + (data[i2 + x - bpl] + data[i2 + x - bpp] >>> 1);
    } else {
      for (; x < bpp; x++)
        data[i2 + x] = data[di + x] + paeth(0, data[i2 + x - bpl], 0);
      for (; x < bpl; x++) {
        data[i2 + x] = data[di + x] + paeth(data[i2 + x - bpp], data[i2 + x - bpl], data[i2 + x - bpp - bpl]);
      }
    }
  }
  return data;
};
UPNG.decode._paeth = function(a2, b2, c) {
  var p = a2 + b2 - c, pa = p - a2, pb = p - b2, pc = p - c;
  if (pa * pa <= pb * pb && pa * pa <= pc * pc)
    return a2;
  else if (pb * pb <= pc * pc)
    return b2;
  return c;
};
UPNG.decode._IHDR = function(data, offset, out) {
  var bin = UPNG._bin;
  out.width = bin.readUint(data, offset);
  offset += 4;
  out.height = bin.readUint(data, offset);
  offset += 4;
  out.depth = data[offset];
  offset++;
  out.ctype = data[offset];
  offset++;
  out.compress = data[offset];
  offset++;
  out.filter = data[offset];
  offset++;
  out.interlace = data[offset];
  offset++;
};
UPNG._bin = {
  nextZero: function(data, p) {
    while (data[p] != 0)
      p++;
    return p;
  },
  readUshort: function(buff, p) {
    return buff[p] << 8 | buff[p + 1];
  },
  writeUshort: function(buff, p, n) {
    buff[p] = n >> 8 & 255;
    buff[p + 1] = n & 255;
  },
  readUint: function(buff, p) {
    return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);
  },
  writeUint: function(buff, p, n) {
    buff[p] = n >> 24 & 255;
    buff[p + 1] = n >> 16 & 255;
    buff[p + 2] = n >> 8 & 255;
    buff[p + 3] = n & 255;
  },
  readASCII: function(buff, p, l) {
    var s = "";
    for (var i2 = 0; i2 < l; i2++)
      s += String.fromCharCode(buff[p + i2]);
    return s;
  },
  writeASCII: function(data, p, s) {
    for (var i2 = 0; i2 < s.length; i2++)
      data[p + i2] = s.charCodeAt(i2);
  },
  readBytes: function(buff, p, l) {
    var arr = [];
    for (var i2 = 0; i2 < l; i2++)
      arr.push(buff[p + i2]);
    return arr;
  },
  pad: function(n) {
    return n.length < 2 ? "0" + n : n;
  },
  readUTF8: function(buff, p, l) {
    var s = "", ns;
    for (var i2 = 0; i2 < l; i2++)
      s += "%" + UPNG._bin.pad(buff[p + i2].toString(16));
    try {
      ns = decodeURIComponent(s);
    } catch (e) {
      return UPNG._bin.readASCII(buff, p, l);
    }
    return ns;
  }
};
UPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {
  var w = Math.min(sw, tw), h = Math.min(sh, th);
  var si = 0, ti = 0;
  for (var y = 0; y < h; y++) {
    for (var x = 0; x < w; x++) {
      if (xoff >= 0 && yoff >= 0) {
        si = y * sw + x << 2;
        ti = (yoff + y) * tw + xoff + x << 2;
      } else {
        si = (-yoff + y) * sw - xoff + x << 2;
        ti = y * tw + x << 2;
      }
      if (mode == 0) {
        tb[ti] = sb[si];
        tb[ti + 1] = sb[si + 1];
        tb[ti + 2] = sb[si + 2];
        tb[ti + 3] = sb[si + 3];
      } else if (mode == 1) {
        var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;
        var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;
        var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;
        tb[ti + 3] = 255 * oa;
        tb[ti + 0] = (fr + br * ifa) * ioa;
        tb[ti + 1] = (fg + bg * ifa) * ioa;
        tb[ti + 2] = (fb + bb * ifa) * ioa;
      } else if (mode == 2) {
        var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
        var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
        if (fa == ba && fr == br && fg == bg && fb == bb) {
          tb[ti] = 0;
          tb[ti + 1] = 0;
          tb[ti + 2] = 0;
          tb[ti + 3] = 0;
        } else {
          tb[ti] = fr;
          tb[ti + 1] = fg;
          tb[ti + 2] = fb;
          tb[ti + 3] = fa;
        }
      } else if (mode == 3) {
        var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];
        var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];
        if (fa == ba && fr == br && fg == bg && fb == bb)
          continue;
        if (fa < 220 && ba > 20)
          return false;
      }
    }
  }
  return true;
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/lines/LineSegmentsGeometry.js
var _box = new Box3();
var _vector4 = new Vector3();

// node_modules/@react-three/rapier/node_modules/three-stdlib/lines/LineMaterial.js
UniformsLib.line = {
  worldUnits: {
    value: 1
  },
  linewidth: {
    value: 1
  },
  resolution: {
    value: new Vector2(1, 1)
  },
  dashOffset: {
    value: 0
  },
  dashScale: {
    value: 1
  },
  dashSize: {
    value: 1
  },
  gapSize: {
    value: 1
  }
  // todo FIX - maybe change to totalSize
};
ShaderLib["line"] = {
  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, UniformsLib.line]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/lines/Wireframe.js
var _start = new Vector3();
var _end = new Vector3();

// node_modules/@react-three/rapier/node_modules/three-stdlib/lines/LineSegments2.js
var _start2 = new Vector3();
var _end2 = new Vector3();
var _start4 = new Vector4();
var _end4 = new Vector4();
var _ssOrigin = new Vector4();
var _ssOrigin3 = new Vector3();
var _mvMatrix = new Matrix4();
var _line = new Line3();
var _closestPoint2 = new Vector3();
var _box2 = new Box3();
var _sphere = new Sphere();
var _clipToWorldVector = new Vector4();

// node_modules/@react-three/rapier/node_modules/three-stdlib/helpers/VertexTangentsHelper.js
var _v12 = new Vector3();
var _v2 = new Vector3();

// node_modules/@react-three/rapier/node_modules/three-stdlib/helpers/VertexNormalsHelper.js
var _v13 = new Vector3();
var _v22 = new Vector3();
var _normalMatrix = new Matrix3();

// node_modules/@react-three/rapier/node_modules/three-stdlib/deprecated/Geometry.js
var _m1 = new Matrix4();
var _obj = new Object3D();
var _offset = new Vector3();
var Geometry = class extends EventDispatcher {
  constructor() {
    super();
    this.isGeometry = true;
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
  }
  applyMatrix4(matrix3) {
    const normalMatrix = new Matrix3().getNormalMatrix(matrix3);
    for (let i2 = 0, il = this.vertices.length; i2 < il; i2++) {
      const vertex = this.vertices[i2];
      vertex.applyMatrix4(matrix3);
    }
    for (let i2 = 0, il = this.faces.length; i2 < il; i2++) {
      const face = this.faces[i2];
      face.normal.applyMatrix3(normalMatrix).normalize();
      for (let j2 = 0, jl2 = face.vertexNormals.length; j2 < jl2; j2++) {
        face.vertexNormals[j2].applyMatrix3(normalMatrix).normalize();
      }
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;
    return this;
  }
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x, y, z) {
    _m1.makeTranslation(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x, y, z) {
    _m1.makeScale(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector2) {
    _obj.lookAt(vector2);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  fromBufferGeometry(geometry) {
    const scope = this;
    const index = geometry.index !== null ? geometry.index : void 0;
    const attributes = geometry.attributes;
    if (attributes.position === void 0) {
      console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.");
      return this;
    }
    const position = attributes.position;
    const normal = attributes.normal;
    const color2 = attributes.color;
    const uv2 = attributes.uv;
    const uv22 = attributes.uv2;
    if (uv22 !== void 0)
      this.faceVertexUvs[1] = [];
    for (let i2 = 0; i2 < position.count; i2++) {
      scope.vertices.push(new Vector3().fromBufferAttribute(position, i2));
      if (color2 !== void 0) {
        scope.colors.push(new Color().fromBufferAttribute(color2, i2));
      }
    }
    function addFace(a2, b2, c, materialIndex) {
      const vertexColors = color2 === void 0 ? [] : [scope.colors[a2].clone(), scope.colors[b2].clone(), scope.colors[c].clone()];
      const vertexNormals = normal === void 0 ? [] : [new Vector3().fromBufferAttribute(normal, a2), new Vector3().fromBufferAttribute(normal, b2), new Vector3().fromBufferAttribute(normal, c)];
      const face = new Face3(a2, b2, c, vertexNormals, vertexColors, materialIndex);
      scope.faces.push(face);
      if (uv2 !== void 0) {
        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv2, a2), new Vector2().fromBufferAttribute(uv2, b2), new Vector2().fromBufferAttribute(uv2, c)]);
      }
      if (uv22 !== void 0) {
        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv22, a2), new Vector2().fromBufferAttribute(uv22, b2), new Vector2().fromBufferAttribute(uv22, c)]);
      }
    }
    const groups = geometry.groups;
    if (groups.length > 0) {
      for (let i2 = 0; i2 < groups.length; i2++) {
        const group = groups[i2];
        const start = group.start;
        const count = group.count;
        for (let j2 = start, jl2 = start + count; j2 < jl2; j2 += 3) {
          if (index !== void 0) {
            addFace(index.getX(j2), index.getX(j2 + 1), index.getX(j2 + 2), group.materialIndex);
          } else {
            addFace(j2, j2 + 1, j2 + 2, group.materialIndex);
          }
        }
      }
    } else {
      if (index !== void 0) {
        for (let i2 = 0; i2 < index.count; i2 += 3) {
          addFace(index.getX(i2), index.getX(i2 + 1), index.getX(i2 + 2));
        }
      } else {
        for (let i2 = 0; i2 < position.count; i2 += 3) {
          addFace(i2, i2 + 1, i2 + 2);
        }
      }
    }
    this.computeFaceNormals();
    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }
    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  normalize() {
    this.computeBoundingSphere();
    const center = this.boundingSphere.center;
    const radius = this.boundingSphere.radius;
    const s = radius === 0 ? 1 : 1 / radius;
    const matrix3 = new Matrix4();
    matrix3.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
    this.applyMatrix4(matrix3);
    return this;
  }
  computeFaceNormals() {
    const cb2 = new Vector3(), ab2 = new Vector3();
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      const vA = this.vertices[face.a];
      const vB = this.vertices[face.b];
      const vC = this.vertices[face.c];
      cb2.subVectors(vC, vB);
      ab2.subVectors(vA, vB);
      cb2.cross(ab2);
      cb2.normalize();
      face.normal.copy(cb2);
    }
  }
  computeVertexNormals(areaWeighted = true) {
    const vertices = new Array(this.vertices.length);
    for (let v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v] = new Vector3();
    }
    if (areaWeighted) {
      const cb2 = new Vector3(), ab2 = new Vector3();
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const vA = this.vertices[face.a];
        const vB = this.vertices[face.b];
        const vC = this.vertices[face.c];
        cb2.subVectors(vC, vB);
        ab2.subVectors(vA, vB);
        cb2.cross(ab2);
        vertices[face.a].add(cb2);
        vertices[face.b].add(cb2);
        vertices[face.c].add(cb2);
      }
    } else {
      this.computeFaceNormals();
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }
    for (let v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v].normalize();
    }
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      const vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(vertices[face.a]);
        vertexNormals[1].copy(vertices[face.b]);
        vertexNormals[2].copy(vertices[face.c]);
      } else {
        vertexNormals[0] = vertices[face.a].clone();
        vertexNormals[1] = vertices[face.b].clone();
        vertexNormals[2] = vertices[face.c].clone();
      }
    }
    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  }
  computeFlatVertexNormals() {
    this.computeFaceNormals();
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      const vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(face.normal);
        vertexNormals[1].copy(face.normal);
        vertexNormals[2].copy(face.normal);
      } else {
        vertexNormals[0] = face.normal.clone();
        vertexNormals[1] = face.normal.clone();
        vertexNormals[2] = face.normal.clone();
      }
    }
    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  }
  computeMorphNormals() {
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }
      if (!face.__originalVertexNormals)
        face.__originalVertexNormals = [];
      for (let i2 = 0, il = face.vertexNormals.length; i2 < il; i2++) {
        if (!face.__originalVertexNormals[i2]) {
          face.__originalVertexNormals[i2] = face.vertexNormals[i2].clone();
        } else {
          face.__originalVertexNormals[i2].copy(face.vertexNormals[i2]);
        }
      }
    }
    const tmpGeo = new Geometry();
    tmpGeo.faces = this.faces;
    for (let i2 = 0, il = this.morphTargets.length; i2 < il; i2++) {
      if (!this.morphNormals[i2]) {
        this.morphNormals[i2] = {};
        this.morphNormals[i2].faceNormals = [];
        this.morphNormals[i2].vertexNormals = [];
        const dstNormalsFace = this.morphNormals[i2].faceNormals;
        const dstNormalsVertex = this.morphNormals[i2].vertexNormals;
        for (let f = 0, fl = this.faces.length; f < fl; f++) {
          const faceNormal = new Vector3();
          const vertexNormals = {
            a: new Vector3(),
            b: new Vector3(),
            c: new Vector3()
          };
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }
      const morphNormals = this.morphNormals[i2];
      tmpGeo.vertices = this.morphTargets[i2].vertices;
      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();
      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const faceNormal = morphNormals.faceNormals[f];
        const vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    }
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    this.boundingBox.setFromPoints(this.vertices);
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    this.boundingSphere.setFromPoints(this.vertices);
  }
  merge(geometry, matrix3, materialIndexOffset = 0) {
    if (!(geometry && geometry.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
      return;
    }
    let normalMatrix;
    const vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;
    if (matrix3 !== void 0) {
      normalMatrix = new Matrix3().getNormalMatrix(matrix3);
    }
    for (let i2 = 0, il = vertices2.length; i2 < il; i2++) {
      const vertex = vertices2[i2];
      const vertexCopy = vertex.clone();
      if (matrix3 !== void 0)
        vertexCopy.applyMatrix4(matrix3);
      vertices1.push(vertexCopy);
    }
    for (let i2 = 0, il = colors2.length; i2 < il; i2++) {
      colors1.push(colors2[i2].clone());
    }
    for (let i2 = 0, il = faces2.length; i2 < il; i2++) {
      const face = faces2[i2];
      let normal, color2;
      const faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);
      if (normalMatrix !== void 0) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
      }
      for (let j2 = 0, jl2 = faceVertexNormals.length; j2 < jl2; j2++) {
        normal = faceVertexNormals[j2].clone();
        if (normalMatrix !== void 0) {
          normal.applyMatrix3(normalMatrix).normalize();
        }
        faceCopy.vertexNormals.push(normal);
      }
      faceCopy.color.copy(face.color);
      for (let j2 = 0, jl2 = faceVertexColors.length; j2 < jl2; j2++) {
        color2 = faceVertexColors[j2];
        faceCopy.vertexColors.push(color2.clone());
      }
      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faces1.push(faceCopy);
    }
    for (let i2 = 0, il = geometry.faceVertexUvs.length; i2 < il; i2++) {
      const faceVertexUvs2 = geometry.faceVertexUvs[i2];
      if (this.faceVertexUvs[i2] === void 0)
        this.faceVertexUvs[i2] = [];
      for (let j2 = 0, jl2 = faceVertexUvs2.length; j2 < jl2; j2++) {
        const uvs2 = faceVertexUvs2[j2], uvsCopy = [];
        for (let k = 0, kl = uvs2.length; k < kl; k++) {
          uvsCopy.push(uvs2[k].clone());
        }
        this.faceVertexUvs[i2].push(uvsCopy);
      }
    }
  }
  mergeMesh(mesh) {
    if (!(mesh && mesh.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
      return;
    }
    if (mesh.matrixAutoUpdate)
      mesh.updateMatrix();
    this.merge(mesh.geometry, mesh.matrix);
  }
  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */
  mergeVertices(precisionPoints = 4) {
    const verticesMap = {};
    const unique = [], changes = [];
    const precision = Math.pow(10, precisionPoints);
    for (let i2 = 0, il = this.vertices.length; i2 < il; i2++) {
      const v = this.vertices[i2];
      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;
      if (verticesMap[key] === void 0) {
        verticesMap[key] = i2;
        unique.push(this.vertices[i2]);
        changes[i2] = unique.length - 1;
      } else {
        changes[i2] = changes[verticesMap[key]];
      }
    }
    const faceIndicesToRemove = [];
    for (let i2 = 0, il = this.faces.length; i2 < il; i2++) {
      const face = this.faces[i2];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      const indices = [face.a, face.b, face.c];
      for (let n = 0; n < 3; n++) {
        if (indices[n] === indices[(n + 1) % 3]) {
          faceIndicesToRemove.push(i2);
          break;
        }
      }
    }
    for (let i2 = faceIndicesToRemove.length - 1; i2 >= 0; i2--) {
      const idx = faceIndicesToRemove[i2];
      this.faces.splice(idx, 1);
      for (let j2 = 0, jl2 = this.faceVertexUvs.length; j2 < jl2; j2++) {
        this.faceVertexUvs[j2].splice(idx, 1);
      }
    }
    const diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;
  }
  setFromPoints(points) {
    this.vertices = [];
    for (let i2 = 0, l = points.length; i2 < l; i2++) {
      const point = points[i2];
      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }
    return this;
  }
  sortFacesByMaterialIndex() {
    const faces = this.faces;
    const length2 = faces.length;
    for (let i2 = 0; i2 < length2; i2++) {
      faces[i2]._id = i2;
    }
    function materialIndexSort(a2, b2) {
      return a2.materialIndex - b2.materialIndex;
    }
    faces.sort(materialIndexSort);
    const uvs1 = this.faceVertexUvs[0];
    const uvs2 = this.faceVertexUvs[1];
    let newUvs1, newUvs2;
    if (uvs1 && uvs1.length === length2)
      newUvs1 = [];
    if (uvs2 && uvs2.length === length2)
      newUvs2 = [];
    for (let i2 = 0; i2 < length2; i2++) {
      const id = faces[i2]._id;
      if (newUvs1)
        newUvs1.push(uvs1[id]);
      if (newUvs2)
        newUvs2.push(uvs2[id]);
    }
    if (newUvs1)
      this.faceVertexUvs[0] = newUvs1;
    if (newUvs2)
      this.faceVertexUvs[1] = newUvs2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (let key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    const vertices = [];
    for (let i2 = 0; i2 < this.vertices.length; i2++) {
      const vertex = this.vertices[i2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
    const faces = [];
    const normals = [];
    const normalsHash = {};
    const colors = [];
    const colorsHash = {};
    const uvs = [];
    const uvsHash = {};
    for (let i2 = 0; i2 < this.faces.length; i2++) {
      const face = this.faces[i2];
      const hasMaterial = true;
      const hasFaceUv = false;
      const hasFaceVertexUv = this.faceVertexUvs[0][i2] !== void 0;
      const hasFaceNormal = face.normal.length() > 0;
      const hasFaceVertexNormal = face.vertexNormals.length > 0;
      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      const hasFaceVertexColor = face.vertexColors.length > 0;
      let faceType = 0;
      faceType = setBit(faceType, 0, 0);
      faceType = setBit(faceType, 1, hasMaterial);
      faceType = setBit(faceType, 2, hasFaceUv);
      faceType = setBit(faceType, 3, hasFaceVertexUv);
      faceType = setBit(faceType, 4, hasFaceNormal);
      faceType = setBit(faceType, 5, hasFaceVertexNormal);
      faceType = setBit(faceType, 6, hasFaceColor);
      faceType = setBit(faceType, 7, hasFaceVertexColor);
      faces.push(faceType);
      faces.push(face.a, face.b, face.c);
      faces.push(face.materialIndex);
      if (hasFaceVertexUv) {
        const faceVertexUvs = this.faceVertexUvs[0][i2];
        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
      }
      if (hasFaceNormal) {
        faces.push(getNormalIndex(face.normal));
      }
      if (hasFaceVertexNormal) {
        const vertexNormals = face.vertexNormals;
        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
      }
      if (hasFaceColor) {
        faces.push(getColorIndex(face.color));
      }
      if (hasFaceVertexColor) {
        const vertexColors = face.vertexColors;
        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
      }
    }
    function setBit(value, position, enabled) {
      return enabled ? value | 1 << position : value & ~(1 << position);
    }
    function getNormalIndex(normal) {
      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
      if (normalsHash[hash] !== void 0) {
        return normalsHash[hash];
      }
      normalsHash[hash] = normals.length / 3;
      normals.push(normal.x, normal.y, normal.z);
      return normalsHash[hash];
    }
    function getColorIndex(color2) {
      const hash = color2.r.toString() + color2.g.toString() + color2.b.toString();
      if (colorsHash[hash] !== void 0) {
        return colorsHash[hash];
      }
      colorsHash[hash] = colors.length;
      colors.push(color2.getHex());
      return colorsHash[hash];
    }
    function getUvIndex(uv2) {
      const hash = uv2.x.toString() + uv2.y.toString();
      if (uvsHash[hash] !== void 0) {
        return uvsHash[hash];
      }
      uvsHash[hash] = uvs.length / 2;
      uvs.push(uv2.x, uv2.y);
      return uvsHash[hash];
    }
    data.data = {};
    data.data.vertices = vertices;
    data.data.normals = normals;
    if (colors.length > 0)
      data.data.colors = colors;
    if (uvs.length > 0)
      data.data.uvs = [uvs];
    data.data.faces = faces;
    return data;
  }
  clone() {
    return new Geometry().copy(this);
  }
  copy(source) {
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.name = source.name;
    const vertices = source.vertices;
    for (let i2 = 0, il = vertices.length; i2 < il; i2++) {
      this.vertices.push(vertices[i2].clone());
    }
    const colors = source.colors;
    for (let i2 = 0, il = colors.length; i2 < il; i2++) {
      this.colors.push(colors[i2].clone());
    }
    const faces = source.faces;
    for (let i2 = 0, il = faces.length; i2 < il; i2++) {
      this.faces.push(faces[i2].clone());
    }
    for (let i2 = 0, il = source.faceVertexUvs.length; i2 < il; i2++) {
      const faceVertexUvs = source.faceVertexUvs[i2];
      if (this.faceVertexUvs[i2] === void 0) {
        this.faceVertexUvs[i2] = [];
      }
      for (let j2 = 0, jl2 = faceVertexUvs.length; j2 < jl2; j2++) {
        const uvs = faceVertexUvs[j2], uvsCopy = [];
        for (let k = 0, kl = uvs.length; k < kl; k++) {
          const uv2 = uvs[k];
          uvsCopy.push(uv2.clone());
        }
        this.faceVertexUvs[i2].push(uvsCopy);
      }
    }
    const morphTargets = source.morphTargets;
    for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
      const morphTarget = {};
      morphTarget.name = morphTargets[i2].name;
      if (morphTargets[i2].vertices !== void 0) {
        morphTarget.vertices = [];
        for (let j2 = 0, jl2 = morphTargets[i2].vertices.length; j2 < jl2; j2++) {
          morphTarget.vertices.push(morphTargets[i2].vertices[j2].clone());
        }
      }
      if (morphTargets[i2].normals !== void 0) {
        morphTarget.normals = [];
        for (let j2 = 0, jl2 = morphTargets[i2].normals.length; j2 < jl2; j2++) {
          morphTarget.normals.push(morphTargets[i2].normals[j2].clone());
        }
      }
      this.morphTargets.push(morphTarget);
    }
    const morphNormals = source.morphNormals;
    for (let i2 = 0, il = morphNormals.length; i2 < il; i2++) {
      const morphNormal = {};
      if (morphNormals[i2].vertexNormals !== void 0) {
        morphNormal.vertexNormals = [];
        for (let j2 = 0, jl2 = morphNormals[i2].vertexNormals.length; j2 < jl2; j2++) {
          const srcVertexNormal = morphNormals[i2].vertexNormals[j2];
          const destVertexNormal = {};
          destVertexNormal.a = srcVertexNormal.a.clone();
          destVertexNormal.b = srcVertexNormal.b.clone();
          destVertexNormal.c = srcVertexNormal.c.clone();
          morphNormal.vertexNormals.push(destVertexNormal);
        }
      }
      if (morphNormals[i2].faceNormals !== void 0) {
        morphNormal.faceNormals = [];
        for (let j2 = 0, jl2 = morphNormals[i2].faceNormals.length; j2 < jl2; j2++) {
          morphNormal.faceNormals.push(morphNormals[i2].faceNormals[j2].clone());
        }
      }
      this.morphNormals.push(morphNormal);
    }
    const skinWeights = source.skinWeights;
    for (let i2 = 0, il = skinWeights.length; i2 < il; i2++) {
      this.skinWeights.push(skinWeights[i2].clone());
    }
    const skinIndices = source.skinIndices;
    for (let i2 = 0, il = skinIndices.length; i2 < il; i2++) {
      this.skinIndices.push(skinIndices[i2].clone());
    }
    const lineDistances = source.lineDistances;
    for (let i2 = 0, il = lineDistances.length; i2 < il; i2++) {
      this.lineDistances.push(lineDistances[i2]);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.elementsNeedUpdate = source.elementsNeedUpdate;
    this.verticesNeedUpdate = source.verticesNeedUpdate;
    this.uvsNeedUpdate = source.uvsNeedUpdate;
    this.normalsNeedUpdate = source.normalsNeedUpdate;
    this.colorsNeedUpdate = source.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = source.groupsNeedUpdate;
    return this;
  }
  toBufferGeometry() {
    const geometry = new DirectGeometry().fromGeometry(this);
    const buffergeometry = new BufferGeometry();
    const positions = new Float32Array(geometry.vertices.length * 3);
    buffergeometry.setAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
    if (geometry.normals.length > 0) {
      const normals = new Float32Array(geometry.normals.length * 3);
      buffergeometry.setAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
    }
    if (geometry.colors.length > 0) {
      const colors = new Float32Array(geometry.colors.length * 3);
      buffergeometry.setAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
    }
    if (geometry.uvs.length > 0) {
      const uvs = new Float32Array(geometry.uvs.length * 2);
      buffergeometry.setAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
    }
    if (geometry.uvs2.length > 0) {
      const uvs2 = new Float32Array(geometry.uvs2.length * 2);
      buffergeometry.setAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
    }
    buffergeometry.groups = geometry.groups;
    for (let name in geometry.morphTargets) {
      const array = [];
      const morphTargets = geometry.morphTargets[name];
      for (let i2 = 0, l = morphTargets.length; i2 < l; i2++) {
        const morphTarget = morphTargets[i2];
        const attribute2 = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
        attribute2.name = morphTarget.name;
        array.push(attribute2.copyVector3sArray(morphTarget.data));
      }
      buffergeometry.morphAttributes[name] = array;
    }
    if (geometry.skinIndices.length > 0) {
      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
      buffergeometry.setAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
    }
    if (geometry.skinWeights.length > 0) {
      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
      buffergeometry.setAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
    }
    if (geometry.boundingSphere !== null) {
      buffergeometry.boundingSphere = geometry.boundingSphere.clone();
    }
    if (geometry.boundingBox !== null) {
      buffergeometry.boundingBox = geometry.boundingBox.clone();
    }
    return buffergeometry;
  }
  computeTangents() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  }
  computeLineDistances() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  }
  applyMatrix(matrix3) {
    console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(matrix3);
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose"
    });
  }
};
Geometry.createBufferGeometryFromObject = (object) => {
  let buffergeometry = new BufferGeometry();
  const geometry = object.geometry;
  if (object.isPoints || object.isLine) {
    const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
    const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
    buffergeometry.setAttribute("position", positions.copyVector3sArray(geometry.vertices));
    buffergeometry.setAttribute("color", colors.copyColorsArray(geometry.colors));
    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
      const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
      buffergeometry.setAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
    }
    if (geometry.boundingSphere !== null) {
      buffergeometry.boundingSphere = geometry.boundingSphere.clone();
    }
    if (geometry.boundingBox !== null) {
      buffergeometry.boundingBox = geometry.boundingBox.clone();
    }
  } else if (object.isMesh) {
    buffergeometry = geometry.toBufferGeometry();
  }
  return buffergeometry;
};
var DirectGeometry = class {
  constructor() {
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;
  }
  computeGroups(geometry) {
    const groups = [];
    let group, i2;
    let materialIndex = void 0;
    const faces = geometry.faces;
    for (i2 = 0; i2 < faces.length; i2++) {
      const face = faces[i2];
      if (face.materialIndex !== materialIndex) {
        materialIndex = face.materialIndex;
        if (group !== void 0) {
          group.count = i2 * 3 - group.start;
          groups.push(group);
        }
        group = {
          start: i2 * 3,
          materialIndex
        };
      }
    }
    if (group !== void 0) {
      group.count = i2 * 3 - group.start;
      groups.push(group);
    }
    this.groups = groups;
  }
  fromGeometry(geometry) {
    const faces = geometry.faces;
    const vertices = geometry.vertices;
    const faceVertexUvs = geometry.faceVertexUvs;
    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
    const morphTargets = geometry.morphTargets;
    const morphTargetsLength = morphTargets.length;
    let morphTargetsPosition;
    if (morphTargetsLength > 0) {
      morphTargetsPosition = [];
      for (let i2 = 0; i2 < morphTargetsLength; i2++) {
        morphTargetsPosition[i2] = {
          name: morphTargets[i2].name,
          data: []
        };
      }
      this.morphTargets.position = morphTargetsPosition;
    }
    const morphNormals = geometry.morphNormals;
    const morphNormalsLength = morphNormals.length;
    let morphTargetsNormal;
    if (morphNormalsLength > 0) {
      morphTargetsNormal = [];
      for (let i2 = 0; i2 < morphNormalsLength; i2++) {
        morphTargetsNormal[i2] = {
          name: morphNormals[i2].name,
          data: []
        };
      }
      this.morphTargets.normal = morphTargetsNormal;
    }
    const skinIndices = geometry.skinIndices;
    const skinWeights = geometry.skinWeights;
    const hasSkinIndices = skinIndices.length === vertices.length;
    const hasSkinWeights = skinWeights.length === vertices.length;
    if (vertices.length > 0 && faces.length === 0) {
      console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    }
    for (let i2 = 0; i2 < faces.length; i2++) {
      const face = faces[i2];
      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
      const vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
      } else {
        const normal = face.normal;
        this.normals.push(normal, normal, normal);
      }
      const vertexColors = face.vertexColors;
      if (vertexColors.length === 3) {
        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
      } else {
        const color2 = face.color;
        this.colors.push(color2, color2, color2);
      }
      if (hasFaceVertexUv === true) {
        const vertexUvs = faceVertexUvs[0][i2];
        if (vertexUvs !== void 0) {
          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i2);
          this.uvs.push(new Vector2(), new Vector2(), new Vector2());
        }
      }
      if (hasFaceVertexUv2 === true) {
        const vertexUvs = faceVertexUvs[1][i2];
        if (vertexUvs !== void 0) {
          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i2);
          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
        }
      }
      for (let j2 = 0; j2 < morphTargetsLength; j2++) {
        const morphTarget = morphTargets[j2].vertices;
        morphTargetsPosition[j2].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
      }
      for (let j2 = 0; j2 < morphNormalsLength; j2++) {
        const morphNormal = morphNormals[j2].vertexNormals[i2];
        morphTargetsNormal[j2].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
      }
      if (hasSkinIndices) {
        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
      }
      if (hasSkinWeights) {
        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
      }
    }
    this.computeGroups(geometry);
    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    this.groupsNeedUpdate = geometry.groupsNeedUpdate;
    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }
    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }
    return this;
  }
};
var Face3 = class {
  constructor(a2, b2, c, normal, color2, materialIndex = 0) {
    this.a = a2;
    this.b = b2;
    this.c = c;
    this.normal = normal && normal.isVector3 ? normal : new Vector3();
    this.vertexNormals = Array.isArray(normal) ? normal : [];
    this.color = color2 && color2.isColor ? color2 : new Color();
    this.vertexColors = Array.isArray(color2) ? color2 : [];
    this.materialIndex = materialIndex;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.a = source.a;
    this.b = source.b;
    this.c = source.c;
    this.normal.copy(source.normal);
    this.color.copy(source.color);
    this.materialIndex = source.materialIndex;
    for (let i2 = 0, il = source.vertexNormals.length; i2 < il; i2++) {
      this.vertexNormals[i2] = source.vertexNormals[i2].clone();
    }
    for (let i2 = 0, il = source.vertexColors.length; i2 < il; i2++) {
      this.vertexColors[i2] = source.vertexColors[i2].clone();
    }
    return this;
  }
};

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/materials/NodeMaterial.js
var NodeMaterial = class extends ShaderMaterial {
  constructor() {
    super();
    this.type = this.constructor.name;
    this.lights = true;
  }
  setDefaultValues(values) {
    let value;
    for (const property in values) {
      value = values[property];
      if (this[property] === void 0) {
        if (value && typeof value.clone === "function") {
          this[property] = value.clone();
        } else {
          this[property] = value;
        }
      }
    }
    Object.assign(this.defines, values.defines);
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    const nodeKeys = getNodesKeys(this);
    data.inputNodes = {};
    for (const name of nodeKeys) {
      data.inputNodes[name] = this[name].toJSON(meta).uuid;
    }
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
NodeMaterial.prototype.isNodeMaterial = true;
var NodeMaterial_default = NodeMaterial;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/materials/LineBasicNodeMaterial.js
var defaultValues = new LineBasicMaterial();
var LineBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
LineBasicNodeMaterial.prototype.isLineBasicNodeMaterial = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/materials/MeshBasicNodeMaterial.js
var defaultValues2 = new MeshBasicMaterial();
var MeshBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.lights = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues2);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
MeshBasicNodeMaterial.prototype.isMeshBasicNodeMaterial = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/materials/MeshStandardNodeMaterial.js
var defaultValues3 = new MeshStandardMaterial();
var MeshStandardNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.normalNode = null;
    this.emissiveNode = null;
    this.metalnessNode = null;
    this.roughnessNode = null;
    this.clearcoatNode = null;
    this.clearcoatRoughnessNode = null;
    this.envNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues3);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.normalNode = source.normalNode;
    this.emissiveNode = source.emissiveNode;
    this.metalnessNode = source.metalnessNode;
    this.roughnessNode = source.roughnessNode;
    this.clearcoatNode = source.clearcoatNode;
    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
    this.envNode = source.envNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
MeshStandardNodeMaterial.prototype.isMeshStandardNodeMaterial = true;

// node_modules/@react-three/rapier/node_modules/three-stdlib/nodes/materials/PointsNodeMaterial.js
var defaultValues4 = new PointsMaterial();
var PointsNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.transparent = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.sizeNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues4);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.sizeNode = source.sizeNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
PointsNodeMaterial.prototype.isPointsNodeMaterial = true;

// node_modules/@react-three/rapier/dist/react-three-rapier.esm.js
var _quaternion = new Quaternion();
new Euler();
var _vector32 = new Vector3();
var _object3d = new Object3D();
var _matrix4 = new Matrix4();
var _position = new Vector3();
var _rotation = new Quaternion();
var _scale = new Vector3();
var vectorArrayToVector3 = (arr) => {
  const [x, y, z] = arr;
  return new Vector3(x, y, z);
};
var rapierVector3ToVector3 = ({
  x,
  y,
  z
}) => _vector32.set(x, y, z);
var rapierQuaternionToQuaternion = ({
  x,
  y,
  z,
  w
}) => _quaternion.set(x, y, z, w);
var rigidBodyTypeMap = {
  fixed: 1,
  dynamic: 0,
  kinematicPosition: 2,
  kinematicVelocity: 3
};
var rigidBodyTypeFromString = (type2) => rigidBodyTypeMap[type2];
var scaleVertices = (vertices, scale) => {
  const scaledVerts = Array.from(vertices);
  for (let i2 = 0; i2 < vertices.length / 3; i2++) {
    scaledVerts[i2 * 3] *= scale.x;
    scaledVerts[i2 * 3 + 1] *= scale.y;
    scaledVerts[i2 * 3 + 2] *= scale.z;
  }
  return scaledVerts;
};
var vectorToTuple = (v) => {
  if (!v)
    return [0];
  if (v instanceof Quaternion) {
    return [v.x, v.y, v.z, v.w];
  }
  if (v instanceof Vector3 || v instanceof Euler) {
    return [v.x, v.y, v.z];
  }
  if (Array.isArray(v)) {
    return v;
  }
  return [v];
};
var createRigidBodyApi = (ref) => {
  return {
    raw: () => ref.current(),
    get handle() {
      return ref.current().handle;
    },
    mass: () => ref.current().mass(),
    applyImpulse(impulseVector, wakeUp = true) {
      ref.current().applyImpulse(impulseVector, wakeUp);
    },
    applyTorqueImpulse(torqueVector, wakeUp = true) {
      ref.current().applyTorqueImpulse(torqueVector, wakeUp);
    },
    applyImpulseAtPoint: (impulseVector, impulsePoint, wakeUp = true) => ref.current().applyImpulseAtPoint(impulseVector, impulsePoint, wakeUp),
    addForce: (force, wakeUp = true) => ref.current().addForce(force, wakeUp),
    addForceAtPoint: (force, point, wakeUp = true) => ref.current().addForceAtPoint(force, point, wakeUp),
    addTorque: (torque, wakeUp = true) => ref.current().addTorque(torque, wakeUp),
    translation() {
      return rapierVector3ToVector3(ref.current().translation());
    },
    setTranslation: (translation, wakeUp = true) => ref.current().setTranslation(translation, wakeUp),
    rotation() {
      const {
        x,
        y,
        z,
        w
      } = ref.current().rotation();
      return new Quaternion(x, y, z, w);
    },
    setRotation: (rotation, wakeUp = true) => {
      ref.current().setRotation(rotation, wakeUp);
    },
    linvel() {
      const {
        x,
        y,
        z
      } = ref.current().linvel();
      return new Vector3(x, y, z);
    },
    setLinvel: (velocity, wakeUp = true) => ref.current().setLinvel(velocity, wakeUp),
    angvel() {
      const {
        x,
        y,
        z
      } = ref.current().angvel();
      return new Vector3(x, y, z);
    },
    setAngvel: (velocity, wakeUp = true) => ref.current().setAngvel(velocity, wakeUp),
    linearDamping() {
      return ref.current().linearDamping();
    },
    setLinearDamping: (factor) => ref.current().setLinearDamping(factor),
    angularDamping() {
      return ref.current().angularDamping();
    },
    setAngularDamping: (factor) => ref.current().setAngularDamping(factor),
    setNextKinematicRotation: (rotation) => {
      ref.current().setNextKinematicRotation(rotation);
    },
    setNextKinematicTranslation: (translation) => ref.current().setNextKinematicTranslation(translation),
    resetForces: (wakeUp = true) => ref.current().resetForces(wakeUp),
    resetTorques: (wakeUp = true) => ref.current().resetTorques(wakeUp),
    lockRotations: (locked, wakeUp = true) => ref.current().lockRotations(locked, wakeUp),
    lockTranslations: (locked, wakeUp = true) => ref.current().lockTranslations(locked, wakeUp),
    setEnabledRotations: (x, y, z, wakeUp = true) => ref.current().setEnabledRotations(x, y, z, wakeUp),
    setEnabledTranslations: (x, y, z, wakeUp = true) => ref.current().setEnabledTranslations(x, y, z, wakeUp)
  };
};
var createInstancedRigidBodiesApi = (bodiesGetter) => ({
  at: (index) => bodiesGetter.current()[index].api,
  forEach(callback) {
    return bodiesGetter.current().map((b2) => b2.api).forEach(callback);
  },
  get count() {
    return bodiesGetter.current().length;
  }
});
var createWorldApi = (ref) => {
  return {
    raw: () => ref.current(),
    getCollider: (handle) => ref.current().getCollider(handle),
    getRigidBody: (handle) => ref.current().getRigidBody(handle),
    createRigidBody: (desc) => ref.current().createRigidBody(desc),
    createCollider: (desc, rigidBody) => ref.current().createCollider(desc, rigidBody),
    removeRigidBody: (rigidBody) => {
      if (!ref.current().bodies.contains(rigidBody.handle))
        return;
      ref.current().removeRigidBody(rigidBody);
    },
    removeCollider: (collider, wakeUp = true) => {
      if (!ref.current().colliders.contains(collider.handle))
        return;
      ref.current().removeCollider(collider, wakeUp);
    },
    createImpulseJoint: (params, rigidBodyA, rigidBodyB, wakeUp = true) => ref.current().createImpulseJoint(params, rigidBodyA, rigidBodyB, wakeUp),
    removeImpulseJoint: (joint, wakeUp = true) => {
      if (!ref.current().impulseJoints.contains(joint.handle))
        return;
      ref.current().removeImpulseJoint(joint, wakeUp);
    },
    forEachCollider: (callback) => ref.current().forEachCollider(callback),
    setGravity: ({
      x,
      y,
      z
    }) => ref.current().gravity = {
      x,
      y,
      z
    },
    debugRender: () => ref.current().debugRender()
  };
};
var createJointApi = (ref) => {
  return {
    raw: () => ref.current(),
    get handle() {
      return ref.current().handle;
    },
    configureMotorPosition: (targetPos, stiffness, damping) => ref.current().configureMotorPosition(targetPos, stiffness, damping),
    configureMotorVelocity: (targetVel, damping) => ref.current().configureMotorVelocity(targetVel, damping)
  };
};
var RapierContext = (0, import_react.createContext)(void 0);
var importRapier = async () => {
  let r = await import("./rapier.es-XTF4VQUU.js");
  await r.init();
  return r;
};
var Physics = ({
  colliders: _colliders = "cuboid",
  gravity: _gravity = [0, -9.81, 0],
  children,
  timeStep: _timeStep = 1 / 60,
  paused: _paused = false,
  updatePriority,
  interpolate: _interpolate = true
}) => {
  const rapier = useAsset(importRapier);
  const worldRef = (0, import_react.useRef)();
  const getWorldRef = (0, import_react.useRef)(() => {
    if (!worldRef.current) {
      const world2 = new rapier.World(vectorArrayToVector3(_gravity));
      worldRef.current = world2;
    }
    return worldRef.current;
  });
  const [rigidBodyStates] = (0, import_react.useState)(() => /* @__PURE__ */ new Map());
  const [colliderStates] = (0, import_react.useState)(() => /* @__PURE__ */ new Map());
  const [rigidBodyEvents] = (0, import_react.useState)(() => /* @__PURE__ */ new Map());
  const [colliderEvents] = (0, import_react.useState)(() => /* @__PURE__ */ new Map());
  const [eventQueue] = (0, import_react.useState)(() => new LI(false));
  (0, import_react.useEffect)(() => {
    const world2 = getWorldRef.current();
    return () => {
      if (world2) {
        world2.free();
        worldRef.current = void 0;
      }
    };
  }, []);
  (0, import_react.useEffect)(() => {
    const world2 = worldRef.current;
    if (world2) {
      world2.gravity = vectorArrayToVector3(_gravity);
    }
  }, [_gravity]);
  const [steppingState] = (0, import_react.useState)({
    previousState: {},
    accumulator: 0
  });
  const timeStepVariable = _timeStep === "vary";
  const getSourceFromColliderHandle = (0, import_react.useCallback)((handle) => {
    const world2 = worldRef.current;
    if (world2) {
      var _collider$parent;
      const collider = world2.getCollider(handle);
      const colEvents = colliderEvents.get(handle);
      const colliderState = colliderStates.get(handle);
      const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;
      const rigidBody = rigidBodyHandle ? world2.getRigidBody(rigidBodyHandle) : void 0;
      const rbEvents = rigidBody && rigidBodyHandle ? rigidBodyEvents.get(rigidBodyHandle) : void 0;
      const rigidBodyState = rigidBodyHandle ? rigidBodyStates.get(rigidBodyHandle) : void 0;
      return {
        collider: {
          object: collider,
          events: colEvents,
          state: colliderState
        },
        rigidBody: {
          object: rigidBody,
          events: rbEvents,
          state: rigidBodyState
        }
      };
    }
  }, []);
  useFrame((_, dt) => {
    const world2 = worldRef.current;
    if (!world2)
      return;
    const clampedDelta = MathUtils.clamp(dt, 0, 0.2);
    if (timeStepVariable) {
      world2.timestep = clampedDelta;
      if (!_paused)
        world2.step(eventQueue);
    } else {
      world2.timestep = _timeStep;
      steppingState.accumulator += _paused ? 0 : clampedDelta;
      if (!_paused) {
        while (steppingState.accumulator >= _timeStep) {
          if (_interpolate) {
            steppingState.previousState = {};
            world2.forEachRigidBody((body) => {
              steppingState.previousState[body.handle] = {
                position: body.translation(),
                rotation: body.rotation()
              };
            });
          }
          world2.step(eventQueue);
          steppingState.accumulator -= _timeStep;
        }
      }
    }
    const interpolationAlpha = timeStepVariable || !_interpolate ? 1 : steppingState.accumulator / _timeStep;
    rigidBodyStates.forEach((state, handle) => {
      const rigidBody = world2.getRigidBody(handle);
      const events = rigidBodyEvents.get(handle);
      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {
        if (rigidBody.isSleeping() && !state.isSleeping) {
          var _events$onSleep;
          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);
        }
        if (!rigidBody.isSleeping() && state.isSleeping) {
          var _events$onWake;
          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);
        }
        state.isSleeping = rigidBody.isSleeping();
      }
      if (!rigidBody || rigidBody.isSleeping() || !state.setMatrix) {
        return;
      }
      let t2 = rigidBody.translation();
      let r = rigidBody.rotation();
      let previousState = steppingState.previousState[handle];
      if (previousState) {
        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);
        if (!(state.object instanceof InstancedMesh)) {
          state.object.position.copy(_position);
          state.object.quaternion.copy(_rotation);
        }
      }
      _matrix4.compose(t2, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);
      if (state.object instanceof InstancedMesh) {
        state.setMatrix(_matrix4);
        state.object.instanceMatrix.needsUpdate = true;
      } else {
        state.object.position.lerp(_position, interpolationAlpha);
        state.object.quaternion.slerp(_rotation, interpolationAlpha);
      }
    });
    eventQueue.drainCollisionEvents((handle1, handle2, started) => {
      const source1 = getSourceFromColliderHandle(handle1);
      const source2 = getSourceFromColliderHandle(handle2);
      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {
        return;
      }
      if (started) {
        world2.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {
          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$collider$sta, _source2$rigidBody$st, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$sta, _source1$rigidBody$st, _source1$collider$eve, _source1$collider$eve2, _source2$collider$sta2, _source2$rigidBody$st2, _source2$collider$eve, _source2$collider$eve2, _source1$collider$sta2, _source1$rigidBody$st2;
          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, {
            rigidBody: source2.rigidBody.object,
            collider: source2.collider.object,
            colliderObject: (_source2$collider$sta = source2.collider.state) === null || _source2$collider$sta === void 0 ? void 0 : _source2$collider$sta.object,
            rigidBodyObject: (_source2$rigidBody$st = source2.rigidBody.state) === null || _source2$rigidBody$st === void 0 ? void 0 : _source2$rigidBody$st.object,
            manifold,
            flipped
          });
          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, {
            rigidBody: source1.rigidBody.object,
            collider: source1.collider.object,
            colliderObject: (_source1$collider$sta = source1.collider.state) === null || _source1$collider$sta === void 0 ? void 0 : _source1$collider$sta.object,
            rigidBodyObject: (_source1$rigidBody$st = source1.rigidBody.state) === null || _source1$rigidBody$st === void 0 ? void 0 : _source1$rigidBody$st.object,
            manifold,
            flipped
          });
          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, {
            rigidBody: source2.rigidBody.object,
            collider: source2.collider.object,
            colliderObject: (_source2$collider$sta2 = source2.collider.state) === null || _source2$collider$sta2 === void 0 ? void 0 : _source2$collider$sta2.object,
            rigidBodyObject: (_source2$rigidBody$st2 = source2.rigidBody.state) === null || _source2$rigidBody$st2 === void 0 ? void 0 : _source2$rigidBody$st2.object,
            manifold,
            flipped
          });
          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, {
            rigidBody: source1.rigidBody.object,
            collider: source1.collider.object,
            colliderObject: (_source1$collider$sta2 = source1.collider.state) === null || _source1$collider$sta2 === void 0 ? void 0 : _source1$collider$sta2.object,
            rigidBodyObject: (_source1$rigidBody$st2 = source1.rigidBody.state) === null || _source1$rigidBody$st2 === void 0 ? void 0 : _source1$rigidBody$st2.object,
            manifold,
            flipped
          });
        });
      } else {
        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;
        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, {
          rigidBody: source2.rigidBody.object,
          collider: source2.collider.object
        });
        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, {
          rigidBody: source1.rigidBody.object,
          collider: source1.collider.object
        });
        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, {
          rigidBody: source2.rigidBody.object,
          collider: source2.collider.object
        });
        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, {
          rigidBody: source1.rigidBody.object,
          collider: source1.collider.object
        });
      }
      if (started) {
        if (world2.intersectionPair(source1.collider.object, source2.collider.object)) {
          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$collider$sta3, _source2$rigidBody$st3, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$sta3, _source1$rigidBody$st3, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$sta4, _source2$rigidBody$st4, _source2$collider$eve5, _source2$collider$eve6, _source1$collider$sta4, _source1$rigidBody$st4;
          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, {
            rigidBody: source2.rigidBody.object,
            collider: source2.collider.object,
            colliderObject: (_source2$collider$sta3 = source2.collider.state) === null || _source2$collider$sta3 === void 0 ? void 0 : _source2$collider$sta3.object,
            rigidBodyObject: (_source2$rigidBody$st3 = source2.rigidBody.state) === null || _source2$rigidBody$st3 === void 0 ? void 0 : _source2$rigidBody$st3.object
          });
          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, {
            rigidBody: source1.rigidBody.object,
            collider: source1.collider.object,
            colliderObject: (_source1$collider$sta3 = source1.collider.state) === null || _source1$collider$sta3 === void 0 ? void 0 : _source1$collider$sta3.object,
            rigidBodyObject: (_source1$rigidBody$st3 = source1.rigidBody.state) === null || _source1$rigidBody$st3 === void 0 ? void 0 : _source1$rigidBody$st3.object
          });
          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, {
            rigidBody: source2.rigidBody.object,
            collider: source2.collider.object,
            colliderObject: (_source2$collider$sta4 = source2.collider.state) === null || _source2$collider$sta4 === void 0 ? void 0 : _source2$collider$sta4.object,
            rigidBodyObject: (_source2$rigidBody$st4 = source2.rigidBody.state) === null || _source2$rigidBody$st4 === void 0 ? void 0 : _source2$rigidBody$st4.object
          });
          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, {
            rigidBody: source1.rigidBody.object,
            collider: source1.collider.object,
            colliderObject: (_source1$collider$sta4 = source1.collider.state) === null || _source1$collider$sta4 === void 0 ? void 0 : _source1$collider$sta4.object,
            rigidBodyObject: (_source1$rigidBody$st4 = source1.rigidBody.state) === null || _source1$rigidBody$st4 === void 0 ? void 0 : _source1$rigidBody$st4.object
          });
        }
      } else {
        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;
        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, {
          rigidBody: source2.rigidBody.object,
          collider: source2.collider.object
        });
        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, {
          rigidBody: source1.rigidBody.object,
          collider: source1.collider.object
        });
        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, {
          rigidBody: source2.rigidBody.object,
          collider: source2.collider.object
        });
        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, {
          rigidBody: source1.rigidBody.object,
          collider: source1.collider.object
        });
      }
    });
    eventQueue.drainContactForceEvents((event) => {
      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$collider$sta5, _source2$rigidBody$st5, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$sta5, _source1$rigidBody$st5, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$sta6, _source2$rigidBody$st6, _source2$collider$eve9, _source2$collider$eve10, _source1$collider$sta6, _source1$rigidBody$st6;
      const source1 = getSourceFromColliderHandle(event.collider1());
      const source2 = getSourceFromColliderHandle(event.collider2());
      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {
        return;
      }
      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, {
        rigidBody: source2.rigidBody.object,
        collider: source2.collider.object,
        colliderObject: (_source2$collider$sta5 = source2.collider.state) === null || _source2$collider$sta5 === void 0 ? void 0 : _source2$collider$sta5.object,
        rigidBodyObject: (_source2$rigidBody$st5 = source2.rigidBody.state) === null || _source2$rigidBody$st5 === void 0 ? void 0 : _source2$rigidBody$st5.object,
        totalForce: event.totalForce(),
        totalForceMagnitude: event.totalForceMagnitude(),
        maxForceDirection: event.maxForceDirection(),
        maxForceMagnitude: event.maxForceMagnitude()
      });
      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, {
        rigidBody: source1.rigidBody.object,
        collider: source1.collider.object,
        colliderObject: (_source1$collider$sta5 = source1.collider.state) === null || _source1$collider$sta5 === void 0 ? void 0 : _source1$collider$sta5.object,
        rigidBodyObject: (_source1$rigidBody$st5 = source1.rigidBody.state) === null || _source1$rigidBody$st5 === void 0 ? void 0 : _source1$rigidBody$st5.object,
        totalForce: event.totalForce(),
        totalForceMagnitude: event.totalForceMagnitude(),
        maxForceDirection: event.maxForceDirection(),
        maxForceMagnitude: event.maxForceMagnitude()
      });
      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, {
        rigidBody: source2.rigidBody.object,
        collider: source2.collider.object,
        colliderObject: (_source2$collider$sta6 = source2.collider.state) === null || _source2$collider$sta6 === void 0 ? void 0 : _source2$collider$sta6.object,
        rigidBodyObject: (_source2$rigidBody$st6 = source2.rigidBody.state) === null || _source2$rigidBody$st6 === void 0 ? void 0 : _source2$rigidBody$st6.object,
        totalForce: event.totalForce(),
        totalForceMagnitude: event.totalForceMagnitude(),
        maxForceDirection: event.maxForceDirection(),
        maxForceMagnitude: event.maxForceMagnitude()
      });
      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, {
        rigidBody: source1.rigidBody.object,
        collider: source1.collider.object,
        colliderObject: (_source1$collider$sta6 = source1.collider.state) === null || _source1$collider$sta6 === void 0 ? void 0 : _source1$collider$sta6.object,
        rigidBodyObject: (_source1$rigidBody$st6 = source1.rigidBody.state) === null || _source1$rigidBody$st6 === void 0 ? void 0 : _source1$rigidBody$st6.object,
        totalForce: event.totalForce(),
        totalForceMagnitude: event.totalForceMagnitude(),
        maxForceDirection: event.maxForceDirection(),
        maxForceMagnitude: event.maxForceMagnitude()
      });
    });
  }, updatePriority);
  const api = (0, import_react.useMemo)(() => createWorldApi(getWorldRef), []);
  const context = (0, import_react.useMemo)(() => ({
    rapier,
    world: api,
    physicsOptions: {
      colliders: _colliders,
      gravity: _gravity
    },
    rigidBodyStates,
    colliderStates,
    rigidBodyEvents,
    colliderEvents,
    isPaused: _paused
  }), [_paused]);
  return import_react.default.createElement(RapierContext.Provider, {
    value: context
  }, children);
};
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var scaleColliderArgs = (shape, args, scale) => {
  const newArgs = args.slice();
  if (shape === "heightfield") {
    const s = newArgs[3];
    s.x *= scale.x;
    s.x *= scale.y;
    s.x *= scale.z;
    return newArgs;
  }
  if (shape === "trimesh" || shape === "convexHull") {
    newArgs[0] = scaleVertices(newArgs[0], scale);
    return newArgs;
  }
  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];
  return newArgs.map((arg, index) => scaleArray[index] * arg);
};
var createColliderFromOptions = (options, world2, scale, rigidBody) => {
  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale);
  const desc = yI[options.shape](...scaledArgs);
  return world2.createCollider(desc, rigidBody);
};
var massPropertiesConflictError = "Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.";
var setColliderMassOptions = (collider, options) => {
  if (options.density !== void 0) {
    if (options.mass !== void 0 || options.massProperties !== void 0) {
      throw new Error(massPropertiesConflictError);
    }
    collider.setDensity(options.density);
    return;
  }
  if (options.mass !== void 0) {
    if (options.massProperties !== void 0) {
      throw new Error(massPropertiesConflictError);
    }
    collider.setMass(options.mass);
    return;
  }
  if (options.massProperties !== void 0) {
    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);
  }
};
var mutableColliderOptions = {
  sensor: (collider, value) => {
    collider.setSensor(value);
  },
  collisionGroups: (collider, value) => {
    collider.setCollisionGroups(value);
  },
  solverGroups: (collider, value) => {
    collider.setSolverGroups(value);
  },
  friction: (collider, value) => {
    collider.setFriction(value);
  },
  frictionCombineRule: (collider, value) => {
    collider.setFrictionCombineRule(value);
  },
  restitution: (collider, value) => {
    collider.setRestitution(value);
  },
  restitutionCombineRule: (collider, value) => {
    collider.setRestitutionCombineRule(value);
  },
  // To make sure the options all mutalbe options are listed
  quaternion: () => {
  },
  position: () => {
  },
  rotation: () => {
  },
  scale: () => {
  }
};
var mutableColliderOptionKeys = Object.keys(mutableColliderOptions);
var setColliderOptions = (collider, options, states) => {
  const state = states.get(collider.handle);
  if (state) {
    const parentWorldScale = state.object.parent.getWorldScale(_vector32);
    state.object.updateWorldMatrix(true, false);
    _matrix4.copy(state.object.matrixWorld).premultiply(state.worldParent.matrixWorld.clone().invert()).decompose(_position, _rotation, _scale);
    if (collider.parent()) {
      collider.setTranslationWrtParent({
        x: _position.x * parentWorldScale.x,
        y: _position.y * parentWorldScale.y,
        z: _position.z * parentWorldScale.z
      });
      collider.setRotationWrtParent(_rotation);
    } else {
      collider.setTranslation({
        x: _position.x * parentWorldScale.x,
        y: _position.y * parentWorldScale.y,
        z: _position.z * parentWorldScale.z
      });
      collider.setRotation(_rotation);
    }
    mutableColliderOptionKeys.forEach((key) => {
      if (key in options) {
        const option = options[key];
        mutableColliderOptions[key](
          collider,
          // @ts-ignore Option does not want to fit into the function, but it will
          option,
          options
        );
      }
    });
    setColliderMassOptions(collider, options);
  }
};
var useUpdateColliderOptions = (collidersRef, props, states) => {
  const mutablePropsAsFlatArray = (0, import_react.useMemo)(() => mutableColliderOptionKeys.flatMap((key) => {
    return vectorToTuple(props[key]);
  }), [props]);
  (0, import_react.useEffect)(() => {
    collidersRef.current.forEach((collider) => {
      setColliderOptions(collider, props, states);
    });
  }, mutablePropsAsFlatArray);
};
var isChildOfMeshCollider = (child) => {
  let flag = false;
  child.traverseAncestors((a2) => {
    if (a2.userData.r3RapierType === "MeshCollider")
      flag = true;
  });
  return flag;
};
var createColliderState = (collider, object, rigidBodyObject) => {
  return {
    collider,
    worldParent: rigidBodyObject || object.parent,
    object
  };
};
var autoColliderMap = {
  cuboid: "cuboid",
  ball: "ball",
  hull: "convexHull",
  trimesh: "trimesh"
};
var createColliderPropsFromChildren = ({
  object,
  ignoreMeshColliders: _ignoreMeshColliders = true,
  options
}) => {
  const colliderProps = [];
  object.updateWorldMatrix(true, false);
  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();
  const colliderFromChild = (child) => {
    if ("isMesh" in child) {
      if (_ignoreMeshColliders && isChildOfMeshCollider(child))
        return;
      const worldScale = child.getWorldScale(_scale);
      const shape = autoColliderMap[options.colliders || "cuboid"];
      child.updateWorldMatrix(true, false);
      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);
      const rotationEuler = new Euler().setFromQuaternion(_rotation, "XYZ");
      const {
        geometry
      } = child;
      const {
        args,
        offset
      } = getColliderArgsFromGeometry(geometry, options.colliders || "cuboid");
      colliderProps.push(_objectSpread2(_objectSpread2({}, options), {}, {
        args,
        shape,
        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],
        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],
        scale: [worldScale.x, worldScale.y, worldScale.z]
      }));
    }
  };
  if (options.includeInvisible) {
    object.traverse(colliderFromChild);
  } else {
    object.traverseVisible(colliderFromChild);
  }
  return colliderProps;
};
var getColliderArgsFromGeometry = (geometry, colliders) => {
  switch (colliders) {
    case "cuboid": {
      geometry.computeBoundingBox();
      const {
        boundingBox
      } = geometry;
      const size2 = boundingBox.getSize(new Vector3());
      return {
        args: [size2.x / 2, size2.y / 2, size2.z / 2],
        offset: boundingBox.getCenter(new Vector3())
      };
    }
    case "ball": {
      geometry.computeBoundingSphere();
      const {
        boundingSphere
      } = geometry;
      const radius = boundingSphere.radius;
      return {
        args: [radius],
        offset: boundingSphere.center
      };
    }
    case "trimesh": {
      var _clonedGeometry$index;
      const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);
      return {
        args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],
        offset: new Vector3()
      };
    }
    case "hull": {
      const g = geometry.clone();
      return {
        args: [g.attributes.position.array],
        offset: new Vector3()
      };
    }
  }
  return {
    args: [],
    offset: new Vector3()
  };
};
var useColliderEvents = (collidersRef, props, events) => {
  const {
    onCollisionEnter,
    onCollisionExit,
    onIntersectionEnter,
    onIntersectionExit,
    onContactForce
  } = props;
  (0, import_react.useEffect)(() => {
    var _collidersRef$current;
    (_collidersRef$current = collidersRef.current) === null || _collidersRef$current === void 0 ? void 0 : _collidersRef$current.forEach((collider) => {
      const hasCollisionEvent = !!(onCollisionEnter || onCollisionExit || onIntersectionEnter || onIntersectionExit);
      const hasContactForceEvent = !!onContactForce;
      if (hasCollisionEvent && hasContactForceEvent) {
        collider.setActiveEvents(JA.COLLISION_EVENTS | JA.CONTACT_FORCE_EVENTS);
      } else if (hasCollisionEvent) {
        collider.setActiveEvents(JA.COLLISION_EVENTS);
      } else if (hasContactForceEvent) {
        collider.setActiveEvents(JA.CONTACT_FORCE_EVENTS);
      }
      events.set(collider.handle, {
        onCollisionEnter,
        onCollisionExit,
        onIntersectionEnter,
        onIntersectionExit,
        onContactForce
      });
    });
    return () => {
      var _collidersRef$current2;
      (_collidersRef$current2 = collidersRef.current) === null || _collidersRef$current2 === void 0 ? void 0 : _collidersRef$current2.forEach((collider) => events.delete(collider.handle));
    };
  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);
};
var rigidBodyDescFromOptions = (options) => {
  const type2 = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || "dynamic");
  const desc = new NA(type2);
  return desc;
};
var createRigidBodyState = ({
  rigidBody,
  object,
  setMatrix,
  getMatrix,
  worldScale
}) => {
  object.updateWorldMatrix(true, false);
  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();
  return {
    object,
    rigidBody,
    invertedWorldMatrix,
    setMatrix: setMatrix ? setMatrix : (matrix3) => {
      object.matrix.copy(matrix3);
    },
    getMatrix: getMatrix ? getMatrix : (matrix3) => matrix3.copy(object.matrix),
    scale: worldScale || object.getWorldScale(_scale).clone(),
    isSleeping: false
  };
};
var mutableRigidBodyOptions = {
  gravityScale: (rb, value) => {
    rb.setGravityScale(value, true);
  },
  linearDamping: (rb, value) => {
    rb.setLinearDamping(value);
  },
  angularDamping: (rb, value) => {
    rb.setAngularDamping(value);
  },
  enabledRotations: (rb, [x, y, z]) => {
    rb.setEnabledRotations(x, y, z, true);
  },
  enabledTranslations: (rb, [x, y, z]) => {
    rb.setEnabledTranslations(x, y, z, true);
  },
  angularVelocity: (rb, [x, y, z]) => {
    rb.setAngvel({
      x,
      y,
      z
    }, true);
  },
  linearVelocity: (rb, [x, y, z]) => {
    rb.setLinvel({
      x,
      y,
      z
    }, true);
  },
  ccd: (rb, value) => {
    rb.enableCcd(value);
  },
  userData: (rb, value) => {
    rb.userData = value;
  },
  position: () => {
  },
  rotation: () => {
  },
  quaternion: () => {
  },
  scale: () => {
  }
};
var mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);
var setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {
  if (!rigidBody) {
    return;
  }
  const state = states.get(rigidBody.handle);
  if (state) {
    if (updateTranslations) {
      state.object.updateWorldMatrix(true, false);
      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);
      rigidBody.setTranslation(_position, false);
      rigidBody.setRotation(_rotation, false);
    }
    mutableRigidBodyOptionKeys.forEach((key) => {
      if (key in options) {
        mutableRigidBodyOptions[key](rigidBody, options[key]);
      }
    });
  }
};
var useUpdateRigidBodyOptions = (rigidBodyRef, props, states, updateTranslations = true) => {
  const mutablePropsAsFlatArray = (0, import_react.useMemo)(() => mutableRigidBodyOptionKeys.flatMap((key) => {
    return vectorToTuple(props[key]);
  }), [props]);
  (0, import_react.useEffect)(() => {
    if (Array.isArray(rigidBodyRef.current)) {
      for (const rigidBody of rigidBodyRef.current) {
        setRigidBodyOptions(rigidBody, props, states, updateTranslations);
      }
    } else if (rigidBodyRef.current) {
      setRigidBodyOptions(rigidBodyRef.current, props, states, updateTranslations);
    }
  }, mutablePropsAsFlatArray);
};
var useRigidBodyEvents = (rigidBodyRef, props, events) => {
  const {
    onWake,
    onSleep,
    onCollisionEnter,
    onCollisionExit,
    onIntersectionEnter,
    onIntersectionExit
  } = props;
  const eventHandlers = {
    onWake,
    onSleep,
    onCollisionEnter,
    onCollisionExit,
    onIntersectionEnter,
    onIntersectionExit
  };
  (0, import_react.useEffect)(() => {
    if (Array.isArray(rigidBodyRef.current)) {
      for (const rigidBody of rigidBodyRef.current) {
        events.set(rigidBody.handle, eventHandlers);
      }
    } else if (rigidBodyRef.current) {
      events.set(rigidBodyRef.current.handle, eventHandlers);
    }
    return () => {
      if (Array.isArray(rigidBodyRef.current)) {
        for (const rigidBody of rigidBodyRef.current) {
          events.delete(rigidBody.handle);
        }
      } else if (rigidBodyRef.current) {
        events.delete(rigidBodyRef.current.handle);
      }
    };
  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit]);
};
var useRapier = () => {
  return (0, import_react.useContext)(RapierContext);
};
var useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {
  const [colliderProps, setColliderProps] = (0, import_react.useState)([]);
  (0, import_react.useEffect)(() => {
    const object = ref.current;
    if (object && options.colliders !== false) {
      setColliderProps(createColliderPropsFromChildren({
        object: ref.current,
        options,
        ignoreMeshColliders
      }));
    }
  }, [options.colliders]);
  return colliderProps;
};
var useRigidBody = (options = {}) => {
  const {
    world: world2,
    rigidBodyStates,
    physicsOptions,
    rigidBodyEvents
  } = useRapier();
  const ref = (0, import_react.useRef)();
  const mergedOptions = (0, import_react.useMemo)(() => {
    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {
      children: void 0
    });
  }, [physicsOptions, options]);
  const childColliderProps = useChildColliderProps(ref, mergedOptions);
  const rigidBodyRef = (0, import_react.useRef)();
  const getRigidBodyRef = (0, import_react.useRef)(() => {
    if (!rigidBodyRef.current) {
      const desc = rigidBodyDescFromOptions(options);
      const rigidBody = world2.createRigidBody(desc);
      rigidBodyRef.current = world2.getRigidBody(rigidBody.handle);
    }
    return rigidBodyRef.current;
  });
  (0, import_react.useEffect)(() => {
    const rigidBody = getRigidBodyRef.current();
    rigidBodyRef.current = rigidBody;
    if (!ref.current) {
      ref.current = new Object3D();
    }
    rigidBodyStates.set(rigidBody.handle, createRigidBodyState({
      rigidBody,
      object: ref.current
    }));
    return () => {
      world2.removeRigidBody(rigidBody);
      rigidBodyStates.delete(rigidBody.handle);
      rigidBodyRef.current = void 0;
    };
  }, []);
  useUpdateRigidBodyOptions(rigidBodyRef, mergedOptions, rigidBodyStates);
  useRigidBodyEvents(rigidBodyRef, mergedOptions, rigidBodyEvents);
  const api = (0, import_react.useMemo)(() => createRigidBodyApi(getRigidBodyRef), []);
  return [ref, api, childColliderProps];
};
var useImpulseJoint = (body1, body2, params) => {
  const {
    world: world2
  } = useRapier();
  const jointRef = (0, import_react.useRef)();
  const getJointRef = (0, import_react.useRef)(() => {
    if (!jointRef.current) {
      let rb1;
      let rb2;
      if ("current" in body1 && body1.current && "current" in body2 && body2.current) {
        rb1 = world2.getRigidBody(body1.current.handle);
        rb2 = world2.getRigidBody(body2.current.handle);
        const newJoint = world2.createImpulseJoint(params, rb1, rb2);
        jointRef.current = newJoint;
      }
    }
    return jointRef.current;
  });
  (0, import_react.useEffect)(() => {
    const joint = getJointRef.current();
    return () => {
      if (joint) {
        world2.removeImpulseJoint(joint);
        jointRef.current = void 0;
      }
    };
  }, []);
  const api = (0, import_react.useMemo)(() => createJointApi(getJointRef), []);
  return api;
};
var useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {
  const {
    rapier
  } = useRapier();
  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vectorArrayToVector3(body1Anchor), _objectSpread2(_objectSpread2({}, vectorArrayToVector3(body1LocalFrame)), {}, {
    w: 1
  }), vectorArrayToVector3(body2Anchor), _objectSpread2(_objectSpread2({}, vectorArrayToVector3(body2LocalFrame)), {}, {
    w: 1
  })));
};
var useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {
  const {
    rapier
  } = useRapier();
  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor)));
};
var useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis]) => {
  const {
    rapier
  } = useRapier();
  return useImpulseJoint(body1, body2, rapier.JointData.revolute(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis)));
};
var usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis]) => {
  const {
    rapier
  } = useRapier();
  return useImpulseJoint(body1, body2, rapier.JointData.prismatic(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis)));
};
var AnyCollider = (0, import_react.memo)(import_react.default.forwardRef((props, forwardedRef) => {
  const {
    children,
    position,
    rotation,
    quaternion,
    scale,
    name
  } = props;
  const {
    world: world2,
    colliderEvents,
    colliderStates
  } = useRapier();
  const rigidBodyContext = useRigidBodyContext();
  const ref = (0, import_react.useRef)(null);
  const collidersRef = (0, import_react.useMemo)(() => {
    if (forwardedRef !== null) {
      return forwardedRef;
    }
    const result = import_react.default.createRef();
    result.current = [];
    return result;
  }, []);
  (0, import_react.useEffect)(() => {
    const object = ref.current;
    const worldScale = object.getWorldScale(new Vector3());
    const colliders = [];
    if (rigidBodyContext && "at" in rigidBodyContext.api) {
      rigidBodyContext.api.forEach((body, index) => {
        var _rigidBodyContext$opt, _rigidBodyContext$opt2;
        let instanceScale = worldScale;
        if ("scales" in rigidBodyContext.options && rigidBodyContext !== null && rigidBodyContext !== void 0 && (_rigidBodyContext$opt = rigidBodyContext.options) !== null && _rigidBodyContext$opt !== void 0 && (_rigidBodyContext$opt2 = _rigidBodyContext$opt.scales) !== null && _rigidBodyContext$opt2 !== void 0 && _rigidBodyContext$opt2[index]) {
          instanceScale = instanceScale.clone().multiply(vectorArrayToVector3(rigidBodyContext.options.scales[index]));
        }
        const collider = createColliderFromOptions(props, world2, instanceScale, body.raw());
        colliderStates.set(collider.handle, createColliderState(collider, object, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));
        colliders.push(collider);
      });
    } else {
      const collider = createColliderFromOptions(props, world2, worldScale, rigidBodyContext && (rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.api).raw());
      colliderStates.set(collider.handle, createColliderState(collider, object, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));
      colliders.push(collider);
    }
    collidersRef.current = colliders;
    return () => {
      colliders.forEach((collider) => {
        world2.removeCollider(collider);
      });
    };
  }, []);
  const mergedProps = (0, import_react.useMemo)(() => {
    return _objectSpread2(_objectSpread2({}, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options), props);
  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);
  useUpdateColliderOptions(collidersRef, mergedProps, colliderStates);
  useColliderEvents(collidersRef, mergedProps, colliderEvents);
  return import_react.default.createElement("object3D", {
    position,
    rotation,
    quaternion,
    scale,
    ref,
    name
  }, children);
}));
var CuboidCollider = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement(AnyCollider, _extends({}, props, {
    shape: "cuboid",
    ref
  }));
});
var RoundCuboidCollider = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement(AnyCollider, _extends({}, props, {
    shape: "roundCuboid",
    ref
  }));
});
var BallCollider = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement(AnyCollider, _extends({}, props, {
    shape: "ball",
    ref
  }));
});
var CapsuleCollider = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement(AnyCollider, _extends({}, props, {
    shape: "capsule",
    ref
  }));
});
var HeightfieldCollider = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement(AnyCollider, _extends({}, props, {
    shape: "heightfield",
    ref
  }));
});
var TrimeshCollider = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement(AnyCollider, _extends({}, props, {
    shape: "trimesh",
    ref
  }));
});
var ConeCollider = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement(AnyCollider, _extends({}, props, {
    shape: "cone",
    ref
  }));
});
var CylinderCollider = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement(AnyCollider, _extends({}, props, {
    shape: "cylinder",
    ref
  }));
});
var ConvexHullCollider = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement(AnyCollider, _extends({}, props, {
    shape: "convexHull",
    ref
  }));
});
var _excluded$1 = ["children", "type", "position", "rotation", "scale", "quaternion"];
var RigidBodyContext = (0, import_react.createContext)(void 0);
var useRigidBodyContext = () => (0, import_react.useContext)(RigidBodyContext);
var RigidBody = (0, import_react.memo)((0, import_react.forwardRef)((props, ref) => {
  const {
    children,
    type: type2,
    position,
    rotation,
    scale,
    quaternion
  } = props, objectProps = _objectWithoutProperties(props, _excluded$1);
  const [object, api, childColliderProps] = useRigidBody(props);
  (0, import_react.useImperativeHandle)(ref, () => api);
  const contextValue = (0, import_react.useMemo)(() => ({
    ref: object,
    api,
    options: props
  }), [object, api, props]);
  return import_react.default.createElement(RigidBodyContext.Provider, {
    value: contextValue
  }, import_react.default.createElement("object3D", _extends({
    ref: object
  }, objectProps, {
    position,
    rotation,
    quaternion,
    scale
  }), children, childColliderProps.map((colliderProps, index) => import_react.default.createElement(AnyCollider, _extends({
    key: index
  }, colliderProps)))));
}));
var MeshCollider = (props) => {
  const {
    children,
    type: type2
  } = props;
  const {
    physicsOptions,
    world: world2
  } = useRapier();
  const object = (0, import_react.useRef)(null);
  const {
    options
  } = useRigidBodyContext();
  const mergedOptions = (0, import_react.useMemo)(() => {
    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {
      children: void 0,
      colliders: type2
    });
  }, [physicsOptions, options]);
  const childColliderProps = useChildColliderProps(object, mergedOptions, false);
  return import_react.default.createElement("object3D", {
    ref: object,
    userData: {
      r3RapierType: "MeshCollider"
    }
  }, children, childColliderProps.map((colliderProps, index) => import_react.default.createElement(AnyCollider, _extends({
    key: index
  }, colliderProps))));
};
var Debug = () => {
  const {
    world: world2
  } = useRapier();
  const ref = (0, import_react.useRef)(null);
  useFrame(() => {
    const mesh = ref.current;
    if (!mesh)
      return;
    const buffers = world2.debugRender();
    mesh.geometry.setAttribute("position", new BufferAttribute(buffers.vertices, 3));
    mesh.geometry.setAttribute("color", new BufferAttribute(buffers.colors, 4));
  });
  return import_react.default.createElement("lineSegments", {
    ref,
    frustumCulled: false
  }, import_react.default.createElement("lineBasicMaterial", {
    color: 16777215,
    vertexColors: true
  }), import_react.default.createElement("bufferGeometry", null));
};
var _excluded = ["positions", "rotations", "children"];
var InstancedRigidBodies = (0, import_react.forwardRef)((props, ref) => {
  const {
    world: world2,
    rigidBodyStates,
    physicsOptions,
    rigidBodyEvents
  } = useRapier();
  const object = (0, import_react.useRef)(null);
  const {
    positions,
    rotations,
    children
  } = props, options = _objectWithoutProperties(props, _excluded);
  const instancesRef = (0, import_react.useRef)([]);
  const rigidBodyRefs = (0, import_react.useRef)([]);
  const instancesRefGetter = (0, import_react.useRef)(() => {
    if (!instancesRef.current) {
      instancesRef.current = [];
    }
    return instancesRef.current;
  });
  const mergedOptions = (0, import_react.useMemo)(() => {
    return _objectSpread2(_objectSpread2({}, physicsOptions), options);
  }, [physicsOptions, options]);
  const childColliderProps = useChildColliderProps(object, mergedOptions);
  (0, import_react.useLayoutEffect)(() => {
    object.current.updateWorldMatrix(true, false);
    const instances = instancesRefGetter.current();
    const invertedWorld = object.current.matrixWorld.clone().invert();
    object.current.traverseVisible((mesh) => {
      if (mesh instanceof InstancedMesh) {
        mesh.instanceMatrix.setUsage(DynamicDrawUsage);
        const worldScale = mesh.getWorldScale(_scale);
        for (let index = 0; index < mesh.count; index++) {
          var _options$scales;
          const desc = rigidBodyDescFromOptions(props);
          const rigidBody = world2.createRigidBody(desc);
          rigidBodyRefs.current.push(rigidBody);
          const scale = ((_options$scales = options.scales) === null || _options$scales === void 0 ? void 0 : _options$scales[index]) || [1, 1, 1];
          const instanceScale = worldScale.clone().multiply(vectorArrayToVector3(scale));
          rigidBodyStates.set(rigidBody.handle, createRigidBodyState({
            rigidBody,
            object: mesh,
            setMatrix: (matrix3) => mesh.setMatrixAt(index, matrix3),
            getMatrix: (matrix3) => {
              mesh.getMatrixAt(index, matrix3);
              return matrix3;
            },
            worldScale: instanceScale
          }));
          const [x, y, z] = (positions === null || positions === void 0 ? void 0 : positions[index]) || [0, 0, 0];
          const [rx, ry, rz] = (rotations === null || rotations === void 0 ? void 0 : rotations[index]) || [0, 0, 0];
          _object3d.position.set(x, y, z);
          _object3d.rotation.set(rx, ry, rz);
          _object3d.applyMatrix4(invertedWorld);
          mesh.setMatrixAt(index, _object3d.matrix);
          rigidBody.setTranslation(_object3d.position, false);
          rigidBody.setRotation(_object3d.quaternion, false);
          const api2 = createRigidBodyApi({
            current() {
              return rigidBody;
            }
          });
          instances.push({
            rigidBody,
            api: api2
          });
        }
      }
    });
    return () => {
      instances.forEach((rb) => {
        world2.removeRigidBody(rb.rigidBody);
        rigidBodyStates.delete(rb.rigidBody.handle);
      });
      rigidBodyRefs.current = [];
      instancesRef.current = [];
    };
  }, []);
  const api = (0, import_react.useMemo)(() => createInstancedRigidBodiesApi(instancesRefGetter), []);
  (0, import_react.useImperativeHandle)(ref, () => api);
  useUpdateRigidBodyOptions(rigidBodyRefs, mergedOptions, rigidBodyStates, false);
  useRigidBodyEvents(rigidBodyRefs, mergedOptions, rigidBodyEvents);
  const contextValue = (0, import_react.useMemo)(() => {
    return {
      ref: object,
      api,
      options: mergedOptions
    };
  }, [api, mergedOptions]);
  return import_react.default.createElement(RigidBodyContext.Provider, {
    value: contextValue
  }, import_react.default.createElement("object3D", {
    ref: object
  }, props.children, childColliderProps.map((colliderProps, index) => import_react.default.createElement(AnyCollider, _extends({
    key: index
  }, colliderProps)))));
});
var interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== void 0 ? bitmask(filters) : 65535);
var bitmask = (groups) => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);
export {
  AnyCollider,
  BallCollider,
  CapsuleCollider,
  SA as CoefficientCombineRule,
  ConeCollider,
  ConvexHullCollider,
  CuboidCollider,
  CylinderCollider,
  Debug,
  HeightfieldCollider,
  InstancedRigidBodies,
  MeshCollider,
  Physics,
  JI as RapierCollider,
  hA as RapierRigidBody,
  RigidBody,
  RoundCuboidCollider,
  TrimeshCollider,
  interactionGroups,
  useChildColliderProps,
  useFixedJoint,
  useImpulseJoint,
  usePrismaticJoint,
  useRapier,
  useRevoluteJoint,
  useRigidBody,
  useSphericalJoint
};
/*! Bundled license information:

three-stdlib/loaders/AssimpLoader.js:
  (*! A directional light source has a well-defined direction *)
  (*! but is infinitely far away. That's quite a good *)
  (*! approximation for sun light. *)
  (*! A point light source has a well-defined position *)
  (*! in space but no direction - it emits light in all *)
  (*! directions. A normal bulb is a point light. *)
  (*! A spot light source emits light in a specific *)
  (*! angle. It has a position and a direction it is pointing to. *)
  (*! A good example for a spot light is a light spot in *)
  (*! sport arenas. *)
  (*! The generic light level of the world, including the bounces *)
  (*! of all other lightsources. *)
  (*! Typically, there's at most one ambient light in a scene. *)
  (*! This light type doesn't have a valid position, direction, or *)
  (*! other properties, just a color. *)
*/
//# sourceMappingURL=@react-three_rapier.js.map
