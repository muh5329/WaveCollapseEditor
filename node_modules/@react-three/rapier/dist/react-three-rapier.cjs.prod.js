'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var rapier3dCompat = require('@dimforge/rapier3d-compat');
var fiber = require('@react-three/fiber');
var React = require('react');
var three = require('three');
var useAsset = require('use-asset');
var threeStdlib = require('three-stdlib');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__default = /*#__PURE__*/_interopDefault(React);

const _quaternion = new three.Quaternion();
new three.Euler();
const _vector3 = new three.Vector3();
const _object3d = new three.Object3D();
const _matrix4 = new three.Matrix4();
const _position = new three.Vector3();
const _rotation = new three.Quaternion();
const _scale = new three.Vector3();

const vectorArrayToVector3 = arr => {
  const [x, y, z] = arr;
  return new three.Vector3(x, y, z);
};
const rapierVector3ToVector3 = ({
  x,
  y,
  z
}) => _vector3.set(x, y, z);
const rapierQuaternionToQuaternion = ({
  x,
  y,
  z,
  w
}) => _quaternion.set(x, y, z, w);
const rigidBodyTypeMap = {
  fixed: 1,
  dynamic: 0,
  kinematicPosition: 2,
  kinematicVelocity: 3
};
const rigidBodyTypeFromString = type => rigidBodyTypeMap[type];
const scaleVertices = (vertices, scale) => {
  const scaledVerts = Array.from(vertices);

  for (let i = 0; i < vertices.length / 3; i++) {
    scaledVerts[i * 3] *= scale.x;
    scaledVerts[i * 3 + 1] *= scale.y;
    scaledVerts[i * 3 + 2] *= scale.z;
  }

  return scaledVerts;
};
const vectorToTuple = v => {
  if (!v) return [0];

  if (v instanceof three.Quaternion) {
    return [v.x, v.y, v.z, v.w];
  }

  if (v instanceof three.Vector3 || v instanceof three.Euler) {
    return [v.x, v.y, v.z];
  }

  if (Array.isArray(v)) {
    return v;
  }

  return [v];
};

const createRigidBodyApi = ref => {
  return {
    raw: () => ref.current(),

    get handle() {
      return ref.current().handle;
    },

    mass: () => ref.current().mass(),

    applyImpulse(impulseVector, wakeUp = true) {
      ref.current().applyImpulse(impulseVector, wakeUp);
    },

    applyTorqueImpulse(torqueVector, wakeUp = true) {
      ref.current().applyTorqueImpulse(torqueVector, wakeUp);
    },

    applyImpulseAtPoint: (impulseVector, impulsePoint, wakeUp = true) => ref.current().applyImpulseAtPoint(impulseVector, impulsePoint, wakeUp),
    addForce: (force, wakeUp = true) => ref.current().addForce(force, wakeUp),
    addForceAtPoint: (force, point, wakeUp = true) => ref.current().addForceAtPoint(force, point, wakeUp),
    addTorque: (torque, wakeUp = true) => ref.current().addTorque(torque, wakeUp),

    translation() {
      return rapierVector3ToVector3(ref.current().translation());
    },

    setTranslation: (translation, wakeUp = true) => ref.current().setTranslation(translation, wakeUp),

    rotation() {
      const {
        x,
        y,
        z,
        w
      } = ref.current().rotation();
      return new three.Quaternion(x, y, z, w);
    },

    setRotation: (rotation, wakeUp = true) => {
      ref.current().setRotation(rotation, wakeUp);
    },

    linvel() {
      const {
        x,
        y,
        z
      } = ref.current().linvel();
      return new three.Vector3(x, y, z);
    },

    setLinvel: (velocity, wakeUp = true) => ref.current().setLinvel(velocity, wakeUp),

    angvel() {
      const {
        x,
        y,
        z
      } = ref.current().angvel();
      return new three.Vector3(x, y, z);
    },

    setAngvel: (velocity, wakeUp = true) => ref.current().setAngvel(velocity, wakeUp),

    linearDamping() {
      return ref.current().linearDamping();
    },

    setLinearDamping: factor => ref.current().setLinearDamping(factor),

    angularDamping() {
      return ref.current().angularDamping();
    },

    setAngularDamping: factor => ref.current().setAngularDamping(factor),
    setNextKinematicRotation: rotation => {
      ref.current().setNextKinematicRotation(rotation);
    },
    setNextKinematicTranslation: translation => ref.current().setNextKinematicTranslation(translation),
    resetForces: (wakeUp = true) => ref.current().resetForces(wakeUp),
    resetTorques: (wakeUp = true) => ref.current().resetTorques(wakeUp),
    lockRotations: (locked, wakeUp = true) => ref.current().lockRotations(locked, wakeUp),
    lockTranslations: (locked, wakeUp = true) => ref.current().lockTranslations(locked, wakeUp),
    setEnabledRotations: (x, y, z, wakeUp = true) => ref.current().setEnabledRotations(x, y, z, wakeUp),
    setEnabledTranslations: (x, y, z, wakeUp = true) => ref.current().setEnabledTranslations(x, y, z, wakeUp)
  };
};
const createInstancedRigidBodiesApi = bodiesGetter => ({
  at: index => bodiesGetter.current()[index].api,

  forEach(callback) {
    return bodiesGetter.current().map(b => b.api).forEach(callback);
  },

  get count() {
    return bodiesGetter.current().length;
  }

}); // TODO: Flesh this out
const createWorldApi = ref => {
  return {
    raw: () => ref.current(),
    getCollider: handle => ref.current().getCollider(handle),
    getRigidBody: handle => ref.current().getRigidBody(handle),
    createRigidBody: desc => ref.current().createRigidBody(desc),
    createCollider: (desc, rigidBody) => ref.current().createCollider(desc, rigidBody),
    removeRigidBody: rigidBody => {
      if (!ref.current().bodies.contains(rigidBody.handle)) return;
      ref.current().removeRigidBody(rigidBody);
    },
    removeCollider: (collider, wakeUp = true) => {
      if (!ref.current().colliders.contains(collider.handle)) return;
      ref.current().removeCollider(collider, wakeUp);
    },
    createImpulseJoint: (params, rigidBodyA, rigidBodyB, wakeUp = true) => ref.current().createImpulseJoint(params, rigidBodyA, rigidBodyB, wakeUp),
    removeImpulseJoint: (joint, wakeUp = true) => {
      if (!ref.current().impulseJoints.contains(joint.handle)) return;
      ref.current().removeImpulseJoint(joint, wakeUp);
    },
    forEachCollider: callback => ref.current().forEachCollider(callback),
    setGravity: ({
      x,
      y,
      z
    }) => ref.current().gravity = {
      x,
      y,
      z
    },
    debugRender: () => ref.current().debugRender()
  };
}; // TODO: Broken currently, waiting for Rapier3D to fix

const createJointApi = ref => {
  return {
    raw: () => ref.current(),

    get handle() {
      return ref.current().handle;
    },

    configureMotorPosition: (targetPos, stiffness, damping) => ref.current().configureMotorPosition(targetPos, stiffness, damping),
    configureMotorVelocity: (targetVel, damping) => ref.current().configureMotorVelocity(targetVel, damping)
  };
};

const RapierContext = /*#__PURE__*/React.createContext(undefined);

const importRapier = async () => {
  let r = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@dimforge/rapier3d-compat')); });
  await r.init();
  return r;
};

const Physics = ({
  colliders: _colliders = "cuboid",
  gravity: _gravity = [0, -9.81, 0],
  children,
  timeStep: _timeStep = 1 / 60,
  paused: _paused = false,
  updatePriority,
  interpolate: _interpolate = true
}) => {
  const rapier = useAsset.useAsset(importRapier);
  const worldRef = React.useRef();
  const getWorldRef = React.useRef(() => {
    if (!worldRef.current) {
      const world = new rapier.World(vectorArrayToVector3(_gravity));
      worldRef.current = world;
    }

    return worldRef.current;
  });
  const [rigidBodyStates] = React.useState(() => new Map());
  const [colliderStates] = React.useState(() => new Map());
  const [rigidBodyEvents] = React.useState(() => new Map());
  const [colliderEvents] = React.useState(() => new Map());
  const [eventQueue] = React.useState(() => new rapier3dCompat.EventQueue(false)); // Init world

  React.useEffect(() => {
    const world = getWorldRef.current();
    return () => {
      if (world) {
        world.free();
        worldRef.current = undefined;
      }
    };
  }, []); // Update gravity

  React.useEffect(() => {
    const world = worldRef.current;

    if (world) {
      world.gravity = vectorArrayToVector3(_gravity);
    }
  }, [_gravity]);
  const [steppingState] = React.useState({
    previousState: {},
    accumulator: 0
  });
  /* Check if the timestep is supposed to be variable. We'll do this here
  once so we don't have to string-check every frame. */

  const timeStepVariable = _timeStep === "vary";
  const getSourceFromColliderHandle = React.useCallback(handle => {
    const world = worldRef.current;

    if (world) {
      var _collider$parent;

      const collider = world.getCollider(handle);
      const colEvents = colliderEvents.get(handle);
      const colliderState = colliderStates.get(handle);
      const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;
      const rigidBody = rigidBodyHandle ? world.getRigidBody(rigidBodyHandle) : undefined;
      const rbEvents = rigidBody && rigidBodyHandle ? rigidBodyEvents.get(rigidBodyHandle) : undefined;
      const rigidBodyState = rigidBodyHandle ? rigidBodyStates.get(rigidBodyHandle) : undefined;
      return {
        collider: {
          object: collider,
          events: colEvents,
          state: colliderState
        },
        rigidBody: {
          object: rigidBody,
          events: rbEvents,
          state: rigidBodyState
        }
      };
    }
  }, []);
  fiber.useFrame((_, dt) => {
    const world = worldRef.current;
    if (!world) return;
    /**
     * Fixed timeStep simulation progression
     * @see https://gafferongames.com/post/fix_your_timestep/
     */

    const clampedDelta = three.MathUtils.clamp(dt, 0, 0.2);

    if (timeStepVariable) {
      world.timestep = clampedDelta;
      if (!_paused) world.step(eventQueue);
    } else {
      world.timestep = _timeStep; // don't step time forwards if paused
      // Increase accumulator

      steppingState.accumulator += _paused ? 0 : clampedDelta;

      if (!_paused) {
        while (steppingState.accumulator >= _timeStep) {
          if (_interpolate) {
            // Set up previous state
            // needed for accurate interpolations if the world steps more than once
            steppingState.previousState = {};
            world.forEachRigidBody(body => {
              steppingState.previousState[body.handle] = {
                position: body.translation(),
                rotation: body.rotation()
              };
            });
          }

          world.step(eventQueue);
          steppingState.accumulator -= _timeStep;
        }
      }
    }

    const interpolationAlpha = timeStepVariable || !_interpolate ? 1 : steppingState.accumulator / _timeStep; // Update meshes

    rigidBodyStates.forEach((state, handle) => {
      const rigidBody = world.getRigidBody(handle);
      const events = rigidBodyEvents.get(handle);

      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {
        if (rigidBody.isSleeping() && !state.isSleeping) {
          var _events$onSleep;

          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);
        }

        if (!rigidBody.isSleeping() && state.isSleeping) {
          var _events$onWake;

          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);
        }

        state.isSleeping = rigidBody.isSleeping();
      }

      if (!rigidBody || rigidBody.isSleeping() || !state.setMatrix) {
        return;
      }

      let t = rigidBody.translation();
      let r = rigidBody.rotation();
      let previousState = steppingState.previousState[handle];

      if (previousState) {
        // Get previous simulated world position
        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale); // Apply previous tick position


        if (!(state.object instanceof three.InstancedMesh)) {
          state.object.position.copy(_position);
          state.object.quaternion.copy(_rotation);
        }
      } // Get new position


      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);

      if (state.object instanceof three.InstancedMesh) {
        state.setMatrix(_matrix4);
        state.object.instanceMatrix.needsUpdate = true;
      } else {
        // Interpolate to new position
        state.object.position.lerp(_position, interpolationAlpha);
        state.object.quaternion.slerp(_rotation, interpolationAlpha);
      }
    });
    eventQueue.drainCollisionEvents((handle1, handle2, started) => {
      const source1 = getSourceFromColliderHandle(handle1);
      const source2 = getSourceFromColliderHandle(handle2); // Collision Events

      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {
        return;
      }

      if (started) {
        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {
          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$collider$sta, _source2$rigidBody$st, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$sta, _source1$rigidBody$st, _source1$collider$eve, _source1$collider$eve2, _source2$collider$sta2, _source2$rigidBody$st2, _source2$collider$eve, _source2$collider$eve2, _source1$collider$sta2, _source1$rigidBody$st2;

          /* RigidBody events */
          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, {
            rigidBody: source2.rigidBody.object,
            collider: source2.collider.object,
            colliderObject: (_source2$collider$sta = source2.collider.state) === null || _source2$collider$sta === void 0 ? void 0 : _source2$collider$sta.object,
            rigidBodyObject: (_source2$rigidBody$st = source2.rigidBody.state) === null || _source2$rigidBody$st === void 0 ? void 0 : _source2$rigidBody$st.object,
            manifold,
            flipped
          });
          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, {
            rigidBody: source1.rigidBody.object,
            collider: source1.collider.object,
            colliderObject: (_source1$collider$sta = source1.collider.state) === null || _source1$collider$sta === void 0 ? void 0 : _source1$collider$sta.object,
            rigidBodyObject: (_source1$rigidBody$st = source1.rigidBody.state) === null || _source1$rigidBody$st === void 0 ? void 0 : _source1$rigidBody$st.object,
            manifold,
            flipped
          });
          /* Collider events */

          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, {
            rigidBody: source2.rigidBody.object,
            collider: source2.collider.object,
            colliderObject: (_source2$collider$sta2 = source2.collider.state) === null || _source2$collider$sta2 === void 0 ? void 0 : _source2$collider$sta2.object,
            rigidBodyObject: (_source2$rigidBody$st2 = source2.rigidBody.state) === null || _source2$rigidBody$st2 === void 0 ? void 0 : _source2$rigidBody$st2.object,
            manifold,
            flipped
          });
          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, {
            rigidBody: source1.rigidBody.object,
            collider: source1.collider.object,
            colliderObject: (_source1$collider$sta2 = source1.collider.state) === null || _source1$collider$sta2 === void 0 ? void 0 : _source1$collider$sta2.object,
            rigidBodyObject: (_source1$rigidBody$st2 = source1.rigidBody.state) === null || _source1$rigidBody$st2 === void 0 ? void 0 : _source1$rigidBody$st2.object,
            manifold,
            flipped
          });
        });
      } else {
        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;

        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, {
          rigidBody: source2.rigidBody.object,
          collider: source2.collider.object
        });
        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, {
          rigidBody: source1.rigidBody.object,
          collider: source1.collider.object
        });
        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, {
          rigidBody: source2.rigidBody.object,
          collider: source2.collider.object
        });
        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, {
          rigidBody: source1.rigidBody.object,
          collider: source1.collider.object
        });
      } // Sensor Intersections


      if (started) {
        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {
          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$collider$sta3, _source2$rigidBody$st3, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$sta3, _source1$rigidBody$st3, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$sta4, _source2$rigidBody$st4, _source2$collider$eve5, _source2$collider$eve6, _source1$collider$sta4, _source1$rigidBody$st4;

          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, {
            rigidBody: source2.rigidBody.object,
            collider: source2.collider.object,
            colliderObject: (_source2$collider$sta3 = source2.collider.state) === null || _source2$collider$sta3 === void 0 ? void 0 : _source2$collider$sta3.object,
            rigidBodyObject: (_source2$rigidBody$st3 = source2.rigidBody.state) === null || _source2$rigidBody$st3 === void 0 ? void 0 : _source2$rigidBody$st3.object
          });
          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, {
            rigidBody: source1.rigidBody.object,
            collider: source1.collider.object,
            colliderObject: (_source1$collider$sta3 = source1.collider.state) === null || _source1$collider$sta3 === void 0 ? void 0 : _source1$collider$sta3.object,
            rigidBodyObject: (_source1$rigidBody$st3 = source1.rigidBody.state) === null || _source1$rigidBody$st3 === void 0 ? void 0 : _source1$rigidBody$st3.object
          });
          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, {
            rigidBody: source2.rigidBody.object,
            collider: source2.collider.object,
            colliderObject: (_source2$collider$sta4 = source2.collider.state) === null || _source2$collider$sta4 === void 0 ? void 0 : _source2$collider$sta4.object,
            rigidBodyObject: (_source2$rigidBody$st4 = source2.rigidBody.state) === null || _source2$rigidBody$st4 === void 0 ? void 0 : _source2$rigidBody$st4.object
          });
          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, {
            rigidBody: source1.rigidBody.object,
            collider: source1.collider.object,
            colliderObject: (_source1$collider$sta4 = source1.collider.state) === null || _source1$collider$sta4 === void 0 ? void 0 : _source1$collider$sta4.object,
            rigidBodyObject: (_source1$rigidBody$st4 = source1.rigidBody.state) === null || _source1$rigidBody$st4 === void 0 ? void 0 : _source1$rigidBody$st4.object
          });
        }
      } else {
        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;

        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, {
          rigidBody: source2.rigidBody.object,
          collider: source2.collider.object
        });
        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, {
          rigidBody: source1.rigidBody.object,
          collider: source1.collider.object
        });
        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, {
          rigidBody: source2.rigidBody.object,
          collider: source2.collider.object
        });
        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, {
          rigidBody: source1.rigidBody.object,
          collider: source1.collider.object
        });
      }
    });
    eventQueue.drainContactForceEvents(event => {
      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$collider$sta5, _source2$rigidBody$st5, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$sta5, _source1$rigidBody$st5, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$sta6, _source2$rigidBody$st6, _source2$collider$eve9, _source2$collider$eve10, _source1$collider$sta6, _source1$rigidBody$st6;

      const source1 = getSourceFromColliderHandle(event.collider1());
      const source2 = getSourceFromColliderHandle(event.collider2()); // Collision Events

      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {
        return;
      }

      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, {
        rigidBody: source2.rigidBody.object,
        collider: source2.collider.object,
        colliderObject: (_source2$collider$sta5 = source2.collider.state) === null || _source2$collider$sta5 === void 0 ? void 0 : _source2$collider$sta5.object,
        rigidBodyObject: (_source2$rigidBody$st5 = source2.rigidBody.state) === null || _source2$rigidBody$st5 === void 0 ? void 0 : _source2$rigidBody$st5.object,
        totalForce: event.totalForce(),
        totalForceMagnitude: event.totalForceMagnitude(),
        maxForceDirection: event.maxForceDirection(),
        maxForceMagnitude: event.maxForceMagnitude()
      });
      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, {
        rigidBody: source1.rigidBody.object,
        collider: source1.collider.object,
        colliderObject: (_source1$collider$sta5 = source1.collider.state) === null || _source1$collider$sta5 === void 0 ? void 0 : _source1$collider$sta5.object,
        rigidBodyObject: (_source1$rigidBody$st5 = source1.rigidBody.state) === null || _source1$rigidBody$st5 === void 0 ? void 0 : _source1$rigidBody$st5.object,
        totalForce: event.totalForce(),
        totalForceMagnitude: event.totalForceMagnitude(),
        maxForceDirection: event.maxForceDirection(),
        maxForceMagnitude: event.maxForceMagnitude()
      });
      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, {
        rigidBody: source2.rigidBody.object,
        collider: source2.collider.object,
        colliderObject: (_source2$collider$sta6 = source2.collider.state) === null || _source2$collider$sta6 === void 0 ? void 0 : _source2$collider$sta6.object,
        rigidBodyObject: (_source2$rigidBody$st6 = source2.rigidBody.state) === null || _source2$rigidBody$st6 === void 0 ? void 0 : _source2$rigidBody$st6.object,
        totalForce: event.totalForce(),
        totalForceMagnitude: event.totalForceMagnitude(),
        maxForceDirection: event.maxForceDirection(),
        maxForceMagnitude: event.maxForceMagnitude()
      });
      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, {
        rigidBody: source1.rigidBody.object,
        collider: source1.collider.object,
        colliderObject: (_source1$collider$sta6 = source1.collider.state) === null || _source1$collider$sta6 === void 0 ? void 0 : _source1$collider$sta6.object,
        rigidBodyObject: (_source1$rigidBody$st6 = source1.rigidBody.state) === null || _source1$rigidBody$st6 === void 0 ? void 0 : _source1$rigidBody$st6.object,
        totalForce: event.totalForce(),
        totalForceMagnitude: event.totalForceMagnitude(),
        maxForceDirection: event.maxForceDirection(),
        maxForceMagnitude: event.maxForceMagnitude()
      });
    });
  }, updatePriority);
  const api = React.useMemo(() => createWorldApi(getWorldRef), []);
  const context = React.useMemo(() => ({
    rapier,
    world: api,
    physicsOptions: {
      colliders: _colliders,
      gravity: _gravity
    },
    rigidBodyStates,
    colliderStates,
    rigidBodyEvents,
    colliderEvents,
    isPaused: _paused
  }), [_paused]);
  return /*#__PURE__*/React__default["default"].createElement(RapierContext.Provider, {
    value: context
  }, children);
};

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

const scaleColliderArgs = (shape, args, scale) => {
  const newArgs = args.slice(); // Heightfield uses a vector

  if (shape === "heightfield") {
    const s = newArgs[3];
    s.x *= scale.x;
    s.x *= scale.y;
    s.x *= scale.z;
    return newArgs;
  } // Trimesh and convex scale the vertices


  if (shape === "trimesh" || shape === "convexHull") {
    newArgs[0] = scaleVertices(newArgs[0], scale);
    return newArgs;
  } // Prepfill with some extra


  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];
  return newArgs.map((arg, index) => scaleArray[index] * arg);
};
const createColliderFromOptions = (options, world, scale, rigidBody) => {
  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale); // @ts-ignore

  const desc = rapier3dCompat.ColliderDesc[options.shape](...scaledArgs);
  return world.createCollider(desc, rigidBody);
};
const massPropertiesConflictError = "Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.";

const setColliderMassOptions = (collider, options) => {
  if (options.density !== undefined) {
    if (options.mass !== undefined || options.massProperties !== undefined) {
      throw new Error(massPropertiesConflictError);
    }

    collider.setDensity(options.density);
    return;
  }

  if (options.mass !== undefined) {
    if (options.massProperties !== undefined) {
      throw new Error(massPropertiesConflictError);
    }

    collider.setMass(options.mass);
    return;
  }

  if (options.massProperties !== undefined) {
    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);
  }
};

const mutableColliderOptions = {
  sensor: (collider, value) => {
    collider.setSensor(value);
  },
  collisionGroups: (collider, value) => {
    collider.setCollisionGroups(value);
  },
  solverGroups: (collider, value) => {
    collider.setSolverGroups(value);
  },
  friction: (collider, value) => {
    collider.setFriction(value);
  },
  frictionCombineRule: (collider, value) => {
    collider.setFrictionCombineRule(value);
  },
  restitution: (collider, value) => {
    collider.setRestitution(value);
  },
  restitutionCombineRule: (collider, value) => {
    collider.setRestitutionCombineRule(value);
  },
  // To make sure the options all mutalbe options are listed
  quaternion: () => {},
  position: () => {},
  rotation: () => {},
  scale: () => {}
};
const mutableColliderOptionKeys = Object.keys(mutableColliderOptions);
const setColliderOptions = (collider, options, states) => {
  const state = states.get(collider.handle);

  if (state) {
    // Update collider position based on the object's position
    const parentWorldScale = state.object.parent.getWorldScale(_vector3);
    state.object.updateWorldMatrix(true, false);

    _matrix4.copy(state.object.matrixWorld).premultiply(state.worldParent.matrixWorld.clone().invert()).decompose(_position, _rotation, _scale);

    if (collider.parent()) {
      collider.setTranslationWrtParent({
        x: _position.x * parentWorldScale.x,
        y: _position.y * parentWorldScale.y,
        z: _position.z * parentWorldScale.z
      });
      collider.setRotationWrtParent(_rotation);
    } else {
      collider.setTranslation({
        x: _position.x * parentWorldScale.x,
        y: _position.y * parentWorldScale.y,
        z: _position.z * parentWorldScale.z
      });
      collider.setRotation(_rotation);
    }

    mutableColliderOptionKeys.forEach(key => {
      if (key in options) {
        const option = options[key];
        mutableColliderOptions[key](collider, // @ts-ignore Option does not want to fit into the function, but it will
        option, options);
      }
    }); // handle mass separately, because the assignments
    // are exclusive.

    setColliderMassOptions(collider, options);
  }
};
const useUpdateColliderOptions = (collidersRef, props, states) => {
  // TODO: Improve this, split each prop into its own effect
  const mutablePropsAsFlatArray = React.useMemo(() => mutableColliderOptionKeys.flatMap(key => {
    return vectorToTuple(props[key]);
  }), [props]);
  React.useEffect(() => {
    collidersRef.current.forEach(collider => {
      setColliderOptions(collider, props, states);
    });
  }, mutablePropsAsFlatArray);
};

const isChildOfMeshCollider = child => {
  let flag = false;
  child.traverseAncestors(a => {
    if (a.userData.r3RapierType === "MeshCollider") flag = true;
  });
  return flag;
};

const createColliderState = (collider, object, rigidBodyObject) => {
  return {
    collider,
    worldParent: rigidBodyObject || object.parent,
    object
  };
};
const autoColliderMap = {
  cuboid: "cuboid",
  ball: "ball",
  hull: "convexHull",
  trimesh: "trimesh"
};
const createColliderPropsFromChildren = ({
  object,
  ignoreMeshColliders: _ignoreMeshColliders = true,
  options
}) => {
  const colliderProps = [];
  object.updateWorldMatrix(true, false);
  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();

  const colliderFromChild = child => {
    if ("isMesh" in child) {
      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;
      const worldScale = child.getWorldScale(_scale);
      const shape = autoColliderMap[options.colliders || "cuboid"];
      child.updateWorldMatrix(true, false);

      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);

      const rotationEuler = new three.Euler().setFromQuaternion(_rotation, "XYZ");
      const {
        geometry
      } = child;
      const {
        args,
        offset
      } = getColliderArgsFromGeometry(geometry, options.colliders || "cuboid");
      colliderProps.push(_objectSpread2(_objectSpread2({}, options), {}, {
        args: args,
        shape: shape,
        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],
        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],
        scale: [worldScale.x, worldScale.y, worldScale.z]
      }));
    }
  };

  if (options.includeInvisible) {
    object.traverse(colliderFromChild);
  } else {
    object.traverseVisible(colliderFromChild);
  }

  return colliderProps;
};
const getColliderArgsFromGeometry = (geometry, colliders) => {
  switch (colliders) {
    case "cuboid":
      {
        geometry.computeBoundingBox();
        const {
          boundingBox
        } = geometry;
        const size = boundingBox.getSize(new three.Vector3());
        return {
          args: [size.x / 2, size.y / 2, size.z / 2],
          offset: boundingBox.getCenter(new three.Vector3())
        };
      }

    case "ball":
      {
        geometry.computeBoundingSphere();
        const {
          boundingSphere
        } = geometry;
        const radius = boundingSphere.radius;
        return {
          args: [radius],
          offset: boundingSphere.center
        };
      }

    case "trimesh":
      {
        var _clonedGeometry$index;

        const clonedGeometry = geometry.index ? geometry.clone() : threeStdlib.mergeVertices(geometry);
        return {
          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],
          offset: new three.Vector3()
        };
      }

    case "hull":
      {
        const g = geometry.clone();
        return {
          args: [g.attributes.position.array],
          offset: new three.Vector3()
        };
      }
  }

  return {
    args: [],
    offset: new three.Vector3()
  };
};
const useColliderEvents = (collidersRef, props, events) => {
  const {
    onCollisionEnter,
    onCollisionExit,
    onIntersectionEnter,
    onIntersectionExit,
    onContactForce
  } = props;
  React.useEffect(() => {
    var _collidersRef$current;

    (_collidersRef$current = collidersRef.current) === null || _collidersRef$current === void 0 ? void 0 : _collidersRef$current.forEach(collider => {
      const hasCollisionEvent = !!(onCollisionEnter || onCollisionExit || onIntersectionEnter || onIntersectionExit);
      const hasContactForceEvent = !!onContactForce;

      if (hasCollisionEvent && hasContactForceEvent) {
        collider.setActiveEvents(rapier3dCompat.ActiveEvents.COLLISION_EVENTS | rapier3dCompat.ActiveEvents.CONTACT_FORCE_EVENTS);
      } else if (hasCollisionEvent) {
        collider.setActiveEvents(rapier3dCompat.ActiveEvents.COLLISION_EVENTS);
      } else if (hasContactForceEvent) {
        collider.setActiveEvents(rapier3dCompat.ActiveEvents.CONTACT_FORCE_EVENTS);
      }

      events.set(collider.handle, {
        onCollisionEnter,
        onCollisionExit,
        onIntersectionEnter,
        onIntersectionExit,
        onContactForce
      });
    });
    return () => {
      var _collidersRef$current2;

      (_collidersRef$current2 = collidersRef.current) === null || _collidersRef$current2 === void 0 ? void 0 : _collidersRef$current2.forEach(collider => events.delete(collider.handle));
    };
  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);
};

const rigidBodyDescFromOptions = options => {
  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || "dynamic");
  const desc = new rapier3dCompat.RigidBodyDesc(type);
  return desc;
};
const createRigidBodyState = ({
  rigidBody,
  object,
  setMatrix,
  getMatrix,
  worldScale
}) => {
  object.updateWorldMatrix(true, false);
  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();
  return {
    object,
    rigidBody,
    invertedWorldMatrix,
    setMatrix: setMatrix ? setMatrix : matrix => {
      object.matrix.copy(matrix);
    },
    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),
    scale: worldScale || object.getWorldScale(_scale).clone(),
    isSleeping: false
  };
};
const mutableRigidBodyOptions = {
  gravityScale: (rb, value) => {
    rb.setGravityScale(value, true);
  },
  linearDamping: (rb, value) => {
    rb.setLinearDamping(value);
  },
  angularDamping: (rb, value) => {
    rb.setAngularDamping(value);
  },
  enabledRotations: (rb, [x, y, z]) => {
    rb.setEnabledRotations(x, y, z, true);
  },
  enabledTranslations: (rb, [x, y, z]) => {
    rb.setEnabledTranslations(x, y, z, true);
  },
  angularVelocity: (rb, [x, y, z]) => {
    rb.setAngvel({
      x,
      y,
      z
    }, true);
  },
  linearVelocity: (rb, [x, y, z]) => {
    rb.setLinvel({
      x,
      y,
      z
    }, true);
  },
  ccd: (rb, value) => {
    rb.enableCcd(value);
  },
  userData: (rb, value) => {
    rb.userData = value;
  },
  position: () => {},
  rotation: () => {},
  quaternion: () => {},
  scale: () => {}
};
const mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);
const setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {
  if (!rigidBody) {
    return;
  }

  const state = states.get(rigidBody.handle);

  if (state) {
    if (updateTranslations) {
      state.object.updateWorldMatrix(true, false);

      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);

      rigidBody.setTranslation(_position, false);
      rigidBody.setRotation(_rotation, false);
    }

    mutableRigidBodyOptionKeys.forEach(key => {
      if (key in options) {
        mutableRigidBodyOptions[key](rigidBody, options[key]);
      }
    });
  }
};
const useUpdateRigidBodyOptions = (rigidBodyRef, props, states, updateTranslations = true) => {
  // TODO: Improve this, split each prop into its own effect
  const mutablePropsAsFlatArray = React.useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {
    return vectorToTuple(props[key]);
  }), [props]);
  React.useEffect(() => {
    if (Array.isArray(rigidBodyRef.current)) {
      for (const rigidBody of rigidBodyRef.current) {
        setRigidBodyOptions(rigidBody, props, states, updateTranslations);
      }
    } else if (rigidBodyRef.current) {
      setRigidBodyOptions(rigidBodyRef.current, props, states, updateTranslations);
    }
  }, mutablePropsAsFlatArray);
};
const useRigidBodyEvents = (rigidBodyRef, props, events) => {
  const {
    onWake,
    onSleep,
    onCollisionEnter,
    onCollisionExit,
    onIntersectionEnter,
    onIntersectionExit
  } = props;
  const eventHandlers = {
    onWake,
    onSleep,
    onCollisionEnter,
    onCollisionExit,
    onIntersectionEnter,
    onIntersectionExit
  };
  React.useEffect(() => {
    if (Array.isArray(rigidBodyRef.current)) {
      for (const rigidBody of rigidBodyRef.current) {
        events.set(rigidBody.handle, eventHandlers);
      }
    } else if (rigidBodyRef.current) {
      events.set(rigidBodyRef.current.handle, eventHandlers);
    }

    return () => {
      if (Array.isArray(rigidBodyRef.current)) {
        for (const rigidBody of rigidBodyRef.current) {
          events.delete(rigidBody.handle);
        }
      } else if (rigidBodyRef.current) {
        events.delete(rigidBodyRef.current.handle);
      }
    };
  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit]);
};

const useRapier = () => {
  return React.useContext(RapierContext);
};
const useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {
  const [colliderProps, setColliderProps] = React.useState([]);
  React.useEffect(() => {
    const object = ref.current;

    if (object && options.colliders !== false) {
      setColliderProps(createColliderPropsFromChildren({
        object: ref.current,
        options,
        ignoreMeshColliders
      }));
    }
  }, [options.colliders]);
  return colliderProps;
};
const useRigidBody = (options = {}) => {
  const {
    world,
    rigidBodyStates,
    physicsOptions,
    rigidBodyEvents
  } = useRapier();
  const ref = React.useRef();
  const mergedOptions = React.useMemo(() => {
    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {
      children: undefined
    });
  }, [physicsOptions, options]);
  const childColliderProps = useChildColliderProps(ref, mergedOptions); // Create rigidbody

  const rigidBodyRef = React.useRef();
  const getRigidBodyRef = React.useRef(() => {
    if (!rigidBodyRef.current) {
      const desc = rigidBodyDescFromOptions(options);
      const rigidBody = world.createRigidBody(desc);
      rigidBodyRef.current = world.getRigidBody(rigidBody.handle);
    }

    return rigidBodyRef.current;
  }); // Setup

  React.useEffect(() => {
    const rigidBody = getRigidBodyRef.current();
    rigidBodyRef.current = rigidBody;

    if (!ref.current) {
      ref.current = new three.Object3D();
    }

    rigidBodyStates.set(rigidBody.handle, createRigidBodyState({
      rigidBody,
      object: ref.current
    }));
    return () => {
      world.removeRigidBody(rigidBody);
      rigidBodyStates.delete(rigidBody.handle);
      rigidBodyRef.current = undefined;
    };
  }, []);
  useUpdateRigidBodyOptions(rigidBodyRef, mergedOptions, rigidBodyStates);
  useRigidBodyEvents(rigidBodyRef, mergedOptions, rigidBodyEvents);
  const api = React.useMemo(() => createRigidBodyApi(getRigidBodyRef), []);
  return [ref, api, childColliderProps];
}; // Joints

const useImpulseJoint = (body1, body2, params) => {
  const {
    world
  } = useRapier();
  const jointRef = React.useRef();
  const getJointRef = React.useRef(() => {
    if (!jointRef.current) {
      let rb1;
      let rb2;

      if ("current" in body1 && body1.current && "current" in body2 && body2.current) {
        rb1 = world.getRigidBody(body1.current.handle);
        rb2 = world.getRigidBody(body2.current.handle);
        const newJoint = world.createImpulseJoint(params, rb1, rb2);
        jointRef.current = newJoint;
      }
    }

    return jointRef.current;
  });
  React.useEffect(() => {
    const joint = getJointRef.current();
    return () => {
      if (joint) {
        world.removeImpulseJoint(joint);
        jointRef.current = undefined;
      }
    };
  }, []);
  const api = React.useMemo(() => createJointApi(getJointRef), []);
  return api;
};
/**
 *
 * A fixed joint ensures that two rigid-bodies don't move relative to each other.
 * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.
 * The fixed-joint makes these frames coincide in world-space.
 */

const useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {
  const {
    rapier
  } = useRapier();
  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vectorArrayToVector3(body1Anchor), _objectSpread2(_objectSpread2({}, vectorArrayToVector3(body1LocalFrame)), {}, {
    w: 1
  }), vectorArrayToVector3(body2Anchor), _objectSpread2(_objectSpread2({}, vectorArrayToVector3(body2LocalFrame)), {}, {
    w: 1
  })));
};
/**
 * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative
 * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.
 * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the
 * points that need to coincide on the local-space of each rigid-body.
 */

const useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {
  const {
    rapier
  } = useRapier();
  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor)));
};
/**
 * The revolute joint prevents any relative movement between two rigid-bodies, except for relative
 * rotations along one axis. This is typically used to simulate wheels, fans, etc.
 * They are characterized by one local anchor as well as one local axis on each rigid-body.
 */

const useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis]) => {
  const {
    rapier
  } = useRapier();
  return useImpulseJoint(body1, body2, rapier.JointData.revolute(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis)));
};
/**
 * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.
 * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional
 * local tangent axis can be specified for each rigid-body.
 */

const usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis]) => {
  const {
    rapier
  } = useRapier();
  return useImpulseJoint(body1, body2, rapier.JointData.prismatic(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis)));
};

// Colliders
const AnyCollider = /*#__PURE__*/React.memo( /*#__PURE__*/React__default["default"].forwardRef((props, forwardedRef) => {
  const {
    children,
    position,
    rotation,
    quaternion,
    scale,
    name
  } = props;
  const {
    world,
    colliderEvents,
    colliderStates
  } = useRapier();
  const rigidBodyContext = useRigidBodyContext();
  const ref = React.useRef(null);
  const collidersRef = React.useMemo(() => {
    if (forwardedRef !== null) {
      return forwardedRef;
    }

    const result = /*#__PURE__*/React__default["default"].createRef();
    result.current = [];
    return result;
  }, []);
  React.useEffect(() => {
    const object = ref.current;
    const worldScale = object.getWorldScale(new three.Vector3());
    const colliders = []; // If this is an InstancedRigidBody api

    if (rigidBodyContext && "at" in rigidBodyContext.api) {
      rigidBodyContext.api.forEach((body, index) => {
        var _rigidBodyContext$opt, _rigidBodyContext$opt2;

        let instanceScale = worldScale;

        if ("scales" in rigidBodyContext.options && rigidBodyContext !== null && rigidBodyContext !== void 0 && (_rigidBodyContext$opt = rigidBodyContext.options) !== null && _rigidBodyContext$opt !== void 0 && (_rigidBodyContext$opt2 = _rigidBodyContext$opt.scales) !== null && _rigidBodyContext$opt2 !== void 0 && _rigidBodyContext$opt2[index]) {
          instanceScale = instanceScale.clone().multiply(vectorArrayToVector3(rigidBodyContext.options.scales[index]));
        }

        const collider = createColliderFromOptions(props, world, instanceScale, body.raw());
        colliderStates.set(collider.handle, createColliderState(collider, object, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));
        colliders.push(collider);
      });
    } else {
      const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext && (rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.api).raw());
      colliderStates.set(collider.handle, createColliderState(collider, object, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));
      colliders.push(collider);
    }

    collidersRef.current = colliders;
    return () => {
      colliders.forEach(collider => {
        world.removeCollider(collider);
      });
    };
  }, []);
  const mergedProps = React.useMemo(() => {
    return _objectSpread2(_objectSpread2({}, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options), props);
  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);
  useUpdateColliderOptions(collidersRef, mergedProps, colliderStates);
  useColliderEvents(collidersRef, mergedProps, colliderEvents);
  return /*#__PURE__*/React__default["default"].createElement("object3D", {
    position: position,
    rotation: rotation,
    quaternion: quaternion,
    scale: scale,
    ref: ref,
    name: name
  }, children);
}));
const CuboidCollider = /*#__PURE__*/React__default["default"].forwardRef((props, ref) => {
  return /*#__PURE__*/React__default["default"].createElement(AnyCollider, _extends({}, props, {
    shape: "cuboid",
    ref: ref
  }));
});
const RoundCuboidCollider = /*#__PURE__*/React__default["default"].forwardRef((props, ref) => {
  return /*#__PURE__*/React__default["default"].createElement(AnyCollider, _extends({}, props, {
    shape: "roundCuboid",
    ref: ref
  }));
});
const BallCollider = /*#__PURE__*/React__default["default"].forwardRef((props, ref) => {
  return /*#__PURE__*/React__default["default"].createElement(AnyCollider, _extends({}, props, {
    shape: "ball",
    ref: ref
  }));
});
const CapsuleCollider = /*#__PURE__*/React__default["default"].forwardRef((props, ref) => {
  return /*#__PURE__*/React__default["default"].createElement(AnyCollider, _extends({}, props, {
    shape: "capsule",
    ref: ref
  }));
});
const HeightfieldCollider = /*#__PURE__*/React__default["default"].forwardRef((props, ref) => {
  return /*#__PURE__*/React__default["default"].createElement(AnyCollider, _extends({}, props, {
    shape: "heightfield",
    ref: ref
  }));
});
const TrimeshCollider = /*#__PURE__*/React__default["default"].forwardRef((props, ref) => {
  return /*#__PURE__*/React__default["default"].createElement(AnyCollider, _extends({}, props, {
    shape: "trimesh",
    ref: ref
  }));
});
const ConeCollider = /*#__PURE__*/React__default["default"].forwardRef((props, ref) => {
  return /*#__PURE__*/React__default["default"].createElement(AnyCollider, _extends({}, props, {
    shape: "cone",
    ref: ref
  }));
});
const CylinderCollider = /*#__PURE__*/React__default["default"].forwardRef((props, ref) => {
  return /*#__PURE__*/React__default["default"].createElement(AnyCollider, _extends({}, props, {
    shape: "cylinder",
    ref: ref
  }));
});
const ConvexHullCollider = /*#__PURE__*/React__default["default"].forwardRef((props, ref) => {
  return /*#__PURE__*/React__default["default"].createElement(AnyCollider, _extends({}, props, {
    shape: "convexHull",
    ref: ref
  }));
});

const _excluded$1 = ["children", "type", "position", "rotation", "scale", "quaternion"];
const RigidBodyContext = /*#__PURE__*/React.createContext(undefined);
const useRigidBodyContext = () => React.useContext(RigidBodyContext);
const RigidBody = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef((props, ref) => {
  const {
    children,
    type,
    position,
    rotation,
    scale,
    quaternion
  } = props,
        objectProps = _objectWithoutProperties(props, _excluded$1);

  const [object, api, childColliderProps] = useRigidBody(props);
  React.useImperativeHandle(ref, () => api);
  const contextValue = React.useMemo(() => ({
    ref: object,
    api,
    options: props
  }), [object, api, props]);
  return /*#__PURE__*/React__default["default"].createElement(RigidBodyContext.Provider, {
    value: contextValue
  }, /*#__PURE__*/React__default["default"].createElement("object3D", _extends({
    ref: object
  }, objectProps, {
    position: position,
    rotation: rotation,
    quaternion: quaternion,
    scale: scale
  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React__default["default"].createElement(AnyCollider, _extends({
    key: index
  }, colliderProps)))));
}));

const MeshCollider = props => {
  const {
    children,
    type
  } = props;
  const {
    physicsOptions,
    world
  } = useRapier();
  const object = React.useRef(null);
  const {
    options
  } = useRigidBodyContext();
  const mergedOptions = React.useMemo(() => {
    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {
      children: undefined,
      colliders: type
    });
  }, [physicsOptions, options]);
  const childColliderProps = useChildColliderProps(object, mergedOptions, false);
  return /*#__PURE__*/React__default["default"].createElement("object3D", {
    ref: object,
    userData: {
      r3RapierType: "MeshCollider"
    }
  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React__default["default"].createElement(AnyCollider, _extends({
    key: index
  }, colliderProps))));
};

const Debug = () => {
  const {
    world
  } = useRapier();
  const ref = React.useRef(null);
  fiber.useFrame(() => {
    const mesh = ref.current;
    if (!mesh) return;
    const buffers = world.debugRender();
    mesh.geometry.setAttribute("position", new three.BufferAttribute(buffers.vertices, 3));
    mesh.geometry.setAttribute("color", new three.BufferAttribute(buffers.colors, 4));
  });
  return /*#__PURE__*/React__default["default"].createElement("lineSegments", {
    ref: ref,
    frustumCulled: false
  }, /*#__PURE__*/React__default["default"].createElement("lineBasicMaterial", {
    color: 0xffffff,
    vertexColors: true
  }), /*#__PURE__*/React__default["default"].createElement("bufferGeometry", null));
};

const _excluded = ["positions", "rotations", "children"];
const InstancedRigidBodies = /*#__PURE__*/React.forwardRef((props, ref) => {
  const {
    world,
    rigidBodyStates,
    physicsOptions,
    rigidBodyEvents
  } = useRapier();
  const object = React.useRef(null);

  const {
    positions,
    rotations,
    children
  } = props,
        options = _objectWithoutProperties(props, _excluded);

  const instancesRef = React.useRef([]);
  const rigidBodyRefs = React.useRef([]);
  const instancesRefGetter = React.useRef(() => {
    if (!instancesRef.current) {
      instancesRef.current = [];
    }

    return instancesRef.current;
  });
  const mergedOptions = React.useMemo(() => {
    return _objectSpread2(_objectSpread2({}, physicsOptions), options);
  }, [physicsOptions, options]);
  const childColliderProps = useChildColliderProps(object, mergedOptions);
  React.useLayoutEffect(() => {
    object.current.updateWorldMatrix(true, false);
    const instances = instancesRefGetter.current();
    const invertedWorld = object.current.matrixWorld.clone().invert();
    object.current.traverseVisible(mesh => {
      if (mesh instanceof three.InstancedMesh) {
        mesh.instanceMatrix.setUsage(three.DynamicDrawUsage);
        const worldScale = mesh.getWorldScale(_scale);

        for (let index = 0; index < mesh.count; index++) {
          var _options$scales;

          const desc = rigidBodyDescFromOptions(props);
          const rigidBody = world.createRigidBody(desc);
          rigidBodyRefs.current.push(rigidBody);
          const scale = ((_options$scales = options.scales) === null || _options$scales === void 0 ? void 0 : _options$scales[index]) || [1, 1, 1];
          const instanceScale = worldScale.clone().multiply(vectorArrayToVector3(scale));
          rigidBodyStates.set(rigidBody.handle, createRigidBodyState({
            rigidBody,
            object: mesh,
            setMatrix: matrix => mesh.setMatrixAt(index, matrix),
            getMatrix: matrix => {
              mesh.getMatrixAt(index, matrix);
              return matrix;
            },
            worldScale: instanceScale
          }));
          const [x, y, z] = (positions === null || positions === void 0 ? void 0 : positions[index]) || [0, 0, 0];
          const [rx, ry, rz] = (rotations === null || rotations === void 0 ? void 0 : rotations[index]) || [0, 0, 0];

          _object3d.position.set(x, y, z);

          _object3d.rotation.set(rx, ry, rz);

          _object3d.applyMatrix4(invertedWorld);

          mesh.setMatrixAt(index, _object3d.matrix);
          rigidBody.setTranslation(_object3d.position, false);
          rigidBody.setRotation(_object3d.quaternion, false);
          const api = createRigidBodyApi({
            current() {
              return rigidBody;
            }

          });
          instances.push({
            rigidBody,
            api
          });
        }
      }
    });
    return () => {
      instances.forEach(rb => {
        world.removeRigidBody(rb.rigidBody);
        rigidBodyStates.delete(rb.rigidBody.handle);
      });
      rigidBodyRefs.current = [];
      instancesRef.current = [];
    };
  }, []);
  const api = React.useMemo(() => createInstancedRigidBodiesApi(instancesRefGetter), []);
  React.useImperativeHandle(ref, () => api);
  useUpdateRigidBodyOptions(rigidBodyRefs, mergedOptions, rigidBodyStates, false);
  useRigidBodyEvents(rigidBodyRefs, mergedOptions, rigidBodyEvents);
  const contextValue = React.useMemo(() => {
    return {
      ref: object,
      api,
      options: mergedOptions
    };
  }, [api, mergedOptions]);
  return /*#__PURE__*/React__default["default"].createElement(RigidBodyContext.Provider, {
    value: contextValue
  }, /*#__PURE__*/React__default["default"].createElement("object3D", {
    ref: object
  }, props.children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React__default["default"].createElement(AnyCollider, _extends({
    key: index
  }, colliderProps)))));
});

/**
 * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`
 * properties of RigidBody or Collider components. The first argument represents a list of
 * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list
 * of groups that will be filtered against. When it is omitted, all groups are filtered against.
 *
 * @example
 * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:
 *
 * ```tsx
 * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />
 * ```
 *
 * A RigidBody that is member of groups 0 and 1 and will collide with everything else:
 *
 * ```tsx
 * <RigidBody collisionGroups={interactionGroups([0, 1])} />
 * ```
 *
 * A RigidBody that is member of groups 0 and 1 and will not collide with anything:
 *
 * ```tsx
 * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />
 * ```
 *
 * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding
 * entities for collision events to trigger.
 *
 * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)
 * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)
 * @returns An InteractionGroup bitmask.
 */
const interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);

const bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);

Object.defineProperty(exports, 'CoefficientCombineRule', {
  enumerable: true,
  get: function () { return rapier3dCompat.CoefficientCombineRule; }
});
Object.defineProperty(exports, 'RapierCollider', {
  enumerable: true,
  get: function () { return rapier3dCompat.Collider; }
});
Object.defineProperty(exports, 'RapierRigidBody', {
  enumerable: true,
  get: function () { return rapier3dCompat.RigidBody; }
});
exports.AnyCollider = AnyCollider;
exports.BallCollider = BallCollider;
exports.CapsuleCollider = CapsuleCollider;
exports.ConeCollider = ConeCollider;
exports.ConvexHullCollider = ConvexHullCollider;
exports.CuboidCollider = CuboidCollider;
exports.CylinderCollider = CylinderCollider;
exports.Debug = Debug;
exports.HeightfieldCollider = HeightfieldCollider;
exports.InstancedRigidBodies = InstancedRigidBodies;
exports.MeshCollider = MeshCollider;
exports.Physics = Physics;
exports.RigidBody = RigidBody;
exports.RoundCuboidCollider = RoundCuboidCollider;
exports.TrimeshCollider = TrimeshCollider;
exports.interactionGroups = interactionGroups;
exports.useChildColliderProps = useChildColliderProps;
exports.useFixedJoint = useFixedJoint;
exports.useImpulseJoint = useImpulseJoint;
exports.usePrismaticJoint = usePrismaticJoint;
exports.useRapier = useRapier;
exports.useRevoluteJoint = useRevoluteJoint;
exports.useRigidBody = useRigidBody;
exports.useSphericalJoint = useSphericalJoint;
