import { Collider, ColliderDesc, DebugRenderBuffers, ImpulseJoint, JointData, RigidBody, RigidBodyDesc, World } from "@dimforge/rapier3d-compat";
import { Quaternion, Vector3 } from "three";
import { RefGetter } from "./types";
declare type Vector3Object = {
    x: number;
    y: number;
    z: number;
};
export interface RigidBodyApi {
    /**
     * Get the raw RigidBody
     */
    raw(): RigidBody;
    /**
     * The handle of this RigidBody
     */
    handle: number;
    /**
     * The mass of this rigid-body.
     */
    mass(): number;
    /**
     * Applies an impulse at the center-of-mass of this rigid-body.
     */
    applyImpulse(impulseVector: Vector3Object, wakeUp?: boolean): void;
    /**
     * Applies an impulsive torque at the center-of-mass of this rigid-body.
     */
    applyTorqueImpulse(torqueVector: Vector3Object, wakeUp?: boolean): void;
    /**
     * Applies an impulse at the given world-space point of this rigid-body.
     */
    applyImpulseAtPoint(impulseVector: Vector3Object, impulsePoint: Vector3Object, wakeUp?: boolean): void;
    /**
     * Adds a force at the center-of-mass of this rigid-body.
     */
    addForce(force: Vector3Object, wakeUp?: boolean): void;
    /**
     * Adds a force at the given world-space point of this rigid-body.
     */
    addForceAtPoint(force: Vector3Object, point: Vector3Object, wakeUp?: boolean): void;
    /**
     * Adds a torque at the center-of-mass of this rigid-body.
     */
    addTorque(torque: Vector3Object, wakeUp?: boolean): void;
    /**
     * The world-space translation of this rigid-body.
     */
    translation(): Vector3;
    /**
     * Sets the translation of this rigid-body.
     */
    setTranslation(translation: Vector3Object, wakeUp?: boolean): void;
    /**
     * The world-space orientation of this rigid-body.
     */
    rotation(): Quaternion;
    /**
     * Sets the rotation quaternion of this rigid-body.
     */
    setRotation(rotation: Quaternion, wakeUp?: boolean): void;
    /**
     * The linear velocity of this rigid-body.
     */
    linvel(): Vector3;
    /**
     * Sets the linear velocity of this rigid-body.
     */
    setLinvel(velocity: Vector3Object, wakeUp?: boolean): void;
    /**
     * The angular velocity of this rigid-body.
     */
    angvel(): Vector3;
    /**
     * Sets the angular velocity of this rigid-body.
     */
    setAngvel(velocity: Vector3Object, wakeUp?: boolean): void;
    /**
     * The linear damping of this rigid-body.
     */
    linearDamping(): number;
    /**
     * Sets the linear damping factor applied to this rigid-body.
     */
    setLinearDamping(factor: number): void;
    /**
     * The angular damping of this rigid-body.
     */
    angularDamping(): number;
    /**
     * Sets the anugular damping factor applied to this rigid-body.
     */
    setAngularDamping(factor: number): void;
    /**
     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.
     *
     * This should be used instead of rigidBody.setRotation to make the dynamic object interacting with this
     * kinematic body behave as expected. Internally, Rapier will compute an artificial velocity for this
     * rigid-body from its current position and its next kinematic position. This velocity will be used
     * to compute forces on dynamic bodies interacting with this body.
     */
    setNextKinematicRotation(rotation: Quaternion): void;
    /**
     * If this rigid body is kinematic, sets its future translation after the next timestep integration.
     *
     * This should be used instead of rigidBody.setTranslation to make the dynamic object interacting with
     * this kinematic body behave as expected. Internally, Rapier will compute an artificial velocity
     * for this rigid-body from its current position and its next kinematic position. This velocity
     * will be used to compute forces on dynamic bodies interacting with this body.
     */
    setNextKinematicTranslation(translation: Vector3Object): void;
    /**
     * Resets to zero the user forces (but not torques) applied to this rigid-body.
     */
    resetForces(wakeUp?: boolean): void;
    /**
     * Resets to zero the user torques applied to this rigid-body.
     */
    resetTorques(wakeUp?: boolean): void;
    /**
     * Locks or unlocks the ability of this rigid-body to rotate.
     */
    lockRotations(locked: boolean, wakeUp?: boolean): void;
    /**
     * Locks or unlocks the ability of this rigid-body to translate.
     */
    lockTranslations(locked: boolean, wakeUp?: boolean): void;
    /**
     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.
     */
    setEnabledRotations(x: boolean, y: boolean, z: boolean, wakeUp?: boolean): void;
    /**
     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.
     */
    setEnabledTranslations(x: boolean, y: boolean, z: boolean, wakeUp?: boolean): void;
}
export declare const createRigidBodyApi: (ref: RefGetter<RigidBody>) => RigidBodyApi;
export interface InstancedRigidBodyApi {
    at(index: number): RigidBodyApi;
    get count(): number;
    forEach(callback: (body: RigidBodyApi, index: number, array: RigidBodyApi[]) => void): void;
}
export declare const createInstancedRigidBodiesApi: (bodiesGetter: RefGetter<{
    rigidBody: RigidBody;
    api: RigidBodyApi;
}[]>) => InstancedRigidBodyApi;
export declare const createColliderApi: (ref: RefGetter<Collider>) => {
    raw: () => Collider | undefined;
    readonly handle: number;
};
export interface WorldApi {
    raw(): World;
    getCollider(handle: number): Collider | undefined;
    getRigidBody(handle: number): RigidBody | undefined;
    createRigidBody(desc: RigidBodyDesc): RigidBody;
    createCollider(desc: ColliderDesc, parent?: RigidBody): Collider;
    removeRigidBody(rigidBody: RigidBody): void;
    removeCollider(collider: Collider, wakeUp?: boolean): void;
    createImpulseJoint(params: JointData, rigidBodyA: RigidBody, rigidBodyB: RigidBody, wakeUp?: boolean): ImpulseJoint;
    removeImpulseJoint(joint: ImpulseJoint, wakeUp?: boolean): void;
    forEachCollider(callback: (collider: Collider) => void): void;
    setGravity(gravity: Vector3): void;
    debugRender(): DebugRenderBuffers;
}
export declare const createWorldApi: (ref: RefGetter<World>) => WorldApi;
export declare const createJointApi: (ref: RefGetter<ImpulseJoint>) => {
    raw: () => ImpulseJoint | undefined;
    readonly handle: number;
    configureMotorPosition: (targetPos: number, stiffness: number, damping: number) => void;
    configureMotorVelocity: (targetVel: number, damping: number) => void;
};
export {};
